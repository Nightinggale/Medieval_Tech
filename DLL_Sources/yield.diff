diff --git a/Assets/CvGameCoreDLL.dll b/Assets/CvGameCoreDLL.dll
index 6700056..2f20e18 100644
Binary files a/Assets/CvGameCoreDLL.dll and b/Assets/CvGameCoreDLL.dll differ
diff --git a/DLL_Sources/CvCity.cpp b/DLL_Sources/CvCity.cpp
index fa229e1..d549caf 100644
--- a/DLL_Sources/CvCity.cpp
+++ b/DLL_Sources/CvCity.cpp
@@ -7196,6 +7196,7 @@ void CvCity::doGrowth()
     ///TKs Med
     bool bNotMaxed = true;
 
+#ifdef USE_NOBLE_CLASS
     //bool bRationsGrowth = false;
     if (!isNative() && getYieldStored(YIELD_GRAIN) >= GC.getCache_BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD() && bNotMaxed)
     {
@@ -7217,6 +7218,7 @@ void CvCity::doGrowth()
             }
 		}
     }
+#endif
 
 
 
@@ -7311,7 +7313,7 @@ void CvCity::doYields()
         {
             switch (eYield)
             {
-
+#ifdef USE_NOBLE_CLASS
                 case YIELD_SPICES:
 
                     //if (!isHuman() && !isNative() && GET_PLAYER(getOwnerINLINE()).getParent() != NO_PLAYER)
@@ -7327,6 +7329,7 @@ void CvCity::doYields()
                     }
 
                     break;
+#endif
                 case YIELD_WEAPONS:
                     if (GC.getCache_AI_CHEAT_AUTO_BUY() > 0 && GET_TEAM(getTeam()).getAtWarCount() == 0)
                     {
@@ -7344,7 +7347,9 @@ void CvCity::doYields()
                     }
                     ///TKe
                     break;
+#ifdef MEDIEVAL_TECH
                 case YIELD_LEATHER_ARMOR:
+#endif
                 case YIELD_HORSES:
                     if (GC.getCache_AI_CHEAT_AUTO_BUY() > 0 && GET_TEAM(getTeam()).getAtWarCount() == 0)
                     {
@@ -7362,6 +7367,7 @@ void CvCity::doYields()
                     }
                     ///TKe
                     break;
+#ifdef MEDIEVAL_TECH
                 case YIELD_SCALE_ARMOR:
                 case YIELD_MAIL_ARMOR:
                  case YIELD_PLATE_ARMOR:
@@ -7422,8 +7428,12 @@ void CvCity::doYields()
 
                     break;
                 case YIELD_COTTON:
+#endif
+#ifdef USE_NOBLE_CLASS
                 case YIELD_GRAIN:
+#endif
                 case YIELD_STONE:
+					// TODO make a yield group of yields, which must be discovered
                     //if (!isHuman() && !isNative() && GET_PLAYER(getOwnerINLINE()).getParent() != NO_PLAYER)
                     {
                         bool bDiscovered = true;
@@ -7696,7 +7706,7 @@ void CvCity::doYields()
                         gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_BUILD_BANK", MESSAGE_TYPE_MINOR_EVENT, GC.getYieldInfo(eYield).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX_INLINE(), getY_INLINE(), true, true);
                     }
 				}
-				else if (iExcess > 0 && eYield != YIELD_GRAIN)
+				else if (iExcess > 0 && !YieldGroup_Luxury_Food(eYield))
 				{
 				    int iLoss = std::max(GC.getCache_CITY_YIELD_DECAY_PERCENT() * iExcess / 100, GC.getCache_MIN_CITY_YIELD_DECAY());
                     iLoss = std::min(iLoss, iExcess);
@@ -7740,7 +7750,7 @@ void CvCity::doYields()
                         }
 					}
 				}
-				else if (aiYields[eYield] > -iExcess && eYield != YIELD_GRAIN)
+				else if (aiYields[eYield] > -iExcess && !YieldGroup_Luxury_Food(eYield))
 				{
 					CvWString szBuffer = gDLL->getText("TXT_KEY_RUNNING_OUT_OF_SPACE",GC.getYieldInfo(eYield).getChar(), getNameKey());
 					gDLL->getInterfaceIFace()->addMessage(getOwnerINLINE(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_DEAL_CANCELLED", MESSAGE_TYPE_MINOR_EVENT, GC.getYieldInfo(eYield).getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), getX_INLINE(), getY_INLINE(), true, true);
@@ -9717,7 +9727,7 @@ void CvCity::ejectTeachUnits()
 bool CvCity::canProduceYield(YieldTypes eYield)
 {
     ///Tks Med
-    if (GC.getYieldInfo(eYield).isNativeTrade() || eYield == YIELD_WOOL || eYield == YIELD_CATTLE || eYield == YIELD_SHEEP)
+    if (YieldGroup_AI_Native_Product(eYield) || GC.getYieldInfo(eYield).isNativeTrade())
     {
         if (isNative())
         {
@@ -10146,6 +10156,7 @@ UnitClassTypes CvCity::bestTeachUnitClass()
 						}
 						///Tks Med
 						YieldTypes eBonus = NO_YIELD;
+#ifdef USE_NOBLE_CLASS
 						if (kIdealProfession.getNumYieldsProduced() > 1)
 						{
                             if (eWantedYield == YIELD_CATTLE)
@@ -10159,6 +10170,7 @@ UnitClassTypes CvCity::bestTeachUnitClass()
                                 eBonus = YIELD_SHEEP;
                             }
 						}
+#endif
 						///TKe
 						// MultipleYieldsConsumed End
 						if (eWantedYield == NO_YIELD)
@@ -10900,7 +10912,7 @@ bool CvCity::isEquipmentType(YieldTypes eEquipment, int iType) const
 {
     if (iType == 0)
     {
-        if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
+        if (YieldGroup_Armor(eEquipment))
         {
             return true;
         }
@@ -10912,21 +10924,21 @@ bool CvCity::isEquipmentType(YieldTypes eEquipment, int iType) const
     }
     else if (iType == 1)
     {
-        if (eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
+        if (YieldGroup_Heavy_Armor(eEquipment))
         {
             return true;
         }
     }
     else if (iType == 2)
     {
-        if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
+        if (YieldGroup_Armor(eEquipment))
         {
             return true;
         }
     }
     else if (iType == 3)
     {
-        if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
+        if (YieldGroup_Armor(eEquipment))
         {
             return true;
         }
@@ -11063,7 +11075,7 @@ BuildingTypes CvCity::getBestFreeBuilding()
             int iCityPlotValue = 0;
             YieldTypes eCityYield = NO_YIELD;
             YieldTypes eYield = (YieldTypes)iI;
-            if (GC.getYieldInfo(eYield).isCargo() && eYield != YIELD_ORE && eYield != YIELD_GRAIN && eYield != YIELD_LUMBER && eYield != YIELD_FOOD)
+            if (GC.getYieldInfo(eYield).isCargo() && eYield != YIELD_ORE && !YieldGroup_Luxury_Food(eYield) && eYield != YIELD_LUMBER && eYield != YIELD_FOOD)
             {
                 if (GET_PLAYER(getOwner()).getYieldBuyPrice(eYield) <= 0)
                 {
diff --git a/DLL_Sources/CvCityAI.cpp b/DLL_Sources/CvCityAI.cpp
index 8e5ddcc..3184043 100644
--- a/DLL_Sources/CvCityAI.cpp
+++ b/DLL_Sources/CvCityAI.cpp
@@ -1079,6 +1079,7 @@ int CvCityAI::AI_buildingValue(BuildingTypes eBuilding, int iFocusFlags) const
 										iTempValue /= 100;
 									}
 								}
+#ifdef USE_NOBLE_CLASS
 								if (getPopulation() >= 2)
 								{
                                     if (eYieldProduced == YIELD_GRAIN)
@@ -1087,6 +1088,7 @@ int CvCityAI::AI_buildingValue(BuildingTypes eBuilding, int iFocusFlags) const
                                         iTempValue /= 100;
                                     }
 								}
+#endif
 
 								if (eYieldConsumed != NO_YIELD)
 								{
@@ -1137,7 +1139,7 @@ int CvCityAI::AI_buildingValue(BuildingTypes eBuilding, int iFocusFlags) const
 									iTempValue /= 100;
 								}
                                 ///TKs Med
-								if (GC.isEquipmentType(eYieldProduced, EQUIPMENT_ANY) || eYieldProduced == YIELD_TOOLS || eYieldProduced == YIELD_FOOD || eYieldProduced == YIELD_GRAIN)
+								if (GC.isEquipmentType(eYieldProduced, EQUIPMENT_ANY) || eYieldProduced == YIELD_TOOLS || eYieldProduced == YIELD_FOOD || YieldGroup_Luxury_Food(eYieldProduced))
 								{
 									bIsMilitary = true;
 								}
@@ -1216,7 +1218,7 @@ int CvCityAI::AI_buildingValue(BuildingTypes eBuilding, int iFocusFlags) const
 			if (iAdded != 0)
 			{
 			    ///TKs
-				if (GC.isEquipmentType(eLoopYield, EQUIPMENT_ANY) || eLoopYield == YIELD_TOOLS || eLoopYield == YIELD_FOOD || eLoopYield == YIELD_GRAIN)
+				if (GC.isEquipmentType(eLoopYield, EQUIPMENT_ANY) || eLoopYield == YIELD_TOOLS || eLoopYield == YIELD_FOOD || YieldGroup_Luxury_Food(eLoopYield))
 				{
 					bIsMilitary = true;
 				}
@@ -3346,7 +3348,7 @@ int CvCityAI::AI_professionValue(ProfessionTypes eProfession, const CvUnit* pUni
 		}
 	}
     ///TKs Med
-	if (eYieldConsumedType != NO_YIELD && eYieldConsumedType != YIELD_FOOD && eYieldConsumedType != YIELD_GRAIN)
+	if (eYieldConsumedType != NO_YIELD && eYieldConsumedType != YIELD_FOOD && !YieldGroup_Luxury_Food(eYieldConsumedType))
 	{
 		if (getYieldStored(eYieldConsumedType) > getMaxYieldCapacity(eYieldConsumedType))
 		{
@@ -3354,7 +3356,7 @@ int CvCityAI::AI_professionValue(ProfessionTypes eProfession, const CvUnit* pUni
 		}
 	}
 
-	if ((eYieldProducedType != YIELD_FOOD && eYieldProducedType != YIELD_GRAIN) && GC.getYieldInfo(eYieldProducedType).isCargo())
+	if (eYieldProducedType != YIELD_FOOD && !YieldGroup_Luxury_Food(eYieldProducedType) && GC.getYieldInfo(eYieldProducedType).isCargo())
 	{
 		int iNeededYield = AI_getNeededYield(eYieldProducedType) - iNetYield;
 
@@ -3425,7 +3427,7 @@ int CvCityAI::AI_professionValue(ProfessionTypes eProfession, const CvUnit* pUni
 		}
 	}
 
-	if (eYieldProducedType == YIELD_FOOD || eYieldProducedType == YIELD_GRAIN)
+	if (eYieldProducedType == YIELD_FOOD || YieldGroup_Luxury_Food(eYieldProducedType))
 	{
 		int iBaseFood = iNetYield;
 
@@ -3841,24 +3843,26 @@ int CvCityAI::AI_calculateAlarm(PlayerTypes eIndex) const
 
 int CvCityAI::AI_estimateYieldValue(YieldTypes eYield, int iAmount) const
 {
+	FAssert(eYield > NO_YIELD && eYield < NUM_YIELD_TYPES);
 	int iValue = iAmount * GET_PLAYER(getOwnerINLINE()).AI_yieldValue(eYield);
 
+#if 0
 	switch (eYield)
 	{
 	    ///TK ME start
 	    ///Food Goods
-	    case YIELD_CATTLE:///NEW*
-	    case YIELD_SHEEP:///NEW*
-        case YIELD_GRAIN:///NEW*
-        case YIELD_WOOL:///NEW*
-        case YIELD_SALT:///NEW*
+	    //case YIELD_CATTLE:///NEW*
+	    //case YIELD_SHEEP:///NEW*
+        //case YIELD_GRAIN:///NEW*
+        //case YIELD_WOOL:///NEW*
+        //case YIELD_SALT:///NEW*
         ///Food Goods^
         ///Building Material
-		case YIELD_STONE:///NEW*
+		//case YIELD_STONE:///NEW*
         ///Building Material^
         ///Bonus Resources
 //		case YIELD_IVORY:///NEW*
-		case YIELD_SPICES:///NEW*
+		//case YIELD_SPICES:///NEW*
         ///Bonus Resources^
         ///Trade Goods
 //        case YIELD_LEATHER:///NEW*
@@ -3868,47 +3872,47 @@ int CvCityAI::AI_estimateYieldValue(YieldTypes eYield, int iAmount) const
 //		case YIELD_PORCELAIN:///NEW*
         ///Discoverys^
         ///Armor
-		case YIELD_LEATHER_ARMOR:///NEW*
-		case YIELD_SCALE_ARMOR:///NEW*
-		case YIELD_MAIL_ARMOR:///NEW*
-		case YIELD_PLATE_ARMOR:///NEW*
+		//case YIELD_LEATHER_ARMOR:///NEW*
+		//case YIELD_SCALE_ARMOR:///NEW*
+		//case YIELD_MAIL_ARMOR:///NEW*
+		//case YIELD_PLATE_ARMOR:///NEW*
         ///Armor^
 
 	    ///TKe
-		case YIELD_FOOD:
-		case YIELD_LUMBER:
-		case YIELD_SILVER:
-		case YIELD_COTTON:
-		case YIELD_FUR:
-		case YIELD_BARLEY:
-		case YIELD_GRAPES:
-		case YIELD_ORE:
-		case YIELD_CLOTH:
-		case YIELD_COATS:
-		case YIELD_ALE:
-		case YIELD_WINE:
-		case YIELD_TOOLS:
-		case YIELD_WEAPONS:
-		case YIELD_HORSES:
-		case YIELD_TRADE_GOODS:
-		case YIELD_HAMMERS:
+		//case YIELD_FOOD:
+		//case YIELD_LUMBER:
+		//case YIELD_SILVER:
+		//case YIELD_COTTON:
+		//case YIELD_FUR:
+		//case YIELD_BARLEY:
+		//case YIELD_GRAPES:
+		//case YIELD_ORE:
+		//case YIELD_CLOTH:
+		//case YIELD_COATS:
+		//case YIELD_ALE:
+		//case YIELD_WINE:
+		//case YIELD_TOOLS:
+		//case YIELD_WEAPONS:
+		//case YIELD_HORSES:
+		//case YIELD_TRADE_GOODS:
+		//case YIELD_HAMMERS:
 		 ///TKs Invention Core Mod v 1.0
 		//case YIELD_COAL:
-		case YIELD_IDEAS:
-		case YIELD_CULTURE:
+		//case YIELD_IDEAS:
+		//case YIELD_CULTURE:
             break;
 		///TKe
-		case YIELD_BELLS:
+		//case YIELD_BELLS:
 			break;
-		case YIELD_CROSSES:
+		//case YIELD_CROSSES:
 			break;
-		case YIELD_EDUCATION:
-		case YIELD_GOLD:///NEW*
+		//case YIELD_EDUCATION:
+		//case YIELD_GOLD:///NEW*
 			break;
 		default:
 			FAssert(false);
 	}
-
+#endif
 	return iValue;
 }
 
@@ -5572,7 +5576,7 @@ void CvCityAI::AI_educateStudent(int iUnitId)
 					if (eYieldProducedType != NO_YIELD)
 					{
 					    ///TKs Med
-						if (eYieldProducedType == YIELD_FOOD || eYieldProducedType == YIELD_GRAIN)
+						if (eYieldProducedType == YIELD_FOOD || YieldGroup_Luxury_Food(eYieldProducedType))
 						{
 							iValue *= 200;
 							iValue /= 100;
diff --git a/DLL_Sources/CvDLLWidgetData.cpp b/DLL_Sources/CvDLLWidgetData.cpp
index b7f674b..14e3ba8 100644
--- a/DLL_Sources/CvDLLWidgetData.cpp
+++ b/DLL_Sources/CvDLLWidgetData.cpp
@@ -2898,8 +2898,11 @@ void CvDLLWidgetData::parsePopulationHelp(CvWidgetDataStruct &widgetDataStruct,
 	{
 	    ///TKs Med
 		//szBuffer.assign(gDLL->getText("TXT_KEY_MISC_FOOD_THRESHOLD", pHeadSelectedCity->getFood(), pHeadSelectedCity->growthThreshold()));
-
+#ifdef USE_NOBLE_CLASS
 		szBuffer.assign(gDLL->getText("TXT_KEY_MISC_LUXURY_FOOD_THRESHOLD", pHeadSelectedCity->getFood(), pHeadSelectedCity->growthThreshold(), pHeadSelectedCity->getYieldStored(YIELD_GRAIN), GC.getCache_BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD(), GC.getYieldInfo(YIELD_GRAIN).getChar()));
+#else
+		szBuffer.assign(gDLL->getText("TXT_KEY_MISC_FOOD_THRESHOLD", pHeadSelectedCity->getFood(), pHeadSelectedCity->growthThreshold()));
+#endif
 		///Tke
 	}
 }
diff --git a/DLL_Sources/CvDefines.h b/DLL_Sources/CvDefines.h
index c49853c..01e3abf 100644
--- a/DLL_Sources/CvDefines.h
+++ b/DLL_Sources/CvDefines.h
@@ -5,6 +5,13 @@
 
 // defines.h
 
+// mod selection - start - Nightinggale
+#ifndef COLONIZATION_2071
+#define MEDIEVAL_TECH
+#define USE_NOBLE_CLASS
+#endif
+// mod selection - end - Nightinggale
+
 // The following #defines should not be moddable...
 
 #define MOVE_IGNORE_DANGER										(0x00000001)
diff --git a/DLL_Sources/CvEnums.h b/DLL_Sources/CvEnums.h
index 5bd2492..185b475 100644
--- a/DLL_Sources/CvEnums.h
+++ b/DLL_Sources/CvEnums.h
@@ -632,60 +632,6 @@ enum DllExport PlotTypes
 #endif
 };
 
-enum DllExport YieldTypes
-{
-	NO_YIELD = -1,
-
-	YIELD_FOOD,///0
-	///TKs ME
-	YIELD_GRAIN,///1NEW*
-	YIELD_CATTLE,///2/NEW*
-	YIELD_SHEEP,///3/NEW*
-	YIELD_WOOL,///4NEW*
-	//YIELD_SALT,///5NEW*
-	YIELD_LUMBER,///6
-	YIELD_STONE,///7NEW*
-//	YIELD_LEATHER,///20NEW*
-	YIELD_SILVER,///8
-	//YIELD_GOLD,///9/NEW*
-//	YIELD_IVORY,//9/NEW*
-    YIELD_SALT,///5NEW*
-	YIELD_SPICES,///10NEW*
-	YIELD_FUR,///11
-	YIELD_COTTON,///12
-	YIELD_BARLEY,///13YIELD_SUGAR,
-	YIELD_GRAPES,///14YIELD_TOBACCO,
-	YIELD_ORE,///15
-	YIELD_CLOTH,///16
-	YIELD_COATS,///17
-	YIELD_ALE,///18YIELD_RUM,
-	YIELD_WINE,///19YIELD_CIGARS,
-	YIELD_TOOLS,///20
-	YIELD_WEAPONS,///21YIELD_MUSKETS,
-	YIELD_HORSES,///22
-	YIELD_LEATHER_ARMOR,///23NEW*
-	YIELD_SCALE_ARMOR,///24NEW*
-	YIELD_MAIL_ARMOR,///25NEW*
-	YIELD_PLATE_ARMOR,///26NEW*
-	YIELD_TRADE_GOODS,///27
-//	YIELD_SILK,///29NEW*
-//	YIELD_PORCELAIN,///30NEW*
-	YIELD_HAMMERS,///28
-	YIELD_BELLS,///29
-	YIELD_CROSSES,///30
-	YIELD_EDUCATION,///31
-	///TKs Invention Core Mod v 1.0
-	YIELD_IDEAS,///32
-	YIELD_CULTURE,///33
-    YIELD_GOLD,///34/NEW*
-
-	///TKe
-
-#ifdef _USRDLL
-	NUM_YIELD_TYPES
-#endif
-};
-
 enum DllExport EmphasizeTypes
 {
 	NO_EMPHASIZE = -1,
@@ -1190,7 +1136,7 @@ enum DllExport DomainTypes
 	DOMAIN_SEA,
 	DOMAIN_LAND,
 	DOMAIN_IMMOBILE,
-	DOMAIN_AIR,
+	//DOMAIN_AIR, // why was this added without any mentioning in XML ???
 
 #ifdef _USRDLL
 	NUM_DOMAIN_TYPES
diff --git a/DLL_Sources/CvGameTextMgr.cpp b/DLL_Sources/CvGameTextMgr.cpp
index 4352efe..dfe0850 100644
--- a/DLL_Sources/CvGameTextMgr.cpp
+++ b/DLL_Sources/CvGameTextMgr.cpp
@@ -8774,13 +8774,13 @@ void CvGameTextMgr::buildCityBillboardIconString( CvWStringBuffer& szBuffer, CvC
             for(int iYield=0;iYield<NUM_YIELD_TYPES;iYield++)
             {
                 YieldTypes eYield = (YieldTypes) iYield;
-                if (pCity->getYieldStored(eYield) > 0 && (eYield == YIELD_SPICES || eYield == YIELD_HORSES || eYield == YIELD_CATTLE || eYield == YIELD_SHEEP || eYield == YIELD_SALT || eYield == YIELD_TOOLS))
+                if (YieldGroup_City_Billboard(eYield) && pCity->getYieldStored(eYield) > 0)
                 {
                     if (aYieldShown[iYield] == 0)
                     {
                         aYieldShown[iYield] = 1;
                         YieldTypes eFixedYield = (YieldTypes) iYield;
-                        if (eYield == YIELD_SPICES || eYield == YIELD_HORSES || eYield == YIELD_SALT || eYield == YIELD_TOOLS)
+                        if (YieldGroup_City_Billboard_Offset_Fix(eYield))
                         {
                             iYield -= 1;
                            eFixedYield = (YieldTypes) iYield;
diff --git a/DLL_Sources/CvGlobals.cpp b/DLL_Sources/CvGlobals.cpp
index e79dab9..9f29ee0 100644
--- a/DLL_Sources/CvGlobals.cpp
+++ b/DLL_Sources/CvGlobals.cpp
@@ -1,3579 +1,3910 @@
-//
-// globals.cpp
-// Author -	Mustafa Thamer
-//
-#include "CvGameCoreDLL.h"
-#include "CvGlobals.h"
-#include "CvRandom.h"
-#include "CvGameAI.h"
-#include "CvDLLInterfaceIFaceBase.h"
-#include "CvMap.h"
-#include "CvPlayerAI.h"
-#include "CvTeamAI.h"
-#include "CvInfos.h"
-#include "CvDLLUtilityIFaceBase.h"
-#include "CvArtFileMgr.h"
-#include "CvDLLXMLIFaceBase.h"
-#include "CvPlayerAI.h"
-#include "CvInfoWater.h"
-#include "CvGameTextMgr.h"
-#include "FProfiler.h"
-#include "FVariableSystem.h"
-#include "CvInitCore.h"
-
-#define COPY(dst, src, typeName) \
-	{ \
-		int iNum = sizeof(src)/sizeof(typeName); \
-		dst = new typeName[iNum]; \
-		for (int i =0;i<iNum;i++) \
-			dst[i] = src[i]; \
-	}
-
-//////////////////////////////////////////////////////////////////////////////////////////////////
-//////////////////////////////////////////////////////////////////////////////////////////////////
-
-CvGlobals gGlobals;
-
-//
-// CONSTRUCTOR
-//
-CvGlobals::CvGlobals() :
-m_bGraphicsInitialized(false),
-m_bLogging(false),
-m_bRandLogging(false),
-m_bOverwriteLogs(false),
-m_bSynchLogging(false),
-m_pkMainMenu(NULL),
-m_iNewPlayers(0),
-m_bZoomOut(false),
-m_bZoomIn(false),
-m_bLoadGameFromFile(false),
-m_pFMPMgr(NULL),
-m_asyncRand(NULL),
-m_interface(NULL),
-m_game(NULL),
-m_messageQueue(NULL),
-m_hotJoinMsgQueue(NULL),
-m_messageControl(NULL),
-m_messageCodes(NULL),
-m_dropMgr(NULL),
-m_portal(NULL),
-m_setupData(NULL),
-m_initCore(NULL),
-m_statsReporter(NULL),
-m_map(NULL),
-m_diplomacyScreen(NULL),
-m_mpDiplomacyScreen(NULL),
-m_pathFinder(NULL),
-m_interfacePathFinder(NULL),
-m_stepFinder(NULL),
-m_routeFinder(NULL),
-m_borderFinder(NULL),
-m_areaFinder(NULL),
-m_pDLL(NULL),
-m_aiPlotDirectionX(NULL),
-m_aiPlotDirectionY(NULL),
-m_aiPlotCardinalDirectionX(NULL),
-m_aiPlotCardinalDirectionY(NULL),
-m_aiCityPlotX(NULL),
-m_aiCityPlotY(NULL),
-m_aiCityPlotPriority(NULL),
-m_aeTurnLeftDirection(NULL),
-m_aeTurnRightDirection(NULL),
-m_VarSystem(NULL),
-m_iMOVE_DENOMINATOR(0),
-m_iFOOD_CONSUMPTION_PER_POPULATION(0),
-m_iMAX_HIT_POINTS(0),
-m_iHILLS_EXTRA_DEFENSE(0),
-m_iRIVER_ATTACK_MODIFIER(0),
-m_iAMPHIB_ATTACK_MODIFIER(0),
-m_iHILLS_EXTRA_MOVEMENT(0),
-m_iPEAK_EXTRA_MOVEMENT(0),
-m_iMAX_PLOT_LIST_ROWS(0),
-m_iUNIT_MULTISELECT_MAX(0),
-m_iEVENT_MESSAGE_TIME(0),
-m_iROUTE_FEATURE_GROWTH_MODIFIER(0),
-m_iFEATURE_GROWTH_MODIFIER(0),
-m_iMIN_CITY_RANGE(0),
-m_iCITY_MAX_NUM_BUILDINGS(0),
-m_iLAKE_MAX_AREA_SIZE(0),
-m_iMIN_WATER_SIZE_FOR_OCEAN(0),
-m_iFORTIFY_MODIFIER_PER_TURN(0),
-m_iMAX_CITY_DEFENSE_DAMAGE(0),
-m_iPEAK_SEE_THROUGH_CHANGE(0),
-m_iHILLS_SEE_THROUGH_CHANGE(0),
-m_iSEAWATER_SEE_FROM_CHANGE(0),
-m_iPEAK_SEE_FROM_CHANGE(0),
-m_iHILLS_SEE_FROM_CHANGE(0),
-m_iMAX_REBEL_YIELD_MODIFIER(0),
-m_fCAMERA_MIN_YAW(0),
-m_fCAMERA_MAX_YAW(0),
-m_fCAMERA_FAR_CLIP_Z_HEIGHT(0),
-m_fCAMERA_MAX_TRAVEL_DISTANCE(0),
-m_fCAMERA_START_DISTANCE(0),
-m_fPLOT_SIZE(0),
-m_fCAMERA_SPECIAL_PITCH(0),
-m_fCAMERA_MAX_TURN_OFFSET(0),
-m_fCAMERA_MIN_DISTANCE(0),
-m_fCAMERA_UPPER_PITCH(0),
-m_fCAMERA_LOWER_PITCH(0),
-m_fFIELD_OF_VIEW(0),
-m_fUNIT_MULTISELECT_DISTANCE(0),
-m_iUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK(0),
-m_iUSE_CANNOT_DO_CIVIC_CALLBACK(0),
-m_iUSE_CAN_DO_CIVIC_CALLBACK(0),
-m_iUSE_CANNOT_CONSTRUCT_CALLBACK(0),
-m_iUSE_CAN_CONSTRUCT_CALLBACK(0),
-m_iUSE_CAN_DECLARE_WAR_CALLBACK(0),
-m_iUSE_GET_UNIT_COST_MOD_CALLBACK(0),
-m_iUSE_GET_CITY_FOUND_VALUE_CALLBACK(0),
-m_iUSE_CANNOT_HANDLE_ACTION_CALLBACK(0),
-m_iUSE_CAN_BUILD_CALLBACK(0),
-m_iUSE_CANNOT_TRAIN_CALLBACK(0),
-m_iUSE_CAN_TRAIN_CALLBACK(0),
-m_iUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK(0),
-m_iUSE_FINISH_TEXT_CALLBACK(0),
-m_iUSE_ON_UNIT_SET_XY_CALLBACK(0),
-m_iUSE_ON_UNIT_SELECTED_CALLBACK(0),
-m_iUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK(0),
-m_iUSE_ON_UPDATE_CALLBACK(0),
-m_iUSE_ON_UNIT_CREATED_CALLBACK(0),
-m_iUSE_ON_UNIT_LOST_CALLBACK(0),
-
-// cache XML - start - Nightinggale
-m_cache_ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES(0),
-m_cache_ADVANCED_START_CITY_COST(0),
-m_cache_ADVANCED_START_CITY_COST_INCREASE(0),
-m_cache_ADVANCED_START_CITY_PLACEMENT_MAX_RANGE(0),
-m_cache_ADVANCED_START_CULTURE_COST(0),
-m_cache_ADVANCED_START_MAX_UNITS_PER_CITY(0),
-m_cache_ADVANCED_START_POPULATION_COST(0),
-m_cache_ADVANCED_START_POPULATION_COST_INCREASE(0),
-m_cache_ADVANCED_START_SIGHT_RANGE(0),
-m_cache_ADVANCED_START_VISIBILITY_COST(0),
-m_cache_ADVANCED_START_VISIBILITY_COST_INCREASE(0),
-m_cache_AI_ADVANCED_TECH_START(0),
-m_cache_AI_CAN_DISBAND_UNITS(0),
-m_cache_AI_CHEAT_AUTO_BUY(0),
-m_cache_AI_CHEAT_NEEDED_DEFENDERS(0),
-m_cache_AI_CHEAT_SPICE(0),
-m_cache_AI_CHEAT_SPICE_BUY(0),
-m_cache_AI_CHEAT_SPICE_MULTIPLE(0),
-m_cache_AI_FAVORED_TERRAIN_MOD(0),
-m_cache_AI_HANDICAP_CASTLE(0),
-m_cache_AI_HANDICAP_MOTTE(0),
-m_cache_AI_MILITARY_PROFESSION_HACK(0),
-m_cache_AI_WAREHOUSE_MOD(0),
-m_cache_ALLIANCE_CULTURE_PERCENT_DENIAL(0),
-m_cache_ALLIANCE_PACT_PEACE_DENIAL(0),
-m_cache_ANIMAL_BANDITS_GUARD_GOODY_TIMER(0),
-m_cache_AUTORESEARCH_ALL(0),
-m_cache_BANQUET_YIELD_AMOUNT(0),
-m_cache_BARBARIAN_CIVILIZATION(0),
-m_cache_BARBARIAN_LEADER(0),
-m_cache_BASE_CITY_GROWTH_THRESHOLD(0),
-m_cache_BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD(0),
-m_cache_BASE_OCCUPATION_TURNS(0),
-m_cache_BASE_UNIT_UPGRADE_COST(0),
-m_cache_BUILDINGCLASS_TRAVEL_TO_FAIR(0),
-m_cache_BUILDING_PRODUCTION_DECAY_PERCENT(0),
-m_cache_BUILDING_PRODUCTION_DECAY_TIME(0),
-m_cache_BUILDING_PRODUCTION_PERCENT(0),
-m_cache_BUY_PLOT_BASE_CULTURE_COST(0),
-m_cache_BUY_PLOT_CULTURE_RANGE(0),
-m_cache_BUY_PLOT_MIN_CULTURE(0),
-m_cache_BUY_PLOT_OWNED_COST_MODIFIER(0),
-m_cache_BUY_PLOT_SELLER_INCOME_PERCENT(0),
-m_cache_CALENDER_YEAR_FIRST_CHANGE_TURN(0),
-m_cache_CALENDER_YEAR_FIRST_MULTIPLIER(0),
-m_cache_CALENDER_YEAR_SECOND_CHANGE_TURN(0),
-m_cache_CALENDER_YEAR_SECOND_MULTIPLIER(0),
-m_cache_CALENDER_YEAR_THIRD_MULTIPLIER(0),
-m_cache_CAPITAL_BUILDINGCLASS(0),
-m_cache_CAPTURED_CARGO_RANDOM_AMOUNT(0),
-m_cache_CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT(0),
-m_cache_CASTLES_TO_VILLAGES_RATIO(0),
-m_cache_CHANCE_TO_CAPTURE_CRIMINALS(0),
-m_cache_CHEAT_TRAVEL_ALL(0),
-m_cache_CITY_DEFENSE_DAMAGE_HEAL_RATE(0),
-m_cache_CITY_FREE_CULTURE_GROWTH_FACTOR(0),
-m_cache_CITY_GROWTH_MULTIPLIER(0),
-m_cache_CITY_HEAL_RATE(0),
-m_cache_CITY_PILGRAM_RANDOM(0),
-m_cache_CITY_SCREEN_FOG_ENABLED(0),
-m_cache_CITY_YIELD_CAPACITY(0),
-m_cache_CITY_YIELD_DECAY_PERCENT(0),
-m_cache_CIVICOPTION_INVENTIONS(0),
-m_cache_COLONIAL_FORCED_PEACE_TURNS(0),
-m_cache_COMBAT_DAMAGE(0),
-m_cache_COMBAT_DIE_SIDES(0),
-m_cache_COMBAT_EXPERIENCE_IN_BORDERS_PERCENT(0),
-m_cache_CONSUME_EQUIPMENT_ON_FOUND(0),
-m_cache_CONTACT_YIELD_GIFT_ENCOMEIDA_TIMER(0),
-m_cache_CONTACT_YIELD_GIFT_TECH(0),
-m_cache_CULTURE_YIELD(0),
-m_cache_DEAL_TRADE_RELATIONS_POINTS(0),
-m_cache_DEEP_WATER_TERRAIN(0),
-m_cache_DEFAULT_BUILD_CASTLE(0),
-m_cache_DEFAULT_BUILD_MOTTE_AND_BAILEY(0),
-m_cache_DEFAULT_CENSURETYPE_ANATHEMA(0),
-m_cache_DEFAULT_CENSURETYPE_ANATHEMA_COUNT(0),
-m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION(0),
-m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION_COUNT(0),
-m_cache_DEFAULT_CENSURETYPE_INTERDICT(0),
-m_cache_DEFAULT_CENSURETYPE_INTERDICT_COUNT(0),
-m_cache_DEFAULT_COMBAT_FOR_TRAINING(0),
-m_cache_DEFAULT_DAWN_POPULATION_UNIT(0),
-m_cache_DEFAULT_FUEDALISM_TECH(0),
-m_cache_DEFAULT_GRAIN_GROWTH_UNIT_CLASS(0),
-m_cache_DEFAULT_HUNTSMAN_PROFESSION(0),
-m_cache_DEFAULT_INVENTOR_CLASS(0),
-m_cache_DEFAULT_KNIGHT_PROFESSION_PROMOTION(0),
-m_cache_DEFAULT_KNIGHT_PROMOTION(0),
-m_cache_DEFAULT_MARAUDER_CLASS(0),
-m_cache_DEFAULT_MARUADER_SEA_PROFESSION(0),
-m_cache_DEFAULT_NOBLEMAN_CLASS(0),
-m_cache_DEFAULT_NOBLE_GROWTH_UNIT_CLASS(0),
-m_cache_DEFAULT_PILGRAM_CLASS(0),
-m_cache_DEFAULT_POPULATION_UNIT(0),
-m_cache_DEFAULT_SHRINE_CLASS(0),
-m_cache_DEFAULT_SLAVE_CLASS(0),
-m_cache_DEFAULT_SPECIALBUILDING_COURTHOUSE(0),
-m_cache_DEFAULT_TEST_DEFINE(0),
-m_cache_DEFAULT_TRAINED_PROMOTION(0),
-m_cache_DEFAULT_TREASURE_YIELD(0),
-m_cache_DEFAULT_UNTRAINED_PROMOTION(0),
-m_cache_DEFAULT_VIKING_ERA(0),
-m_cache_DEFAULT_YIELD_ARMOR_TYPE(0),
-m_cache_DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT(0),
-m_cache_DIPLOMACY_VALUE_REMAINDER(0),
-m_cache_DOCKS_NEXT_UNITS(0),
-m_cache_EDUCATION_BASE_TUITION(0),
-m_cache_EDUCATION_THRESHOLD(0),
-m_cache_EDUCATION_THRESHOLD_INCREASE(0),
-m_cache_ENABLE_ALLIANCE_TRADING(0),
-m_cache_ENABLE_DEFENSIVE_PACT_TRADING(0),
-m_cache_ENABLE_GOLD_TRADING(0),
-m_cache_ENABLE_MAP_TRADING(0),
-m_cache_ENABLE_OPEN_BORDERS(0),
-m_cache_END_GAME_DISPLAY_WARNING(0),
-m_cache_ENEMY_HEAL_RATE(0),
-m_cache_ESTABLISH_TRADEPOST_COST(0),
-m_cache_EUROPE_EAST(0),
-m_cache_EUROPE_MARKET_CORRELATION_PERCENT(0),
-m_cache_EVENT_PROBABILITY_ROLL_SIDES(0),
-m_cache_EXPERIENCE_FROM_WITHDRAWL(0),
-m_cache_EXTRA_YIELD(0),
-m_cache_FATHER_COST_EXTRA_TEAM_MEMBER_MODIFIER(0),
-m_cache_FATHER_POINT_REAL_TRADE(0),
-m_cache_FEATURE_PRODUCTION_YIELD_MAX_DISTANCE(0),
-m_cache_FIRST_EVENT_DELAY_TURNS(0),
-m_cache_FOUND_MONASTERY_NUMBER(0),
-m_cache_FOUND_MOTTE_AND_BAILEY_NUMBER(0),
-m_cache_FOUND_OUTPOST_NUMBER(0),
-m_cache_FOUND_VILLAGE_NUMBER(0),
-m_cache_FREE_CITY_ADJACENT_CULTURE(0),
-m_cache_FREE_CITY_CULTURE(0),
-m_cache_FREE_PEASANT_CIVIC(0),
-m_cache_FRIENDLY_HEAL_RATE(0),
-m_cache_GREAT_GENERALS_THRESHOLD(0),
-m_cache_GREAT_GENERALS_THRESHOLD_INCREASE(0),
-m_cache_GREAT_GENERALS_THRESHOLD_INCREASE_TEAM(0),
-m_cache_HIRE_GUARD_COST(0),
-m_cache_HIRE_GUARD_PROMOTION(0),
-m_cache_IMMIGRATION_MAX_CITY_DISTANCE(0),
-m_cache_IMMIGRATION_THRESHOLD(0),
-m_cache_IMMIGRATION_THRESHOLD_INCREASE(0),
-m_cache_IMMIGRATION_TRAVEL_MOD(0),
-m_cache_INDUSTRIAL_VICTORY_SINGLE_YIELD(0),
-m_cache_INITIAL_AI_CITY_PRODUCTION(0),
-m_cache_INITIAL_CITY_POPULATION(0),
-m_cache_INITIAL_CITY_ROUTE_TYPE(0),
-m_cache_JUNGLE_FEATURE(0),
-m_cache_KING_BUY_UNIT_PRICE_MODIFIER(0),
-m_cache_KING_INITIAL_UNIT_INCREASE(0),
-m_cache_KING_TRANSPORT_TREASURE_COMISSION(0),
-m_cache_KNIGHT_RANSOM_MOD(0),
-m_cache_LAKE_PLOT_RAND(0),
-m_cache_LAND_IMPROVEMENT(0),
-m_cache_LAND_TERRAIN(0),
-m_cache_MARAUDERS_DAYSOUT_RANDOM(0),
-m_cache_MARAUDERS_TOWER_RANGE(0),
-m_cache_MARAUDER_CRUMBS_EVENT(0),
-m_cache_MARAUDER_EVENT_DEFAULT_TURNS(0),
-m_cache_MAX_CITY_POPULATION_COMMUNE(0),
-m_cache_MAX_CITY_POPULATION_VILLAGE(0),
-m_cache_MAX_EXPERIENCE_AFTER_UPGRADE(0),
-m_cache_MAX_EXPERIENCE_PER_COMBAT(0),
-m_cache_MAX_FORTIFY_TURNS(0),
-m_cache_MAX_INSULT_MODIFIER(0),
-m_cache_MAX_LEVEL_FROM_ANIMAL_XP(0),
-m_cache_MAX_MARAUDERS(0),
-m_cache_MAX_NUM_LANGUAGES(0),
-m_cache_MAX_PLOT_LIST_SIZE(0),
-m_cache_MAX_REBEL_COMBAT_MULTIPLER(0),
-m_cache_MAX_TRAINED_EXPERIENCE(0),
-m_cache_MAX_WITHDRAWAL_PROBABILITY(0),
-m_cache_MEDIEVAL_CENSURE(0),
-m_cache_MEDIEVAL_TRADE_TECH(0),
-m_cache_MINIMAP_RENDER_SIZE(0),
-m_cache_MIN_ANIMAL_STARTING_DISTANCE(0),
-m_cache_MIN_CITY_YIELD_DECAY(0),
-m_cache_MIN_CIV_STARTING_DISTANCE(0),
-m_cache_MIN_EXPERIENCE_PER_COMBAT(0),
-m_cache_MIN_TIMER_UNIT_DOUBLE_MOVES(0),
-m_cache_MIN_WATER_SIZE_FOR_OCEAN(0),
-m_cache_MISSIONARY_RATE_EFFECT_ON_SUCCESS(0),
-m_cache_MISSIONARY_THRESHOLD(0),
-m_cache_MISSIONARY_THRESHOLD_INCREASE(0),
-m_cache_MONASTERIES_TO_VILLAGES_RATIO(0),
-m_cache_NATIVE_AUTO_SELL_PERCENT(0),
-m_cache_NATIVE_GOODS_RAID_PERCENT(0),
-m_cache_NATIVE_GROWTH_THRESHOLD_MULTIPLIER(0),
-m_cache_NATIVE_HORSES_FOR_SALE(0),
-m_cache_NATIVE_HORSES_FOR_SALE_PERCENT(0),
-m_cache_NATIVE_TEACH_THRESHOLD_INCREASE(0),
-m_cache_NATIVE_TECH(0),
-m_cache_NATIVE_TRADING_TRADEPOST(0),
-m_cache_NEUTRAL_HEAL_RATE(0),
-m_cache_NEW_CITY_BUILDING_VALUE_MODIFIER(0),
-m_cache_NEW_HURRY_MODIFIER(0),
-m_cache_NOBLE_FIELD_LABOR_PENALTY(0),
-m_cache_NO_BAD_GOODIES_EXPERIENCE_PERCENT(0),
-m_cache_NO_BAD_GOODIES_GOLD_PERCENT(0),
-m_cache_NO_CITY_SHORTAGE_MESSAGES(0),
-m_cache_NO_STARTING_PLOTS_IN_JUNGLE(0),
-m_cache_OCCUPATION_CULTURE_PERCENT_THRESHOLD(0),
-m_cache_OCCUPATION_TURNS_POPULATION_PERCENT(0),
-m_cache_OWNERSHIP_SCORE_DURATION_THRESHOLD(0),
-m_cache_OWN_TEAM_STARTING_MODIFIER(0),
-m_cache_PEACE_TREATY_LENGTH(0),
-m_cache_PERCENT_TAX_ON_AUTOSELL_GOODS(0),
-m_cache_PILGRAM_OFFER_GOLD(0),
-m_cache_PILGRAM_OFFER_GOLD_DISTANCE_MOD(0),
-m_cache_PLAYER_ALWAYS_RAZES_CITIES(0),
-m_cache_PLOTS_PER_RIVER_EDGE(0),
-m_cache_PLOT_VISIBILITY_RANGE(0),
-m_cache_PROFESSION_COAL_BURNER(0),
-m_cache_PROFESSION_INVENTOR(0),
-m_cache_PROLIFIC_INVENTOR_THRESHOLD_INCREASE(0),
-m_cache_PROMOTION_BUILD_HOME(0),
-m_cache_RANDOM_TURNS_LOST_AT_SEA(0),
-m_cache_RAZING_CULTURAL_PERCENT_THRESHOLD(0),
-m_cache_REBEL_PERCENT_FOR_REVOLUTION(0),
-m_cache_REBEL_SENTIMENT_BELLS_FACTOR(0),
-m_cache_REBEL_SENTIMENT_TURN_WEIGHT(0),
-m_cache_REVOLUTION_EUROPE_UNIT_SHIP_MODIFIER(0),
-m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD(0),
-m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD_INCREASE(0),
-m_cache_RIVAL_TEAM_STARTING_MODIFIER(0),
-m_cache_RIVER_SOURCE_MIN_RIVER_RANGE(0),
-m_cache_RIVER_SOURCE_MIN_SEAWATER_RANGE(0),
-m_cache_RUINS_IMPROVEMENT(0),
-m_cache_SCORE_FATHER_FACTOR(0),
-m_cache_SCORE_LAND_FACTOR(0),
-m_cache_SCORE_POPULATION_FACTOR(0),
-m_cache_SCORE_TAX_FACTOR(0),
-m_cache_SETTLEMENT_TREASURE_YIELD(0),
-m_cache_SHALLOW_WATER_TERRAIN(0),
-m_cache_SLAVE_FOOD_CONSUMPTION_PER_POPULATION(0),
-m_cache_STANDARD_CALENDAR(0),
-m_cache_STANDARD_CLIMATE(0),
-m_cache_STANDARD_ERA(0),
-m_cache_STANDARD_GAMESPEED(0),
-m_cache_STANDARD_HANDICAP(0),
-m_cache_STANDARD_SEALEVEL(0),
-m_cache_STANDARD_TURNTIMER(0),
-m_cache_STARTING_DISTANCE_PERCENT(0),
-m_cache_START_YEAR(0),
-m_cache_STEAMWORKS_BUILDING(0),
-m_cache_STEAMWORKS_CLASS_TYPE(0),
-m_cache_TAX_INCREASE_CHANCE(0),
-m_cache_TAX_RATE_MAX_INCREASE(0),
-m_cache_TAX_TRADE_THRESHOLD(0),
-m_cache_TAX_TRADE_THRESHOLD_ATTITUDE_PERCENT(0),
-m_cache_TAX_TRADE_THRESHOLD_TAX_RATE_PERCENT(0),
-m_cache_TK_AI_RESEARCH_COST_MOD_PERCENT(0),
-m_cache_TK_HUMAN_RESEARCH_COST_MOD_PERCENT(0),
-m_cache_TK_IDEAS_CITY_VALUE(0),
-m_cache_TK_MAX_FORTS_PER_CITY(0),
-m_cache_TK_PIONEER_COAL_FURNACE_BONUS(0),
-m_cache_TK_PROLIFIC_INVENTOR_PROGRESS(0),
-m_cache_TK_PROLIFIC_INVENTOR_THRESHOLD(0),
-m_cache_TK_RESEARCH_PACT_IDEAS_THRESHOLD(0),
-m_cache_TK_RESEARCH_TRADE_VALUE(0),
-m_cache_TK_STEAMWORKS_MODIFIER(0),
-m_cache_TRADE_POINTS_FOR_ROUTE(0),
-m_cache_TRADE_ROUTE_SPICE(0),
-m_cache_TRADE_STIMULATES_RESEARCH_MIN_VALUE(0),
-m_cache_TRADE_STIMULATES_RESEARCH_PERCENT(0),
-m_cache_TRADING_POINTS_MOD_PERCENT(0),
-m_cache_TREASURE_UNITCLASS(0),
-m_cache_TREASURE_UNITS_ONLY_SELECT_COASTAL(0),
-m_cache_TURNS_TO_TRAIN(0),
-m_cache_UNITARMOR_LEATHER(0),
-m_cache_UNITARMOR_MAIL(0),
-m_cache_UNITARMOR_PLATE(0),
-m_cache_UNITARMOR_SCALE(0),
-m_cache_UNITARMOR_SHIELD(0),
-m_cache_UNITCLASS_PIONEER(0),
-m_cache_UNITTACTIC_PARRY(0),
-m_cache_UNITWEAPON_BLUNT(0),
-m_cache_UNIT_PRODUCTION_DECAY_PERCENT(0),
-m_cache_UNIT_PRODUCTION_DECAY_TIME(0),
-m_cache_UNIT_PRODUCTION_PERCENT(0),
-m_cache_UNIT_UPGRADE_COST_PER_PRODUCTION(0),
-m_cache_UNIT_VISIBILITY_RANGE(0),
-m_cache_USE_MEDIEVAL_CALENDER(0),
-m_cache_VASSAL_CIVILIZATION(0),
-m_cache_VASSAL_LEADER(0),
-m_cache_WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT(0),
-m_cache_WAR_SUCCESS_ATTACKING(0),
-m_cache_WAR_SUCCESS_CITY_CAPTURING(0),
-m_cache_WAR_SUCCESS_DEFENDING(0),
-m_cache_WAR_SUCCESS_UNIT_CAPTURING(0),
-m_cache_WATER_IMPROVEMENT(0),
-m_cache_WATER_UNIT_FACING_DIRECTION(0),
-m_cache_WEEKS_PER_MONTHS(0),
-m_cache_WILD_ANIMAL_ATTACK_WEIGHT(0),
-m_cache_WILD_ANIMAL_LAND_BONUS_NATIVE_WEIGHT(0),
-m_cache_WILD_ANIMAL_LAND_FEATURE_NATIVE_WEIGHT(0),
-m_cache_WILD_ANIMAL_LAND_PATROL_BASE_WEIGHT(0),
-m_cache_WILD_ANIMAL_LAND_TERRAIN_NATIVE_WEIGHT(0),
-m_cache_WILD_ANIMAL_LAND_UNIT_VARIATION_WEIGHT(0),
-m_cache_WILD_ANIMAL_SEA_BONUS_NATIVE_WEIGHT(0),
-m_cache_WILD_ANIMAL_SEA_FEATURE_NATIVE_WEIGHT(0),
-m_cache_WILD_ANIMAL_SEA_PATROL_BASE_WEIGHT(0),
-m_cache_WILD_ANIMAL_SEA_TERRAIN_NATIVE_WEIGHT(0),
-m_cache_WILD_ANIMAL_SEA_UNIT_VARIATION_WEIGHT(0),
-// cache XML - end - Nightinggale
-
-m_paHints(NULL),
-m_paMainMenus(NULL)
-{
-}
-
-CvGlobals::~CvGlobals()
-{
-}
-
-//
-// allocate
-//
-void CvGlobals::init()
-{
-	//
-	// These vars are used to initialize the globals.
-	//
-
-	int aiPlotDirectionX[NUM_DIRECTION_TYPES] =
-	{
-		0,	// DIRECTION_NORTH
-		1,	// DIRECTION_NORTHEAST
-		1,	// DIRECTION_EAST
-		1,	// DIRECTION_SOUTHEAST
-		0,	// DIRECTION_SOUTH
-		-1,	// DIRECTION_SOUTHWEST
-		-1,	// DIRECTION_WEST
-		-1,	// DIRECTION_NORTHWEST
-	};
-
-	int aiPlotDirectionY[NUM_DIRECTION_TYPES] =
-	{
-		1,	// DIRECTION_NORTH
-		1,	// DIRECTION_NORTHEAST
-		0,	// DIRECTION_EAST
-		-1,	// DIRECTION_SOUTHEAST
-		-1,	// DIRECTION_SOUTH
-		-1,	// DIRECTION_SOUTHWEST
-		0,	// DIRECTION_WEST
-		1,	// DIRECTION_NORTHWEST
-	};
-
-	int aiPlotCardinalDirectionX[NUM_CARDINALDIRECTION_TYPES] =
-	{
-		0,	// CARDINALDIRECTION_NORTH
-		1,	// CARDINALDIRECTION_EAST
-		0,	// CARDINALDIRECTION_SOUTH
-		-1,	// CARDINALDIRECTION_WEST
-	};
-
-	int aiPlotCardinalDirectionY[NUM_CARDINALDIRECTION_TYPES] =
-	{
-		1,	// CARDINALDIRECTION_NORTH
-		0,	// CARDINALDIRECTION_EAST
-		-1,	// CARDINALDIRECTION_SOUTH
-		0,	// CARDINALDIRECTION_WEST
-	};
-
-	int aiCityPlotX[NUM_CITY_PLOTS] =
-	{
-		0,
-		0, 1, 1, 1, 0,-1,-1,-1,
-//		0, 1, 2, 2, 2, 1, 0,-1,-2,-2,-2,-1,
-	};
-
-	int aiCityPlotY[NUM_CITY_PLOTS] =
-	{
-		0,
-		1, 1, 0,-1,-1,-1, 0, 1,
-//		2, 2, 1, 0,-1,-2,-2,-2,-1, 0, 1, 2,
-	};
-
-	int aiCityPlotPriority[NUM_CITY_PLOTS] =
-	{
-		0,
-		1, 2, 1, 2, 1, 2, 1, 2,
-//		3, 4, 4, 3, 4, 4, 3, 4, 4, 3, 4, 4,
-	};
-
-	int aaiXYCityPlot[CITY_PLOTS_DIAMETER][CITY_PLOTS_DIAMETER] =
-	{
-		{6, 7, 8,},
-
-		{5, 0, 1,},
-
-		{4, 3, 2,}
-	};
-
-	DirectionTypes aeTurnRightDirection[NUM_DIRECTION_TYPES] =
-	{
-		DIRECTION_NORTHEAST,	// DIRECTION_NORTH
-		DIRECTION_EAST,				// DIRECTION_NORTHEAST
-		DIRECTION_SOUTHEAST,	// DIRECTION_EAST
-		DIRECTION_SOUTH,			// DIRECTION_SOUTHEAST
-		DIRECTION_SOUTHWEST,	// DIRECTION_SOUTH
-		DIRECTION_WEST,				// DIRECTION_SOUTHWEST
-		DIRECTION_NORTHWEST,	// DIRECTION_WEST
-		DIRECTION_NORTH,			// DIRECTION_NORTHWEST
-	};
-
-	DirectionTypes aeTurnLeftDirection[NUM_DIRECTION_TYPES] =
-	{
-		DIRECTION_NORTHWEST,	// DIRECTION_NORTH
-		DIRECTION_NORTH,			// DIRECTION_NORTHEAST
-		DIRECTION_NORTHEAST,	// DIRECTION_EAST
-		DIRECTION_EAST,				// DIRECTION_SOUTHEAST
-		DIRECTION_SOUTHEAST,	// DIRECTION_SOUTH
-		DIRECTION_SOUTH,			// DIRECTION_SOUTHWEST
-		DIRECTION_SOUTHWEST,	// DIRECTION_WEST
-		DIRECTION_WEST,				// DIRECTION_NORTHWEST
-	};
-
-	DirectionTypes aaeXYDirection[DIRECTION_DIAMETER][DIRECTION_DIAMETER] =
-	{
-		DIRECTION_SOUTHWEST, DIRECTION_WEST,	DIRECTION_NORTHWEST,
-		DIRECTION_SOUTH,     NO_DIRECTION,    DIRECTION_NORTH,
-		DIRECTION_SOUTHEAST, DIRECTION_EAST,	DIRECTION_NORTHEAST,
-	};
-
-	FAssertMsg(gDLL != NULL, "Civ app needs to set gDLL");
-
-	m_VarSystem = new FVariableSystem;
-	m_asyncRand = new CvRandom;
-	m_initCore = new CvInitCore;
-	m_loadedInitCore = new CvInitCore;
-	m_iniInitCore = new CvInitCore;
-
-	gDLL->initGlobals();	// some globals need to be allocated outside the dll
-
-	m_game = new CvGameAI;
-	m_map = new CvMap;
-
-	CvPlayerAI::initStatics();
-	CvTeamAI::initStatics();
-
-	m_pt3Origin = NiPoint3(0.0f, 0.0f, 0.0f);
-
-	COPY(m_aiPlotDirectionX, aiPlotDirectionX, int);
-	COPY(m_aiPlotDirectionY, aiPlotDirectionY, int);
-	COPY(m_aiPlotCardinalDirectionX, aiPlotCardinalDirectionX, int);
-	COPY(m_aiPlotCardinalDirectionY, aiPlotCardinalDirectionY, int);
-	COPY(m_aiCityPlotX, aiCityPlotX, int);
-	COPY(m_aiCityPlotY, aiCityPlotY, int);
-	COPY(m_aiCityPlotPriority, aiCityPlotPriority, int);
-	COPY(m_aeTurnLeftDirection, aeTurnLeftDirection, DirectionTypes);
-	COPY(m_aeTurnRightDirection, aeTurnRightDirection, DirectionTypes);
-	memcpy(m_aaiXYCityPlot, aaiXYCityPlot, sizeof(m_aaiXYCityPlot));
-	memcpy(m_aaeXYDirection, aaeXYDirection,sizeof(m_aaeXYDirection));
-}
-
-//
-// free
-//
-void CvGlobals::uninit()
-{
-	//
-	// See also CvXMLLoadUtilityInit.cpp::CleanUpGlobalVariables()
-	//
-	SAFE_DELETE_ARRAY(m_aiPlotDirectionX);
-	SAFE_DELETE_ARRAY(m_aiPlotDirectionY);
-	SAFE_DELETE_ARRAY(m_aiPlotCardinalDirectionX);
-	SAFE_DELETE_ARRAY(m_aiPlotCardinalDirectionY);
-	SAFE_DELETE_ARRAY(m_aiCityPlotX);
-	SAFE_DELETE_ARRAY(m_aiCityPlotY);
-	SAFE_DELETE_ARRAY(m_aiCityPlotPriority);
-	SAFE_DELETE_ARRAY(m_aeTurnLeftDirection);
-	SAFE_DELETE_ARRAY(m_aeTurnRightDirection);
-
-	CvPlayerAI::freeStatics();
-	CvTeamAI::freeStatics();
-
-	SAFE_DELETE(m_game);
-	SAFE_DELETE(m_map);
-
-	SAFE_DELETE(m_asyncRand);
-	SAFE_DELETE(m_initCore);
-	SAFE_DELETE(m_loadedInitCore);
-	SAFE_DELETE(m_iniInitCore);
-	gDLL->uninitGlobals();	// free globals allocated outside the dll
-	SAFE_DELETE(m_VarSystem);
-
-	// already deleted outside of the dll, set to null for safety
-	m_messageQueue=NULL;
-	m_hotJoinMsgQueue=NULL;
-	m_messageControl=NULL;
-	m_setupData=NULL;
-	m_messageCodes=NULL;
-	m_dropMgr=NULL;
-	m_portal=NULL;
-	m_statsReporter=NULL;
-	m_interface=NULL;
-	m_diplomacyScreen=NULL;
-	m_mpDiplomacyScreen=NULL;
-	m_pathFinder=NULL;
-	m_interfacePathFinder=NULL;
-	m_stepFinder=NULL;
-	m_routeFinder=NULL;
-	m_borderFinder=NULL;
-	m_areaFinder=NULL;
-
-	deleteInfoArrays();
-}
-
-void CvGlobals::clearTypesMap()
-{
-	infoTypeFromStringReset();
-	if (m_VarSystem)
-	{
-		m_VarSystem->UnInit();
-	}
-}
-
-
-CvDiplomacyScreen* CvGlobals::getDiplomacyScreen()
-{
-	return m_diplomacyScreen;
-}
-
-CMPDiplomacyScreen* CvGlobals::getMPDiplomacyScreen()
-{
-	return m_mpDiplomacyScreen;
-}
-
-CvMessageCodeTranslator& CvGlobals::getMessageCodes()
-{
-	return *m_messageCodes;
-}
-
-FMPIManager*& CvGlobals::getFMPMgrPtr()
-{
-	return m_pFMPMgr;
-}
-
-CvPortal& CvGlobals::getPortal()
-{
-	return *m_portal;
-}
-
-CvSetupData& CvGlobals::getSetupData()
-{
-	return *m_setupData;
-}
-
-CvInitCore& CvGlobals::getInitCore()
-{
-	return *m_initCore;
-}
-
-CvInitCore& CvGlobals::getLoadedInitCore()
-{
-	return *m_loadedInitCore;
-}
-
-CvInitCore& CvGlobals::getIniInitCore()
-{
-	return *m_iniInitCore;
-}
-
-CvStatsReporter& CvGlobals::getStatsReporter()
-{
-	return *m_statsReporter;
-}
-
-CvStatsReporter* CvGlobals::getStatsReporterPtr()
-{
-	return m_statsReporter;
-}
-
-CvInterface& CvGlobals::getInterface()
-{
-	return *m_interface;
-}
-
-CvInterface* CvGlobals::getInterfacePtr()
-{
-	return m_interface;
-}
-
-CvRandom& CvGlobals::getASyncRand()
-{
-	return *m_asyncRand;
-}
-
-CMessageQueue& CvGlobals::getMessageQueue()
-{
-	return *m_messageQueue;
-}
-
-CMessageQueue& CvGlobals::getHotMessageQueue()
-{
-	return *m_hotJoinMsgQueue;
-}
-
-CMessageControl& CvGlobals::getMessageControl()
-{
-	return *m_messageControl;
-}
-
-CvDropMgr& CvGlobals::getDropMgr()
-{
-	return *m_dropMgr;
-}
-
-FAStar& CvGlobals::getPathFinder()
-{
-	return *m_pathFinder;
-}
-
-FAStar& CvGlobals::getInterfacePathFinder()
-{
-	return *m_interfacePathFinder;
-}
-
-FAStar& CvGlobals::getStepFinder()
-{
-	return *m_stepFinder;
-}
-
-FAStar& CvGlobals::getRouteFinder()
-{
-	return *m_routeFinder;
-}
-
-FAStar& CvGlobals::getBorderFinder()
-{
-	return *m_borderFinder;
-}
-
-FAStar& CvGlobals::getAreaFinder()
-{
-	return *m_areaFinder;
-}
-
-NiPoint3& CvGlobals::getPt3Origin()
-{
-	return m_pt3Origin;
-}
-
-std::vector<CvInterfaceModeInfo*>& CvGlobals::getInterfaceModeInfo()		// For Moose - XML Load Util and CvInfos
-{
-	return m_paInterfaceModeInfo;
-}
-
-CvInterfaceModeInfo& CvGlobals::getInterfaceModeInfo(InterfaceModeTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_INTERFACEMODE_TYPES);
-	return *(m_paInterfaceModeInfo[e]);
-}
-
-NiPoint3& CvGlobals::getPt3CameraDir()
-{
-	return m_pt3CameraDir;
-}
-
-bool& CvGlobals::getLogging()
-{
-	return m_bLogging;
-}
-
-bool& CvGlobals::getRandLogging()
-{
-	return m_bRandLogging;
-}
-
-bool& CvGlobals::getSynchLogging()
-{
-	return m_bSynchLogging;
-}
-
-bool& CvGlobals::overwriteLogs()
-{
-	return m_bOverwriteLogs;
-}
-
-int* CvGlobals::getPlotDirectionX()
-{
-	return m_aiPlotDirectionX;
-}
-
-int* CvGlobals::getPlotDirectionY()
-{
-	return m_aiPlotDirectionY;
-}
-
-int* CvGlobals::getPlotCardinalDirectionX()
-{
-	return m_aiPlotCardinalDirectionX;
-}
-
-int* CvGlobals::getPlotCardinalDirectionY()
-{
-	return m_aiPlotCardinalDirectionY;
-}
-
-int* CvGlobals::getCityPlotX()
-{
-	return m_aiCityPlotX;
-}
-
-int* CvGlobals::getCityPlotY()
-{
-	return m_aiCityPlotY;
-}
-
-int* CvGlobals::getCityPlotPriority()
-{
-	return m_aiCityPlotPriority;
-}
-
-int CvGlobals::getXYCityPlot(int i, int j)
-{
-	FAssertMsg(i < CITY_PLOTS_DIAMETER, "Index out of bounds");
-	FAssertMsg(i > -1, "Index out of bounds");
-	FAssertMsg(j < CITY_PLOTS_DIAMETER, "Index out of bounds");
-	FAssertMsg(j > -1, "Index out of bounds");
-	return m_aaiXYCityPlot[i][j];
-}
-
-DirectionTypes* CvGlobals::getTurnLeftDirection()
-{
-	return m_aeTurnLeftDirection;
-}
-
-DirectionTypes CvGlobals::getTurnLeftDirection(int i)
-{
-	FAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
-	FAssertMsg(i > -1, "Index out of bounds");
-	return m_aeTurnLeftDirection[i];
-}
-
-DirectionTypes* CvGlobals::getTurnRightDirection()
-{
-	return m_aeTurnRightDirection;
-}
-
-DirectionTypes CvGlobals::getTurnRightDirection(int i)
-{
-	FAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
-	FAssertMsg(i > -1, "Index out of bounds");
-	return m_aeTurnRightDirection[i];
-}
-
-DirectionTypes CvGlobals::getXYDirection(int i, int j)
-{
-	FAssertMsg(i < DIRECTION_DIAMETER, "Index out of bounds");
-	FAssertMsg(i > -1, "Index out of bounds");
-	FAssertMsg(j < DIRECTION_DIAMETER, "Index out of bounds");
-	FAssertMsg(j > -1, "Index out of bounds");
-	return m_aaeXYDirection[i][j];
-}
-
-int CvGlobals::getNumWorldInfos()
-{
-	return (int)m_paWorldInfo.size();
-}
-
-std::vector<CvWorldInfo*>& CvGlobals::getWorldInfo()
-{
-	return m_paWorldInfo;
-}
-
-CvWorldInfo& CvGlobals::getWorldInfo(WorldSizeTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumWorldInfos());
-	return *(m_paWorldInfo[e]);
-}
-
-/////////////////////////////////////////////
-// CLIMATE
-/////////////////////////////////////////////
-
-int CvGlobals::getNumClimateInfos()
-{
-	return (int)m_paClimateInfo.size();
-}
-
-std::vector<CvClimateInfo*>& CvGlobals::getClimateInfo()
-{
-	return m_paClimateInfo;
-}
-
-CvClimateInfo& CvGlobals::getClimateInfo(ClimateTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumClimateInfos());
-	return *(m_paClimateInfo[e]);
-}
-
-/////////////////////////////////////////////
-// SEALEVEL
-/////////////////////////////////////////////
-
-int CvGlobals::getNumSeaLevelInfos()
-{
-	return (int)m_paSeaLevelInfo.size();
-}
-
-std::vector<CvSeaLevelInfo*>& CvGlobals::getSeaLevelInfo()
-{
-	return m_paSeaLevelInfo;
-}
-
-CvSeaLevelInfo& CvGlobals::getSeaLevelInfo(SeaLevelTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumSeaLevelInfos());
-	return *(m_paSeaLevelInfo[e]);
-}
-
-/////////////////////////////////////////////
-// EUROPE
-/////////////////////////////////////////////
-
-int CvGlobals::getNumEuropeInfos()
-{
-	return (int)m_paEuropeInfo.size();
-}
-
-std::vector<CvEuropeInfo*>& CvGlobals::getEuropeInfo()
-{
-	return m_paEuropeInfo;
-}
-
-CvEuropeInfo& CvGlobals::getEuropeInfo(EuropeTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumEuropeInfos());
-	return *(m_paEuropeInfo[e]);
-}
-
-int CvGlobals::getNumHints()
-{
-	return (int)m_paHints.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getHints()
-{
-	return m_paHints;
-}
-
-CvInfoBase& CvGlobals::getHints(int i)
-{
-	return *(m_paHints[i]);
-}
-
-int CvGlobals::getNumMainMenus()
-{
-	return (int)m_paMainMenus.size();
-}
-
-std::vector<CvMainMenuInfo*>& CvGlobals::getMainMenus()
-{
-	return m_paMainMenus;
-}
-
-CvMainMenuInfo& CvGlobals::getMainMenus(int i)
-{
-	if (i >= getNumMainMenus())
-	{
-		return *(m_paMainMenus[0]);
-	}
-
-	return *(m_paMainMenus[i]);
-}
-
-int CvGlobals::getNumColorInfos()
-{
-	return (int)m_paColorInfo.size();
-}
-
-std::vector<CvColorInfo*>& CvGlobals::getColorInfo()
-{
-	return m_paColorInfo;
-}
-
-CvColorInfo& CvGlobals::getColorInfo(ColorTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumColorInfos());
-	return *(m_paColorInfo[e]);
-}
-
-
-int CvGlobals::getNumPlayerColorInfos()
-{
-	return (int)m_paPlayerColorInfo.size();
-}
-
-std::vector<CvPlayerColorInfo*>& CvGlobals::getPlayerColorInfo()
-{
-	return m_paPlayerColorInfo;
-}
-
-CvPlayerColorInfo& CvGlobals::getPlayerColorInfo(PlayerColorTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumPlayerColorInfos());
-	return *(m_paPlayerColorInfo[e]);
-}
-
-int CvGlobals::getNumRouteModelInfos()
-{
-	return (int)m_paRouteModelInfo.size();
-}
-
-std::vector<CvRouteModelInfo*>& CvGlobals::getRouteModelInfo()
-{
-	return m_paRouteModelInfo;
-}
-
-CvRouteModelInfo& CvGlobals::getRouteModelInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumRouteModelInfos());
-	return *(m_paRouteModelInfo[i]);
-}
-
-int CvGlobals::getNumRiverModelInfos()
-{
-	return (int)m_paRiverModelInfo.size();
-}
-
-std::vector<CvRiverModelInfo*>& CvGlobals::getRiverModelInfo()
-{
-	return m_paRiverModelInfo;
-}
-
-CvRiverModelInfo& CvGlobals::getRiverModelInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumRiverModelInfos());
-	return *(m_paRiverModelInfo[i]);
-}
-
-int CvGlobals::getNumWaterPlaneInfos()
-{
-	return (int)m_paWaterPlaneInfo.size();
-}
-
-std::vector<CvWaterPlaneInfo*>& CvGlobals::getWaterPlaneInfo()
-{
-	return m_paWaterPlaneInfo;
-}
-
-CvWaterPlaneInfo& CvGlobals::getWaterPlaneInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumWaterPlaneInfos());
-	return *(m_paWaterPlaneInfo[i]);
-}
-
-int CvGlobals::getNumTerrainPlaneInfos()
-{
-	return (int)m_paTerrainPlaneInfo.size();
-}
-
-std::vector<CvTerrainPlaneInfo*>& CvGlobals::getTerrainPlaneInfo()
-{
-	return m_paTerrainPlaneInfo;
-}
-
-CvTerrainPlaneInfo& CvGlobals::getTerrainPlaneInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumTerrainPlaneInfos());
-	return *(m_paTerrainPlaneInfo[i]);
-}
-
-int CvGlobals::getNumCameraOverlayInfos()
-{
-	return (int)m_paCameraOverlayInfo.size();
-}
-
-std::vector<CvCameraOverlayInfo*>& CvGlobals::getCameraOverlayInfo()
-{
-	return m_paCameraOverlayInfo;
-}
-
-CvCameraOverlayInfo& CvGlobals::getCameraOverlayInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumCameraOverlayInfos());
-	return *(m_paCameraOverlayInfo[i]);
-}
-
-int CvGlobals::getNumAnimationPathInfos()
-{
-	return (int)m_paAnimationPathInfo.size();
-}
-
-std::vector<CvAnimationPathInfo*>& CvGlobals::getAnimationPathInfo()
-{
-	return m_paAnimationPathInfo;
-}
-
-CvAnimationPathInfo& CvGlobals::getAnimationPathInfo(AnimationPathTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumAnimationPathInfos());
-	return *(m_paAnimationPathInfo[e]);
-}
-
-int CvGlobals::getNumAnimationCategoryInfos()
-{
-	return (int)m_paAnimationCategoryInfo.size();
-}
-
-std::vector<CvAnimationCategoryInfo*>& CvGlobals::getAnimationCategoryInfo()
-{
-	return m_paAnimationCategoryInfo;
-}
-
-CvAnimationCategoryInfo& CvGlobals::getAnimationCategoryInfo(AnimationCategoryTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumAnimationCategoryInfos());
-	return *(m_paAnimationCategoryInfo[e]);
-}
-
-int CvGlobals::getNumEntityEventInfos()
-{
-	return (int)m_paEntityEventInfo.size();
-}
-
-std::vector<CvEntityEventInfo*>& CvGlobals::getEntityEventInfo()
-{
-	return m_paEntityEventInfo;
-}
-
-CvEntityEventInfo& CvGlobals::getEntityEventInfo(EntityEventTypes e)
-{
-	FAssert( e > -1 );
-	FAssert( e < GC.getNumEntityEventInfos() );
-	return *(m_paEntityEventInfo[e]);
-}
-
-int CvGlobals::getNumEffectInfos()
-{
-	return (int)m_paEffectInfo.size();
-}
-
-std::vector<CvEffectInfo*>& CvGlobals::getEffectInfo()
-{
-	return m_paEffectInfo;
-}
-
-CvEffectInfo& CvGlobals::getEffectInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumEffectInfos());
-	return *(m_paEffectInfo[i]);
-}
-
-
-int CvGlobals::getNumAttachableInfos()
-{
-	return (int)m_paAttachableInfo.size();
-}
-
-std::vector<CvAttachableInfo*>& CvGlobals::getAttachableInfo()
-{
-	return m_paAttachableInfo;
-}
-
-CvAttachableInfo& CvGlobals::getAttachableInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumAttachableInfos());
-	return *(m_paAttachableInfo[i]);
-}
-
-int CvGlobals::getNumUnitFormationInfos()
-{
-	return (int)m_paUnitFormationInfo.size();
-}
-
-std::vector<CvUnitFormationInfo*>& CvGlobals::getUnitFormationInfo()		// For Moose - CvUnitEntity
-{
-	return m_paUnitFormationInfo;
-}
-
-CvUnitFormationInfo& CvGlobals::getUnitFormationInfo(int i)
-{
-	FAssert(i > -1);
-	FAssert(i < GC.getNumUnitFormationInfos());
-	return *(m_paUnitFormationInfo[i]);
-}
-
-// TEXT
-int CvGlobals::getNumGameTextXML()
-{
-	return (int)m_paGameTextXML.size();
-}
-
-std::vector<CvGameText*>& CvGlobals::getGameTextXML()
-{
-	return m_paGameTextXML;
-}
-
-// Landscape INFOS
-int CvGlobals::getNumLandscapeInfos()
-{
-	return (int)m_paLandscapeInfo.size();
-}
-
-std::vector<CvLandscapeInfo*>& CvGlobals::getLandscapeInfo()
-{
-	return m_paLandscapeInfo;
-}
-
-CvLandscapeInfo& CvGlobals::getLandscapeInfo(int iIndex)
-{
-	FAssert(iIndex > -1);
-	FAssert(iIndex < GC.getNumLandscapeInfos());
-	return *(m_paLandscapeInfo[iIndex]);
-}
-
-int CvGlobals::getActiveLandscapeID()
-{
-	return m_iActiveLandscapeID;
-}
-
-void CvGlobals::setActiveLandscapeID(int iLandscapeID)
-{
-	m_iActiveLandscapeID = iLandscapeID;
-}
-
-
-int CvGlobals::getNumTerrainInfos()
-{
-	return (int)m_paTerrainInfo.size();
-}
-
-std::vector<CvTerrainInfo*>& CvGlobals::getTerrainInfo()		// For Moose - XML Load Util, CvInfos, CvTerrainTypeWBPalette
-{
-	return m_paTerrainInfo;
-}
-
-CvTerrainInfo& CvGlobals::getTerrainInfo(TerrainTypes eTerrainNum)
-{
-	FAssert(eTerrainNum > -1);
-	FAssert(eTerrainNum < (int)m_paTerrainInfo.size());
-	return *(m_paTerrainInfo[eTerrainNum]);
-}
-
-int CvGlobals::getNumBonusInfos()
-{
-	return (int)m_paBonusInfo.size();
-}
-
-std::vector<CvBonusInfo*>& CvGlobals::getBonusInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paBonusInfo;
-}
-
-CvBonusInfo& CvGlobals::getBonusInfo(BonusTypes eBonusNum)
-{
-	FAssert(eBonusNum > -1);
-	FAssert(eBonusNum < (int)m_paBonusInfo.size());
-	return *(m_paBonusInfo[eBonusNum]);
-}
-
-int CvGlobals::getNumFeatureInfos()
-{
-	return (int)m_paFeatureInfo.size();
-}
-
-std::vector<CvFeatureInfo*>& CvGlobals::getFeatureInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paFeatureInfo;
-}
-
-CvFeatureInfo& CvGlobals::getFeatureInfo(FeatureTypes eFeatureNum)
-{
-	FAssert(eFeatureNum > -1);
-	FAssert(eFeatureNum < (int)m_paFeatureInfo.size());
-	return *(m_paFeatureInfo[eFeatureNum]);
-}
-
-int CvGlobals::getNumCivilizationInfos()
-{
-	return (int)m_paCivilizationInfo.size();
-}
-
-std::vector<CvCivilizationInfo*>& CvGlobals::getCivilizationInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paCivilizationInfo;
-}
-
-CvCivilizationInfo& CvGlobals::getCivilizationInfo(CivilizationTypes eCivilizationNum)
-{
-	FAssert(eCivilizationNum > -1);
-	FAssert(eCivilizationNum < (int)m_paCivilizationInfo.size());
-	return *(m_paCivilizationInfo[eCivilizationNum]);
-}
-
-
-int CvGlobals::getNumLeaderHeadInfos()
-{
-	return (int)m_paLeaderHeadInfo.size();
-}
-
-std::vector<CvLeaderHeadInfo*>& CvGlobals::getLeaderHeadInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paLeaderHeadInfo;
-}
-
-CvLeaderHeadInfo& CvGlobals::getLeaderHeadInfo(LeaderHeadTypes eLeaderHeadNum)
-{
-	FAssert(eLeaderHeadNum > -1);
-	FAssert(eLeaderHeadNum < GC.getNumLeaderHeadInfos());
-	return *(m_paLeaderHeadInfo[eLeaderHeadNum]);
-}
-
-
-int CvGlobals::getNumTraitInfos()
-{
-	return (int)m_paTraitInfo.size();
-}
-
-std::vector<CvTraitInfo*>& CvGlobals::getTraitInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paTraitInfo;
-}
-
-CvTraitInfo& CvGlobals::getTraitInfo(TraitTypes eTraitNum)
-{
-	FAssert(eTraitNum > -1);
-	FAssert(eTraitNum < GC.getNumTraitInfos());
-	return *(m_paTraitInfo[eTraitNum]);
-}
-
-
-int CvGlobals::getNumCursorInfos()
-{
-	return (int)m_paCursorInfo.size();
-}
-
-std::vector<CvCursorInfo*>& CvGlobals::getCursorInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paCursorInfo;
-}
-
-CvCursorInfo& CvGlobals::getCursorInfo(CursorTypes eCursorNum)
-{
-	FAssert(eCursorNum > -1);
-	FAssert(eCursorNum < GC.getNumCursorInfos());
-	return *(m_paCursorInfo[eCursorNum]);
-}
-
-int CvGlobals::getNumSlideShowInfos()
-{
-	return (int)m_paSlideShowInfo.size();
-}
-
-std::vector<CvSlideShowInfo*>& CvGlobals::getSlideShowInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paSlideShowInfo;
-}
-
-CvSlideShowInfo& CvGlobals::getSlideShowInfo(int iIndex)
-{
-	FAssert(iIndex > -1);
-	FAssert(iIndex < GC.getNumSlideShowInfos());
-	return *(m_paSlideShowInfo[iIndex]);
-}
-
-int CvGlobals::getNumSlideShowRandomInfos()
-{
-	return (int)m_paSlideShowRandomInfo.size();
-}
-
-std::vector<CvSlideShowRandomInfo*>& CvGlobals::getSlideShowRandomInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paSlideShowRandomInfo;
-}
-
-CvSlideShowRandomInfo& CvGlobals::getSlideShowRandomInfo(int iIndex)
-{
-	FAssert(iIndex > -1);
-	FAssert(iIndex < GC.getNumSlideShowRandomInfos());
-	return *(m_paSlideShowRandomInfo[iIndex]);
-}
-
-int CvGlobals::getNumWorldPickerInfos()
-{
-	return (int)m_paWorldPickerInfo.size();
-}
-
-std::vector<CvWorldPickerInfo*>& CvGlobals::getWorldPickerInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paWorldPickerInfo;
-}
-
-CvWorldPickerInfo& CvGlobals::getWorldPickerInfo(int iIndex)
-{
-	FAssert(iIndex > -1);
-	FAssert(iIndex < GC.getNumWorldPickerInfos());
-	return *(m_paWorldPickerInfo[iIndex]);
-}
-
-int CvGlobals::getNumUnitInfos()
-{
-	return (int)m_paUnitInfo.size();
-}
-
-std::vector<CvUnitInfo*>& CvGlobals::getUnitInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paUnitInfo;
-}
-
-CvUnitInfo& CvGlobals::getUnitInfo(UnitTypes eUnitNum)
-{
-	FAssert(eUnitNum > -1);
-	FAssert(eUnitNum < GC.getNumUnitInfos());
-	return *(m_paUnitInfo[eUnitNum]);
-}
-
-int CvGlobals::getNumSpecialUnitInfos()
-{
-	return (int)m_paSpecialUnitInfo.size();
-}
-
-std::vector<CvSpecialUnitInfo*>& CvGlobals::getSpecialUnitInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paSpecialUnitInfo;
-}
-
-CvSpecialUnitInfo& CvGlobals::getSpecialUnitInfo(SpecialUnitTypes eSpecialUnitNum)
-{
-	FAssert(eSpecialUnitNum > -1);
-	FAssert(eSpecialUnitNum < GC.getNumSpecialUnitInfos());
-	return *(m_paSpecialUnitInfo[eSpecialUnitNum]);
-}
-
-
-int CvGlobals::getNumConceptInfos()
-{
-	return (int)m_paConceptInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getConceptInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paConceptInfo;
-}
-
-CvInfoBase& CvGlobals::getConceptInfo(ConceptTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumConceptInfos());
-	return *(m_paConceptInfo[e]);
-}
-int CvGlobals::getNumCalendarInfos()
-{
-	return (int)m_paCalendarInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getCalendarInfo()
-{
-	return m_paCalendarInfo;
-}
-
-CvInfoBase& CvGlobals::getCalendarInfo(CalendarTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumCalendarInfos());
-	return *(m_paCalendarInfo[e]);
-}
-
-
-int CvGlobals::getNumSeasonInfos()
-{
-	return (int)m_paSeasonInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getSeasonInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paSeasonInfo;
-}
-
-CvInfoBase& CvGlobals::getSeasonInfo(SeasonTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumSeasonInfos());
-	return *(m_paSeasonInfo[e]);
-}
-
-
-int CvGlobals::getNumMonthInfos()
-{
-	return (int)m_paMonthInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getMonthInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paMonthInfo;
-}
-
-CvInfoBase& CvGlobals::getMonthInfo(MonthTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumMonthInfos());
-	return *(m_paMonthInfo[e]);
-}
-
-
-int CvGlobals::getNumDenialInfos()
-{
-	return (int)m_paDenialInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getDenialInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paDenialInfo;
-}
-
-CvInfoBase& CvGlobals::getDenialInfo(DenialTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumDenialInfos());
-	return *(m_paDenialInfo[e]);
-}
-
-
-int CvGlobals::getNumInvisibleInfos()
-{
-	return (int)m_paInvisibleInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getInvisibleInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paInvisibleInfo;
-}
-
-CvInfoBase& CvGlobals::getInvisibleInfo(InvisibleTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumInvisibleInfos());
-	return *(m_paInvisibleInfo[e]);
-}
-
-
-int CvGlobals::getNumFatherInfos()
-{
-	return (int)m_paFatherInfo.size();
-}
-
-std::vector<CvFatherInfo*>& CvGlobals::getFatherInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paFatherInfo;
-}
-
-CvFatherInfo& CvGlobals::getFatherInfo(FatherTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumFatherInfos());
-	return *(m_paFatherInfo[e]);
-}
-
-int CvGlobals::getNumFatherPointInfos()
-{
-	return (int)m_paFatherPointInfo.size();
-}
-
-std::vector<CvFatherPointInfo*>& CvGlobals::getFatherPointInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paFatherPointInfo;
-}
-
-CvFatherPointInfo& CvGlobals::getFatherPointInfo(FatherPointTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumFatherPointInfos());
-	return *(m_paFatherPointInfo[e]);
-}
-
-int CvGlobals::getNumUnitCombatInfos()
-{
-	return (int)m_paUnitCombatInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getUnitCombatInfo()
-{
-	return m_paUnitCombatInfo;
-}
-
-CvInfoBase& CvGlobals::getUnitCombatInfo(UnitCombatTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumUnitCombatInfos());
-	return *(m_paUnitCombatInfo[e]);
-}
-
-
-std::vector<CvInfoBase*>& CvGlobals::getDomainInfo()
-{
-	return m_paDomainInfo;
-}
-
-CvInfoBase& CvGlobals::getDomainInfo(DomainTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_DOMAIN_TYPES);
-	return *(m_paDomainInfo[e]);
-}
-
-
-std::vector<CvInfoBase*>& CvGlobals::getUnitAIInfo()
-{
-	return m_paUnitAIInfos;
-}
-
-CvInfoBase& CvGlobals::getUnitAIInfo(UnitAITypes eUnitAINum)
-{
-	FAssert(eUnitAINum >= 0);
-	FAssert(eUnitAINum < NUM_UNITAI_TYPES);
-	return *(m_paUnitAIInfos[eUnitAINum]);
-}
-
-
-std::vector<CvInfoBase*>& CvGlobals::getAttitudeInfo()
-{
-	return m_paAttitudeInfos;
-}
-
-CvInfoBase& CvGlobals::getAttitudeInfo(AttitudeTypes eAttitudeNum)
-{
-	FAssert(eAttitudeNum >= 0);
-	FAssert(eAttitudeNum < NUM_ATTITUDE_TYPES);
-	return *(m_paAttitudeInfos[eAttitudeNum]);
-}
-
-
-std::vector<CvInfoBase*>& CvGlobals::getMemoryInfo()
-{
-	return m_paMemoryInfos;
-}
-
-CvInfoBase& CvGlobals::getMemoryInfo(MemoryTypes eMemoryNum)
-{
-	FAssert(eMemoryNum >= 0);
-	FAssert(eMemoryNum < NUM_MEMORY_TYPES);
-	return *(m_paMemoryInfos[eMemoryNum]);
-}
-
-int CvGlobals::getNumFatherCategoryInfos()
-{
-	return (int)m_paFatherCategoryInfos.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getFatherCategoryInfo()
-{
-	return m_paFatherCategoryInfos;
-}
-
-CvInfoBase& CvGlobals::getFatherCategoryInfo(FatherCategoryTypes eFatherCategoryNum)
-{
-	FAssert(eFatherCategoryNum >= 0);
-	FAssert(eFatherCategoryNum < GC.getNumFatherCategoryInfos());
-	return *(m_paFatherCategoryInfos[eFatherCategoryNum]);
-}
-
-int CvGlobals::getNumGameOptionInfos()
-{
-	return (int)m_paGameOptionInfos.size();
-}
-
-std::vector<CvGameOptionInfo*>& CvGlobals::getGameOptionInfo()
-{
-	return m_paGameOptionInfos;
-}
-
-CvGameOptionInfo& CvGlobals::getGameOptionInfo(GameOptionTypes eGameOptionNum)
-{
-	FAssert(eGameOptionNum >= 0);
-	FAssert(eGameOptionNum < GC.getNumGameOptionInfos());
-	return *(m_paGameOptionInfos[eGameOptionNum]);
-}
-
-int CvGlobals::getNumMPOptionInfos()
-{
-	return (int)m_paMPOptionInfos.size();
-}
-
-std::vector<CvMPOptionInfo*>& CvGlobals::getMPOptionInfo()
-{
-	 return m_paMPOptionInfos;
-}
-
-CvMPOptionInfo& CvGlobals::getMPOptionInfo(MultiplayerOptionTypes eMPOptionNum)
-{
-	FAssert(eMPOptionNum >= 0);
-	FAssert(eMPOptionNum < GC.getNumMPOptionInfos());
-	return *(m_paMPOptionInfos[eMPOptionNum]);
-}
-
-int CvGlobals::getNumForceControlInfos()
-{
-	return (int)m_paForceControlInfos.size();
-}
-
-std::vector<CvForceControlInfo*>& CvGlobals::getForceControlInfo()
-{
-	return m_paForceControlInfos;
-}
-
-CvForceControlInfo& CvGlobals::getForceControlInfo(ForceControlTypes eForceControlNum)
-{
-	FAssert(eForceControlNum >= 0);
-	FAssert(eForceControlNum < GC.getNumForceControlInfos());
-	return *(m_paForceControlInfos[eForceControlNum]);
-}
-
-std::vector<CvPlayerOptionInfo*>& CvGlobals::getPlayerOptionInfo()
-{
-	return m_paPlayerOptionInfos;
-}
-
-CvPlayerOptionInfo& CvGlobals::getPlayerOptionInfo(PlayerOptionTypes ePlayerOptionNum)
-{
-	FAssert(ePlayerOptionNum >= 0);
-	FAssert(ePlayerOptionNum < NUM_PLAYEROPTION_TYPES);
-	return *(m_paPlayerOptionInfos[ePlayerOptionNum]);
-}
-
-std::vector<CvGraphicOptionInfo*>& CvGlobals::getGraphicOptionInfo()
-{
-	return m_paGraphicOptionInfos;
-}
-
-CvGraphicOptionInfo& CvGlobals::getGraphicOptionInfo(GraphicOptionTypes eGraphicOptionNum)
-{
-	FAssert(eGraphicOptionNum >= 0);
-	FAssert(eGraphicOptionNum < NUM_GRAPHICOPTION_TYPES);
-	return *(m_paGraphicOptionInfos[eGraphicOptionNum]);
-}
-
-
-std::vector<CvYieldInfo*>& CvGlobals::getYieldInfo()	// For Moose - XML Load Util
-{
-	return m_paYieldInfo;
-}
-
-CvYieldInfo& CvGlobals::getYieldInfo(YieldTypes eYieldNum)
-{
-	FAssert(eYieldNum > -1);
-	FAssert(eYieldNum < NUM_YIELD_TYPES);
-	return *(m_paYieldInfo[eYieldNum]);
-}
-
-
-int CvGlobals::getNumRouteInfos()
-{
-	return (int)m_paRouteInfo.size();
-}
-
-std::vector<CvRouteInfo*>& CvGlobals::getRouteInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paRouteInfo;
-}
-
-CvRouteInfo& CvGlobals::getRouteInfo(RouteTypes eRouteNum)
-{
-	FAssert(eRouteNum > -1);
-	FAssert(eRouteNum < GC.getNumRouteInfos());
-	return *(m_paRouteInfo[eRouteNum]);
-}
-
-int CvGlobals::getNumImprovementInfos()
-{
-	return (int)m_paImprovementInfo.size();
-}
-
-std::vector<CvImprovementInfo*>& CvGlobals::getImprovementInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paImprovementInfo;
-}
-
-CvImprovementInfo& CvGlobals::getImprovementInfo(ImprovementTypes eImprovementNum)
-{
-	FAssert(eImprovementNum > -1);
-	FAssert(eImprovementNum < GC.getNumImprovementInfos());
-	return *(m_paImprovementInfo[eImprovementNum]);
-}
-
-int CvGlobals::getNumGoodyInfos()
-{
-	return (int)m_paGoodyInfo.size();
-}
-
-std::vector<CvGoodyInfo*>& CvGlobals::getGoodyInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paGoodyInfo;
-}
-
-CvGoodyInfo& CvGlobals::getGoodyInfo(GoodyTypes eGoodyNum)
-{
-	FAssert(eGoodyNum > -1);
-	FAssert(eGoodyNum < GC.getNumGoodyInfos());
-	return *(m_paGoodyInfo[eGoodyNum]);
-}
-
-int CvGlobals::getNumBuildInfos()
-{
-	return (int)m_paBuildInfo.size();
-}
-
-std::vector<CvBuildInfo*>& CvGlobals::getBuildInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paBuildInfo;
-}
-
-CvBuildInfo& CvGlobals::getBuildInfo(BuildTypes eBuildNum)
-{
-	FAssert(eBuildNum > -1);
-	FAssert(eBuildNum < GC.getNumBuildInfos());
-	return *(m_paBuildInfo[eBuildNum]);
-}
-
-int CvGlobals::getNumHandicapInfos()
-{
-	return (int)m_paHandicapInfo.size();
-}
-
-std::vector<CvHandicapInfo*>& CvGlobals::getHandicapInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
-{
-	return m_paHandicapInfo;
-}
-
-CvHandicapInfo& CvGlobals::getHandicapInfo(HandicapTypes eHandicapNum)
-{
-	FAssert(eHandicapNum > -1);
-	FAssert(eHandicapNum < GC.getNumHandicapInfos());
-	return *(m_paHandicapInfo[eHandicapNum]);
-}
-
-int CvGlobals::getNumGameSpeedInfos()
-{
-	return (int)m_paGameSpeedInfo.size();
-}
-
-std::vector<CvGameSpeedInfo*>& CvGlobals::getGameSpeedInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
-{
-	return m_paGameSpeedInfo;
-}
-
-CvGameSpeedInfo& CvGlobals::getGameSpeedInfo(GameSpeedTypes eGameSpeedNum)
-{
-	FAssert(eGameSpeedNum > -1);
-	FAssert(eGameSpeedNum < GC.getNumGameSpeedInfos());
-	return *(m_paGameSpeedInfo[eGameSpeedNum]);
-}
-
-int CvGlobals::getNumAlarmInfos()
-{
-	return (int)m_paAlarmInfo.size();
-}
-///TKs Invention Core Mod v 1.0
-int CvGlobals::getCostToResearch(CivicTypes eCivic)
-{
-    if (eCivic != NO_CIVIC)
-    {
-        ///TK Update 1.1b
-        CvCivicInfo& kCivicInfo = GC.getCivicInfo(eCivic);
-        int iCivicResearchCost = kCivicInfo.getCostToResearch();
-        iCivicResearchCost = (iCivicResearchCost * GC.getCache_TK_HUMAN_RESEARCH_COST_MOD_PERCENT()) / 100;
-        return iCivicResearchCost;
-    }
-    return 0;
-
-}
-
-///Equipment Types 0 = Any; 1 = Heavy Armor; 2 = Any Armor; 3 = Armor & Horses
-bool CvGlobals::isEquipmentType(YieldTypes eEquipment, UnitEquipmentTypes eType) const
-{
-    if (eType == EQUIPMENT_ANY)
-    {
-        if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
-        //if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR)
-        {
-            return true;
-        }
-
-        if (eEquipment == YIELD_WEAPONS || eEquipment == YIELD_HORSES)
-        {
-            return true;
-        }
-    }
-    else if (eType == EQUIPMENT_HEAVY_ARMOR)
-    {
-        if (eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
-        //if (eEquipment == YIELD_SCALE_ARMOR)
-        {
-            return true;
-        }
-    }
-    else if (eType == EQUIPMENT_ANY_ARMOR)
-    {
-        if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
-        //if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR)
-        {
-            return true;
-        }
-    }
-    else if (eType == EQUIPMENT_ARMOR_HORSES)
-    {
-        if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
-        //if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
-        {
-            return true;
-        }
-
-        if (eEquipment == YIELD_HORSES)
-        {
-            return true;
-        }
-    }
-    return false;
-}
-///TKe
-
-std::vector<CvAlarmInfo*>& CvGlobals::getAlarmInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
-{
-	return m_paAlarmInfo;
-}
-
-CvAlarmInfo& CvGlobals::getAlarmInfo(AlarmTypes eAlarm)
-{
-	FAssert(eAlarm > -1);
-	FAssert(eAlarm < GC.getNumAlarmInfos());
-	return *(m_paAlarmInfo[eAlarm]);
-}
-
-int CvGlobals::getNumTurnTimerInfos()
-{
-	return (int)m_paTurnTimerInfo.size();
-}
-
-std::vector<CvTurnTimerInfo*>& CvGlobals::getTurnTimerInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
-{
-	return m_paTurnTimerInfo;
-}
-
-CvTurnTimerInfo& CvGlobals::getTurnTimerInfo(TurnTimerTypes eTurnTimerNum)
-{
-	FAssert(eTurnTimerNum > -1);
-	FAssert(eTurnTimerNum < GC.getNumTurnTimerInfos());
-	return *(m_paTurnTimerInfo[eTurnTimerNum]);
-}
-
-int CvGlobals::getNumBuildingClassInfos()
-{
-	return (int)m_paBuildingClassInfo.size();
-}
-
-std::vector<CvBuildingClassInfo*>& CvGlobals::getBuildingClassInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paBuildingClassInfo;
-}
-
-CvBuildingClassInfo& CvGlobals::getBuildingClassInfo(BuildingClassTypes eBuildingClassNum)
-{
-	FAssert(eBuildingClassNum > -1);
-	FAssert(eBuildingClassNum < GC.getNumBuildingClassInfos());
-	return *(m_paBuildingClassInfo[eBuildingClassNum]);
-}
-
-int CvGlobals::getNumBuildingInfos()
-{
-	return (int)m_paBuildingInfo.size();
-}
-
-std::vector<CvBuildingInfo*>& CvGlobals::getBuildingInfo()	// For Moose - XML Load Util, CvInfos, CvCacheObject
-{
-	return m_paBuildingInfo;
-}
-
-CvBuildingInfo& CvGlobals::getBuildingInfo(BuildingTypes eBuildingNum)
-{
-	FAssert(eBuildingNum > -1);
-	FAssert(eBuildingNum < GC.getNumBuildingInfos());
-	return *(m_paBuildingInfo[eBuildingNum]);
-}
-
-int CvGlobals::getNumSpecialBuildingInfos()
-{
-	return (int)m_paSpecialBuildingInfo.size();
-}
-
-std::vector<CvSpecialBuildingInfo*>& CvGlobals::getSpecialBuildingInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paSpecialBuildingInfo;
-}
-
-CvSpecialBuildingInfo& CvGlobals::getSpecialBuildingInfo(SpecialBuildingTypes eSpecialBuildingNum)
-{
-	FAssert(eSpecialBuildingNum > -1);
-	FAssert(eSpecialBuildingNum < GC.getNumSpecialBuildingInfos());
-	return *(m_paSpecialBuildingInfo[eSpecialBuildingNum]);
-}
-
-int CvGlobals::getNumUnitClassInfos()
-{
-	return (int)m_paUnitClassInfo.size();
-}
-
-std::vector<CvUnitClassInfo*>& CvGlobals::getUnitClassInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paUnitClassInfo;
-}
-
-CvUnitClassInfo& CvGlobals::getUnitClassInfo(UnitClassTypes eUnitClassNum)
-{
-	FAssert(eUnitClassNum > -1);
-	FAssert(eUnitClassNum < GC.getNumUnitClassInfos());
-	return *(m_paUnitClassInfo[eUnitClassNum]);
-}
-
-int CvGlobals::getNumActionInfos()
-{
-	return (int)m_paActionInfo.size();
-}
-
-std::vector<CvActionInfo*>& CvGlobals::getActionInfo()	// For Moose - XML Load Util
-{
-	return m_paActionInfo;
-}
-
-CvActionInfo& CvGlobals::getActionInfo(int i)
-{
-	FAssertMsg(i < getNumActionInfos(), "Index out of bounds");
-	FAssertMsg(i > -1, "Index out of bounds");
-	return *(m_paActionInfo[i]);
-}
-
-std::vector<CvMissionInfo*>& CvGlobals::getMissionInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paMissionInfo;
-}
-
-CvMissionInfo& CvGlobals::getMissionInfo(MissionTypes eMissionNum)
-{
-	FAssert(eMissionNum > -1);
-	FAssert(eMissionNum < NUM_MISSION_TYPES);
-	return *(m_paMissionInfo[eMissionNum]);
-}
-
-std::vector<CvControlInfo*>& CvGlobals::getControlInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paControlInfo;
-}
-
-CvControlInfo& CvGlobals::getControlInfo(ControlTypes eControlNum)
-{
-	FAssert(eControlNum > -1);
-	FAssert(eControlNum < NUM_CONTROL_TYPES);
-	FAssert(m_paControlInfo.size() > 0);
-	return *(m_paControlInfo[eControlNum]);
-}
-
-std::vector<CvCommandInfo*>& CvGlobals::getCommandInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paCommandInfo;
-}
-
-CvCommandInfo& CvGlobals::getCommandInfo(CommandTypes eCommandNum)
-{
-	FAssert(eCommandNum > -1);
-	FAssert(eCommandNum < NUM_COMMAND_TYPES);
-	return *(m_paCommandInfo[eCommandNum]);
-}
-
-int CvGlobals::getNumAutomateInfos()
-{
-	return (int)m_paAutomateInfo.size();
-}
-
-std::vector<CvAutomateInfo*>& CvGlobals::getAutomateInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paAutomateInfo;
-}
-
-CvAutomateInfo& CvGlobals::getAutomateInfo(int iAutomateNum)
-{
-	FAssertMsg(iAutomateNum < getNumAutomateInfos(), "Index out of bounds");
-	FAssertMsg(iAutomateNum > -1, "Index out of bounds");
-	return *(m_paAutomateInfo[iAutomateNum]);
-}
-
-int CvGlobals::getNumPromotionInfos()
-{
-	return (int)m_paPromotionInfo.size();
-}
-
-std::vector<CvPromotionInfo*>& CvGlobals::getPromotionInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paPromotionInfo;
-}
-
-CvPromotionInfo& CvGlobals::getPromotionInfo(PromotionTypes ePromotionNum)
-{
-	FAssert(ePromotionNum > -1);
-	FAssert(ePromotionNum < GC.getNumPromotionInfos());
-	return *(m_paPromotionInfo[ePromotionNum]);
-}
-
-int CvGlobals::getNumProfessionInfos()
-{
-	return (int)m_paProfessionInfo.size();
-}
-
-std::vector<CvProfessionInfo*>& CvGlobals::getProfessionInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paProfessionInfo;
-}
-
-CvProfessionInfo& CvGlobals::getProfessionInfo(ProfessionTypes eProfessionNum)
-{
-	FAssert(eProfessionNum > -1);
-	FAssert(eProfessionNum < (int)m_paProfessionInfo.size());
-	return *(m_paProfessionInfo[eProfessionNum]);
-}
-int CvGlobals::getNumCivicOptionInfos()
-{
-	return (int)m_paCivicOptionInfo.size();
-}
-
-std::vector<CvInfoBase*>& CvGlobals::getCivicOptionInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paCivicOptionInfo;
-}
-
-CvInfoBase& CvGlobals::getCivicOptionInfo(CivicOptionTypes eCivicOptionNum)
-{
-	FAssert(eCivicOptionNum > -1);
-	FAssert(eCivicOptionNum < GC.getNumCivicOptionInfos());
-	return *(m_paCivicOptionInfo[eCivicOptionNum]);
-}
-
-int CvGlobals::getNumCivicInfos()
-{
-	return (int)m_paCivicInfo.size();
-}
-
-std::vector<CvCivicInfo*>& CvGlobals::getCivicInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paCivicInfo;
-}
-
-CvCivicInfo& CvGlobals::getCivicInfo(CivicTypes eCivicNum)
-{
-	FAssert(eCivicNum > -1);
-	FAssert(eCivicNum < GC.getNumCivicInfos());
-	return *(m_paCivicInfo[eCivicNum]);
-}
-
-int CvGlobals::getNumDiplomacyInfos()
-{
-	return (int)m_paDiplomacyInfo.size();
-}
-
-std::vector<CvDiplomacyInfo*>& CvGlobals::getDiplomacyInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paDiplomacyInfo;
-}
-
-CvDiplomacyInfo& CvGlobals::getDiplomacyInfo(int iDiplomacyNum)
-{
-	FAssertMsg(iDiplomacyNum < getNumDiplomacyInfos(), "Index out of bounds");
-	FAssertMsg(iDiplomacyNum > -1, "Index out of bounds");
-	return *(m_paDiplomacyInfo[iDiplomacyNum]);
-}
-
-int CvGlobals::getNumEraInfos()
-{
-	return (int)m_aEraInfo.size();
-}
-
-std::vector<CvEraInfo*>& CvGlobals::getEraInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_aEraInfo;
-}
-
-CvEraInfo& CvGlobals::getEraInfo(EraTypes eEraNum)
-{
-	FAssert(eEraNum > -1);
-	FAssert(eEraNum < GC.getNumEraInfos());
-	return *(m_aEraInfo[eEraNum]);
-}
-
-int CvGlobals::getNumHurryInfos()
-{
-	return (int)m_paHurryInfo.size();
-}
-
-std::vector<CvHurryInfo*>& CvGlobals::getHurryInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paHurryInfo;
-}
-
-CvHurryInfo& CvGlobals::getHurryInfo(HurryTypes eHurryNum)
-{
-	FAssert(eHurryNum > -1);
-	FAssert(eHurryNum < GC.getNumHurryInfos());
-	return *(m_paHurryInfo[eHurryNum]);
-}
-
-int CvGlobals::getNumEmphasizeInfos()
-{
-	return (int)m_paEmphasizeInfo.size();
-}
-
-std::vector<CvEmphasizeInfo*>& CvGlobals::getEmphasizeInfo()	// For Moose - XML Load Util
-{
-	return m_paEmphasizeInfo;
-}
-
-CvEmphasizeInfo& CvGlobals::getEmphasizeInfo(EmphasizeTypes eEmphasizeNum)
-{
-	FAssert(eEmphasizeNum > -1);
-	FAssert(eEmphasizeNum < GC.getNumEmphasizeInfos());
-	return *(m_paEmphasizeInfo[eEmphasizeNum]);
-}
-
-int CvGlobals::getNumCultureLevelInfos()
-{
-	return (int)m_paCultureLevelInfo.size();
-}
-
-std::vector<CvCultureLevelInfo*>& CvGlobals::getCultureLevelInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paCultureLevelInfo;
-}
-
-CvCultureLevelInfo& CvGlobals::getCultureLevelInfo(CultureLevelTypes eCultureLevelNum)
-{
-	FAssert(eCultureLevelNum > -1);
-	FAssert(eCultureLevelNum < GC.getNumCultureLevelInfos());
-	return *(m_paCultureLevelInfo[eCultureLevelNum]);
-}
-
-int CvGlobals::getNumVictoryInfos()
-{
-	return (int)m_paVictoryInfo.size();
-}
-
-std::vector<CvVictoryInfo*>& CvGlobals::getVictoryInfo()	// For Moose - XML Load Util, CvInfos
-{
-	return m_paVictoryInfo;
-}
-
-CvVictoryInfo& CvGlobals::getVictoryInfo(VictoryTypes eVictoryNum)
-{
-	FAssert(eVictoryNum > -1);
-	FAssert(eVictoryNum < GC.getNumVictoryInfos());
-	return *(m_paVictoryInfo[eVictoryNum]);
-}
-
-int CvGlobals::getNumEventTriggerInfos()
-{
-	return (int)m_paEventTriggerInfo.size();
-}
-
-std::vector<CvEventTriggerInfo*>& CvGlobals::getEventTriggerInfo()
-{
-	return m_paEventTriggerInfo;
-}
-
-CvEventTriggerInfo& CvGlobals::getEventTriggerInfo(EventTriggerTypes eEventTrigger)
-{
-	FAssert(eEventTrigger > -1);
-	FAssert(eEventTrigger < GC.getNumEventTriggerInfos());
-	return *(m_paEventTriggerInfo[eEventTrigger]);
-}
-
-int CvGlobals::getNumEventInfos()
-{
-	return (int)m_paEventInfo.size();
-}
-
-std::vector<CvEventInfo*>& CvGlobals::getEventInfo()
-{
-	return m_paEventInfo;
-}
-
-CvEventInfo& CvGlobals::getEventInfo(EventTypes eEvent)
-{
-	FAssert(eEvent > -1);
-	FAssert(eEvent < GC.getNumEventInfos());
-	return *(m_paEventInfo[eEvent]);
-}
-
-int& CvGlobals::getNumEntityEventTypes()
-{
-	return m_iNumEntityEventTypes;
-}
-
-CvString*& CvGlobals::getEntityEventTypes()
-{
-	return m_paszEntityEventTypes;
-}
-
-CvString& CvGlobals::getEntityEventTypes(EntityEventTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumEntityEventTypes());
-	return m_paszEntityEventTypes[e];
-}
-
-int& CvGlobals::getNumAnimationOperatorTypes()
-{
-	return m_iNumAnimationOperatorTypes;
-}
-
-CvString*& CvGlobals::getAnimationOperatorTypes()
-{
-	return m_paszAnimationOperatorTypes;
-}
-
-CvString& CvGlobals::getAnimationOperatorTypes(AnimationOperatorTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumAnimationOperatorTypes());
-	return m_paszAnimationOperatorTypes[e];
-}
-
-CvString*& CvGlobals::getFunctionTypes()
-{
-	return m_paszFunctionTypes;
-}
-
-CvString& CvGlobals::getFunctionTypes(FunctionTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_FUNC_TYPES);
-	return m_paszFunctionTypes[e];
-}
-
-int& CvGlobals::getNumArtStyleTypes()
-{
-	return m_iNumArtStyleTypes;
-}
-
-CvString*& CvGlobals::getArtStyleTypes()
-{
-	return m_paszArtStyleTypes;
-}
-
-CvString& CvGlobals::getArtStyleTypes(ArtStyleTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < GC.getNumArtStyleTypes());
-	return m_paszArtStyleTypes[e];
-}
-
-
-//Androrc UnitArtStyles
-int CvGlobals::getNumUnitArtStyleTypeInfos()
-{
-    return (int)m_paUnitArtStyleTypeInfo.size();
-}
-
-std::vector<CvUnitArtStyleTypeInfo*>& CvGlobals::getUnitArtStyleTypeInfo()
-{
-	return m_paUnitArtStyleTypeInfo;
-}
-
-CvUnitArtStyleTypeInfo& CvGlobals::getUnitArtStyleTypeInfo(UnitArtStyleTypes eUnitArtStyleTypeNum)
-{
-	FAssert(eUnitArtStyleTypeNum > -1);
-	FAssert(eUnitArtStyleTypeNum < GC.getNumUnitArtStyleTypeInfos());
-	return *(m_paUnitArtStyleTypeInfo[eUnitArtStyleTypeNum]);
-}
-//Androrc End
-
-int& CvGlobals::getNumCitySizeTypes()
-{
-	return m_iNumCitySizeTypes;
-}
-
-CvString*& CvGlobals::getCitySizeTypes()
-{
-	return m_paszCitySizeTypes;
-}
-
-CvString& CvGlobals::getCitySizeTypes(int i)
-{
-	FAssertMsg(i < getNumCitySizeTypes(), "Index out of bounds");
-	FAssertMsg(i > -1, "Index out of bounds");
-	return m_paszCitySizeTypes[i];
-}
-
-CvString*& CvGlobals::getContactTypes()
-{
-	return m_paszContactTypes;
-}
-
-CvString& CvGlobals::getContactTypes(ContactTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_CONTACT_TYPES);
-	return m_paszContactTypes[e];
-}
-
-CvString*& CvGlobals::getDiplomacyPowerTypes()
-{
-	return m_paszDiplomacyPowerTypes;
-}
-
-CvString& CvGlobals::getDiplomacyPowerTypes(DiplomacyPowerTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_DIPLOMACYPOWER_TYPES);
-	return m_paszDiplomacyPowerTypes[e];
-}
-
-CvString*& CvGlobals::getAutomateTypes()
-{
-	return m_paszAutomateTypes;
-}
-
-CvString& CvGlobals::getAutomateTypes(AutomateTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_AUTOMATE_TYPES);
-	return m_paszAutomateTypes[e];
-}
-///TKs Med
-CvString*& CvGlobals::getMedCityTypes()
-{
-	return m_paszMedCityTypes;
-}
-
-CvString*& CvGlobals::getModCodeTypes()
-{
-	return m_paszModCodeTypes;
-}
-
-CvString& CvGlobals::getModCodeTypes(ModCodeTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_MOD_CODE_TYPES);
-	return m_paszModCodeTypes[e];
-}
-
-CvString& CvGlobals::getMedCityTypes(MedCityTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_CITY_TYPES);
-	return m_paszMedCityTypes[e];
-}
-CvString*& CvGlobals::getTradeScreenTypes()
-{
-	return m_paszTradeScreenTypes;
-}
-
-CvString& CvGlobals::getTradeScreenTypes(TradeScreenTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_TRADE_SCREEN_TYPES);
-	return m_paszTradeScreenTypes[e];
-}
-///Tke
-
-CvString*& CvGlobals::getDirectionTypes()
-{
-	return m_paszDirectionTypes;
-}
-
-CvString& CvGlobals::getDirectionTypes(AutomateTypes e)
-{
-	FAssert(e > -1);
-	FAssert(e < NUM_DIRECTION_TYPES);
-	return m_paszDirectionTypes[e];
-}
-
-int& CvGlobals::getNumFootstepAudioTypes()
-{
-	return m_iNumFootstepAudioTypes;
-}
-
-CvString*& CvGlobals::getFootstepAudioTypes()
-{
-	return m_paszFootstepAudioTypes;
-}
-
-CvString& CvGlobals::getFootstepAudioTypes(int i)
-{
-	FAssertMsg(i < getNumFootstepAudioTypes(), "Index out of bounds");
-	FAssertMsg(i > -1, "Index out of bounds");
-	return m_paszFootstepAudioTypes[i];
-}
-
-int CvGlobals::getFootstepAudioTypeByTag(CvString strTag)
-{
-	int iIndex = -1;
-
-	if ( strTag.GetLength() <= 0 )
-	{
-		return iIndex;
-	}
-
-	for ( int i = 0; i < m_iNumFootstepAudioTypes; i++ )
-	{
-		if ( strTag.CompareNoCase(m_paszFootstepAudioTypes[i]) == 0 )
-		{
-			iIndex = i;
-			break;
-		}
-	}
-
-	return iIndex;
-}
-
-CvString*& CvGlobals::getFootstepAudioTags()
-{
-	return m_paszFootstepAudioTags;
-}
-
-CvString& CvGlobals::getFootstepAudioTags(int i)
-{
-//	FAssertMsg(i < getNumFootstepAudioTags(), "Index out of bounds")
-	FAssertMsg(i > -1, "Index out of bounds");
-	return m_paszFootstepAudioTags[i];
-}
-
-void CvGlobals::setCurrentXMLFile(const TCHAR* szFileName)
-{
-	m_szCurrentXMLFile = szFileName;
-}
-
-CvString& CvGlobals::getCurrentXMLFile()
-{
-	return m_szCurrentXMLFile;
-}
-
-FVariableSystem* CvGlobals::getDefinesVarSystem()
-{
-	return m_VarSystem;
-}
-
-void CvGlobals::cacheGlobals()
-{
-	m_iMOVE_DENOMINATOR = getDefineINT("MOVE_DENOMINATOR");
-	m_iFOOD_CONSUMPTION_PER_POPULATION = getDefineINT("FOOD_CONSUMPTION_PER_POPULATION");
-	m_iMAX_HIT_POINTS = getDefineINT("MAX_HIT_POINTS");
-	m_iHILLS_EXTRA_DEFENSE = getDefineINT("HILLS_EXTRA_DEFENSE");
-	m_iRIVER_ATTACK_MODIFIER = getDefineINT("RIVER_ATTACK_MODIFIER");
-	m_iAMPHIB_ATTACK_MODIFIER = getDefineINT("AMPHIB_ATTACK_MODIFIER");
-	m_iHILLS_EXTRA_MOVEMENT = getDefineINT("HILLS_EXTRA_MOVEMENT");
-	m_iPEAK_EXTRA_MOVEMENT = getDefineINT("PEAK_EXTRA_MOVEMENT");
-	m_iMAX_PLOT_LIST_ROWS = getDefineINT("MAX_PLOT_LIST_ROWS");
-	m_iUNIT_MULTISELECT_MAX = getDefineINT("UNIT_MULTISELECT_MAX");
-	m_iEVENT_MESSAGE_TIME = getDefineINT("EVENT_MESSAGE_TIME");
-	m_iROUTE_FEATURE_GROWTH_MODIFIER = getDefineINT("ROUTE_FEATURE_GROWTH_MODIFIER");
-	m_iFEATURE_GROWTH_MODIFIER = getDefineINT("FEATURE_GROWTH_MODIFIER");
-	m_iMIN_CITY_RANGE = getDefineINT("MIN_CITY_RANGE");
-	m_iCITY_MAX_NUM_BUILDINGS = getDefineINT("CITY_MAX_NUM_BUILDINGS");
-	m_iLAKE_MAX_AREA_SIZE = getDefineINT("LAKE_MAX_AREA_SIZE");
-	m_iMIN_WATER_SIZE_FOR_OCEAN = getDefineINT("MIN_WATER_SIZE_FOR_OCEAN");
-	m_iFORTIFY_MODIFIER_PER_TURN = getDefineINT("FORTIFY_MODIFIER_PER_TURN");
-	m_iMAX_CITY_DEFENSE_DAMAGE = getDefineINT("MAX_CITY_DEFENSE_DAMAGE");
-	m_iPEAK_SEE_THROUGH_CHANGE = getDefineINT("PEAK_SEE_THROUGH_CHANGE");
-	m_iHILLS_SEE_THROUGH_CHANGE = getDefineINT("HILLS_SEE_THROUGH_CHANGE");
-	m_iSEAWATER_SEE_FROM_CHANGE = getDefineINT("SEAWATER_SEE_FROM_CHANGE");
-	m_iPEAK_SEE_FROM_CHANGE = getDefineINT("PEAK_SEE_FROM_CHANGE");
-	m_iHILLS_SEE_FROM_CHANGE = getDefineINT("HILLS_SEE_FROM_CHANGE");
-	m_iMAX_REBEL_YIELD_MODIFIER = getDefineINT("MAX_REBEL_YIELD_MODIFIER");
-
-	m_fCAMERA_MIN_YAW = getDefineFLOAT("CAMERA_MIN_YAW");
-	m_fCAMERA_MAX_YAW = getDefineFLOAT("CAMERA_MAX_YAW");
-	m_fCAMERA_FAR_CLIP_Z_HEIGHT = getDefineFLOAT("CAMERA_FAR_CLIP_Z_HEIGHT");
-	m_fCAMERA_MAX_TRAVEL_DISTANCE = getDefineFLOAT("CAMERA_MAX_TRAVEL_DISTANCE");
-	m_fCAMERA_START_DISTANCE = getDefineFLOAT("CAMERA_START_DISTANCE");
-	m_fPLOT_SIZE = getDefineFLOAT("PLOT_SIZE");
-	m_fCAMERA_SPECIAL_PITCH = getDefineFLOAT("CAMERA_SPECIAL_PITCH");
-	m_fCAMERA_MAX_TURN_OFFSET = getDefineFLOAT("CAMERA_MAX_TURN_OFFSET");
-	m_fCAMERA_MIN_DISTANCE = getDefineFLOAT("CAMERA_MIN_DISTANCE");
-	m_fCAMERA_UPPER_PITCH = getDefineFLOAT("CAMERA_UPPER_PITCH");
-	m_fCAMERA_LOWER_PITCH = getDefineFLOAT("CAMERA_LOWER_PITCH");
-	m_fFIELD_OF_VIEW = getDefineFLOAT("FIELD_OF_VIEW");
-	m_fUNIT_MULTISELECT_DISTANCE = getDefineFLOAT("UNIT_MULTISELECT_DISTANCE");
-
-	m_iUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK = getDefineINT("USE_CAN_FOUND_CITIES_ON_WATER_CALLBACK");
-	m_iUSE_CANNOT_DO_CIVIC_CALLBACK = getDefineINT("USE_CANNOT_DO_CIVIC_CALLBACK");
-	m_iUSE_CAN_DO_CIVIC_CALLBACK = getDefineINT("USE_CAN_DO_CIVIC_CALLBACK");
-	m_iUSE_CANNOT_CONSTRUCT_CALLBACK = getDefineINT("USE_CANNOT_CONSTRUCT_CALLBACK");
-	m_iUSE_CAN_CONSTRUCT_CALLBACK = getDefineINT("USE_CAN_CONSTRUCT_CALLBACK");
-	m_iUSE_CAN_DECLARE_WAR_CALLBACK = getDefineINT("USE_CAN_DECLARE_WAR_CALLBACK");
-	m_iUSE_GET_UNIT_COST_MOD_CALLBACK = getDefineINT("USE_GET_UNIT_COST_MOD_CALLBACK");
-	m_iUSE_GET_BUILDING_COST_MOD_CALLBACK = getDefineINT("USE_GET_BUILDING_COST_MOD_CALLBACK");
-	m_iUSE_GET_CITY_FOUND_VALUE_CALLBACK = getDefineINT("USE_GET_CITY_FOUND_VALUE_CALLBACK");
-	m_iUSE_CANNOT_HANDLE_ACTION_CALLBACK = getDefineINT("USE_CANNOT_HANDLE_ACTION_CALLBACK");
-	m_iUSE_CAN_BUILD_CALLBACK = getDefineINT("USE_CAN_BUILD_CALLBACK");
-	m_iUSE_CANNOT_TRAIN_CALLBACK = getDefineINT("USE_CANNOT_TRAIN_CALLBACK");
-	m_iUSE_CAN_TRAIN_CALLBACK = getDefineINT("USE_CAN_TRAIN_CALLBACK");
-	m_iUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK = getDefineINT("USE_UNIT_CANNOT_MOVE_INTO_CALLBACK");
-	m_iUSE_FINISH_TEXT_CALLBACK = getDefineINT("USE_FINISH_TEXT_CALLBACK");
-	m_iUSE_ON_UNIT_SET_XY_CALLBACK = getDefineINT("USE_ON_UNIT_SET_XY_CALLBACK");
-	m_iUSE_ON_UNIT_SELECTED_CALLBACK = getDefineINT("USE_ON_UNIT_SELECTED_CALLBACK");
-	m_iUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK = getDefineINT("USE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK");
-	m_iUSE_ON_UPDATE_CALLBACK = getDefineINT("USE_ON_UPDATE_CALLBACK");
-	m_iUSE_ON_UNIT_CREATED_CALLBACK = getDefineINT("USE_ON_UNIT_CREATED_CALLBACK");
-	m_iUSE_ON_UNIT_LOST_CALLBACK = getDefineINT("USE_ON_UNIT_LOST_CALLBACK");
-}
-
-int CvGlobals::getDefineINT( const char * szName ) const
-{
-	int iReturn = 0;
-	GC.getDefinesVarSystem()->GetValue( szName, iReturn );
-	return iReturn;
-}
-
-float CvGlobals::getDefineFLOAT( const char * szName ) const
-{
-	float fReturn = 0;
-	GC.getDefinesVarSystem()->GetValue( szName, fReturn );
-	return fReturn;
-}
-
-const char * CvGlobals::getDefineSTRING( const char * szName ) const
-{
-	const char * szReturn = NULL;
-	GC.getDefinesVarSystem()->GetValue( szName, szReturn );
-	return szReturn;
-}
-
-void CvGlobals::setDefineINT( const char * szName, int iValue )
-{
-	GC.getDefinesVarSystem()->SetValue( szName, iValue );
-	cacheGlobals();
-}
-
-void CvGlobals::setDefineFLOAT( const char * szName, float fValue )
-{
-	GC.getDefinesVarSystem()->SetValue( szName, fValue );
-	cacheGlobals();
-}
-
-void CvGlobals::setDefineSTRING( const char * szName, const char * szValue )
-{
-	GC.getDefinesVarSystem()->SetValue( szName, szValue );
-	cacheGlobals();
-}
-
-int CvGlobals::getMOVE_DENOMINATOR()
-{
-	return m_iMOVE_DENOMINATOR;
-}
-
-int CvGlobals::getFOOD_CONSUMPTION_PER_POPULATION()
-{
-	return m_iFOOD_CONSUMPTION_PER_POPULATION;
-}
-
-int CvGlobals::getMAX_HIT_POINTS()
-{
-	return m_iMAX_HIT_POINTS;
-}
-
-int CvGlobals::getHILLS_EXTRA_DEFENSE()
-{
-	return m_iHILLS_EXTRA_DEFENSE;
-}
-
-int CvGlobals::getRIVER_ATTACK_MODIFIER()
-{
-	return m_iRIVER_ATTACK_MODIFIER;
-}
-
-int CvGlobals::getAMPHIB_ATTACK_MODIFIER()
-{
-	return m_iAMPHIB_ATTACK_MODIFIER;
-}
-
-int CvGlobals::getHILLS_EXTRA_MOVEMENT()
-{
-	return m_iHILLS_EXTRA_MOVEMENT;
-}
-
-int CvGlobals::getPEAK_EXTRA_MOVEMENT()
-{
-	return m_iPEAK_EXTRA_MOVEMENT;
-}
-
-int CvGlobals::getMAX_PLOT_LIST_ROWS()
-{
-	return m_iMAX_PLOT_LIST_ROWS;
-}
-
-int CvGlobals::getUNIT_MULTISELECT_MAX()
-{
-	return m_iUNIT_MULTISELECT_MAX;
-}
-
-int CvGlobals::getEVENT_MESSAGE_TIME()
-{
-	return m_iEVENT_MESSAGE_TIME;
-}
-
-int CvGlobals::getROUTE_FEATURE_GROWTH_MODIFIER()
-{
-	return m_iROUTE_FEATURE_GROWTH_MODIFIER;
-}
-
-int CvGlobals::getFEATURE_GROWTH_MODIFIER()
-{
-	return m_iFEATURE_GROWTH_MODIFIER;
-}
-
-int CvGlobals::getMIN_CITY_RANGE()
-{
-	return m_iMIN_CITY_RANGE;
-}
-
-int CvGlobals::getCITY_MAX_NUM_BUILDINGS()
-{
-	return m_iCITY_MAX_NUM_BUILDINGS;
-}
-int CvGlobals::getLAKE_MAX_AREA_SIZE()
-{
-	return m_iLAKE_MAX_AREA_SIZE;
-}
-int CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN()
-{
-	return m_iMIN_WATER_SIZE_FOR_OCEAN;
-}
-
-int CvGlobals::getFORTIFY_MODIFIER_PER_TURN()
-{
-	return m_iFORTIFY_MODIFIER_PER_TURN;
-}
-
-int CvGlobals::getMAX_CITY_DEFENSE_DAMAGE()
-{
-	return m_iMAX_CITY_DEFENSE_DAMAGE;
-}
-
-int CvGlobals::getPEAK_SEE_THROUGH_CHANGE()
-{
-	return m_iPEAK_SEE_THROUGH_CHANGE;
-}
-
-int CvGlobals::getHILLS_SEE_THROUGH_CHANGE()
-{
-	return m_iHILLS_SEE_THROUGH_CHANGE;
-}
-
-int CvGlobals::getSEAWATER_SEE_FROM_CHANGE()
-{
-	return m_iSEAWATER_SEE_FROM_CHANGE;
-}
-
-int CvGlobals::getPEAK_SEE_FROM_CHANGE()
-{
-	return m_iPEAK_SEE_FROM_CHANGE;
-}
-
-int CvGlobals::getHILLS_SEE_FROM_CHANGE()
-{
-	return m_iHILLS_SEE_FROM_CHANGE;
-}
-
-int CvGlobals::getMAX_REBEL_YIELD_MODIFIER()
-{
-	return m_iMAX_REBEL_YIELD_MODIFIER;
-}
-
-float CvGlobals::getCAMERA_MIN_YAW()
-{
-	return m_fCAMERA_MIN_YAW;
-}
-
-float CvGlobals::getCAMERA_MAX_YAW()
-{
-	return m_fCAMERA_MAX_YAW;
-}
-
-float CvGlobals::getCAMERA_FAR_CLIP_Z_HEIGHT()
-{
-	return m_fCAMERA_FAR_CLIP_Z_HEIGHT;
-}
-
-float CvGlobals::getCAMERA_MAX_TRAVEL_DISTANCE()
-{
-	return m_fCAMERA_MAX_TRAVEL_DISTANCE;
-}
-
-float CvGlobals::getCAMERA_START_DISTANCE()
-{
-	return m_fCAMERA_START_DISTANCE;
-}
-
-float CvGlobals::getPLOT_SIZE()
-{
-	return m_fPLOT_SIZE;
-}
-
-float CvGlobals::getCAMERA_SPECIAL_PITCH()
-{
-	return m_fCAMERA_SPECIAL_PITCH;
-}
-
-float CvGlobals::getCAMERA_MAX_TURN_OFFSET()
-{
-	return m_fCAMERA_MAX_TURN_OFFSET;
-}
-
-float CvGlobals::getCAMERA_MIN_DISTANCE()
-{
-	return m_fCAMERA_MIN_DISTANCE;
-}
-
-float CvGlobals::getCAMERA_UPPER_PITCH()
-{
-	return m_fCAMERA_UPPER_PITCH;
-}
-
-float CvGlobals::getCAMERA_LOWER_PITCH()
-{
-	return m_fCAMERA_LOWER_PITCH;
-}
-
-float CvGlobals::getFIELD_OF_VIEW()
-{
-	return m_fFIELD_OF_VIEW;
-}
-
-float CvGlobals::getUNIT_MULTISELECT_DISTANCE()
-{
-	return m_fUNIT_MULTISELECT_DISTANCE;
-}
-
-int CvGlobals::getUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK()
-{
-	return m_iUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK;
-}
-int CvGlobals::getUSE_CANNOT_DO_CIVIC_CALLBACK()
-{
-	return m_iUSE_CANNOT_DO_CIVIC_CALLBACK;
-}
-
-int CvGlobals::getUSE_CAN_DO_CIVIC_CALLBACK()
-{
-	return m_iUSE_CAN_DO_CIVIC_CALLBACK;
-}
-
-int CvGlobals::getUSE_CANNOT_CONSTRUCT_CALLBACK()
-{
-	return m_iUSE_CANNOT_CONSTRUCT_CALLBACK;
-}
-
-int CvGlobals::getUSE_CAN_CONSTRUCT_CALLBACK()
-{
-	return m_iUSE_CAN_CONSTRUCT_CALLBACK;
-}
-
-int CvGlobals::getUSE_CAN_DECLARE_WAR_CALLBACK()
-{
-	return m_iUSE_CAN_DECLARE_WAR_CALLBACK;
-}
-int CvGlobals::getUSE_GET_UNIT_COST_MOD_CALLBACK()
-{
-	return m_iUSE_GET_UNIT_COST_MOD_CALLBACK;
-}
-
-int CvGlobals::getUSE_GET_BUILDING_COST_MOD_CALLBACK()
-{
-	return m_iUSE_GET_BUILDING_COST_MOD_CALLBACK;
-}
-
-int CvGlobals::getUSE_GET_CITY_FOUND_VALUE_CALLBACK()
-{
-	return m_iUSE_GET_CITY_FOUND_VALUE_CALLBACK;
-}
-
-int CvGlobals::getUSE_CANNOT_HANDLE_ACTION_CALLBACK()
-{
-	return m_iUSE_CANNOT_HANDLE_ACTION_CALLBACK;
-}
-
-int CvGlobals::getUSE_CAN_BUILD_CALLBACK()
-{
-	return m_iUSE_CAN_BUILD_CALLBACK;
-}
-
-int CvGlobals::getUSE_CANNOT_TRAIN_CALLBACK()
-{
-	return m_iUSE_CANNOT_TRAIN_CALLBACK;
-}
-
-int CvGlobals::getUSE_CAN_TRAIN_CALLBACK()
-{
-	return m_iUSE_CAN_TRAIN_CALLBACK;
-}
-
-int CvGlobals::getUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK()
-{
-	return m_iUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK;
-}
-
-int CvGlobals::getUSE_FINISH_TEXT_CALLBACK()
-{
-	return m_iUSE_FINISH_TEXT_CALLBACK;
-}
-
-int CvGlobals::getUSE_ON_UNIT_SET_XY_CALLBACK()
-{
-	return m_iUSE_ON_UNIT_SET_XY_CALLBACK;
-}
-
-int CvGlobals::getUSE_ON_UNIT_SELECTED_CALLBACK()
-{
-	return m_iUSE_ON_UNIT_SELECTED_CALLBACK;
-}
-
-int CvGlobals::getUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK()
-{
-	return m_iUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK;
-}
-
-int CvGlobals::getUSE_ON_UPDATE_CALLBACK()
-{
-	return m_iUSE_ON_UPDATE_CALLBACK;
-}
-
-int CvGlobals::getUSE_ON_UNIT_CREATED_CALLBACK()
-{
-	return m_iUSE_ON_UNIT_CREATED_CALLBACK;
-}
-
-int CvGlobals::getUSE_ON_UNIT_LOST_CALLBACK()
-{
-	return m_iUSE_ON_UNIT_LOST_CALLBACK;
-}
-
-int CvGlobals::getMAX_CIV_PLAYERS()
-{
-	return MAX_PLAYERS;
-}
-
-int CvGlobals::getMAX_PLAYERS()
-{
-	return MAX_PLAYERS;
-}
-
-int CvGlobals::getMAX_CIV_TEAMS()
-{
-	return MAX_TEAMS;
-}
-
-int CvGlobals::getMAX_TEAMS()
-{
-	return MAX_TEAMS;
-}
-
-int CvGlobals::getINVALID_PLOT_COORD()
-{
-	return INVALID_PLOT_COORD;
-}
-
-int CvGlobals::getNUM_CITY_PLOTS()
-{
-	return NUM_CITY_PLOTS;
-}
-
-int CvGlobals::getCITY_HOME_PLOT()
-{
-	return CITY_HOME_PLOT;
-}
-
-void CvGlobals::setDLLIFace(CvDLLUtilityIFaceBase* pDll)
-{
-	m_pDLL = pDll;
-}
-
-int CvGlobals::getNUM_ENGINE_DIRTY_BITS() const
-{
-	return NUM_ENGINE_DIRTY_BITS;
-}
-
-int CvGlobals::getNUM_INTERFACE_DIRTY_BITS() const
-{
-	return NUM_INTERFACE_DIRTY_BITS;
-}
-
-int CvGlobals::getNUM_YIELD_TYPES() const
-{
-	return NUM_YIELD_TYPES;
-}
-
-int CvGlobals::getNUM_FORCECONTROL_TYPES() const
-{
-	return NUM_FORCECONTROL_TYPES;
-}
-
-int CvGlobals::getNUM_INFOBAR_TYPES() const
-{
-	return NUM_INFOBAR_TYPES;
-}
-
-int CvGlobals::getNUM_HEALTHBAR_TYPES() const
-{
-	return NUM_HEALTHBAR_TYPES;
-}
-
-int CvGlobals::getNUM_CONTROL_TYPES() const
-{
-	return NUM_CONTROL_TYPES;
-}
-
-int CvGlobals::getNUM_LEADERANIM_TYPES() const
-{
-	return NUM_LEADERANIM_TYPES;
-}
-
-
-void CvGlobals::deleteInfoArrays()
-{
-	for(int i=0;i<(int)m_aInfoVectors.size();i++)
-	{
-		deleteInfoArray(*m_aInfoVectors[i]);
-	}
-    //Androrc UnitArtStyles
-	//this probably isn't necessary, due to the loop just before, which wasn't present in the BTS code; however, I want to be safe.
-	deleteInfoArray(m_paUnitArtStyleTypeInfo);
-	//Androrc End
-	SAFE_DELETE_ARRAY(GC.getEntityEventTypes());
-	SAFE_DELETE_ARRAY(GC.getAnimationOperatorTypes());
-	SAFE_DELETE_ARRAY(GC.getFunctionTypes());
-	SAFE_DELETE_ARRAY(GC.getArtStyleTypes());
-	SAFE_DELETE_ARRAY(GC.getCitySizeTypes());
-	SAFE_DELETE_ARRAY(GC.getContactTypes());
-	SAFE_DELETE_ARRAY(GC.getDiplomacyPowerTypes());
-	SAFE_DELETE_ARRAY(GC.getAutomateTypes());
-	///TKs Med
-	SAFE_DELETE_ARRAY(GC.getMedCityTypes());
-	SAFE_DELETE_ARRAY(GC.getTradeScreenTypes());
-	SAFE_DELETE_ARRAY(GC.getModCodeTypes());
-	///TKe
-	SAFE_DELETE_ARRAY(GC.getDirectionTypes());
-	SAFE_DELETE_ARRAY(GC.getFootstepAudioTypes());
-	SAFE_DELETE_ARRAY(GC.getFootstepAudioTags());
-
-	clearTypesMap();
-	m_aInfoVectors.clear();
-}
-
-
-//
-// Global Infos Hash Map
-//
-
-int CvGlobals::getInfoTypeForString(const char* szType, bool hideAssert) const
-{
-	FAssertMsg(szType, "null info type string");
-	InfosMap::const_iterator it = m_infosMap.find(szType);
-	if (it!=m_infosMap.end())
-	{
-		return it->second;
-	}
-
-	if(!hideAssert)
-	{
-		CvString szError;
-		szError.Format("info type %s not found, Current XML file is: %s", szType, GC.getCurrentXMLFile().GetCString());
-		FAssertMsg(strcmp(szType, "NONE")==0 || strcmp(szType, "")==0, szError.c_str());
-		gDLL->logMsg("xml.log", szError);
-	}
-
-	return -1;
-}
-
-void CvGlobals::setInfoTypeFromString(const char* szType, int idx)
-{
-	FAssertMsg(szType, "null info type string");
-#ifdef _DEBUG
-	InfosMap::const_iterator it = m_infosMap.find(szType);
-	int iExisting = (it!=m_infosMap.end()) ? it->second : -1;
-	FAssertMsg(iExisting==-1 || iExisting==idx || strcmp(szType, "ERROR")==0, CvString::format("xml info type entry %s already exists", szType).c_str());
-#endif
-	m_infosMap[szType] = idx;
-}
-
-void CvGlobals::infoTypeFromStringReset()
-{
-	m_infosMap.clear();
-}
-
-void CvGlobals::addToInfosVectors(void *infoVector)
-{
-	std::vector<CvInfoBase *> *infoBaseVector = (std::vector<CvInfoBase *> *) infoVector;
-	m_aInfoVectors.push_back(infoBaseVector);
-}
-
-void CvGlobals::infosReset()
-{
-	for(int i=0;i<(int)m_aInfoVectors.size();i++)
-	{
-		std::vector<CvInfoBase *> *infoBaseVector = m_aInfoVectors[i];
-		for(int j=0;j<(int)infoBaseVector->size();j++)
-			infoBaseVector->at(j)->reset();
-	}
-}
-
-int CvGlobals::getNumDirections() const { return NUM_DIRECTION_TYPES; }
-int CvGlobals::getNumResourceLayers() const { return NUM_RESOURCE_LAYERS; }
-int CvGlobals::getNumUnitLayerOptionTypes() const { return NUM_UNIT_LAYER_OPTION_TYPES; }
-int CvGlobals::getNumGameOptions() const { return NUM_GAMEOPTION_TYPES; }
-int CvGlobals::getNumMPOptions() const { return NUM_MPOPTION_TYPES; }
-int CvGlobals::getNumSpecialOptions() const { return NUM_SPECIALOPTION_TYPES; }
-int CvGlobals::getNumGraphicOptions() const { return NUM_GRAPHICOPTION_TYPES; }
-int CvGlobals::getNumTradeableItems() const { return NUM_TRADEABLE_ITEMS; }
-int CvGlobals::getNumBasicItems() const { return NUM_BASIC_ITEMS; }
-int CvGlobals::getNumTradeableHeadings() const { return NUM_TRADEABLE_HEADINGS; }
-int CvGlobals::getNumCommandInfos() const { return NUM_COMMAND_TYPES; }
-int CvGlobals::getNumControlInfos() const { return NUM_CONTROL_TYPES; }
-int CvGlobals::getNumMissionInfos() const { return NUM_MISSION_TYPES; }
-int CvGlobals::getNumPlayerOptionInfos() const { return NUM_PLAYEROPTION_TYPES; }
-int CvGlobals::getMaxNumSymbols() const { return MAX_NUM_SYMBOLS; }
-int CvGlobals::getNumGraphicLevels() const { return NUM_GRAPHICLEVELS; }
-
-
-//
-// non-inline versions
-//
-CvMap& CvGlobals::getMap() { return *m_map; }
-CvGameAI& CvGlobals::getGame() { return *m_game; }
-CvGameAI *CvGlobals::getGamePointer(){ return m_game; }
-
-int CvGlobals::getMaxCivPlayers() const
-{
-	return MAX_PLAYERS;
-}
-
-bool CvGlobals::IsGraphicsInitialized() const { return m_bGraphicsInitialized;}
-void CvGlobals::SetGraphicsInitialized(bool bVal) { m_bGraphicsInitialized = bVal;}
-void CvGlobals::setInterface(CvInterface* pVal) { m_interface = pVal; }
-void CvGlobals::setDiplomacyScreen(CvDiplomacyScreen* pVal) { m_diplomacyScreen = pVal; }
-void CvGlobals::setMPDiplomacyScreen(CMPDiplomacyScreen* pVal) { m_mpDiplomacyScreen = pVal; }
-void CvGlobals::setMessageQueue(CMessageQueue* pVal) { m_messageQueue = pVal; }
-void CvGlobals::setHotJoinMessageQueue(CMessageQueue* pVal) { m_hotJoinMsgQueue = pVal; }
-void CvGlobals::setMessageControl(CMessageControl* pVal) { m_messageControl = pVal; }
-void CvGlobals::setSetupData(CvSetupData* pVal) { m_setupData = pVal; }
-void CvGlobals::setMessageCodeTranslator(CvMessageCodeTranslator* pVal) { m_messageCodes = pVal; }
-void CvGlobals::setDropMgr(CvDropMgr* pVal) { m_dropMgr = pVal; }
-void CvGlobals::setPortal(CvPortal* pVal) { m_portal = pVal; }
-void CvGlobals::setStatsReport(CvStatsReporter* pVal) { m_statsReporter = pVal; }
-void CvGlobals::setPathFinder(FAStar* pVal) { m_pathFinder = pVal; }
-void CvGlobals::setInterfacePathFinder(FAStar* pVal) { m_interfacePathFinder = pVal; }
-void CvGlobals::setStepFinder(FAStar* pVal) { m_stepFinder = pVal; }
-void CvGlobals::setRouteFinder(FAStar* pVal) { m_routeFinder = pVal; }
-void CvGlobals::setBorderFinder(FAStar* pVal) { m_borderFinder = pVal; }
-void CvGlobals::setAreaFinder(FAStar* pVal) { m_areaFinder = pVal; }
-CvDLLUtilityIFaceBase* CvGlobals::getDLLIFaceNonInl() { return m_pDLL; }
-
-
-// XML enum check - start - Nightinggale
-
-/*
- * Certain XML files have their types hardcoded in enums.
- * While this certainly increase execution speed, it also adds the risk that the XML and DLL goes out of sync.
- * The following code is to detect desyncs when the game starts as undetected desyncs can cause havoc.
- *
- * Most of the code is autogenerated based on the enums.
- *    Nightinggale
- */
-
-void CvGlobals::CheckEnumYields() const
-{
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_FOOD).getType(), "YIELD_FOOD"), CvString::format("XML error. Found yield type %s instead of YIELD_FOOD at index %d", GC.getYieldInfo(YIELD_FOOD).getType(), YIELD_FOOD).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_GRAIN).getType(), "YIELD_GRAIN"), CvString::format("XML error. Found yield type %s instead of YIELD_GRAIN at index %d", GC.getYieldInfo(YIELD_GRAIN).getType(), YIELD_GRAIN).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_CATTLE).getType(), "YIELD_CATTLE"), CvString::format("XML error. Found yield type %s instead of YIELD_CATTLE at index %d", GC.getYieldInfo(YIELD_CATTLE).getType(), YIELD_CATTLE).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_SHEEP).getType(), "YIELD_SHEEP"), CvString::format("XML error. Found yield type %s instead of YIELD_SHEEP at index %d", GC.getYieldInfo(YIELD_SHEEP).getType(), YIELD_SHEEP).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_WOOL).getType(), "YIELD_WOOL"), CvString::format("XML error. Found yield type %s instead of YIELD_WOOL at index %d", GC.getYieldInfo(YIELD_WOOL).getType(), YIELD_WOOL).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_LUMBER).getType(), "YIELD_LUMBER"), CvString::format("XML error. Found yield type %s instead of YIELD_LUMBER at index %d", GC.getYieldInfo(YIELD_LUMBER).getType(), YIELD_LUMBER).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_STONE).getType(), "YIELD_STONE"), CvString::format("XML error. Found yield type %s instead of YIELD_STONE at index %d", GC.getYieldInfo(YIELD_STONE).getType(), YIELD_STONE).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_SILVER).getType(), "YIELD_SILVER"), CvString::format("XML error. Found yield type %s instead of YIELD_SILVER at index %d", GC.getYieldInfo(YIELD_SILVER).getType(), YIELD_SILVER).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_SALT).getType(), "YIELD_SALT"), CvString::format("XML error. Found yield type %s instead of YIELD_SALT at index %d", GC.getYieldInfo(YIELD_SALT).getType(), YIELD_SALT).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_SPICES).getType(), "YIELD_SPICES"), CvString::format("XML error. Found yield type %s instead of YIELD_SPICES at index %d", GC.getYieldInfo(YIELD_SPICES).getType(), YIELD_SPICES).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_FUR).getType(), "YIELD_FUR"), CvString::format("XML error. Found yield type %s instead of YIELD_FUR at index %d", GC.getYieldInfo(YIELD_FUR).getType(), YIELD_FUR).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_COTTON).getType(), "YIELD_COTTON"), CvString::format("XML error. Found yield type %s instead of YIELD_COTTON at index %d", GC.getYieldInfo(YIELD_COTTON).getType(), YIELD_COTTON).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_BARLEY).getType(), "YIELD_BARLEY"), CvString::format("XML error. Found yield type %s instead of YIELD_BARLEY at index %d", GC.getYieldInfo(YIELD_BARLEY).getType(), YIELD_BARLEY).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_GRAPES).getType(), "YIELD_GRAPES"), CvString::format("XML error. Found yield type %s instead of YIELD_GRAPES at index %d", GC.getYieldInfo(YIELD_GRAPES).getType(), YIELD_GRAPES).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_ORE).getType(), "YIELD_ORE"), CvString::format("XML error. Found yield type %s instead of YIELD_ORE at index %d", GC.getYieldInfo(YIELD_ORE).getType(), YIELD_ORE).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_CLOTH).getType(), "YIELD_CLOTH"), CvString::format("XML error. Found yield type %s instead of YIELD_CLOTH at index %d", GC.getYieldInfo(YIELD_CLOTH).getType(), YIELD_CLOTH).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_COATS).getType(), "YIELD_COATS"), CvString::format("XML error. Found yield type %s instead of YIELD_COATS at index %d", GC.getYieldInfo(YIELD_COATS).getType(), YIELD_COATS).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_ALE).getType(), "YIELD_ALE"), CvString::format("XML error. Found yield type %s instead of YIELD_ALE at index %d", GC.getYieldInfo(YIELD_ALE).getType(), YIELD_ALE).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_WINE).getType(), "YIELD_WINE"), CvString::format("XML error. Found yield type %s instead of YIELD_WINE at index %d", GC.getYieldInfo(YIELD_WINE).getType(), YIELD_WINE).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_TOOLS).getType(), "YIELD_TOOLS"), CvString::format("XML error. Found yield type %s instead of YIELD_TOOLS at index %d", GC.getYieldInfo(YIELD_TOOLS).getType(), YIELD_TOOLS).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_WEAPONS).getType(), "YIELD_WEAPONS"), CvString::format("XML error. Found yield type %s instead of YIELD_WEAPONS at index %d", GC.getYieldInfo(YIELD_WEAPONS).getType(), YIELD_WEAPONS).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_HORSES).getType(), "YIELD_HORSES"), CvString::format("XML error. Found yield type %s instead of YIELD_HORSES at index %d", GC.getYieldInfo(YIELD_HORSES).getType(), YIELD_HORSES).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_LEATHER_ARMOR).getType(), "YIELD_LEATHER_ARMOR"), CvString::format("XML error. Found yield type %s instead of YIELD_LEATHER_ARMOR at index %d", GC.getYieldInfo(YIELD_LEATHER_ARMOR).getType(), YIELD_LEATHER_ARMOR).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_SCALE_ARMOR).getType(), "YIELD_SCALE_ARMOR"), CvString::format("XML error. Found yield type %s instead of YIELD_SCALE_ARMOR at index %d", GC.getYieldInfo(YIELD_SCALE_ARMOR).getType(), YIELD_SCALE_ARMOR).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_MAIL_ARMOR).getType(), "YIELD_MAIL_ARMOR"), CvString::format("XML error. Found yield type %s instead of YIELD_MAIL_ARMOR at index %d", GC.getYieldInfo(YIELD_MAIL_ARMOR).getType(), YIELD_MAIL_ARMOR).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_PLATE_ARMOR).getType(), "YIELD_PLATE_ARMOR"), CvString::format("XML error. Found yield type %s instead of YIELD_PLATE_ARMOR at index %d", GC.getYieldInfo(YIELD_PLATE_ARMOR).getType(), YIELD_PLATE_ARMOR).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_TRADE_GOODS).getType(), "YIELD_TRADE_GOODS"), CvString::format("XML error. Found yield type %s instead of YIELD_TRADE_GOODS at index %d", GC.getYieldInfo(YIELD_TRADE_GOODS).getType(), YIELD_TRADE_GOODS).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_HAMMERS).getType(), "YIELD_HAMMERS"), CvString::format("XML error. Found yield type %s instead of YIELD_HAMMERS at index %d", GC.getYieldInfo(YIELD_HAMMERS).getType(), YIELD_HAMMERS).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_BELLS).getType(), "YIELD_BELLS"), CvString::format("XML error. Found yield type %s instead of YIELD_BELLS at index %d", GC.getYieldInfo(YIELD_BELLS).getType(), YIELD_BELLS).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_CROSSES).getType(), "YIELD_CROSSES"), CvString::format("XML error. Found yield type %s instead of YIELD_CROSSES at index %d", GC.getYieldInfo(YIELD_CROSSES).getType(), YIELD_CROSSES).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_EDUCATION).getType(), "YIELD_EDUCATION"), CvString::format("XML error. Found yield type %s instead of YIELD_EDUCATION at index %d", GC.getYieldInfo(YIELD_EDUCATION).getType(), YIELD_EDUCATION).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_IDEAS).getType(), "YIELD_IDEAS"), CvString::format("XML error. Found yield type %s instead of YIELD_IDEAS at index %d", GC.getYieldInfo(YIELD_IDEAS).getType(), YIELD_IDEAS).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_CULTURE).getType(), "YIELD_CULTURE"), CvString::format("XML error. Found yield type %s instead of YIELD_CULTURE at index %d", GC.getYieldInfo(YIELD_CULTURE).getType(), YIELD_CULTURE).c_str());
-	FAssertMsg(!strcmp(GC.getYieldInfo(YIELD_GOLD).getType(), "YIELD_GOLD"), CvString::format("XML error. Found yield type %s instead of YIELD_GOLD at index %d", GC.getYieldInfo(YIELD_GOLD).getType(), YIELD_GOLD).c_str());
-
-
-
-	FAssertMsg(GC.getYieldInfo().size() == NUM_YIELD_TYPES, CvString::format("XML error. Expected %d yield types, but found %d", NUM_YIELD_TYPES, GC.getYieldInfo().size()));
-}
-// XML enum check - end - Nightinggale
-
-// cache XML - start - Nightinggale
-void CvGlobals::setXMLCache()
-{
-	if (m_cache_WEEKS_PER_MONTHS > 0)
-	{
-		// cache is already set.
-		return;
-	}
-
-	m_cache_ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES = getDefineINT("ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES");
-	m_cache_ADVANCED_START_CITY_COST = getDefineINT("ADVANCED_START_CITY_COST");
-	m_cache_ADVANCED_START_CITY_COST_INCREASE = getDefineINT("ADVANCED_START_CITY_COST_INCREASE");
-	m_cache_ADVANCED_START_CITY_PLACEMENT_MAX_RANGE = getDefineINT("ADVANCED_START_CITY_PLACEMENT_MAX_RANGE");
-	m_cache_ADVANCED_START_CULTURE_COST = getDefineINT("ADVANCED_START_CULTURE_COST"); 
-	m_cache_ADVANCED_START_MAX_UNITS_PER_CITY = getDefineINT("ADVANCED_START_MAX_UNITS_PER_CITY");
-	m_cache_ADVANCED_START_POPULATION_COST = getDefineINT("ADVANCED_START_POPULATION_COST");
-	m_cache_ADVANCED_START_POPULATION_COST_INCREASE = getDefineINT("ADVANCED_START_POPULATION_COST_INCREASE");
-	m_cache_ADVANCED_START_SIGHT_RANGE = getDefineINT("ADVANCED_START_SIGHT_RANGE");
-	m_cache_ADVANCED_START_VISIBILITY_COST = getDefineINT("ADVANCED_START_VISIBILITY_COST");
-	m_cache_ADVANCED_START_VISIBILITY_COST_INCREASE = getDefineINT("ADVANCED_START_VISIBILITY_COST_INCREASE");
-	m_cache_AI_ADVANCED_TECH_START = getDefineINT("AI_ADVANCED_TECH_START");
-	m_cache_AI_CAN_DISBAND_UNITS = getDefineINT("AI_CAN_DISBAND_UNITS");
-	m_cache_AI_CHEAT_AUTO_BUY = getDefineINT("AI_CHEAT_AUTO_BUY");
-	m_cache_AI_CHEAT_NEEDED_DEFENDERS = getDefineINT("AI_CHEAT_NEEDED_DEFENDERS");
-	m_cache_AI_CHEAT_SPICE = getDefineINT("AI_CHEAT_SPICE");
-	m_cache_AI_CHEAT_SPICE_BUY = getDefineINT("AI_CHEAT_SPICE_BUY");
-	m_cache_AI_CHEAT_SPICE_MULTIPLE = getDefineINT("AI_CHEAT_SPICE_MULTIPLE");
-	m_cache_AI_FAVORED_TERRAIN_MOD = getDefineINT("AI_FAVORED_TERRAIN_MOD");
-	m_cache_AI_HANDICAP_CASTLE = getDefineINT("AI_HANDICAP_CASTLE");
-	m_cache_AI_HANDICAP_MOTTE = getDefineINT("AI_HANDICAP_MOTTE");
-	m_cache_AI_MILITARY_PROFESSION_HACK = getDefineINT("AI_MILITARY_PROFESSION_HACK");
-	m_cache_AI_WAREHOUSE_MOD = getDefineINT("AI_WAREHOUSE_MOD");
-	m_cache_ALLIANCE_CULTURE_PERCENT_DENIAL = getDefineINT("ALLIANCE_CULTURE_PERCENT_DENIAL");
-	m_cache_ALLIANCE_PACT_PEACE_DENIAL = getDefineINT("ALLIANCE_PACT_PEACE_DENIAL");
-	m_cache_ANIMAL_BANDITS_GUARD_GOODY_TIMER = getDefineINT("ANIMAL_BANDITS_GUARD_GOODY_TIMER");
-	m_cache_AUTORESEARCH_ALL = getDefineINT("AUTORESEARCH_ALL");
-	m_cache_BANQUET_YIELD_AMOUNT = getDefineINT("BANQUET_YIELD_AMOUNT");
-	m_cache_BARBARIAN_CIVILIZATION = getDefineINT("BARBARIAN_CIVILIZATION");
-	m_cache_BARBARIAN_LEADER = getDefineINT("BARBARIAN_LEADER");
-	m_cache_BASE_CITY_GROWTH_THRESHOLD = getDefineINT("BASE_CITY_GROWTH_THRESHOLD");
-	m_cache_BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD = getDefineINT("BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD");
-	m_cache_BASE_OCCUPATION_TURNS = getDefineINT("BASE_OCCUPATION_TURNS");
-	m_cache_BASE_UNIT_UPGRADE_COST = getDefineINT("BASE_UNIT_UPGRADE_COST");
-	m_cache_BUILDINGCLASS_TRAVEL_TO_FAIR = getDefineINT("BUILDINGCLASS_TRAVEL_TO_FAIR");
-	m_cache_BUILDING_PRODUCTION_DECAY_PERCENT = getDefineINT("BUILDING_PRODUCTION_DECAY_PERCENT");
-	m_cache_BUILDING_PRODUCTION_DECAY_TIME = getDefineINT("BUILDING_PRODUCTION_DECAY_TIME");
-	m_cache_BUILDING_PRODUCTION_PERCENT = getDefineINT("BUILDING_PRODUCTION_PERCENT");
-	m_cache_BUY_PLOT_BASE_CULTURE_COST = getDefineINT("BUY_PLOT_BASE_CULTURE_COST");
-	m_cache_BUY_PLOT_CULTURE_RANGE = getDefineINT("BUY_PLOT_CULTURE_RANGE");
-	m_cache_BUY_PLOT_MIN_CULTURE = getDefineINT("BUY_PLOT_MIN_CULTURE");
-	m_cache_BUY_PLOT_OWNED_COST_MODIFIER = getDefineINT("BUY_PLOT_OWNED_COST_MODIFIER");
-	m_cache_BUY_PLOT_SELLER_INCOME_PERCENT = getDefineINT("BUY_PLOT_SELLER_INCOME_PERCENT");
-	m_cache_CALENDER_YEAR_FIRST_CHANGE_TURN = getDefineINT("CALENDER_YEAR_FIRST_CHANGE_TURN");
-	m_cache_CALENDER_YEAR_FIRST_MULTIPLIER = getDefineINT("CALENDER_YEAR_FIRST_MULTIPLIER");
-	m_cache_CALENDER_YEAR_SECOND_CHANGE_TURN = getDefineINT("CALENDER_YEAR_SECOND_CHANGE_TURN");
-	m_cache_CALENDER_YEAR_SECOND_MULTIPLIER = getDefineINT("CALENDER_YEAR_SECOND_MULTIPLIER");
-	m_cache_CALENDER_YEAR_THIRD_MULTIPLIER = getDefineINT("CALENDER_YEAR_THIRD_MULTIPLIER");
-	m_cache_CAPITAL_BUILDINGCLASS = getDefineINT("CAPITAL_BUILDINGCLASS");
-	m_cache_CAPTURED_CARGO_RANDOM_AMOUNT = getDefineINT("CAPTURED_CARGO_RANDOM_AMOUNT");
-	m_cache_CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT = getDefineINT("CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT");
-	m_cache_CASTLES_TO_VILLAGES_RATIO = getDefineINT("CASTLES_TO_VILLAGES_RATIO");
-	m_cache_CHANCE_TO_CAPTURE_CRIMINALS = getDefineINT("CHANCE_TO_CAPTURE_CRIMINALS");
-	m_cache_CHEAT_TRAVEL_ALL = getDefineINT("CHEAT_TRAVEL_ALL");
-	m_cache_CITY_DEFENSE_DAMAGE_HEAL_RATE = getDefineINT("CITY_DEFENSE_DAMAGE_HEAL_RATE");
-	m_cache_CITY_FREE_CULTURE_GROWTH_FACTOR = getDefineINT("CITY_FREE_CULTURE_GROWTH_FACTOR");
-	m_cache_CITY_GROWTH_MULTIPLIER = getDefineINT("CITY_GROWTH_MULTIPLIER");
-	m_cache_CITY_HEAL_RATE = getDefineINT("CITY_HEAL_RATE");
-	m_cache_CITY_PILGRAM_RANDOM = getDefineINT("CITY_PILGRAM_RANDOM");
-	m_cache_CITY_SCREEN_FOG_ENABLED = getDefineINT("CITY_SCREEN_FOG_ENABLED");
-	m_cache_CITY_YIELD_CAPACITY = getDefineINT("CITY_YIELD_CAPACITY");
-	m_cache_CITY_YIELD_DECAY_PERCENT = getDefineINT("CITY_YIELD_DECAY_PERCENT");
-	m_cache_CIVICOPTION_INVENTIONS = getDefineINT("CIVICOPTION_INVENTIONS");
-	m_cache_COLONIAL_FORCED_PEACE_TURNS = getDefineINT("COLONIAL_FORCED_PEACE_TURNS");
-	m_cache_COMBAT_DAMAGE = getDefineINT("COMBAT_DAMAGE");
-	m_cache_COMBAT_DIE_SIDES = getDefineINT("COMBAT_DIE_SIDES");
-	m_cache_COMBAT_EXPERIENCE_IN_BORDERS_PERCENT = getDefineINT("COMBAT_EXPERIENCE_IN_BORDERS_PERCENT");
-	m_cache_CONSUME_EQUIPMENT_ON_FOUND = getDefineINT("CONSUME_EQUIPMENT_ON_FOUND");
-	m_cache_CONTACT_YIELD_GIFT_ENCOMEIDA_TIMER = getDefineINT("CONTACT_YIELD_GIFT_ENCOMEIDA_TIMER");
-	m_cache_CONTACT_YIELD_GIFT_TECH = getDefineINT("CONTACT_YIELD_GIFT_TECH");
-	m_cache_CULTURE_YIELD = getDefineINT("CULTURE_YIELD");
-	m_cache_DEAL_TRADE_RELATIONS_POINTS = getDefineINT("DEAL_TRADE_RELATIONS_POINTS");
-	m_cache_DEEP_WATER_TERRAIN = getDefineINT("DEEP_WATER_TERRAIN");
-	m_cache_DEFAULT_BUILD_CASTLE = getDefineINT("DEFAULT_BUILD_CASTLE");
-	m_cache_DEFAULT_BUILD_MOTTE_AND_BAILEY = getDefineINT("DEFAULT_BUILD_MOTTE_AND_BAILEY");
-	m_cache_DEFAULT_CENSURETYPE_ANATHEMA = getDefineINT("DEFAULT_CENSURETYPE_ANATHEMA");
-	m_cache_DEFAULT_CENSURETYPE_ANATHEMA_COUNT = getDefineINT("DEFAULT_CENSURETYPE_ANATHEMA_COUNT");
-	m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION = getDefineINT("DEFAULT_CENSURETYPE_EXCOMMUNICATION");
-	m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION_COUNT = getDefineINT("DEFAULT_CENSURETYPE_EXCOMMUNICATION_COUNT");
-	m_cache_DEFAULT_CENSURETYPE_INTERDICT = getDefineINT("DEFAULT_CENSURETYPE_INTERDICT");
-	m_cache_DEFAULT_CENSURETYPE_INTERDICT_COUNT = getDefineINT("DEFAULT_CENSURETYPE_INTERDICT_COUNT");
-	m_cache_DEFAULT_COMBAT_FOR_TRAINING = getDefineINT("DEFAULT_COMBAT_FOR_TRAINING");
-	m_cache_DEFAULT_DAWN_POPULATION_UNIT = getDefineINT("DEFAULT_DAWN_POPULATION_UNIT");
-	m_cache_DEFAULT_FUEDALISM_TECH = getDefineINT("DEFAULT_FUEDALISM_TECH");
-	m_cache_DEFAULT_GRAIN_GROWTH_UNIT_CLASS = getDefineINT("DEFAULT_GRAIN_GROWTH_UNIT_CLASS");
-	m_cache_DEFAULT_HUNTSMAN_PROFESSION = getDefineINT("DEFAULT_HUNTSMAN_PROFESSION");
-	m_cache_DEFAULT_INVENTOR_CLASS = getDefineINT("DEFAULT_INVENTOR_CLASS");
-	m_cache_DEFAULT_KNIGHT_PROFESSION_PROMOTION = getDefineINT("DEFAULT_KNIGHT_PROFESSION_PROMOTION");
-	m_cache_DEFAULT_KNIGHT_PROMOTION = getDefineINT("DEFAULT_KNIGHT_PROMOTION");
-	m_cache_DEFAULT_MARAUDER_CLASS = getDefineINT("DEFAULT_MARAUDER_CLASS");
-	m_cache_DEFAULT_MARUADER_SEA_PROFESSION = getDefineINT("DEFAULT_MARUADER_SEA_PROFESSION");
-	m_cache_DEFAULT_NOBLEMAN_CLASS = getDefineINT("DEFAULT_NOBLEMAN_CLASS");
-	m_cache_DEFAULT_NOBLE_GROWTH_UNIT_CLASS = getDefineINT("DEFAULT_NOBLE_GROWTH_UNIT_CLASS");
-	m_cache_DEFAULT_PILGRAM_CLASS = getDefineINT("DEFAULT_PILGRAM_CLASS");
-	m_cache_DEFAULT_POPULATION_UNIT = getDefineINT("DEFAULT_POPULATION_UNIT");
-	m_cache_DEFAULT_SHRINE_CLASS = getDefineINT("DEFAULT_SHRINE_CLASS");
-	m_cache_DEFAULT_SLAVE_CLASS = getDefineINT("DEFAULT_SLAVE_CLASS");
-	m_cache_DEFAULT_SPECIALBUILDING_COURTHOUSE = getDefineINT("DEFAULT_SPECIALBUILDING_COURTHOUSE");
-	m_cache_DEFAULT_TEST_DEFINE = getDefineINT("DEFAULT_TEST_DEFINE");
-	m_cache_DEFAULT_TRAINED_PROMOTION = getDefineINT("DEFAULT_TRAINED_PROMOTION");
-	m_cache_DEFAULT_TREASURE_YIELD = getDefineINT("DEFAULT_TREASURE_YIELD");
-	m_cache_DEFAULT_UNTRAINED_PROMOTION = getDefineINT("DEFAULT_UNTRAINED_PROMOTION");
-	m_cache_DEFAULT_VIKING_ERA = getDefineINT("DEFAULT_VIKING_ERA");
-	m_cache_DEFAULT_YIELD_ARMOR_TYPE = getDefineINT("DEFAULT_YIELD_ARMOR_TYPE");
-	m_cache_DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT = getDefineINT("DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT");
-	m_cache_DIPLOMACY_VALUE_REMAINDER = getDefineINT("DIPLOMACY_VALUE_REMAINDER");
-	m_cache_DOCKS_NEXT_UNITS = getDefineINT("DOCKS_NEXT_UNITS");
-	m_cache_EDUCATION_BASE_TUITION = getDefineINT("EDUCATION_BASE_TUITION");
-	m_cache_EDUCATION_THRESHOLD = getDefineINT("EDUCATION_THRESHOLD");
-	m_cache_EDUCATION_THRESHOLD_INCREASE = getDefineINT("EDUCATION_THRESHOLD_INCREASE");
-	m_cache_ENABLE_ALLIANCE_TRADING = getDefineINT("ENABLE_ALLIANCE_TRADING");
-	m_cache_ENABLE_DEFENSIVE_PACT_TRADING = getDefineINT("ENABLE_DEFENSIVE_PACT_TRADING");
-	m_cache_ENABLE_GOLD_TRADING = getDefineINT("ENABLE_GOLD_TRADING");
-	m_cache_ENABLE_MAP_TRADING = getDefineINT("ENABLE_MAP_TRADING");
-	m_cache_ENABLE_OPEN_BORDERS = getDefineINT("ENABLE_OPEN_BORDERS");
-	m_cache_END_GAME_DISPLAY_WARNING = getDefineINT("END_GAME_DISPLAY_WARNING");
-	m_cache_ENEMY_HEAL_RATE = getDefineINT("ENEMY_HEAL_RATE");
-	m_cache_ESTABLISH_TRADEPOST_COST = getDefineINT("ESTABLISH_TRADEPOST_COST");
-	m_cache_EUROPE_EAST = getDefineINT("EUROPE_EAST");
-	m_cache_EUROPE_MARKET_CORRELATION_PERCENT = getDefineINT("EUROPE_MARKET_CORRELATION_PERCENT");
-	m_cache_EVENT_PROBABILITY_ROLL_SIDES = getDefineINT("EVENT_PROBABILITY_ROLL_SIDES");
-	m_cache_EXPERIENCE_FROM_WITHDRAWL = getDefineINT("EXPERIENCE_FROM_WITHDRAWL");
-	m_cache_EXTRA_YIELD = getDefineINT("EXTRA_YIELD");
-	m_cache_FATHER_COST_EXTRA_TEAM_MEMBER_MODIFIER = getDefineINT("FATHER_COST_EXTRA_TEAM_MEMBER_MODIFIER");
-	m_cache_FATHER_POINT_REAL_TRADE = getDefineINT("FATHER_POINT_REAL_TRADE");
-	m_cache_FEATURE_PRODUCTION_YIELD_MAX_DISTANCE = getDefineINT("FEATURE_PRODUCTION_YIELD_MAX_DISTANCE");
-	m_cache_FIRST_EVENT_DELAY_TURNS = getDefineINT("FIRST_EVENT_DELAY_TURNS");
-	m_cache_FOUND_MONASTERY_NUMBER = getDefineINT("FOUND_MONASTERY_NUMBER");
-	m_cache_FOUND_MOTTE_AND_BAILEY_NUMBER = getDefineINT("FOUND_MOTTE_AND_BAILEY_NUMBER");
-	m_cache_FOUND_OUTPOST_NUMBER = getDefineINT("FOUND_OUTPOST_NUMBER");
-	m_cache_FOUND_VILLAGE_NUMBER = getDefineINT("FOUND_VILLAGE_NUMBER");
-	m_cache_FREE_CITY_ADJACENT_CULTURE = getDefineINT("FREE_CITY_ADJACENT_CULTURE");
-	m_cache_FREE_CITY_CULTURE = getDefineINT("FREE_CITY_CULTURE");
-	m_cache_FREE_PEASANT_CIVIC = getDefineINT("FREE_PEASANT_CIVIC");
-	m_cache_FRIENDLY_HEAL_RATE = getDefineINT("FRIENDLY_HEAL_RATE");
-	m_cache_GREAT_GENERALS_THRESHOLD = getDefineINT("GREAT_GENERALS_THRESHOLD");
-	m_cache_GREAT_GENERALS_THRESHOLD_INCREASE = getDefineINT("GREAT_GENERALS_THRESHOLD_INCREASE");
-	m_cache_GREAT_GENERALS_THRESHOLD_INCREASE_TEAM = getDefineINT("GREAT_GENERALS_THRESHOLD_INCREASE_TEAM");
-	m_cache_HIRE_GUARD_COST = getDefineINT("HIRE_GUARD_COST");
-	m_cache_HIRE_GUARD_PROMOTION = getDefineINT("HIRE_GUARD_PROMOTION");
-	m_cache_IMMIGRATION_MAX_CITY_DISTANCE = getDefineINT("IMMIGRATION_MAX_CITY_DISTANCE");
-	m_cache_IMMIGRATION_THRESHOLD = getDefineINT("IMMIGRATION_THRESHOLD");
-	m_cache_IMMIGRATION_THRESHOLD_INCREASE = getDefineINT("IMMIGRATION_THRESHOLD_INCREASE");
-	m_cache_IMMIGRATION_TRAVEL_MOD = getDefineINT("IMMIGRATION_TRAVEL_MOD");
-	m_cache_INDUSTRIAL_VICTORY_SINGLE_YIELD = getDefineINT("INDUSTRIAL_VICTORY_SINGLE_YIELD");
-	m_cache_INITIAL_AI_CITY_PRODUCTION = getDefineINT("INITIAL_AI_CITY_PRODUCTION");
-	m_cache_INITIAL_CITY_POPULATION = getDefineINT("INITIAL_CITY_POPULATION");
-	m_cache_INITIAL_CITY_ROUTE_TYPE = getDefineINT("INITIAL_CITY_ROUTE_TYPE");
-	m_cache_JUNGLE_FEATURE = getDefineINT("JUNGLE_FEATURE");
-	m_cache_KING_BUY_UNIT_PRICE_MODIFIER = getDefineINT("KING_BUY_UNIT_PRICE_MODIFIER");
-	m_cache_KING_INITIAL_UNIT_INCREASE = getDefineINT("KING_INITIAL_UNIT_INCREASE");
-	m_cache_KING_TRANSPORT_TREASURE_COMISSION = getDefineINT("KING_TRANSPORT_TREASURE_COMISSION");
-	m_cache_KNIGHT_RANSOM_MOD = getDefineINT("KNIGHT_RANSOM_MOD");
-	m_cache_LAKE_PLOT_RAND = getDefineINT("LAKE_PLOT_RAND");
-	m_cache_LAND_IMPROVEMENT = getDefineINT("LAND_IMPROVEMENT");
-	m_cache_LAND_TERRAIN = getDefineINT("LAND_TERRAIN");
-	m_cache_MARAUDERS_DAYSOUT_RANDOM = getDefineINT("MARAUDERS_DAYSOUT_RANDOM");
-	m_cache_MARAUDERS_TOWER_RANGE = getDefineINT("MARAUDERS_TOWER_RANGE");
-	m_cache_MARAUDER_CRUMBS_EVENT = getDefineINT("MARAUDER_CRUMBS_EVENT");
-	m_cache_MARAUDER_EVENT_DEFAULT_TURNS = getDefineINT("MARAUDER_EVENT_DEFAULT_TURNS");
-	m_cache_MAX_CITY_POPULATION_COMMUNE = getDefineINT("MAX_CITY_POPULATION_COMMUNE");
-	m_cache_MAX_CITY_POPULATION_VILLAGE = getDefineINT("MAX_CITY_POPULATION_VILLAGE");
-	m_cache_MAX_EXPERIENCE_AFTER_UPGRADE = getDefineINT("MAX_EXPERIENCE_AFTER_UPGRADE");
-	m_cache_MAX_EXPERIENCE_PER_COMBAT = getDefineINT("MAX_EXPERIENCE_PER_COMBAT");
-	m_cache_MAX_FORTIFY_TURNS = getDefineINT("MAX_FORTIFY_TURNS");
-	m_cache_MAX_INSULT_MODIFIER = getDefineINT("MAX_INSULT_MODIFIER");
-	m_cache_MAX_LEVEL_FROM_ANIMAL_XP = getDefineINT("MAX_LEVEL_FROM_ANIMAL_XP");
-	m_cache_MAX_MARAUDERS = getDefineINT("MAX_MARAUDERS");
-	m_cache_MAX_NUM_LANGUAGES = getDefineINT("MAX_NUM_LANGUAGES");
-	m_cache_MAX_PLOT_LIST_SIZE = getDefineINT("MAX_PLOT_LIST_SIZE");
-	m_cache_MAX_REBEL_COMBAT_MULTIPLER = getDefineINT("MAX_REBEL_COMBAT_MULTIPLER");
-	m_cache_MAX_TRAINED_EXPERIENCE = getDefineINT("MAX_TRAINED_EXPERIENCE");
-	m_cache_MAX_WITHDRAWAL_PROBABILITY = getDefineINT("MAX_WITHDRAWAL_PROBABILITY");
-	m_cache_MEDIEVAL_CENSURE = getDefineINT("MEDIEVAL_CENSURE");
-	m_cache_MEDIEVAL_TRADE_TECH = getDefineINT("MEDIEVAL_TRADE_TECH");
-	m_cache_MINIMAP_RENDER_SIZE = getDefineINT("MINIMAP_RENDER_SIZE");
-	m_cache_MIN_ANIMAL_STARTING_DISTANCE = getDefineINT("MIN_ANIMAL_STARTING_DISTANCE");
-	m_cache_MIN_CITY_YIELD_DECAY = getDefineINT("MIN_CITY_YIELD_DECAY");
-	m_cache_MIN_CIV_STARTING_DISTANCE = getDefineINT("MIN_CIV_STARTING_DISTANCE");
-	m_cache_MIN_EXPERIENCE_PER_COMBAT = getDefineINT("MIN_EXPERIENCE_PER_COMBAT");
-	m_cache_MIN_TIMER_UNIT_DOUBLE_MOVES = getDefineINT("MIN_TIMER_UNIT_DOUBLE_MOVES");
-	m_cache_MIN_WATER_SIZE_FOR_OCEAN = getDefineINT("MIN_WATER_SIZE_FOR_OCEAN");
-	m_cache_MISSIONARY_RATE_EFFECT_ON_SUCCESS = getDefineINT("MISSIONARY_RATE_EFFECT_ON_SUCCESS");
-	m_cache_MISSIONARY_THRESHOLD = getDefineINT("MISSIONARY_THRESHOLD");
-	m_cache_MISSIONARY_THRESHOLD_INCREASE = getDefineINT("MISSIONARY_THRESHOLD_INCREASE");
-	m_cache_MONASTERIES_TO_VILLAGES_RATIO = getDefineINT("MONASTERIES_TO_VILLAGES_RATIO");
-	m_cache_NATIVE_AUTO_SELL_PERCENT = getDefineINT("NATIVE_AUTO_SELL_PERCENT");
-	m_cache_NATIVE_GOODS_RAID_PERCENT = getDefineINT("NATIVE_GOODS_RAID_PERCENT");
-	m_cache_NATIVE_GROWTH_THRESHOLD_MULTIPLIER = getDefineINT("NATIVE_GROWTH_THRESHOLD_MULTIPLIER");
-	m_cache_NATIVE_HORSES_FOR_SALE = getDefineINT("NATIVE_HORSES_FOR_SALE");
-	m_cache_NATIVE_HORSES_FOR_SALE_PERCENT = getDefineINT("NATIVE_HORSES_FOR_SALE_PERCENT");
-	m_cache_NATIVE_TEACH_THRESHOLD_INCREASE = getDefineINT("NATIVE_TEACH_THRESHOLD_INCREASE");
-	m_cache_NATIVE_TECH = getDefineINT("NATIVE_TECH");
-	m_cache_NATIVE_TRADING_TRADEPOST = getDefineINT("NATIVE_TRADING_TRADEPOST");
-	m_cache_NEUTRAL_HEAL_RATE = getDefineINT("NEUTRAL_HEAL_RATE");
-	m_cache_NEW_CITY_BUILDING_VALUE_MODIFIER = getDefineINT("NEW_CITY_BUILDING_VALUE_MODIFIER");
-	m_cache_NEW_HURRY_MODIFIER = getDefineINT("NEW_HURRY_MODIFIER");
-	m_cache_NOBLE_FIELD_LABOR_PENALTY = getDefineINT("NOBLE_FIELD_LABOR_PENALTY");
-	m_cache_NO_BAD_GOODIES_EXPERIENCE_PERCENT = getDefineINT("NO_BAD_GOODIES_EXPERIENCE_PERCENT");
-	m_cache_NO_BAD_GOODIES_GOLD_PERCENT = getDefineINT("NO_BAD_GOODIES_GOLD_PERCENT");
-	m_cache_NO_CITY_SHORTAGE_MESSAGES = getDefineINT("NO_CITY_SHORTAGE_MESSAGES");
-	m_cache_NO_STARTING_PLOTS_IN_JUNGLE = getDefineINT("NO_STARTING_PLOTS_IN_JUNGLE");
-	m_cache_OCCUPATION_CULTURE_PERCENT_THRESHOLD = getDefineINT("OCCUPATION_CULTURE_PERCENT_THRESHOLD");
-	m_cache_OCCUPATION_TURNS_POPULATION_PERCENT = getDefineINT("OCCUPATION_TURNS_POPULATION_PERCENT");
-	m_cache_OWNERSHIP_SCORE_DURATION_THRESHOLD = getDefineINT("OWNERSHIP_SCORE_DURATION_THRESHOLD");
-	m_cache_OWN_TEAM_STARTING_MODIFIER = getDefineINT("OWN_TEAM_STARTING_MODIFIER");
-	m_cache_PEACE_TREATY_LENGTH = getDefineINT("PEACE_TREATY_LENGTH");
-	m_cache_PERCENT_TAX_ON_AUTOSELL_GOODS = getDefineINT("PERCENT_TAX_ON_AUTOSELL_GOODS");
-	m_cache_PILGRAM_OFFER_GOLD = getDefineINT("PILGRAM_OFFER_GOLD");
-	m_cache_PILGRAM_OFFER_GOLD_DISTANCE_MOD = getDefineINT("PILGRAM_OFFER_GOLD_DISTANCE_MOD");
-	m_cache_PLAYER_ALWAYS_RAZES_CITIES = getDefineINT("PLAYER_ALWAYS_RAZES_CITIES");
-	m_cache_PLOTS_PER_RIVER_EDGE = getDefineINT("PLOTS_PER_RIVER_EDGE");
-	m_cache_PLOT_VISIBILITY_RANGE = getDefineINT("PLOT_VISIBILITY_RANGE");
-	m_cache_PROFESSION_COAL_BURNER = getDefineINT("PROFESSION_COAL_BURNER");
-	m_cache_PROFESSION_INVENTOR = getDefineINT("PROFESSION_INVENTOR");
-	m_cache_PROLIFIC_INVENTOR_THRESHOLD_INCREASE = getDefineINT("PROLIFIC_INVENTOR_THRESHOLD_INCREASE");
-	m_cache_PROMOTION_BUILD_HOME = getDefineINT("PROMOTION_BUILD_HOME");
-	m_cache_RANDOM_TURNS_LOST_AT_SEA = getDefineINT("RANDOM_TURNS_LOST_AT_SEA");
-	m_cache_RAZING_CULTURAL_PERCENT_THRESHOLD = getDefineINT("RAZING_CULTURAL_PERCENT_THRESHOLD");
-	m_cache_REBEL_PERCENT_FOR_REVOLUTION = getDefineINT("REBEL_PERCENT_FOR_REVOLUTION");
-	m_cache_REBEL_SENTIMENT_BELLS_FACTOR = getDefineINT("REBEL_SENTIMENT_BELLS_FACTOR");
-	m_cache_REBEL_SENTIMENT_TURN_WEIGHT = getDefineINT("REBEL_SENTIMENT_TURN_WEIGHT");
-	m_cache_REVOLUTION_EUROPE_UNIT_SHIP_MODIFIER = getDefineINT("REVOLUTION_EUROPE_UNIT_SHIP_MODIFIER");
-	m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD = getDefineINT("REVOLUTION_EUROPE_UNIT_THRESHOLD");
-	m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD_INCREASE = getDefineINT("REVOLUTION_EUROPE_UNIT_THRESHOLD_INCREASE");
-	m_cache_RIVAL_TEAM_STARTING_MODIFIER = getDefineINT("RIVAL_TEAM_STARTING_MODIFIER");
-	m_cache_RIVER_SOURCE_MIN_RIVER_RANGE = getDefineINT("RIVER_SOURCE_MIN_RIVER_RANGE");
-	m_cache_RIVER_SOURCE_MIN_SEAWATER_RANGE = getDefineINT("RIVER_SOURCE_MIN_SEAWATER_RANGE");
-	m_cache_RUINS_IMPROVEMENT = getDefineINT("RUINS_IMPROVEMENT");
-	m_cache_SCORE_FATHER_FACTOR = getDefineINT("SCORE_FATHER_FACTOR");
-	m_cache_SCORE_LAND_FACTOR = getDefineINT("SCORE_LAND_FACTOR");
-	m_cache_SCORE_POPULATION_FACTOR = getDefineINT("SCORE_POPULATION_FACTOR");
-	m_cache_SCORE_TAX_FACTOR = getDefineINT("SCORE_TAX_FACTOR");
-	m_cache_SETTLEMENT_TREASURE_YIELD = getDefineINT("SETTLEMENT_TREASURE_YIELD");
-	m_cache_SHALLOW_WATER_TERRAIN = getDefineINT("SHALLOW_WATER_TERRAIN");
-	m_cache_SLAVE_FOOD_CONSUMPTION_PER_POPULATION = getDefineINT("SLAVE_FOOD_CONSUMPTION_PER_POPULATION");
-	m_cache_STANDARD_CALENDAR = getDefineINT("STANDARD_CALENDAR");
-	m_cache_STANDARD_CLIMATE = getDefineINT("STANDARD_CLIMATE");
-	m_cache_STANDARD_ERA = getDefineINT("STANDARD_ERA");
-	m_cache_STANDARD_GAMESPEED = getDefineINT("STANDARD_GAMESPEED");
-	m_cache_STANDARD_HANDICAP = getDefineINT("STANDARD_HANDICAP");
-	m_cache_STANDARD_SEALEVEL = getDefineINT("STANDARD_SEALEVEL");
-	m_cache_STANDARD_TURNTIMER = getDefineINT("STANDARD_TURNTIMER");
-	m_cache_STARTING_DISTANCE_PERCENT = getDefineINT("STARTING_DISTANCE_PERCENT");
-	m_cache_START_YEAR = getDefineINT("START_YEAR");
-	m_cache_STEAMWORKS_BUILDING = getDefineINT("STEAMWORKS_BUILDING");
-	m_cache_STEAMWORKS_CLASS_TYPE = getDefineINT("STEAMWORKS_CLASS_TYPE");
-	m_cache_TAX_INCREASE_CHANCE = getDefineINT("TAX_INCREASE_CHANCE");
-	m_cache_TAX_RATE_MAX_INCREASE = getDefineINT("TAX_RATE_MAX_INCREASE");
-	m_cache_TAX_TRADE_THRESHOLD = getDefineINT("TAX_TRADE_THRESHOLD");
-	m_cache_TAX_TRADE_THRESHOLD_ATTITUDE_PERCENT = getDefineINT("TAX_TRADE_THRESHOLD_ATTITUDE_PERCENT");
-	m_cache_TAX_TRADE_THRESHOLD_TAX_RATE_PERCENT = getDefineINT("TAX_TRADE_THRESHOLD_TAX_RATE_PERCENT");
-	m_cache_TK_AI_RESEARCH_COST_MOD_PERCENT = getDefineINT("TK_AI_RESEARCH_COST_MOD_PERCENT");
-	m_cache_TK_HUMAN_RESEARCH_COST_MOD_PERCENT = getDefineINT("TK_HUMAN_RESEARCH_COST_MOD_PERCENT");
-	m_cache_TK_IDEAS_CITY_VALUE = getDefineINT("TK_IDEAS_CITY_VALUE");
-	m_cache_TK_MAX_FORTS_PER_CITY = getDefineINT("TK_MAX_FORTS_PER_CITY");
-	m_cache_TK_PIONEER_COAL_FURNACE_BONUS = getDefineINT("TK_PIONEER_COAL_FURNACE_BONUS");
-	m_cache_TK_PROLIFIC_INVENTOR_PROGRESS = getDefineINT("TK_PROLIFIC_INVENTOR_PROGRESS");
-	m_cache_TK_PROLIFIC_INVENTOR_THRESHOLD = getDefineINT("TK_PROLIFIC_INVENTOR_THRESHOLD");
-	m_cache_TK_RESEARCH_PACT_IDEAS_THRESHOLD = getDefineINT("TK_RESEARCH_PACT_IDEAS_THRESHOLD");
-	m_cache_TK_RESEARCH_TRADE_VALUE = getDefineINT("TK_RESEARCH_TRADE_VALUE");
-	m_cache_TK_STEAMWORKS_MODIFIER = getDefineINT("TK_STEAMWORKS_MODIFIER");
-	m_cache_TRADE_POINTS_FOR_ROUTE = getDefineINT("TRADE_POINTS_FOR_ROUTE");
-	m_cache_TRADE_ROUTE_SPICE = getDefineINT("TRADE_ROUTE_SPICE");
-	m_cache_TRADE_STIMULATES_RESEARCH_MIN_VALUE = getDefineINT("TRADE_STIMULATES_RESEARCH_MIN_VALUE");
-	m_cache_TRADE_STIMULATES_RESEARCH_PERCENT = getDefineINT("TRADE_STIMULATES_RESEARCH_PERCENT");
-	m_cache_TRADING_POINTS_MOD_PERCENT = getDefineINT("TRADING_POINTS_MOD_PERCENT");
-	m_cache_TREASURE_UNITCLASS = getDefineINT("TREASURE_UNITCLASS");
-	m_cache_TREASURE_UNITS_ONLY_SELECT_COASTAL = getDefineINT("TREASURE_UNITS_ONLY_SELECT_COASTAL");
-	m_cache_TURNS_TO_TRAIN = getDefineINT("TURNS_TO_TRAIN");
-	m_cache_UNITARMOR_LEATHER = getDefineINT("UNITARMOR_LEATHER");
-	m_cache_UNITARMOR_MAIL = getDefineINT("UNITARMOR_MAIL");
-	m_cache_UNITARMOR_PLATE = getDefineINT("UNITARMOR_PLATE");
-	m_cache_UNITARMOR_SCALE = getDefineINT("UNITARMOR_SCALE");
-	m_cache_UNITARMOR_SHIELD = getDefineINT("UNITARMOR_SHIELD");
-	m_cache_UNITCLASS_PIONEER = getDefineINT("UNITCLASS_PIONEER");
-	m_cache_UNITTACTIC_PARRY = getDefineINT("UNITTACTIC_PARRY");
-	m_cache_UNITWEAPON_BLUNT = getDefineINT("UNITWEAPON_BLUNT");
-	m_cache_UNIT_PRODUCTION_DECAY_PERCENT = getDefineINT("UNIT_PRODUCTION_DECAY_PERCENT");
-	m_cache_UNIT_PRODUCTION_DECAY_TIME = getDefineINT("UNIT_PRODUCTION_DECAY_TIME");
-	m_cache_UNIT_PRODUCTION_PERCENT = getDefineINT("UNIT_PRODUCTION_PERCENT");
-	m_cache_UNIT_UPGRADE_COST_PER_PRODUCTION = getDefineINT("UNIT_UPGRADE_COST_PER_PRODUCTION");
-	m_cache_UNIT_VISIBILITY_RANGE = getDefineINT("UNIT_VISIBILITY_RANGE");
-	m_cache_USE_MEDIEVAL_CALENDER = getDefineINT("USE_MEDIEVAL_CALENDER");
-	m_cache_VASSAL_CIVILIZATION = getDefineINT("VASSAL_CIVILIZATION");
-	m_cache_VASSAL_LEADER = getDefineINT("VASSAL_LEADER");
-	m_cache_WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT = getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT");
-	m_cache_WAR_SUCCESS_ATTACKING = getDefineINT("WAR_SUCCESS_ATTACKING");
-	m_cache_WAR_SUCCESS_CITY_CAPTURING = getDefineINT("WAR_SUCCESS_CITY_CAPTURING");
-	m_cache_WAR_SUCCESS_DEFENDING = getDefineINT("WAR_SUCCESS_DEFENDING");
-	m_cache_WAR_SUCCESS_UNIT_CAPTURING = getDefineINT("WAR_SUCCESS_UNIT_CAPTURING");
-	m_cache_WATER_IMPROVEMENT = getDefineINT("WATER_IMPROVEMENT");
-	m_cache_WATER_UNIT_FACING_DIRECTION = getDefineINT("WATER_UNIT_FACING_DIRECTION");
-	m_cache_WEEKS_PER_MONTHS = getDefineINT("WEEKS_PER_MONTHS");
-	m_cache_WILD_ANIMAL_ATTACK_WEIGHT = getDefineINT("WILD_ANIMAL_ATTACK_WEIGHT");
-	m_cache_WILD_ANIMAL_LAND_BONUS_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_BONUS_NATIVE_WEIGHT");
-	m_cache_WILD_ANIMAL_LAND_FEATURE_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_FEATURE_NATIVE_WEIGHT");
-	m_cache_WILD_ANIMAL_LAND_PATROL_BASE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_PATROL_BASE_WEIGHT");
-	m_cache_WILD_ANIMAL_LAND_TERRAIN_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_TERRAIN_NATIVE_WEIGHT");
-	m_cache_WILD_ANIMAL_LAND_UNIT_VARIATION_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_UNIT_VARIATION_WEIGHT");
-	m_cache_WILD_ANIMAL_SEA_BONUS_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_BONUS_NATIVE_WEIGHT");
-	m_cache_WILD_ANIMAL_SEA_FEATURE_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_FEATURE_NATIVE_WEIGHT");
-	m_cache_WILD_ANIMAL_SEA_PATROL_BASE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_PATROL_BASE_WEIGHT");
-	m_cache_WILD_ANIMAL_SEA_TERRAIN_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_TERRAIN_NATIVE_WEIGHT");
-	m_cache_WILD_ANIMAL_SEA_UNIT_VARIATION_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_UNIT_VARIATION_WEIGHT");
-}
-// cache XML - end - Nightinggale
+//
+// globals.cpp
+// Author -	Mustafa Thamer
+//
+#include "CvGameCoreDLL.h"
+#include "CvGlobals.h"
+#include "CvRandom.h"
+#include "CvGameAI.h"
+#include "CvDLLInterfaceIFaceBase.h"
+#include "CvMap.h"
+#include "CvPlayerAI.h"
+#include "CvTeamAI.h"
+#include "CvInfos.h"
+#include "CvDLLUtilityIFaceBase.h"
+#include "CvArtFileMgr.h"
+#include "CvDLLXMLIFaceBase.h"
+#include "CvPlayerAI.h"
+#include "CvInfoWater.h"
+#include "CvGameTextMgr.h"
+#include "FProfiler.h"
+#include "FVariableSystem.h"
+#include "CvInitCore.h"
+
+#define COPY(dst, src, typeName) \
+	{ \
+		int iNum = sizeof(src)/sizeof(typeName); \
+		dst = new typeName[iNum]; \
+		for (int i =0;i<iNum;i++) \
+			dst[i] = src[i]; \
+	}
+
+//////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////
+
+CvGlobals gGlobals;
+
+//
+// CONSTRUCTOR
+//
+CvGlobals::CvGlobals() :
+m_bGraphicsInitialized(false),
+m_bLogging(false),
+m_bRandLogging(false),
+m_bOverwriteLogs(false),
+m_bSynchLogging(false),
+m_pkMainMenu(NULL),
+m_iNewPlayers(0),
+m_bZoomOut(false),
+m_bZoomIn(false),
+m_bLoadGameFromFile(false),
+m_pFMPMgr(NULL),
+m_asyncRand(NULL),
+m_interface(NULL),
+m_game(NULL),
+m_messageQueue(NULL),
+m_hotJoinMsgQueue(NULL),
+m_messageControl(NULL),
+m_messageCodes(NULL),
+m_dropMgr(NULL),
+m_portal(NULL),
+m_setupData(NULL),
+m_initCore(NULL),
+m_statsReporter(NULL),
+m_map(NULL),
+m_diplomacyScreen(NULL),
+m_mpDiplomacyScreen(NULL),
+m_pathFinder(NULL),
+m_interfacePathFinder(NULL),
+m_stepFinder(NULL),
+m_routeFinder(NULL),
+m_borderFinder(NULL),
+m_areaFinder(NULL),
+m_pDLL(NULL),
+m_aiPlotDirectionX(NULL),
+m_aiPlotDirectionY(NULL),
+m_aiPlotCardinalDirectionX(NULL),
+m_aiPlotCardinalDirectionY(NULL),
+m_aiCityPlotX(NULL),
+m_aiCityPlotY(NULL),
+m_aiCityPlotPriority(NULL),
+m_aeTurnLeftDirection(NULL),
+m_aeTurnRightDirection(NULL),
+m_VarSystem(NULL),
+m_iMOVE_DENOMINATOR(0),
+m_iFOOD_CONSUMPTION_PER_POPULATION(0),
+m_iMAX_HIT_POINTS(0),
+m_iHILLS_EXTRA_DEFENSE(0),
+m_iRIVER_ATTACK_MODIFIER(0),
+m_iAMPHIB_ATTACK_MODIFIER(0),
+m_iHILLS_EXTRA_MOVEMENT(0),
+m_iPEAK_EXTRA_MOVEMENT(0),
+m_iMAX_PLOT_LIST_ROWS(0),
+m_iUNIT_MULTISELECT_MAX(0),
+m_iEVENT_MESSAGE_TIME(0),
+m_iROUTE_FEATURE_GROWTH_MODIFIER(0),
+m_iFEATURE_GROWTH_MODIFIER(0),
+m_iMIN_CITY_RANGE(0),
+m_iCITY_MAX_NUM_BUILDINGS(0),
+m_iLAKE_MAX_AREA_SIZE(0),
+m_iMIN_WATER_SIZE_FOR_OCEAN(0),
+m_iFORTIFY_MODIFIER_PER_TURN(0),
+m_iMAX_CITY_DEFENSE_DAMAGE(0),
+m_iPEAK_SEE_THROUGH_CHANGE(0),
+m_iHILLS_SEE_THROUGH_CHANGE(0),
+m_iSEAWATER_SEE_FROM_CHANGE(0),
+m_iPEAK_SEE_FROM_CHANGE(0),
+m_iHILLS_SEE_FROM_CHANGE(0),
+m_iMAX_REBEL_YIELD_MODIFIER(0),
+m_fCAMERA_MIN_YAW(0),
+m_fCAMERA_MAX_YAW(0),
+m_fCAMERA_FAR_CLIP_Z_HEIGHT(0),
+m_fCAMERA_MAX_TRAVEL_DISTANCE(0),
+m_fCAMERA_START_DISTANCE(0),
+m_fPLOT_SIZE(0),
+m_fCAMERA_SPECIAL_PITCH(0),
+m_fCAMERA_MAX_TURN_OFFSET(0),
+m_fCAMERA_MIN_DISTANCE(0),
+m_fCAMERA_UPPER_PITCH(0),
+m_fCAMERA_LOWER_PITCH(0),
+m_fFIELD_OF_VIEW(0),
+m_fUNIT_MULTISELECT_DISTANCE(0),
+m_iUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK(0),
+m_iUSE_CANNOT_DO_CIVIC_CALLBACK(0),
+m_iUSE_CAN_DO_CIVIC_CALLBACK(0),
+m_iUSE_CANNOT_CONSTRUCT_CALLBACK(0),
+m_iUSE_CAN_CONSTRUCT_CALLBACK(0),
+m_iUSE_CAN_DECLARE_WAR_CALLBACK(0),
+m_iUSE_GET_UNIT_COST_MOD_CALLBACK(0),
+m_iUSE_GET_CITY_FOUND_VALUE_CALLBACK(0),
+m_iUSE_CANNOT_HANDLE_ACTION_CALLBACK(0),
+m_iUSE_CAN_BUILD_CALLBACK(0),
+m_iUSE_CANNOT_TRAIN_CALLBACK(0),
+m_iUSE_CAN_TRAIN_CALLBACK(0),
+m_iUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK(0),
+m_iUSE_FINISH_TEXT_CALLBACK(0),
+m_iUSE_ON_UNIT_SET_XY_CALLBACK(0),
+m_iUSE_ON_UNIT_SELECTED_CALLBACK(0),
+m_iUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK(0),
+m_iUSE_ON_UPDATE_CALLBACK(0),
+m_iUSE_ON_UNIT_CREATED_CALLBACK(0),
+m_iUSE_ON_UNIT_LOST_CALLBACK(0),
+
+// cache XML - start - Nightinggale
+m_cache_ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES(0),
+m_cache_ADVANCED_START_CITY_COST(0),
+m_cache_ADVANCED_START_CITY_COST_INCREASE(0),
+m_cache_ADVANCED_START_CITY_PLACEMENT_MAX_RANGE(0),
+m_cache_ADVANCED_START_CULTURE_COST(0),
+m_cache_ADVANCED_START_MAX_UNITS_PER_CITY(0),
+m_cache_ADVANCED_START_POPULATION_COST(0),
+m_cache_ADVANCED_START_POPULATION_COST_INCREASE(0),
+m_cache_ADVANCED_START_SIGHT_RANGE(0),
+m_cache_ADVANCED_START_VISIBILITY_COST(0),
+m_cache_ADVANCED_START_VISIBILITY_COST_INCREASE(0),
+m_cache_AI_ADVANCED_TECH_START(0),
+m_cache_AI_CAN_DISBAND_UNITS(0),
+m_cache_AI_CHEAT_AUTO_BUY(0),
+m_cache_AI_CHEAT_NEEDED_DEFENDERS(0),
+m_cache_AI_CHEAT_SPICE(0),
+m_cache_AI_CHEAT_SPICE_BUY(0),
+m_cache_AI_CHEAT_SPICE_MULTIPLE(0),
+m_cache_AI_FAVORED_TERRAIN_MOD(0),
+m_cache_AI_HANDICAP_CASTLE(0),
+m_cache_AI_HANDICAP_MOTTE(0),
+m_cache_AI_MILITARY_PROFESSION_HACK(0),
+m_cache_AI_WAREHOUSE_MOD(0),
+m_cache_ALLIANCE_CULTURE_PERCENT_DENIAL(0),
+m_cache_ALLIANCE_PACT_PEACE_DENIAL(0),
+m_cache_ANIMAL_BANDITS_GUARD_GOODY_TIMER(0),
+m_cache_AUTORESEARCH_ALL(0),
+m_cache_BANQUET_YIELD_AMOUNT(0),
+m_cache_BARBARIAN_CIVILIZATION(0),
+m_cache_BARBARIAN_LEADER(0),
+m_cache_BASE_CITY_GROWTH_THRESHOLD(0),
+m_cache_BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD(0),
+m_cache_BASE_OCCUPATION_TURNS(0),
+m_cache_BASE_UNIT_UPGRADE_COST(0),
+m_cache_BUILDINGCLASS_TRAVEL_TO_FAIR(0),
+m_cache_BUILDING_PRODUCTION_DECAY_PERCENT(0),
+m_cache_BUILDING_PRODUCTION_DECAY_TIME(0),
+m_cache_BUILDING_PRODUCTION_PERCENT(0),
+m_cache_BUY_PLOT_BASE_CULTURE_COST(0),
+m_cache_BUY_PLOT_CULTURE_RANGE(0),
+m_cache_BUY_PLOT_MIN_CULTURE(0),
+m_cache_BUY_PLOT_OWNED_COST_MODIFIER(0),
+m_cache_BUY_PLOT_SELLER_INCOME_PERCENT(0),
+m_cache_CALENDER_YEAR_FIRST_CHANGE_TURN(0),
+m_cache_CALENDER_YEAR_FIRST_MULTIPLIER(0),
+m_cache_CALENDER_YEAR_SECOND_CHANGE_TURN(0),
+m_cache_CALENDER_YEAR_SECOND_MULTIPLIER(0),
+m_cache_CALENDER_YEAR_THIRD_MULTIPLIER(0),
+m_cache_CAPITAL_BUILDINGCLASS(0),
+m_cache_CAPTURED_CARGO_RANDOM_AMOUNT(0),
+m_cache_CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT(0),
+m_cache_CASTLES_TO_VILLAGES_RATIO(0),
+m_cache_CHANCE_TO_CAPTURE_CRIMINALS(0),
+m_cache_CHEAT_TRAVEL_ALL(0),
+m_cache_CITY_DEFENSE_DAMAGE_HEAL_RATE(0),
+m_cache_CITY_FREE_CULTURE_GROWTH_FACTOR(0),
+m_cache_CITY_GROWTH_MULTIPLIER(0),
+m_cache_CITY_HEAL_RATE(0),
+m_cache_CITY_PILGRAM_RANDOM(0),
+m_cache_CITY_SCREEN_FOG_ENABLED(0),
+m_cache_CITY_YIELD_CAPACITY(0),
+m_cache_CITY_YIELD_DECAY_PERCENT(0),
+m_cache_CIVICOPTION_INVENTIONS(0),
+m_cache_COLONIAL_FORCED_PEACE_TURNS(0),
+m_cache_COMBAT_DAMAGE(0),
+m_cache_COMBAT_DIE_SIDES(0),
+m_cache_COMBAT_EXPERIENCE_IN_BORDERS_PERCENT(0),
+m_cache_CONSUME_EQUIPMENT_ON_FOUND(0),
+m_cache_CONTACT_YIELD_GIFT_ENCOMEIDA_TIMER(0),
+m_cache_CONTACT_YIELD_GIFT_TECH(0),
+m_cache_CULTURE_YIELD(0),
+m_cache_DEAL_TRADE_RELATIONS_POINTS(0),
+m_cache_DEEP_WATER_TERRAIN(0),
+m_cache_DEFAULT_BUILD_CASTLE(0),
+m_cache_DEFAULT_BUILD_MOTTE_AND_BAILEY(0),
+m_cache_DEFAULT_CENSURETYPE_ANATHEMA(0),
+m_cache_DEFAULT_CENSURETYPE_ANATHEMA_COUNT(0),
+m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION(0),
+m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION_COUNT(0),
+m_cache_DEFAULT_CENSURETYPE_INTERDICT(0),
+m_cache_DEFAULT_CENSURETYPE_INTERDICT_COUNT(0),
+m_cache_DEFAULT_COMBAT_FOR_TRAINING(0),
+m_cache_DEFAULT_DAWN_POPULATION_UNIT(0),
+m_cache_DEFAULT_FUEDALISM_TECH(0),
+m_cache_DEFAULT_GRAIN_GROWTH_UNIT_CLASS(0),
+m_cache_DEFAULT_HUNTSMAN_PROFESSION(0),
+m_cache_DEFAULT_INVENTOR_CLASS(0),
+m_cache_DEFAULT_KNIGHT_PROFESSION_PROMOTION(0),
+m_cache_DEFAULT_KNIGHT_PROMOTION(0),
+m_cache_DEFAULT_MARAUDER_CLASS(0),
+m_cache_DEFAULT_MARUADER_SEA_PROFESSION(0),
+m_cache_DEFAULT_NOBLEMAN_CLASS(0),
+m_cache_DEFAULT_NOBLE_GROWTH_UNIT_CLASS(0),
+m_cache_DEFAULT_PILGRAM_CLASS(0),
+m_cache_DEFAULT_POPULATION_UNIT(0),
+m_cache_DEFAULT_SHRINE_CLASS(0),
+m_cache_DEFAULT_SLAVE_CLASS(0),
+m_cache_DEFAULT_SPECIALBUILDING_COURTHOUSE(0),
+m_cache_DEFAULT_TEST_DEFINE(0),
+m_cache_DEFAULT_TRAINED_PROMOTION(0),
+m_cache_DEFAULT_TREASURE_YIELD(0),
+m_cache_DEFAULT_UNTRAINED_PROMOTION(0),
+m_cache_DEFAULT_VIKING_ERA(0),
+m_cache_DEFAULT_YIELD_ARMOR_TYPE(0),
+m_cache_DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT(0),
+m_cache_DIPLOMACY_VALUE_REMAINDER(0),
+m_cache_DOCKS_NEXT_UNITS(0),
+m_cache_EDUCATION_BASE_TUITION(0),
+m_cache_EDUCATION_THRESHOLD(0),
+m_cache_EDUCATION_THRESHOLD_INCREASE(0),
+m_cache_ENABLE_ALLIANCE_TRADING(0),
+m_cache_ENABLE_DEFENSIVE_PACT_TRADING(0),
+m_cache_ENABLE_GOLD_TRADING(0),
+m_cache_ENABLE_MAP_TRADING(0),
+m_cache_ENABLE_OPEN_BORDERS(0),
+m_cache_END_GAME_DISPLAY_WARNING(0),
+m_cache_ENEMY_HEAL_RATE(0),
+m_cache_ESTABLISH_TRADEPOST_COST(0),
+m_cache_EUROPE_EAST(0),
+m_cache_EUROPE_MARKET_CORRELATION_PERCENT(0),
+m_cache_EVENT_PROBABILITY_ROLL_SIDES(0),
+m_cache_EXPERIENCE_FROM_WITHDRAWL(0),
+m_cache_EXTRA_YIELD(0),
+m_cache_FATHER_COST_EXTRA_TEAM_MEMBER_MODIFIER(0),
+m_cache_FATHER_POINT_REAL_TRADE(0),
+m_cache_FEATURE_PRODUCTION_YIELD_MAX_DISTANCE(0),
+m_cache_FIRST_EVENT_DELAY_TURNS(0),
+m_cache_FOUND_MONASTERY_NUMBER(0),
+m_cache_FOUND_MOTTE_AND_BAILEY_NUMBER(0),
+m_cache_FOUND_OUTPOST_NUMBER(0),
+m_cache_FOUND_VILLAGE_NUMBER(0),
+m_cache_FREE_CITY_ADJACENT_CULTURE(0),
+m_cache_FREE_CITY_CULTURE(0),
+m_cache_FREE_PEASANT_CIVIC(0),
+m_cache_FRIENDLY_HEAL_RATE(0),
+m_cache_GREAT_GENERALS_THRESHOLD(0),
+m_cache_GREAT_GENERALS_THRESHOLD_INCREASE(0),
+m_cache_GREAT_GENERALS_THRESHOLD_INCREASE_TEAM(0),
+m_cache_HIRE_GUARD_COST(0),
+m_cache_HIRE_GUARD_PROMOTION(0),
+m_cache_IMMIGRATION_MAX_CITY_DISTANCE(0),
+m_cache_IMMIGRATION_THRESHOLD(0),
+m_cache_IMMIGRATION_THRESHOLD_INCREASE(0),
+m_cache_IMMIGRATION_TRAVEL_MOD(0),
+m_cache_INDUSTRIAL_VICTORY_SINGLE_YIELD(0),
+m_cache_INITIAL_AI_CITY_PRODUCTION(0),
+m_cache_INITIAL_CITY_POPULATION(0),
+m_cache_INITIAL_CITY_ROUTE_TYPE(0),
+m_cache_JUNGLE_FEATURE(0),
+m_cache_KING_BUY_UNIT_PRICE_MODIFIER(0),
+m_cache_KING_INITIAL_UNIT_INCREASE(0),
+m_cache_KING_TRANSPORT_TREASURE_COMISSION(0),
+m_cache_KNIGHT_RANSOM_MOD(0),
+m_cache_LAKE_PLOT_RAND(0),
+m_cache_LAND_IMPROVEMENT(0),
+m_cache_LAND_TERRAIN(0),
+m_cache_MARAUDERS_DAYSOUT_RANDOM(0),
+m_cache_MARAUDERS_TOWER_RANGE(0),
+m_cache_MARAUDER_CRUMBS_EVENT(0),
+m_cache_MARAUDER_EVENT_DEFAULT_TURNS(0),
+m_cache_MAX_CITY_POPULATION_COMMUNE(0),
+m_cache_MAX_CITY_POPULATION_VILLAGE(0),
+m_cache_MAX_EXPERIENCE_AFTER_UPGRADE(0),
+m_cache_MAX_EXPERIENCE_PER_COMBAT(0),
+m_cache_MAX_FORTIFY_TURNS(0),
+m_cache_MAX_INSULT_MODIFIER(0),
+m_cache_MAX_LEVEL_FROM_ANIMAL_XP(0),
+m_cache_MAX_MARAUDERS(0),
+m_cache_MAX_NUM_LANGUAGES(0),
+m_cache_MAX_PLOT_LIST_SIZE(0),
+m_cache_MAX_REBEL_COMBAT_MULTIPLER(0),
+m_cache_MAX_TRAINED_EXPERIENCE(0),
+m_cache_MAX_WITHDRAWAL_PROBABILITY(0),
+m_cache_MEDIEVAL_CENSURE(0),
+m_cache_MEDIEVAL_TRADE_TECH(0),
+m_cache_MINIMAP_RENDER_SIZE(0),
+m_cache_MIN_ANIMAL_STARTING_DISTANCE(0),
+m_cache_MIN_CITY_YIELD_DECAY(0),
+m_cache_MIN_CIV_STARTING_DISTANCE(0),
+m_cache_MIN_EXPERIENCE_PER_COMBAT(0),
+m_cache_MIN_TIMER_UNIT_DOUBLE_MOVES(0),
+m_cache_MIN_WATER_SIZE_FOR_OCEAN(0),
+m_cache_MISSIONARY_RATE_EFFECT_ON_SUCCESS(0),
+m_cache_MISSIONARY_THRESHOLD(0),
+m_cache_MISSIONARY_THRESHOLD_INCREASE(0),
+m_cache_MONASTERIES_TO_VILLAGES_RATIO(0),
+m_cache_NATIVE_AUTO_SELL_PERCENT(0),
+m_cache_NATIVE_GOODS_RAID_PERCENT(0),
+m_cache_NATIVE_GROWTH_THRESHOLD_MULTIPLIER(0),
+m_cache_NATIVE_HORSES_FOR_SALE(0),
+m_cache_NATIVE_HORSES_FOR_SALE_PERCENT(0),
+m_cache_NATIVE_TEACH_THRESHOLD_INCREASE(0),
+m_cache_NATIVE_TECH(0),
+m_cache_NATIVE_TRADING_TRADEPOST(0),
+m_cache_NEUTRAL_HEAL_RATE(0),
+m_cache_NEW_CITY_BUILDING_VALUE_MODIFIER(0),
+m_cache_NEW_HURRY_MODIFIER(0),
+m_cache_NOBLE_FIELD_LABOR_PENALTY(0),
+m_cache_NO_BAD_GOODIES_EXPERIENCE_PERCENT(0),
+m_cache_NO_BAD_GOODIES_GOLD_PERCENT(0),
+m_cache_NO_CITY_SHORTAGE_MESSAGES(0),
+m_cache_NO_STARTING_PLOTS_IN_JUNGLE(0),
+m_cache_OCCUPATION_CULTURE_PERCENT_THRESHOLD(0),
+m_cache_OCCUPATION_TURNS_POPULATION_PERCENT(0),
+m_cache_OWNERSHIP_SCORE_DURATION_THRESHOLD(0),
+m_cache_OWN_TEAM_STARTING_MODIFIER(0),
+m_cache_PEACE_TREATY_LENGTH(0),
+m_cache_PERCENT_TAX_ON_AUTOSELL_GOODS(0),
+m_cache_PILGRAM_OFFER_GOLD(0),
+m_cache_PILGRAM_OFFER_GOLD_DISTANCE_MOD(0),
+m_cache_PLAYER_ALWAYS_RAZES_CITIES(0),
+m_cache_PLOTS_PER_RIVER_EDGE(0),
+m_cache_PLOT_VISIBILITY_RANGE(0),
+m_cache_PROFESSION_COAL_BURNER(0),
+m_cache_PROFESSION_INVENTOR(0),
+m_cache_PROLIFIC_INVENTOR_THRESHOLD_INCREASE(0),
+m_cache_PROMOTION_BUILD_HOME(0),
+m_cache_RANDOM_TURNS_LOST_AT_SEA(0),
+m_cache_RAZING_CULTURAL_PERCENT_THRESHOLD(0),
+m_cache_REBEL_PERCENT_FOR_REVOLUTION(0),
+m_cache_REBEL_SENTIMENT_BELLS_FACTOR(0),
+m_cache_REBEL_SENTIMENT_TURN_WEIGHT(0),
+m_cache_REVOLUTION_EUROPE_UNIT_SHIP_MODIFIER(0),
+m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD(0),
+m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD_INCREASE(0),
+m_cache_RIVAL_TEAM_STARTING_MODIFIER(0),
+m_cache_RIVER_SOURCE_MIN_RIVER_RANGE(0),
+m_cache_RIVER_SOURCE_MIN_SEAWATER_RANGE(0),
+m_cache_RUINS_IMPROVEMENT(0),
+m_cache_SCORE_FATHER_FACTOR(0),
+m_cache_SCORE_LAND_FACTOR(0),
+m_cache_SCORE_POPULATION_FACTOR(0),
+m_cache_SCORE_TAX_FACTOR(0),
+m_cache_SETTLEMENT_TREASURE_YIELD(0),
+m_cache_SHALLOW_WATER_TERRAIN(0),
+m_cache_SLAVE_FOOD_CONSUMPTION_PER_POPULATION(0),
+m_cache_STANDARD_CALENDAR(0),
+m_cache_STANDARD_CLIMATE(0),
+m_cache_STANDARD_ERA(0),
+m_cache_STANDARD_GAMESPEED(0),
+m_cache_STANDARD_HANDICAP(0),
+m_cache_STANDARD_SEALEVEL(0),
+m_cache_STANDARD_TURNTIMER(0),
+m_cache_STARTING_DISTANCE_PERCENT(0),
+m_cache_START_YEAR(0),
+m_cache_STEAMWORKS_BUILDING(0),
+m_cache_STEAMWORKS_CLASS_TYPE(0),
+m_cache_TAX_INCREASE_CHANCE(0),
+m_cache_TAX_RATE_MAX_INCREASE(0),
+m_cache_TAX_TRADE_THRESHOLD(0),
+m_cache_TAX_TRADE_THRESHOLD_ATTITUDE_PERCENT(0),
+m_cache_TAX_TRADE_THRESHOLD_TAX_RATE_PERCENT(0),
+m_cache_TK_AI_RESEARCH_COST_MOD_PERCENT(0),
+m_cache_TK_HUMAN_RESEARCH_COST_MOD_PERCENT(0),
+m_cache_TK_IDEAS_CITY_VALUE(0),
+m_cache_TK_MAX_FORTS_PER_CITY(0),
+m_cache_TK_PIONEER_COAL_FURNACE_BONUS(0),
+m_cache_TK_PROLIFIC_INVENTOR_PROGRESS(0),
+m_cache_TK_PROLIFIC_INVENTOR_THRESHOLD(0),
+m_cache_TK_RESEARCH_PACT_IDEAS_THRESHOLD(0),
+m_cache_TK_RESEARCH_TRADE_VALUE(0),
+m_cache_TK_STEAMWORKS_MODIFIER(0),
+m_cache_TRADE_POINTS_FOR_ROUTE(0),
+m_cache_TRADE_ROUTE_SPICE(0),
+m_cache_TRADE_STIMULATES_RESEARCH_MIN_VALUE(0),
+m_cache_TRADE_STIMULATES_RESEARCH_PERCENT(0),
+m_cache_TRADING_POINTS_MOD_PERCENT(0),
+m_cache_TREASURE_UNITCLASS(0),
+m_cache_TREASURE_UNITS_ONLY_SELECT_COASTAL(0),
+m_cache_TURNS_TO_TRAIN(0),
+m_cache_UNITARMOR_LEATHER(0),
+m_cache_UNITARMOR_MAIL(0),
+m_cache_UNITARMOR_PLATE(0),
+m_cache_UNITARMOR_SCALE(0),
+m_cache_UNITARMOR_SHIELD(0),
+m_cache_UNITCLASS_PIONEER(0),
+m_cache_UNITTACTIC_PARRY(0),
+m_cache_UNITWEAPON_BLUNT(0),
+m_cache_UNIT_PRODUCTION_DECAY_PERCENT(0),
+m_cache_UNIT_PRODUCTION_DECAY_TIME(0),
+m_cache_UNIT_PRODUCTION_PERCENT(0),
+m_cache_UNIT_UPGRADE_COST_PER_PRODUCTION(0),
+m_cache_UNIT_VISIBILITY_RANGE(0),
+m_cache_USE_MEDIEVAL_CALENDER(0),
+m_cache_VASSAL_CIVILIZATION(0),
+m_cache_VASSAL_LEADER(0),
+m_cache_WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT(0),
+m_cache_WAR_SUCCESS_ATTACKING(0),
+m_cache_WAR_SUCCESS_CITY_CAPTURING(0),
+m_cache_WAR_SUCCESS_DEFENDING(0),
+m_cache_WAR_SUCCESS_UNIT_CAPTURING(0),
+m_cache_WATER_IMPROVEMENT(0),
+m_cache_WATER_UNIT_FACING_DIRECTION(0),
+m_cache_WEEKS_PER_MONTHS(0),
+m_cache_WILD_ANIMAL_ATTACK_WEIGHT(0),
+m_cache_WILD_ANIMAL_LAND_BONUS_NATIVE_WEIGHT(0),
+m_cache_WILD_ANIMAL_LAND_FEATURE_NATIVE_WEIGHT(0),
+m_cache_WILD_ANIMAL_LAND_PATROL_BASE_WEIGHT(0),
+m_cache_WILD_ANIMAL_LAND_TERRAIN_NATIVE_WEIGHT(0),
+m_cache_WILD_ANIMAL_LAND_UNIT_VARIATION_WEIGHT(0),
+m_cache_WILD_ANIMAL_SEA_BONUS_NATIVE_WEIGHT(0),
+m_cache_WILD_ANIMAL_SEA_FEATURE_NATIVE_WEIGHT(0),
+m_cache_WILD_ANIMAL_SEA_PATROL_BASE_WEIGHT(0),
+m_cache_WILD_ANIMAL_SEA_TERRAIN_NATIVE_WEIGHT(0),
+m_cache_WILD_ANIMAL_SEA_UNIT_VARIATION_WEIGHT(0),
+// cache XML - end - Nightinggale
+
+m_paHints(NULL),
+m_paMainMenus(NULL)
+{
+}
+
+CvGlobals::~CvGlobals()
+{
+}
+
+//
+// allocate
+//
+void CvGlobals::init()
+{
+	//
+	// These vars are used to initialize the globals.
+	//
+
+	int aiPlotDirectionX[NUM_DIRECTION_TYPES] =
+	{
+		0,	// DIRECTION_NORTH
+		1,	// DIRECTION_NORTHEAST
+		1,	// DIRECTION_EAST
+		1,	// DIRECTION_SOUTHEAST
+		0,	// DIRECTION_SOUTH
+		-1,	// DIRECTION_SOUTHWEST
+		-1,	// DIRECTION_WEST
+		-1,	// DIRECTION_NORTHWEST
+	};
+
+	int aiPlotDirectionY[NUM_DIRECTION_TYPES] =
+	{
+		1,	// DIRECTION_NORTH
+		1,	// DIRECTION_NORTHEAST
+		0,	// DIRECTION_EAST
+		-1,	// DIRECTION_SOUTHEAST
+		-1,	// DIRECTION_SOUTH
+		-1,	// DIRECTION_SOUTHWEST
+		0,	// DIRECTION_WEST
+		1,	// DIRECTION_NORTHWEST
+	};
+
+	int aiPlotCardinalDirectionX[NUM_CARDINALDIRECTION_TYPES] =
+	{
+		0,	// CARDINALDIRECTION_NORTH
+		1,	// CARDINALDIRECTION_EAST
+		0,	// CARDINALDIRECTION_SOUTH
+		-1,	// CARDINALDIRECTION_WEST
+	};
+
+	int aiPlotCardinalDirectionY[NUM_CARDINALDIRECTION_TYPES] =
+	{
+		1,	// CARDINALDIRECTION_NORTH
+		0,	// CARDINALDIRECTION_EAST
+		-1,	// CARDINALDIRECTION_SOUTH
+		0,	// CARDINALDIRECTION_WEST
+	};
+
+	int aiCityPlotX[NUM_CITY_PLOTS] =
+	{
+		0,
+		0, 1, 1, 1, 0,-1,-1,-1,
+//		0, 1, 2, 2, 2, 1, 0,-1,-2,-2,-2,-1,
+	};
+
+	int aiCityPlotY[NUM_CITY_PLOTS] =
+	{
+		0,
+		1, 1, 0,-1,-1,-1, 0, 1,
+//		2, 2, 1, 0,-1,-2,-2,-2,-1, 0, 1, 2,
+	};
+
+	int aiCityPlotPriority[NUM_CITY_PLOTS] =
+	{
+		0,
+		1, 2, 1, 2, 1, 2, 1, 2,
+//		3, 4, 4, 3, 4, 4, 3, 4, 4, 3, 4, 4,
+	};
+
+	int aaiXYCityPlot[CITY_PLOTS_DIAMETER][CITY_PLOTS_DIAMETER] =
+	{
+		{6, 7, 8,},
+
+		{5, 0, 1,},
+
+		{4, 3, 2,}
+	};
+
+	DirectionTypes aeTurnRightDirection[NUM_DIRECTION_TYPES] =
+	{
+		DIRECTION_NORTHEAST,	// DIRECTION_NORTH
+		DIRECTION_EAST,				// DIRECTION_NORTHEAST
+		DIRECTION_SOUTHEAST,	// DIRECTION_EAST
+		DIRECTION_SOUTH,			// DIRECTION_SOUTHEAST
+		DIRECTION_SOUTHWEST,	// DIRECTION_SOUTH
+		DIRECTION_WEST,				// DIRECTION_SOUTHWEST
+		DIRECTION_NORTHWEST,	// DIRECTION_WEST
+		DIRECTION_NORTH,			// DIRECTION_NORTHWEST
+	};
+
+	DirectionTypes aeTurnLeftDirection[NUM_DIRECTION_TYPES] =
+	{
+		DIRECTION_NORTHWEST,	// DIRECTION_NORTH
+		DIRECTION_NORTH,			// DIRECTION_NORTHEAST
+		DIRECTION_NORTHEAST,	// DIRECTION_EAST
+		DIRECTION_EAST,				// DIRECTION_SOUTHEAST
+		DIRECTION_SOUTHEAST,	// DIRECTION_SOUTH
+		DIRECTION_SOUTH,			// DIRECTION_SOUTHWEST
+		DIRECTION_SOUTHWEST,	// DIRECTION_WEST
+		DIRECTION_WEST,				// DIRECTION_NORTHWEST
+	};
+
+	DirectionTypes aaeXYDirection[DIRECTION_DIAMETER][DIRECTION_DIAMETER] =
+	{
+		DIRECTION_SOUTHWEST, DIRECTION_WEST,	DIRECTION_NORTHWEST,
+		DIRECTION_SOUTH,     NO_DIRECTION,    DIRECTION_NORTH,
+		DIRECTION_SOUTHEAST, DIRECTION_EAST,	DIRECTION_NORTHEAST,
+	};
+
+	FAssertMsg(gDLL != NULL, "Civ app needs to set gDLL");
+
+	m_VarSystem = new FVariableSystem;
+	m_asyncRand = new CvRandom;
+	m_initCore = new CvInitCore;
+	m_loadedInitCore = new CvInitCore;
+	m_iniInitCore = new CvInitCore;
+
+	gDLL->initGlobals();	// some globals need to be allocated outside the dll
+
+	m_game = new CvGameAI;
+	m_map = new CvMap;
+
+	CvPlayerAI::initStatics();
+	CvTeamAI::initStatics();
+
+	m_pt3Origin = NiPoint3(0.0f, 0.0f, 0.0f);
+
+	COPY(m_aiPlotDirectionX, aiPlotDirectionX, int);
+	COPY(m_aiPlotDirectionY, aiPlotDirectionY, int);
+	COPY(m_aiPlotCardinalDirectionX, aiPlotCardinalDirectionX, int);
+	COPY(m_aiPlotCardinalDirectionY, aiPlotCardinalDirectionY, int);
+	COPY(m_aiCityPlotX, aiCityPlotX, int);
+	COPY(m_aiCityPlotY, aiCityPlotY, int);
+	COPY(m_aiCityPlotPriority, aiCityPlotPriority, int);
+	COPY(m_aeTurnLeftDirection, aeTurnLeftDirection, DirectionTypes);
+	COPY(m_aeTurnRightDirection, aeTurnRightDirection, DirectionTypes);
+	memcpy(m_aaiXYCityPlot, aaiXYCityPlot, sizeof(m_aaiXYCityPlot));
+	memcpy(m_aaeXYDirection, aaeXYDirection,sizeof(m_aaeXYDirection));
+}
+
+//
+// free
+//
+void CvGlobals::uninit()
+{
+	//
+	// See also CvXMLLoadUtilityInit.cpp::CleanUpGlobalVariables()
+	//
+	SAFE_DELETE_ARRAY(m_aiPlotDirectionX);
+	SAFE_DELETE_ARRAY(m_aiPlotDirectionY);
+	SAFE_DELETE_ARRAY(m_aiPlotCardinalDirectionX);
+	SAFE_DELETE_ARRAY(m_aiPlotCardinalDirectionY);
+	SAFE_DELETE_ARRAY(m_aiCityPlotX);
+	SAFE_DELETE_ARRAY(m_aiCityPlotY);
+	SAFE_DELETE_ARRAY(m_aiCityPlotPriority);
+	SAFE_DELETE_ARRAY(m_aeTurnLeftDirection);
+	SAFE_DELETE_ARRAY(m_aeTurnRightDirection);
+
+	CvPlayerAI::freeStatics();
+	CvTeamAI::freeStatics();
+
+	SAFE_DELETE(m_game);
+	SAFE_DELETE(m_map);
+
+	SAFE_DELETE(m_asyncRand);
+	SAFE_DELETE(m_initCore);
+	SAFE_DELETE(m_loadedInitCore);
+	SAFE_DELETE(m_iniInitCore);
+	gDLL->uninitGlobals();	// free globals allocated outside the dll
+	SAFE_DELETE(m_VarSystem);
+
+	// already deleted outside of the dll, set to null for safety
+	m_messageQueue=NULL;
+	m_hotJoinMsgQueue=NULL;
+	m_messageControl=NULL;
+	m_setupData=NULL;
+	m_messageCodes=NULL;
+	m_dropMgr=NULL;
+	m_portal=NULL;
+	m_statsReporter=NULL;
+	m_interface=NULL;
+	m_diplomacyScreen=NULL;
+	m_mpDiplomacyScreen=NULL;
+	m_pathFinder=NULL;
+	m_interfacePathFinder=NULL;
+	m_stepFinder=NULL;
+	m_routeFinder=NULL;
+	m_borderFinder=NULL;
+	m_areaFinder=NULL;
+
+	deleteInfoArrays();
+}
+
+void CvGlobals::clearTypesMap()
+{
+	infoTypeFromStringReset();
+	if (m_VarSystem)
+	{
+		m_VarSystem->UnInit();
+	}
+}
+
+
+CvDiplomacyScreen* CvGlobals::getDiplomacyScreen()
+{
+	return m_diplomacyScreen;
+}
+
+CMPDiplomacyScreen* CvGlobals::getMPDiplomacyScreen()
+{
+	return m_mpDiplomacyScreen;
+}
+
+CvMessageCodeTranslator& CvGlobals::getMessageCodes()
+{
+	return *m_messageCodes;
+}
+
+FMPIManager*& CvGlobals::getFMPMgrPtr()
+{
+	return m_pFMPMgr;
+}
+
+CvPortal& CvGlobals::getPortal()
+{
+	return *m_portal;
+}
+
+CvSetupData& CvGlobals::getSetupData()
+{
+	return *m_setupData;
+}
+
+CvInitCore& CvGlobals::getInitCore()
+{
+	return *m_initCore;
+}
+
+CvInitCore& CvGlobals::getLoadedInitCore()
+{
+	return *m_loadedInitCore;
+}
+
+CvInitCore& CvGlobals::getIniInitCore()
+{
+	return *m_iniInitCore;
+}
+
+CvStatsReporter& CvGlobals::getStatsReporter()
+{
+	return *m_statsReporter;
+}
+
+CvStatsReporter* CvGlobals::getStatsReporterPtr()
+{
+	return m_statsReporter;
+}
+
+CvInterface& CvGlobals::getInterface()
+{
+	return *m_interface;
+}
+
+CvInterface* CvGlobals::getInterfacePtr()
+{
+	return m_interface;
+}
+
+CvRandom& CvGlobals::getASyncRand()
+{
+	return *m_asyncRand;
+}
+
+CMessageQueue& CvGlobals::getMessageQueue()
+{
+	return *m_messageQueue;
+}
+
+CMessageQueue& CvGlobals::getHotMessageQueue()
+{
+	return *m_hotJoinMsgQueue;
+}
+
+CMessageControl& CvGlobals::getMessageControl()
+{
+	return *m_messageControl;
+}
+
+CvDropMgr& CvGlobals::getDropMgr()
+{
+	return *m_dropMgr;
+}
+
+FAStar& CvGlobals::getPathFinder()
+{
+	return *m_pathFinder;
+}
+
+FAStar& CvGlobals::getInterfacePathFinder()
+{
+	return *m_interfacePathFinder;
+}
+
+FAStar& CvGlobals::getStepFinder()
+{
+	return *m_stepFinder;
+}
+
+FAStar& CvGlobals::getRouteFinder()
+{
+	return *m_routeFinder;
+}
+
+FAStar& CvGlobals::getBorderFinder()
+{
+	return *m_borderFinder;
+}
+
+FAStar& CvGlobals::getAreaFinder()
+{
+	return *m_areaFinder;
+}
+
+NiPoint3& CvGlobals::getPt3Origin()
+{
+	return m_pt3Origin;
+}
+
+std::vector<CvInterfaceModeInfo*>& CvGlobals::getInterfaceModeInfo()		// For Moose - XML Load Util and CvInfos
+{
+	return m_paInterfaceModeInfo;
+}
+
+CvInterfaceModeInfo& CvGlobals::getInterfaceModeInfo(InterfaceModeTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_INTERFACEMODE_TYPES);
+	return *(m_paInterfaceModeInfo[e]);
+}
+
+NiPoint3& CvGlobals::getPt3CameraDir()
+{
+	return m_pt3CameraDir;
+}
+
+bool& CvGlobals::getLogging()
+{
+	return m_bLogging;
+}
+
+bool& CvGlobals::getRandLogging()
+{
+	return m_bRandLogging;
+}
+
+bool& CvGlobals::getSynchLogging()
+{
+	return m_bSynchLogging;
+}
+
+bool& CvGlobals::overwriteLogs()
+{
+	return m_bOverwriteLogs;
+}
+
+int* CvGlobals::getPlotDirectionX()
+{
+	return m_aiPlotDirectionX;
+}
+
+int* CvGlobals::getPlotDirectionY()
+{
+	return m_aiPlotDirectionY;
+}
+
+int* CvGlobals::getPlotCardinalDirectionX()
+{
+	return m_aiPlotCardinalDirectionX;
+}
+
+int* CvGlobals::getPlotCardinalDirectionY()
+{
+	return m_aiPlotCardinalDirectionY;
+}
+
+int* CvGlobals::getCityPlotX()
+{
+	return m_aiCityPlotX;
+}
+
+int* CvGlobals::getCityPlotY()
+{
+	return m_aiCityPlotY;
+}
+
+int* CvGlobals::getCityPlotPriority()
+{
+	return m_aiCityPlotPriority;
+}
+
+int CvGlobals::getXYCityPlot(int i, int j)
+{
+	FAssertMsg(i < CITY_PLOTS_DIAMETER, "Index out of bounds");
+	FAssertMsg(i > -1, "Index out of bounds");
+	FAssertMsg(j < CITY_PLOTS_DIAMETER, "Index out of bounds");
+	FAssertMsg(j > -1, "Index out of bounds");
+	return m_aaiXYCityPlot[i][j];
+}
+
+DirectionTypes* CvGlobals::getTurnLeftDirection()
+{
+	return m_aeTurnLeftDirection;
+}
+
+DirectionTypes CvGlobals::getTurnLeftDirection(int i)
+{
+	FAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
+	FAssertMsg(i > -1, "Index out of bounds");
+	return m_aeTurnLeftDirection[i];
+}
+
+DirectionTypes* CvGlobals::getTurnRightDirection()
+{
+	return m_aeTurnRightDirection;
+}
+
+DirectionTypes CvGlobals::getTurnRightDirection(int i)
+{
+	FAssertMsg(i < NUM_DIRECTION_TYPES, "Index out of bounds");
+	FAssertMsg(i > -1, "Index out of bounds");
+	return m_aeTurnRightDirection[i];
+}
+
+DirectionTypes CvGlobals::getXYDirection(int i, int j)
+{
+	FAssertMsg(i < DIRECTION_DIAMETER, "Index out of bounds");
+	FAssertMsg(i > -1, "Index out of bounds");
+	FAssertMsg(j < DIRECTION_DIAMETER, "Index out of bounds");
+	FAssertMsg(j > -1, "Index out of bounds");
+	return m_aaeXYDirection[i][j];
+}
+
+int CvGlobals::getNumWorldInfos()
+{
+	return (int)m_paWorldInfo.size();
+}
+
+std::vector<CvWorldInfo*>& CvGlobals::getWorldInfo()
+{
+	return m_paWorldInfo;
+}
+
+CvWorldInfo& CvGlobals::getWorldInfo(WorldSizeTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumWorldInfos());
+	return *(m_paWorldInfo[e]);
+}
+
+/////////////////////////////////////////////
+// CLIMATE
+/////////////////////////////////////////////
+
+int CvGlobals::getNumClimateInfos()
+{
+	return (int)m_paClimateInfo.size();
+}
+
+std::vector<CvClimateInfo*>& CvGlobals::getClimateInfo()
+{
+	return m_paClimateInfo;
+}
+
+CvClimateInfo& CvGlobals::getClimateInfo(ClimateTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumClimateInfos());
+	return *(m_paClimateInfo[e]);
+}
+
+/////////////////////////////////////////////
+// SEALEVEL
+/////////////////////////////////////////////
+
+int CvGlobals::getNumSeaLevelInfos()
+{
+	return (int)m_paSeaLevelInfo.size();
+}
+
+std::vector<CvSeaLevelInfo*>& CvGlobals::getSeaLevelInfo()
+{
+	return m_paSeaLevelInfo;
+}
+
+CvSeaLevelInfo& CvGlobals::getSeaLevelInfo(SeaLevelTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumSeaLevelInfos());
+	return *(m_paSeaLevelInfo[e]);
+}
+
+/////////////////////////////////////////////
+// EUROPE
+/////////////////////////////////////////////
+
+int CvGlobals::getNumEuropeInfos()
+{
+	return (int)m_paEuropeInfo.size();
+}
+
+std::vector<CvEuropeInfo*>& CvGlobals::getEuropeInfo()
+{
+	return m_paEuropeInfo;
+}
+
+CvEuropeInfo& CvGlobals::getEuropeInfo(EuropeTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumEuropeInfos());
+	return *(m_paEuropeInfo[e]);
+}
+
+int CvGlobals::getNumHints()
+{
+	return (int)m_paHints.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getHints()
+{
+	return m_paHints;
+}
+
+CvInfoBase& CvGlobals::getHints(int i)
+{
+	return *(m_paHints[i]);
+}
+
+int CvGlobals::getNumMainMenus()
+{
+	return (int)m_paMainMenus.size();
+}
+
+std::vector<CvMainMenuInfo*>& CvGlobals::getMainMenus()
+{
+	return m_paMainMenus;
+}
+
+CvMainMenuInfo& CvGlobals::getMainMenus(int i)
+{
+	if (i >= getNumMainMenus())
+	{
+		return *(m_paMainMenus[0]);
+	}
+
+	return *(m_paMainMenus[i]);
+}
+
+int CvGlobals::getNumColorInfos()
+{
+	return (int)m_paColorInfo.size();
+}
+
+std::vector<CvColorInfo*>& CvGlobals::getColorInfo()
+{
+	return m_paColorInfo;
+}
+
+CvColorInfo& CvGlobals::getColorInfo(ColorTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumColorInfos());
+	return *(m_paColorInfo[e]);
+}
+
+
+int CvGlobals::getNumPlayerColorInfos()
+{
+	return (int)m_paPlayerColorInfo.size();
+}
+
+std::vector<CvPlayerColorInfo*>& CvGlobals::getPlayerColorInfo()
+{
+	return m_paPlayerColorInfo;
+}
+
+CvPlayerColorInfo& CvGlobals::getPlayerColorInfo(PlayerColorTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumPlayerColorInfos());
+	return *(m_paPlayerColorInfo[e]);
+}
+
+int CvGlobals::getNumRouteModelInfos()
+{
+	return (int)m_paRouteModelInfo.size();
+}
+
+std::vector<CvRouteModelInfo*>& CvGlobals::getRouteModelInfo()
+{
+	return m_paRouteModelInfo;
+}
+
+CvRouteModelInfo& CvGlobals::getRouteModelInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumRouteModelInfos());
+	return *(m_paRouteModelInfo[i]);
+}
+
+int CvGlobals::getNumRiverModelInfos()
+{
+	return (int)m_paRiverModelInfo.size();
+}
+
+std::vector<CvRiverModelInfo*>& CvGlobals::getRiverModelInfo()
+{
+	return m_paRiverModelInfo;
+}
+
+CvRiverModelInfo& CvGlobals::getRiverModelInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumRiverModelInfos());
+	return *(m_paRiverModelInfo[i]);
+}
+
+int CvGlobals::getNumWaterPlaneInfos()
+{
+	return (int)m_paWaterPlaneInfo.size();
+}
+
+std::vector<CvWaterPlaneInfo*>& CvGlobals::getWaterPlaneInfo()
+{
+	return m_paWaterPlaneInfo;
+}
+
+CvWaterPlaneInfo& CvGlobals::getWaterPlaneInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumWaterPlaneInfos());
+	return *(m_paWaterPlaneInfo[i]);
+}
+
+int CvGlobals::getNumTerrainPlaneInfos()
+{
+	return (int)m_paTerrainPlaneInfo.size();
+}
+
+std::vector<CvTerrainPlaneInfo*>& CvGlobals::getTerrainPlaneInfo()
+{
+	return m_paTerrainPlaneInfo;
+}
+
+CvTerrainPlaneInfo& CvGlobals::getTerrainPlaneInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumTerrainPlaneInfos());
+	return *(m_paTerrainPlaneInfo[i]);
+}
+
+int CvGlobals::getNumCameraOverlayInfos()
+{
+	return (int)m_paCameraOverlayInfo.size();
+}
+
+std::vector<CvCameraOverlayInfo*>& CvGlobals::getCameraOverlayInfo()
+{
+	return m_paCameraOverlayInfo;
+}
+
+CvCameraOverlayInfo& CvGlobals::getCameraOverlayInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumCameraOverlayInfos());
+	return *(m_paCameraOverlayInfo[i]);
+}
+
+int CvGlobals::getNumAnimationPathInfos()
+{
+	return (int)m_paAnimationPathInfo.size();
+}
+
+std::vector<CvAnimationPathInfo*>& CvGlobals::getAnimationPathInfo()
+{
+	return m_paAnimationPathInfo;
+}
+
+CvAnimationPathInfo& CvGlobals::getAnimationPathInfo(AnimationPathTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumAnimationPathInfos());
+	return *(m_paAnimationPathInfo[e]);
+}
+
+int CvGlobals::getNumAnimationCategoryInfos()
+{
+	return (int)m_paAnimationCategoryInfo.size();
+}
+
+std::vector<CvAnimationCategoryInfo*>& CvGlobals::getAnimationCategoryInfo()
+{
+	return m_paAnimationCategoryInfo;
+}
+
+CvAnimationCategoryInfo& CvGlobals::getAnimationCategoryInfo(AnimationCategoryTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumAnimationCategoryInfos());
+	return *(m_paAnimationCategoryInfo[e]);
+}
+
+int CvGlobals::getNumEntityEventInfos()
+{
+	return (int)m_paEntityEventInfo.size();
+}
+
+std::vector<CvEntityEventInfo*>& CvGlobals::getEntityEventInfo()
+{
+	return m_paEntityEventInfo;
+}
+
+CvEntityEventInfo& CvGlobals::getEntityEventInfo(EntityEventTypes e)
+{
+	FAssert( e > -1 );
+	FAssert( e < GC.getNumEntityEventInfos() );
+	return *(m_paEntityEventInfo[e]);
+}
+
+int CvGlobals::getNumEffectInfos()
+{
+	return (int)m_paEffectInfo.size();
+}
+
+std::vector<CvEffectInfo*>& CvGlobals::getEffectInfo()
+{
+	return m_paEffectInfo;
+}
+
+CvEffectInfo& CvGlobals::getEffectInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumEffectInfos());
+	return *(m_paEffectInfo[i]);
+}
+
+
+int CvGlobals::getNumAttachableInfos()
+{
+	return (int)m_paAttachableInfo.size();
+}
+
+std::vector<CvAttachableInfo*>& CvGlobals::getAttachableInfo()
+{
+	return m_paAttachableInfo;
+}
+
+CvAttachableInfo& CvGlobals::getAttachableInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumAttachableInfos());
+	return *(m_paAttachableInfo[i]);
+}
+
+int CvGlobals::getNumUnitFormationInfos()
+{
+	return (int)m_paUnitFormationInfo.size();
+}
+
+std::vector<CvUnitFormationInfo*>& CvGlobals::getUnitFormationInfo()		// For Moose - CvUnitEntity
+{
+	return m_paUnitFormationInfo;
+}
+
+CvUnitFormationInfo& CvGlobals::getUnitFormationInfo(int i)
+{
+	FAssert(i > -1);
+	FAssert(i < GC.getNumUnitFormationInfos());
+	return *(m_paUnitFormationInfo[i]);
+}
+
+// TEXT
+int CvGlobals::getNumGameTextXML()
+{
+	return (int)m_paGameTextXML.size();
+}
+
+std::vector<CvGameText*>& CvGlobals::getGameTextXML()
+{
+	return m_paGameTextXML;
+}
+
+// Landscape INFOS
+int CvGlobals::getNumLandscapeInfos()
+{
+	return (int)m_paLandscapeInfo.size();
+}
+
+std::vector<CvLandscapeInfo*>& CvGlobals::getLandscapeInfo()
+{
+	return m_paLandscapeInfo;
+}
+
+CvLandscapeInfo& CvGlobals::getLandscapeInfo(int iIndex)
+{
+	FAssert(iIndex > -1);
+	FAssert(iIndex < GC.getNumLandscapeInfos());
+	return *(m_paLandscapeInfo[iIndex]);
+}
+
+int CvGlobals::getActiveLandscapeID()
+{
+	return m_iActiveLandscapeID;
+}
+
+void CvGlobals::setActiveLandscapeID(int iLandscapeID)
+{
+	m_iActiveLandscapeID = iLandscapeID;
+}
+
+
+int CvGlobals::getNumTerrainInfos()
+{
+	return (int)m_paTerrainInfo.size();
+}
+
+std::vector<CvTerrainInfo*>& CvGlobals::getTerrainInfo()		// For Moose - XML Load Util, CvInfos, CvTerrainTypeWBPalette
+{
+	return m_paTerrainInfo;
+}
+
+CvTerrainInfo& CvGlobals::getTerrainInfo(TerrainTypes eTerrainNum)
+{
+	FAssert(eTerrainNum > -1);
+	FAssert(eTerrainNum < (int)m_paTerrainInfo.size());
+	return *(m_paTerrainInfo[eTerrainNum]);
+}
+
+int CvGlobals::getNumBonusInfos()
+{
+	return (int)m_paBonusInfo.size();
+}
+
+std::vector<CvBonusInfo*>& CvGlobals::getBonusInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paBonusInfo;
+}
+
+CvBonusInfo& CvGlobals::getBonusInfo(BonusTypes eBonusNum)
+{
+	FAssert(eBonusNum > -1);
+	FAssert(eBonusNum < (int)m_paBonusInfo.size());
+	return *(m_paBonusInfo[eBonusNum]);
+}
+
+int CvGlobals::getNumFeatureInfos()
+{
+	return (int)m_paFeatureInfo.size();
+}
+
+std::vector<CvFeatureInfo*>& CvGlobals::getFeatureInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paFeatureInfo;
+}
+
+CvFeatureInfo& CvGlobals::getFeatureInfo(FeatureTypes eFeatureNum)
+{
+	FAssert(eFeatureNum > -1);
+	FAssert(eFeatureNum < (int)m_paFeatureInfo.size());
+	return *(m_paFeatureInfo[eFeatureNum]);
+}
+
+int CvGlobals::getNumCivilizationInfos()
+{
+	return (int)m_paCivilizationInfo.size();
+}
+
+std::vector<CvCivilizationInfo*>& CvGlobals::getCivilizationInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paCivilizationInfo;
+}
+
+CvCivilizationInfo& CvGlobals::getCivilizationInfo(CivilizationTypes eCivilizationNum)
+{
+	FAssert(eCivilizationNum > -1);
+	FAssert(eCivilizationNum < (int)m_paCivilizationInfo.size());
+	return *(m_paCivilizationInfo[eCivilizationNum]);
+}
+
+
+int CvGlobals::getNumLeaderHeadInfos()
+{
+	return (int)m_paLeaderHeadInfo.size();
+}
+
+std::vector<CvLeaderHeadInfo*>& CvGlobals::getLeaderHeadInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paLeaderHeadInfo;
+}
+
+CvLeaderHeadInfo& CvGlobals::getLeaderHeadInfo(LeaderHeadTypes eLeaderHeadNum)
+{
+	FAssert(eLeaderHeadNum > -1);
+	FAssert(eLeaderHeadNum < GC.getNumLeaderHeadInfos());
+	return *(m_paLeaderHeadInfo[eLeaderHeadNum]);
+}
+
+
+int CvGlobals::getNumTraitInfos()
+{
+	return (int)m_paTraitInfo.size();
+}
+
+std::vector<CvTraitInfo*>& CvGlobals::getTraitInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paTraitInfo;
+}
+
+CvTraitInfo& CvGlobals::getTraitInfo(TraitTypes eTraitNum)
+{
+	FAssert(eTraitNum > -1);
+	FAssert(eTraitNum < GC.getNumTraitInfos());
+	return *(m_paTraitInfo[eTraitNum]);
+}
+
+
+int CvGlobals::getNumCursorInfos()
+{
+	return (int)m_paCursorInfo.size();
+}
+
+std::vector<CvCursorInfo*>& CvGlobals::getCursorInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paCursorInfo;
+}
+
+CvCursorInfo& CvGlobals::getCursorInfo(CursorTypes eCursorNum)
+{
+	FAssert(eCursorNum > -1);
+	FAssert(eCursorNum < GC.getNumCursorInfos());
+	return *(m_paCursorInfo[eCursorNum]);
+}
+
+int CvGlobals::getNumSlideShowInfos()
+{
+	return (int)m_paSlideShowInfo.size();
+}
+
+std::vector<CvSlideShowInfo*>& CvGlobals::getSlideShowInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paSlideShowInfo;
+}
+
+CvSlideShowInfo& CvGlobals::getSlideShowInfo(int iIndex)
+{
+	FAssert(iIndex > -1);
+	FAssert(iIndex < GC.getNumSlideShowInfos());
+	return *(m_paSlideShowInfo[iIndex]);
+}
+
+int CvGlobals::getNumSlideShowRandomInfos()
+{
+	return (int)m_paSlideShowRandomInfo.size();
+}
+
+std::vector<CvSlideShowRandomInfo*>& CvGlobals::getSlideShowRandomInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paSlideShowRandomInfo;
+}
+
+CvSlideShowRandomInfo& CvGlobals::getSlideShowRandomInfo(int iIndex)
+{
+	FAssert(iIndex > -1);
+	FAssert(iIndex < GC.getNumSlideShowRandomInfos());
+	return *(m_paSlideShowRandomInfo[iIndex]);
+}
+
+int CvGlobals::getNumWorldPickerInfos()
+{
+	return (int)m_paWorldPickerInfo.size();
+}
+
+std::vector<CvWorldPickerInfo*>& CvGlobals::getWorldPickerInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paWorldPickerInfo;
+}
+
+CvWorldPickerInfo& CvGlobals::getWorldPickerInfo(int iIndex)
+{
+	FAssert(iIndex > -1);
+	FAssert(iIndex < GC.getNumWorldPickerInfos());
+	return *(m_paWorldPickerInfo[iIndex]);
+}
+
+int CvGlobals::getNumUnitInfos()
+{
+	return (int)m_paUnitInfo.size();
+}
+
+std::vector<CvUnitInfo*>& CvGlobals::getUnitInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paUnitInfo;
+}
+
+CvUnitInfo& CvGlobals::getUnitInfo(UnitTypes eUnitNum)
+{
+	FAssert(eUnitNum > -1);
+	FAssert(eUnitNum < GC.getNumUnitInfos());
+	return *(m_paUnitInfo[eUnitNum]);
+}
+
+int CvGlobals::getNumSpecialUnitInfos()
+{
+	return (int)m_paSpecialUnitInfo.size();
+}
+
+std::vector<CvSpecialUnitInfo*>& CvGlobals::getSpecialUnitInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paSpecialUnitInfo;
+}
+
+CvSpecialUnitInfo& CvGlobals::getSpecialUnitInfo(SpecialUnitTypes eSpecialUnitNum)
+{
+	FAssert(eSpecialUnitNum > -1);
+	FAssert(eSpecialUnitNum < GC.getNumSpecialUnitInfos());
+	return *(m_paSpecialUnitInfo[eSpecialUnitNum]);
+}
+
+
+int CvGlobals::getNumConceptInfos()
+{
+	return (int)m_paConceptInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getConceptInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paConceptInfo;
+}
+
+CvInfoBase& CvGlobals::getConceptInfo(ConceptTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumConceptInfos());
+	return *(m_paConceptInfo[e]);
+}
+int CvGlobals::getNumCalendarInfos()
+{
+	return (int)m_paCalendarInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getCalendarInfo()
+{
+	return m_paCalendarInfo;
+}
+
+CvInfoBase& CvGlobals::getCalendarInfo(CalendarTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumCalendarInfos());
+	return *(m_paCalendarInfo[e]);
+}
+
+
+int CvGlobals::getNumSeasonInfos()
+{
+	return (int)m_paSeasonInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getSeasonInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paSeasonInfo;
+}
+
+CvInfoBase& CvGlobals::getSeasonInfo(SeasonTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumSeasonInfos());
+	return *(m_paSeasonInfo[e]);
+}
+
+
+int CvGlobals::getNumMonthInfos()
+{
+	return (int)m_paMonthInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getMonthInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paMonthInfo;
+}
+
+CvInfoBase& CvGlobals::getMonthInfo(MonthTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumMonthInfos());
+	return *(m_paMonthInfo[e]);
+}
+
+
+int CvGlobals::getNumDenialInfos()
+{
+	return (int)m_paDenialInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getDenialInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paDenialInfo;
+}
+
+CvInfoBase& CvGlobals::getDenialInfo(DenialTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumDenialInfos());
+	return *(m_paDenialInfo[e]);
+}
+
+
+int CvGlobals::getNumInvisibleInfos()
+{
+	return (int)m_paInvisibleInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getInvisibleInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paInvisibleInfo;
+}
+
+CvInfoBase& CvGlobals::getInvisibleInfo(InvisibleTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumInvisibleInfos());
+	return *(m_paInvisibleInfo[e]);
+}
+
+
+int CvGlobals::getNumFatherInfos()
+{
+	return (int)m_paFatherInfo.size();
+}
+
+std::vector<CvFatherInfo*>& CvGlobals::getFatherInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paFatherInfo;
+}
+
+CvFatherInfo& CvGlobals::getFatherInfo(FatherTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumFatherInfos());
+	return *(m_paFatherInfo[e]);
+}
+
+int CvGlobals::getNumFatherPointInfos()
+{
+	return (int)m_paFatherPointInfo.size();
+}
+
+std::vector<CvFatherPointInfo*>& CvGlobals::getFatherPointInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paFatherPointInfo;
+}
+
+CvFatherPointInfo& CvGlobals::getFatherPointInfo(FatherPointTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumFatherPointInfos());
+	return *(m_paFatherPointInfo[e]);
+}
+
+int CvGlobals::getNumUnitCombatInfos()
+{
+	return (int)m_paUnitCombatInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getUnitCombatInfo()
+{
+	return m_paUnitCombatInfo;
+}
+
+CvInfoBase& CvGlobals::getUnitCombatInfo(UnitCombatTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumUnitCombatInfos());
+	return *(m_paUnitCombatInfo[e]);
+}
+
+
+std::vector<CvInfoBase*>& CvGlobals::getDomainInfo()
+{
+	return m_paDomainInfo;
+}
+
+CvInfoBase& CvGlobals::getDomainInfo(DomainTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_DOMAIN_TYPES);
+	return *(m_paDomainInfo[e]);
+}
+
+
+std::vector<CvInfoBase*>& CvGlobals::getUnitAIInfo()
+{
+	return m_paUnitAIInfos;
+}
+
+CvInfoBase& CvGlobals::getUnitAIInfo(UnitAITypes eUnitAINum)
+{
+	FAssert(eUnitAINum >= 0);
+	FAssert(eUnitAINum < NUM_UNITAI_TYPES);
+	return *(m_paUnitAIInfos[eUnitAINum]);
+}
+
+
+std::vector<CvInfoBase*>& CvGlobals::getAttitudeInfo()
+{
+	return m_paAttitudeInfos;
+}
+
+CvInfoBase& CvGlobals::getAttitudeInfo(AttitudeTypes eAttitudeNum)
+{
+	FAssert(eAttitudeNum >= 0);
+	FAssert(eAttitudeNum < NUM_ATTITUDE_TYPES);
+	return *(m_paAttitudeInfos[eAttitudeNum]);
+}
+
+
+std::vector<CvInfoBase*>& CvGlobals::getMemoryInfo()
+{
+	return m_paMemoryInfos;
+}
+
+CvInfoBase& CvGlobals::getMemoryInfo(MemoryTypes eMemoryNum)
+{
+	FAssert(eMemoryNum >= 0);
+	FAssert(eMemoryNum < NUM_MEMORY_TYPES);
+	return *(m_paMemoryInfos[eMemoryNum]);
+}
+
+int CvGlobals::getNumFatherCategoryInfos()
+{
+	return (int)m_paFatherCategoryInfos.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getFatherCategoryInfo()
+{
+	return m_paFatherCategoryInfos;
+}
+
+CvInfoBase& CvGlobals::getFatherCategoryInfo(FatherCategoryTypes eFatherCategoryNum)
+{
+	FAssert(eFatherCategoryNum >= 0);
+	FAssert(eFatherCategoryNum < GC.getNumFatherCategoryInfos());
+	return *(m_paFatherCategoryInfos[eFatherCategoryNum]);
+}
+
+int CvGlobals::getNumGameOptionInfos()
+{
+	return (int)m_paGameOptionInfos.size();
+}
+
+std::vector<CvGameOptionInfo*>& CvGlobals::getGameOptionInfo()
+{
+	return m_paGameOptionInfos;
+}
+
+CvGameOptionInfo& CvGlobals::getGameOptionInfo(GameOptionTypes eGameOptionNum)
+{
+	FAssert(eGameOptionNum >= 0);
+	FAssert(eGameOptionNum < GC.getNumGameOptionInfos());
+	return *(m_paGameOptionInfos[eGameOptionNum]);
+}
+
+int CvGlobals::getNumMPOptionInfos()
+{
+	return (int)m_paMPOptionInfos.size();
+}
+
+std::vector<CvMPOptionInfo*>& CvGlobals::getMPOptionInfo()
+{
+	 return m_paMPOptionInfos;
+}
+
+CvMPOptionInfo& CvGlobals::getMPOptionInfo(MultiplayerOptionTypes eMPOptionNum)
+{
+	FAssert(eMPOptionNum >= 0);
+	FAssert(eMPOptionNum < GC.getNumMPOptionInfos());
+	return *(m_paMPOptionInfos[eMPOptionNum]);
+}
+
+int CvGlobals::getNumForceControlInfos()
+{
+	return (int)m_paForceControlInfos.size();
+}
+
+std::vector<CvForceControlInfo*>& CvGlobals::getForceControlInfo()
+{
+	return m_paForceControlInfos;
+}
+
+CvForceControlInfo& CvGlobals::getForceControlInfo(ForceControlTypes eForceControlNum)
+{
+	FAssert(eForceControlNum >= 0);
+	FAssert(eForceControlNum < GC.getNumForceControlInfos());
+	return *(m_paForceControlInfos[eForceControlNum]);
+}
+
+std::vector<CvPlayerOptionInfo*>& CvGlobals::getPlayerOptionInfo()
+{
+	return m_paPlayerOptionInfos;
+}
+
+CvPlayerOptionInfo& CvGlobals::getPlayerOptionInfo(PlayerOptionTypes ePlayerOptionNum)
+{
+	FAssert(ePlayerOptionNum >= 0);
+	FAssert(ePlayerOptionNum < NUM_PLAYEROPTION_TYPES);
+	return *(m_paPlayerOptionInfos[ePlayerOptionNum]);
+}
+
+std::vector<CvGraphicOptionInfo*>& CvGlobals::getGraphicOptionInfo()
+{
+	return m_paGraphicOptionInfos;
+}
+
+CvGraphicOptionInfo& CvGlobals::getGraphicOptionInfo(GraphicOptionTypes eGraphicOptionNum)
+{
+	FAssert(eGraphicOptionNum >= 0);
+	FAssert(eGraphicOptionNum < NUM_GRAPHICOPTION_TYPES);
+	return *(m_paGraphicOptionInfos[eGraphicOptionNum]);
+}
+
+
+std::vector<CvYieldInfo*>& CvGlobals::getYieldInfo()	// For Moose - XML Load Util
+{
+	return m_paYieldInfo;
+}
+
+CvYieldInfo& CvGlobals::getYieldInfo(YieldTypes eYieldNum)
+{
+	FAssert(eYieldNum > -1);
+	FAssert(eYieldNum < NUM_YIELD_TYPES);
+	return *(m_paYieldInfo[eYieldNum]);
+}
+
+
+int CvGlobals::getNumRouteInfos()
+{
+	return (int)m_paRouteInfo.size();
+}
+
+std::vector<CvRouteInfo*>& CvGlobals::getRouteInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paRouteInfo;
+}
+
+CvRouteInfo& CvGlobals::getRouteInfo(RouteTypes eRouteNum)
+{
+	FAssert(eRouteNum > -1);
+	FAssert(eRouteNum < GC.getNumRouteInfos());
+	return *(m_paRouteInfo[eRouteNum]);
+}
+
+int CvGlobals::getNumImprovementInfos()
+{
+	return (int)m_paImprovementInfo.size();
+}
+
+std::vector<CvImprovementInfo*>& CvGlobals::getImprovementInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paImprovementInfo;
+}
+
+CvImprovementInfo& CvGlobals::getImprovementInfo(ImprovementTypes eImprovementNum)
+{
+	FAssert(eImprovementNum > -1);
+	FAssert(eImprovementNum < GC.getNumImprovementInfos());
+	return *(m_paImprovementInfo[eImprovementNum]);
+}
+
+int CvGlobals::getNumGoodyInfos()
+{
+	return (int)m_paGoodyInfo.size();
+}
+
+std::vector<CvGoodyInfo*>& CvGlobals::getGoodyInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paGoodyInfo;
+}
+
+CvGoodyInfo& CvGlobals::getGoodyInfo(GoodyTypes eGoodyNum)
+{
+	FAssert(eGoodyNum > -1);
+	FAssert(eGoodyNum < GC.getNumGoodyInfos());
+	return *(m_paGoodyInfo[eGoodyNum]);
+}
+
+int CvGlobals::getNumBuildInfos()
+{
+	return (int)m_paBuildInfo.size();
+}
+
+std::vector<CvBuildInfo*>& CvGlobals::getBuildInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paBuildInfo;
+}
+
+CvBuildInfo& CvGlobals::getBuildInfo(BuildTypes eBuildNum)
+{
+	FAssert(eBuildNum > -1);
+	FAssert(eBuildNum < GC.getNumBuildInfos());
+	return *(m_paBuildInfo[eBuildNum]);
+}
+
+int CvGlobals::getNumHandicapInfos()
+{
+	return (int)m_paHandicapInfo.size();
+}
+
+std::vector<CvHandicapInfo*>& CvGlobals::getHandicapInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
+{
+	return m_paHandicapInfo;
+}
+
+CvHandicapInfo& CvGlobals::getHandicapInfo(HandicapTypes eHandicapNum)
+{
+	FAssert(eHandicapNum > -1);
+	FAssert(eHandicapNum < GC.getNumHandicapInfos());
+	return *(m_paHandicapInfo[eHandicapNum]);
+}
+
+int CvGlobals::getNumGameSpeedInfos()
+{
+	return (int)m_paGameSpeedInfo.size();
+}
+
+std::vector<CvGameSpeedInfo*>& CvGlobals::getGameSpeedInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
+{
+	return m_paGameSpeedInfo;
+}
+
+CvGameSpeedInfo& CvGlobals::getGameSpeedInfo(GameSpeedTypes eGameSpeedNum)
+{
+	FAssert(eGameSpeedNum > -1);
+	FAssert(eGameSpeedNum < GC.getNumGameSpeedInfos());
+	return *(m_paGameSpeedInfo[eGameSpeedNum]);
+}
+
+int CvGlobals::getNumAlarmInfos()
+{
+	return (int)m_paAlarmInfo.size();
+}
+///TKs Invention Core Mod v 1.0
+int CvGlobals::getCostToResearch(CivicTypes eCivic)
+{
+    if (eCivic != NO_CIVIC)
+    {
+        ///TK Update 1.1b
+        CvCivicInfo& kCivicInfo = GC.getCivicInfo(eCivic);
+        int iCivicResearchCost = kCivicInfo.getCostToResearch();
+        iCivicResearchCost = (iCivicResearchCost * GC.getCache_TK_HUMAN_RESEARCH_COST_MOD_PERCENT()) / 100;
+        return iCivicResearchCost;
+    }
+    return 0;
+
+}
+
+///Equipment Types 0 = Any; 1 = Heavy Armor; 2 = Any Armor; 3 = Armor & Horses
+bool CvGlobals::isEquipmentType(YieldTypes eEquipment, UnitEquipmentTypes eType) const
+{
+    if (eType == EQUIPMENT_ANY)
+    {
+        if (YieldGroup_Armor(eEquipment))
+        //if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR)
+        {
+            return true;
+        }
+
+        if (eEquipment == YIELD_WEAPONS || eEquipment == YIELD_HORSES)
+        {
+            return true;
+        }
+    }
+    else if (eType == EQUIPMENT_HEAVY_ARMOR)
+    {
+        if (YieldGroup_Heavy_Armor(eEquipment))
+        //if (eEquipment == YIELD_SCALE_ARMOR)
+        {
+            return true;
+        }
+    }
+    else if (eType == EQUIPMENT_ANY_ARMOR)
+    {
+        if (YieldGroup_Armor(eEquipment))
+        //if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR)
+        {
+            return true;
+        }
+    }
+    else if (eType == EQUIPMENT_ARMOR_HORSES)
+    {
+        if (YieldGroup_Armor(eEquipment))
+        //if (eEquipment == YIELD_LEATHER_ARMOR || eEquipment == YIELD_SCALE_ARMOR || eEquipment == YIELD_MAIL_ARMOR || eEquipment == YIELD_PLATE_ARMOR)
+        {
+            return true;
+        }
+
+        if (eEquipment == YIELD_HORSES)
+        {
+            return true;
+        }
+    }
+    return false;
+}
+///TKe
+
+std::vector<CvAlarmInfo*>& CvGlobals::getAlarmInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
+{
+	return m_paAlarmInfo;
+}
+
+CvAlarmInfo& CvGlobals::getAlarmInfo(AlarmTypes eAlarm)
+{
+	FAssert(eAlarm > -1);
+	FAssert(eAlarm < GC.getNumAlarmInfos());
+	return *(m_paAlarmInfo[eAlarm]);
+}
+
+int CvGlobals::getNumTurnTimerInfos()
+{
+	return (int)m_paTurnTimerInfo.size();
+}
+
+std::vector<CvTurnTimerInfo*>& CvGlobals::getTurnTimerInfo()	// Do NOT export outside of the DLL	// For Moose - XML Load Util
+{
+	return m_paTurnTimerInfo;
+}
+
+CvTurnTimerInfo& CvGlobals::getTurnTimerInfo(TurnTimerTypes eTurnTimerNum)
+{
+	FAssert(eTurnTimerNum > -1);
+	FAssert(eTurnTimerNum < GC.getNumTurnTimerInfos());
+	return *(m_paTurnTimerInfo[eTurnTimerNum]);
+}
+
+int CvGlobals::getNumBuildingClassInfos()
+{
+	return (int)m_paBuildingClassInfo.size();
+}
+
+std::vector<CvBuildingClassInfo*>& CvGlobals::getBuildingClassInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paBuildingClassInfo;
+}
+
+CvBuildingClassInfo& CvGlobals::getBuildingClassInfo(BuildingClassTypes eBuildingClassNum)
+{
+	FAssert(eBuildingClassNum > -1);
+	FAssert(eBuildingClassNum < GC.getNumBuildingClassInfos());
+	return *(m_paBuildingClassInfo[eBuildingClassNum]);
+}
+
+int CvGlobals::getNumBuildingInfos()
+{
+	return (int)m_paBuildingInfo.size();
+}
+
+std::vector<CvBuildingInfo*>& CvGlobals::getBuildingInfo()	// For Moose - XML Load Util, CvInfos, CvCacheObject
+{
+	return m_paBuildingInfo;
+}
+
+CvBuildingInfo& CvGlobals::getBuildingInfo(BuildingTypes eBuildingNum)
+{
+	FAssert(eBuildingNum > -1);
+	FAssert(eBuildingNum < GC.getNumBuildingInfos());
+	return *(m_paBuildingInfo[eBuildingNum]);
+}
+
+int CvGlobals::getNumSpecialBuildingInfos()
+{
+	return (int)m_paSpecialBuildingInfo.size();
+}
+
+std::vector<CvSpecialBuildingInfo*>& CvGlobals::getSpecialBuildingInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paSpecialBuildingInfo;
+}
+
+CvSpecialBuildingInfo& CvGlobals::getSpecialBuildingInfo(SpecialBuildingTypes eSpecialBuildingNum)
+{
+	FAssert(eSpecialBuildingNum > -1);
+	FAssert(eSpecialBuildingNum < GC.getNumSpecialBuildingInfos());
+	return *(m_paSpecialBuildingInfo[eSpecialBuildingNum]);
+}
+
+int CvGlobals::getNumUnitClassInfos()
+{
+	return (int)m_paUnitClassInfo.size();
+}
+
+std::vector<CvUnitClassInfo*>& CvGlobals::getUnitClassInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paUnitClassInfo;
+}
+
+CvUnitClassInfo& CvGlobals::getUnitClassInfo(UnitClassTypes eUnitClassNum)
+{
+	FAssert(eUnitClassNum > -1);
+	FAssert(eUnitClassNum < GC.getNumUnitClassInfos());
+	return *(m_paUnitClassInfo[eUnitClassNum]);
+}
+
+int CvGlobals::getNumActionInfos()
+{
+	return (int)m_paActionInfo.size();
+}
+
+std::vector<CvActionInfo*>& CvGlobals::getActionInfo()	// For Moose - XML Load Util
+{
+	return m_paActionInfo;
+}
+
+CvActionInfo& CvGlobals::getActionInfo(int i)
+{
+	FAssertMsg(i < getNumActionInfos(), "Index out of bounds");
+	FAssertMsg(i > -1, "Index out of bounds");
+	return *(m_paActionInfo[i]);
+}
+
+std::vector<CvMissionInfo*>& CvGlobals::getMissionInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paMissionInfo;
+}
+
+CvMissionInfo& CvGlobals::getMissionInfo(MissionTypes eMissionNum)
+{
+	FAssert(eMissionNum > -1);
+	FAssert(eMissionNum < NUM_MISSION_TYPES);
+	return *(m_paMissionInfo[eMissionNum]);
+}
+
+std::vector<CvControlInfo*>& CvGlobals::getControlInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paControlInfo;
+}
+
+CvControlInfo& CvGlobals::getControlInfo(ControlTypes eControlNum)
+{
+	FAssert(eControlNum > -1);
+	FAssert(eControlNum < NUM_CONTROL_TYPES);
+	FAssert(m_paControlInfo.size() > 0);
+	return *(m_paControlInfo[eControlNum]);
+}
+
+std::vector<CvCommandInfo*>& CvGlobals::getCommandInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paCommandInfo;
+}
+
+CvCommandInfo& CvGlobals::getCommandInfo(CommandTypes eCommandNum)
+{
+	FAssert(eCommandNum > -1);
+	FAssert(eCommandNum < NUM_COMMAND_TYPES);
+	return *(m_paCommandInfo[eCommandNum]);
+}
+
+int CvGlobals::getNumAutomateInfos()
+{
+	return (int)m_paAutomateInfo.size();
+}
+
+std::vector<CvAutomateInfo*>& CvGlobals::getAutomateInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paAutomateInfo;
+}
+
+CvAutomateInfo& CvGlobals::getAutomateInfo(int iAutomateNum)
+{
+	FAssertMsg(iAutomateNum < getNumAutomateInfos(), "Index out of bounds");
+	FAssertMsg(iAutomateNum > -1, "Index out of bounds");
+	return *(m_paAutomateInfo[iAutomateNum]);
+}
+
+int CvGlobals::getNumPromotionInfos()
+{
+	return (int)m_paPromotionInfo.size();
+}
+
+std::vector<CvPromotionInfo*>& CvGlobals::getPromotionInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paPromotionInfo;
+}
+
+CvPromotionInfo& CvGlobals::getPromotionInfo(PromotionTypes ePromotionNum)
+{
+	FAssert(ePromotionNum > -1);
+	FAssert(ePromotionNum < GC.getNumPromotionInfos());
+	return *(m_paPromotionInfo[ePromotionNum]);
+}
+
+int CvGlobals::getNumProfessionInfos()
+{
+	return (int)m_paProfessionInfo.size();
+}
+
+std::vector<CvProfessionInfo*>& CvGlobals::getProfessionInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paProfessionInfo;
+}
+
+CvProfessionInfo& CvGlobals::getProfessionInfo(ProfessionTypes eProfessionNum)
+{
+	FAssert(eProfessionNum > -1);
+	FAssert(eProfessionNum < (int)m_paProfessionInfo.size());
+	return *(m_paProfessionInfo[eProfessionNum]);
+}
+int CvGlobals::getNumCivicOptionInfos()
+{
+	return (int)m_paCivicOptionInfo.size();
+}
+
+std::vector<CvInfoBase*>& CvGlobals::getCivicOptionInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paCivicOptionInfo;
+}
+
+CvInfoBase& CvGlobals::getCivicOptionInfo(CivicOptionTypes eCivicOptionNum)
+{
+	FAssert(eCivicOptionNum > -1);
+	FAssert(eCivicOptionNum < GC.getNumCivicOptionInfos());
+	return *(m_paCivicOptionInfo[eCivicOptionNum]);
+}
+
+int CvGlobals::getNumCivicInfos()
+{
+	return (int)m_paCivicInfo.size();
+}
+
+std::vector<CvCivicInfo*>& CvGlobals::getCivicInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paCivicInfo;
+}
+
+CvCivicInfo& CvGlobals::getCivicInfo(CivicTypes eCivicNum)
+{
+	FAssert(eCivicNum > -1);
+	FAssert(eCivicNum < GC.getNumCivicInfos());
+	return *(m_paCivicInfo[eCivicNum]);
+}
+
+int CvGlobals::getNumDiplomacyInfos()
+{
+	return (int)m_paDiplomacyInfo.size();
+}
+
+std::vector<CvDiplomacyInfo*>& CvGlobals::getDiplomacyInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paDiplomacyInfo;
+}
+
+CvDiplomacyInfo& CvGlobals::getDiplomacyInfo(int iDiplomacyNum)
+{
+	FAssertMsg(iDiplomacyNum < getNumDiplomacyInfos(), "Index out of bounds");
+	FAssertMsg(iDiplomacyNum > -1, "Index out of bounds");
+	return *(m_paDiplomacyInfo[iDiplomacyNum]);
+}
+
+int CvGlobals::getNumEraInfos()
+{
+	return (int)m_aEraInfo.size();
+}
+
+std::vector<CvEraInfo*>& CvGlobals::getEraInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_aEraInfo;
+}
+
+CvEraInfo& CvGlobals::getEraInfo(EraTypes eEraNum)
+{
+	FAssert(eEraNum > -1);
+	FAssert(eEraNum < GC.getNumEraInfos());
+	return *(m_aEraInfo[eEraNum]);
+}
+
+int CvGlobals::getNumHurryInfos()
+{
+	return (int)m_paHurryInfo.size();
+}
+
+std::vector<CvHurryInfo*>& CvGlobals::getHurryInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paHurryInfo;
+}
+
+CvHurryInfo& CvGlobals::getHurryInfo(HurryTypes eHurryNum)
+{
+	FAssert(eHurryNum > -1);
+	FAssert(eHurryNum < GC.getNumHurryInfos());
+	return *(m_paHurryInfo[eHurryNum]);
+}
+
+int CvGlobals::getNumEmphasizeInfos()
+{
+	return (int)m_paEmphasizeInfo.size();
+}
+
+std::vector<CvEmphasizeInfo*>& CvGlobals::getEmphasizeInfo()	// For Moose - XML Load Util
+{
+	return m_paEmphasizeInfo;
+}
+
+CvEmphasizeInfo& CvGlobals::getEmphasizeInfo(EmphasizeTypes eEmphasizeNum)
+{
+	FAssert(eEmphasizeNum > -1);
+	FAssert(eEmphasizeNum < GC.getNumEmphasizeInfos());
+	return *(m_paEmphasizeInfo[eEmphasizeNum]);
+}
+
+int CvGlobals::getNumCultureLevelInfos()
+{
+	return (int)m_paCultureLevelInfo.size();
+}
+
+std::vector<CvCultureLevelInfo*>& CvGlobals::getCultureLevelInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paCultureLevelInfo;
+}
+
+CvCultureLevelInfo& CvGlobals::getCultureLevelInfo(CultureLevelTypes eCultureLevelNum)
+{
+	FAssert(eCultureLevelNum > -1);
+	FAssert(eCultureLevelNum < GC.getNumCultureLevelInfos());
+	return *(m_paCultureLevelInfo[eCultureLevelNum]);
+}
+
+int CvGlobals::getNumVictoryInfos()
+{
+	return (int)m_paVictoryInfo.size();
+}
+
+std::vector<CvVictoryInfo*>& CvGlobals::getVictoryInfo()	// For Moose - XML Load Util, CvInfos
+{
+	return m_paVictoryInfo;
+}
+
+CvVictoryInfo& CvGlobals::getVictoryInfo(VictoryTypes eVictoryNum)
+{
+	FAssert(eVictoryNum > -1);
+	FAssert(eVictoryNum < GC.getNumVictoryInfos());
+	return *(m_paVictoryInfo[eVictoryNum]);
+}
+
+int CvGlobals::getNumEventTriggerInfos()
+{
+	return (int)m_paEventTriggerInfo.size();
+}
+
+std::vector<CvEventTriggerInfo*>& CvGlobals::getEventTriggerInfo()
+{
+	return m_paEventTriggerInfo;
+}
+
+CvEventTriggerInfo& CvGlobals::getEventTriggerInfo(EventTriggerTypes eEventTrigger)
+{
+	FAssert(eEventTrigger > -1);
+	FAssert(eEventTrigger < GC.getNumEventTriggerInfos());
+	return *(m_paEventTriggerInfo[eEventTrigger]);
+}
+
+int CvGlobals::getNumEventInfos()
+{
+	return (int)m_paEventInfo.size();
+}
+
+std::vector<CvEventInfo*>& CvGlobals::getEventInfo()
+{
+	return m_paEventInfo;
+}
+
+CvEventInfo& CvGlobals::getEventInfo(EventTypes eEvent)
+{
+	FAssert(eEvent > -1);
+	FAssert(eEvent < GC.getNumEventInfos());
+	return *(m_paEventInfo[eEvent]);
+}
+
+int& CvGlobals::getNumEntityEventTypes()
+{
+	return m_iNumEntityEventTypes;
+}
+
+CvString*& CvGlobals::getEntityEventTypes()
+{
+	return m_paszEntityEventTypes;
+}
+
+CvString& CvGlobals::getEntityEventTypes(EntityEventTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumEntityEventTypes());
+	return m_paszEntityEventTypes[e];
+}
+
+int& CvGlobals::getNumAnimationOperatorTypes()
+{
+	return m_iNumAnimationOperatorTypes;
+}
+
+CvString*& CvGlobals::getAnimationOperatorTypes()
+{
+	return m_paszAnimationOperatorTypes;
+}
+
+CvString& CvGlobals::getAnimationOperatorTypes(AnimationOperatorTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumAnimationOperatorTypes());
+	return m_paszAnimationOperatorTypes[e];
+}
+
+CvString*& CvGlobals::getFunctionTypes()
+{
+	return m_paszFunctionTypes;
+}
+
+CvString& CvGlobals::getFunctionTypes(FunctionTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_FUNC_TYPES);
+	return m_paszFunctionTypes[e];
+}
+
+int& CvGlobals::getNumArtStyleTypes()
+{
+	return m_iNumArtStyleTypes;
+}
+
+CvString*& CvGlobals::getArtStyleTypes()
+{
+	return m_paszArtStyleTypes;
+}
+
+CvString& CvGlobals::getArtStyleTypes(ArtStyleTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < GC.getNumArtStyleTypes());
+	return m_paszArtStyleTypes[e];
+}
+
+
+//Androrc UnitArtStyles
+int CvGlobals::getNumUnitArtStyleTypeInfos()
+{
+    return (int)m_paUnitArtStyleTypeInfo.size();
+}
+
+std::vector<CvUnitArtStyleTypeInfo*>& CvGlobals::getUnitArtStyleTypeInfo()
+{
+	return m_paUnitArtStyleTypeInfo;
+}
+
+CvUnitArtStyleTypeInfo& CvGlobals::getUnitArtStyleTypeInfo(UnitArtStyleTypes eUnitArtStyleTypeNum)
+{
+	FAssert(eUnitArtStyleTypeNum > -1);
+	FAssert(eUnitArtStyleTypeNum < GC.getNumUnitArtStyleTypeInfos());
+	return *(m_paUnitArtStyleTypeInfo[eUnitArtStyleTypeNum]);
+}
+//Androrc End
+
+int& CvGlobals::getNumCitySizeTypes()
+{
+	return m_iNumCitySizeTypes;
+}
+
+CvString*& CvGlobals::getCitySizeTypes()
+{
+	return m_paszCitySizeTypes;
+}
+
+CvString& CvGlobals::getCitySizeTypes(int i)
+{
+	FAssertMsg(i < getNumCitySizeTypes(), "Index out of bounds");
+	FAssertMsg(i > -1, "Index out of bounds");
+	return m_paszCitySizeTypes[i];
+}
+
+CvString*& CvGlobals::getContactTypes()
+{
+	return m_paszContactTypes;
+}
+
+CvString& CvGlobals::getContactTypes(ContactTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_CONTACT_TYPES);
+	return m_paszContactTypes[e];
+}
+
+CvString*& CvGlobals::getDiplomacyPowerTypes()
+{
+	return m_paszDiplomacyPowerTypes;
+}
+
+CvString& CvGlobals::getDiplomacyPowerTypes(DiplomacyPowerTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_DIPLOMACYPOWER_TYPES);
+	return m_paszDiplomacyPowerTypes[e];
+}
+
+CvString*& CvGlobals::getAutomateTypes()
+{
+	return m_paszAutomateTypes;
+}
+
+CvString& CvGlobals::getAutomateTypes(AutomateTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_AUTOMATE_TYPES);
+	return m_paszAutomateTypes[e];
+}
+///TKs Med
+CvString*& CvGlobals::getMedCityTypes()
+{
+	return m_paszMedCityTypes;
+}
+
+CvString*& CvGlobals::getModCodeTypes()
+{
+	return m_paszModCodeTypes;
+}
+
+CvString& CvGlobals::getModCodeTypes(ModCodeTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_MOD_CODE_TYPES);
+	return m_paszModCodeTypes[e];
+}
+
+CvString& CvGlobals::getMedCityTypes(MedCityTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_CITY_TYPES);
+	return m_paszMedCityTypes[e];
+}
+CvString*& CvGlobals::getTradeScreenTypes()
+{
+	return m_paszTradeScreenTypes;
+}
+
+CvString& CvGlobals::getTradeScreenTypes(TradeScreenTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_TRADE_SCREEN_TYPES);
+	return m_paszTradeScreenTypes[e];
+}
+///Tke
+
+CvString*& CvGlobals::getDirectionTypes()
+{
+	return m_paszDirectionTypes;
+}
+
+CvString& CvGlobals::getDirectionTypes(AutomateTypes e)
+{
+	FAssert(e > -1);
+	FAssert(e < NUM_DIRECTION_TYPES);
+	return m_paszDirectionTypes[e];
+}
+
+int& CvGlobals::getNumFootstepAudioTypes()
+{
+	return m_iNumFootstepAudioTypes;
+}
+
+CvString*& CvGlobals::getFootstepAudioTypes()
+{
+	return m_paszFootstepAudioTypes;
+}
+
+CvString& CvGlobals::getFootstepAudioTypes(int i)
+{
+	FAssertMsg(i < getNumFootstepAudioTypes(), "Index out of bounds");
+	FAssertMsg(i > -1, "Index out of bounds");
+	return m_paszFootstepAudioTypes[i];
+}
+
+int CvGlobals::getFootstepAudioTypeByTag(CvString strTag)
+{
+	int iIndex = -1;
+
+	if ( strTag.GetLength() <= 0 )
+	{
+		return iIndex;
+	}
+
+	for ( int i = 0; i < m_iNumFootstepAudioTypes; i++ )
+	{
+		if ( strTag.CompareNoCase(m_paszFootstepAudioTypes[i]) == 0 )
+		{
+			iIndex = i;
+			break;
+		}
+	}
+
+	return iIndex;
+}
+
+CvString*& CvGlobals::getFootstepAudioTags()
+{
+	return m_paszFootstepAudioTags;
+}
+
+CvString& CvGlobals::getFootstepAudioTags(int i)
+{
+//	FAssertMsg(i < getNumFootstepAudioTags(), "Index out of bounds")
+	FAssertMsg(i > -1, "Index out of bounds");
+	return m_paszFootstepAudioTags[i];
+}
+
+void CvGlobals::setCurrentXMLFile(const TCHAR* szFileName)
+{
+	m_szCurrentXMLFile = szFileName;
+}
+
+CvString& CvGlobals::getCurrentXMLFile()
+{
+	return m_szCurrentXMLFile;
+}
+
+FVariableSystem* CvGlobals::getDefinesVarSystem()
+{
+	return m_VarSystem;
+}
+
+void CvGlobals::cacheGlobals()
+{
+	m_iMOVE_DENOMINATOR = getDefineINT("MOVE_DENOMINATOR");
+	m_iFOOD_CONSUMPTION_PER_POPULATION = getDefineINT("FOOD_CONSUMPTION_PER_POPULATION");
+	m_iMAX_HIT_POINTS = getDefineINT("MAX_HIT_POINTS");
+	m_iHILLS_EXTRA_DEFENSE = getDefineINT("HILLS_EXTRA_DEFENSE");
+	m_iRIVER_ATTACK_MODIFIER = getDefineINT("RIVER_ATTACK_MODIFIER");
+	m_iAMPHIB_ATTACK_MODIFIER = getDefineINT("AMPHIB_ATTACK_MODIFIER");
+	m_iHILLS_EXTRA_MOVEMENT = getDefineINT("HILLS_EXTRA_MOVEMENT");
+	m_iPEAK_EXTRA_MOVEMENT = getDefineINT("PEAK_EXTRA_MOVEMENT");
+	m_iMAX_PLOT_LIST_ROWS = getDefineINT("MAX_PLOT_LIST_ROWS");
+	m_iUNIT_MULTISELECT_MAX = getDefineINT("UNIT_MULTISELECT_MAX");
+	m_iEVENT_MESSAGE_TIME = getDefineINT("EVENT_MESSAGE_TIME");
+	m_iROUTE_FEATURE_GROWTH_MODIFIER = getDefineINT("ROUTE_FEATURE_GROWTH_MODIFIER");
+	m_iFEATURE_GROWTH_MODIFIER = getDefineINT("FEATURE_GROWTH_MODIFIER");
+	m_iMIN_CITY_RANGE = getDefineINT("MIN_CITY_RANGE");
+	m_iCITY_MAX_NUM_BUILDINGS = getDefineINT("CITY_MAX_NUM_BUILDINGS");
+	m_iLAKE_MAX_AREA_SIZE = getDefineINT("LAKE_MAX_AREA_SIZE");
+	m_iMIN_WATER_SIZE_FOR_OCEAN = getDefineINT("MIN_WATER_SIZE_FOR_OCEAN");
+	m_iFORTIFY_MODIFIER_PER_TURN = getDefineINT("FORTIFY_MODIFIER_PER_TURN");
+	m_iMAX_CITY_DEFENSE_DAMAGE = getDefineINT("MAX_CITY_DEFENSE_DAMAGE");
+	m_iPEAK_SEE_THROUGH_CHANGE = getDefineINT("PEAK_SEE_THROUGH_CHANGE");
+	m_iHILLS_SEE_THROUGH_CHANGE = getDefineINT("HILLS_SEE_THROUGH_CHANGE");
+	m_iSEAWATER_SEE_FROM_CHANGE = getDefineINT("SEAWATER_SEE_FROM_CHANGE");
+	m_iPEAK_SEE_FROM_CHANGE = getDefineINT("PEAK_SEE_FROM_CHANGE");
+	m_iHILLS_SEE_FROM_CHANGE = getDefineINT("HILLS_SEE_FROM_CHANGE");
+	m_iMAX_REBEL_YIELD_MODIFIER = getDefineINT("MAX_REBEL_YIELD_MODIFIER");
+
+	m_fCAMERA_MIN_YAW = getDefineFLOAT("CAMERA_MIN_YAW");
+	m_fCAMERA_MAX_YAW = getDefineFLOAT("CAMERA_MAX_YAW");
+	m_fCAMERA_FAR_CLIP_Z_HEIGHT = getDefineFLOAT("CAMERA_FAR_CLIP_Z_HEIGHT");
+	m_fCAMERA_MAX_TRAVEL_DISTANCE = getDefineFLOAT("CAMERA_MAX_TRAVEL_DISTANCE");
+	m_fCAMERA_START_DISTANCE = getDefineFLOAT("CAMERA_START_DISTANCE");
+	m_fPLOT_SIZE = getDefineFLOAT("PLOT_SIZE");
+	m_fCAMERA_SPECIAL_PITCH = getDefineFLOAT("CAMERA_SPECIAL_PITCH");
+	m_fCAMERA_MAX_TURN_OFFSET = getDefineFLOAT("CAMERA_MAX_TURN_OFFSET");
+	m_fCAMERA_MIN_DISTANCE = getDefineFLOAT("CAMERA_MIN_DISTANCE");
+	m_fCAMERA_UPPER_PITCH = getDefineFLOAT("CAMERA_UPPER_PITCH");
+	m_fCAMERA_LOWER_PITCH = getDefineFLOAT("CAMERA_LOWER_PITCH");
+	m_fFIELD_OF_VIEW = getDefineFLOAT("FIELD_OF_VIEW");
+	m_fUNIT_MULTISELECT_DISTANCE = getDefineFLOAT("UNIT_MULTISELECT_DISTANCE");
+
+	m_iUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK = getDefineINT("USE_CAN_FOUND_CITIES_ON_WATER_CALLBACK");
+	m_iUSE_CANNOT_DO_CIVIC_CALLBACK = getDefineINT("USE_CANNOT_DO_CIVIC_CALLBACK");
+	m_iUSE_CAN_DO_CIVIC_CALLBACK = getDefineINT("USE_CAN_DO_CIVIC_CALLBACK");
+	m_iUSE_CANNOT_CONSTRUCT_CALLBACK = getDefineINT("USE_CANNOT_CONSTRUCT_CALLBACK");
+	m_iUSE_CAN_CONSTRUCT_CALLBACK = getDefineINT("USE_CAN_CONSTRUCT_CALLBACK");
+	m_iUSE_CAN_DECLARE_WAR_CALLBACK = getDefineINT("USE_CAN_DECLARE_WAR_CALLBACK");
+	m_iUSE_GET_UNIT_COST_MOD_CALLBACK = getDefineINT("USE_GET_UNIT_COST_MOD_CALLBACK");
+	m_iUSE_GET_BUILDING_COST_MOD_CALLBACK = getDefineINT("USE_GET_BUILDING_COST_MOD_CALLBACK");
+	m_iUSE_GET_CITY_FOUND_VALUE_CALLBACK = getDefineINT("USE_GET_CITY_FOUND_VALUE_CALLBACK");
+	m_iUSE_CANNOT_HANDLE_ACTION_CALLBACK = getDefineINT("USE_CANNOT_HANDLE_ACTION_CALLBACK");
+	m_iUSE_CAN_BUILD_CALLBACK = getDefineINT("USE_CAN_BUILD_CALLBACK");
+	m_iUSE_CANNOT_TRAIN_CALLBACK = getDefineINT("USE_CANNOT_TRAIN_CALLBACK");
+	m_iUSE_CAN_TRAIN_CALLBACK = getDefineINT("USE_CAN_TRAIN_CALLBACK");
+	m_iUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK = getDefineINT("USE_UNIT_CANNOT_MOVE_INTO_CALLBACK");
+	m_iUSE_FINISH_TEXT_CALLBACK = getDefineINT("USE_FINISH_TEXT_CALLBACK");
+	m_iUSE_ON_UNIT_SET_XY_CALLBACK = getDefineINT("USE_ON_UNIT_SET_XY_CALLBACK");
+	m_iUSE_ON_UNIT_SELECTED_CALLBACK = getDefineINT("USE_ON_UNIT_SELECTED_CALLBACK");
+	m_iUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK = getDefineINT("USE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK");
+	m_iUSE_ON_UPDATE_CALLBACK = getDefineINT("USE_ON_UPDATE_CALLBACK");
+	m_iUSE_ON_UNIT_CREATED_CALLBACK = getDefineINT("USE_ON_UNIT_CREATED_CALLBACK");
+	m_iUSE_ON_UNIT_LOST_CALLBACK = getDefineINT("USE_ON_UNIT_LOST_CALLBACK");
+}
+
+int CvGlobals::getDefineINT( const char * szName ) const
+{
+	int iReturn = 0;
+	GC.getDefinesVarSystem()->GetValue( szName, iReturn );
+	return iReturn;
+}
+
+float CvGlobals::getDefineFLOAT( const char * szName ) const
+{
+	float fReturn = 0;
+	GC.getDefinesVarSystem()->GetValue( szName, fReturn );
+	return fReturn;
+}
+
+const char * CvGlobals::getDefineSTRING( const char * szName ) const
+{
+	const char * szReturn = NULL;
+	GC.getDefinesVarSystem()->GetValue( szName, szReturn );
+	return szReturn;
+}
+
+void CvGlobals::setDefineINT( const char * szName, int iValue )
+{
+	GC.getDefinesVarSystem()->SetValue( szName, iValue );
+	cacheGlobals();
+}
+
+void CvGlobals::setDefineFLOAT( const char * szName, float fValue )
+{
+	GC.getDefinesVarSystem()->SetValue( szName, fValue );
+	cacheGlobals();
+}
+
+void CvGlobals::setDefineSTRING( const char * szName, const char * szValue )
+{
+	GC.getDefinesVarSystem()->SetValue( szName, szValue );
+	cacheGlobals();
+}
+
+int CvGlobals::getMOVE_DENOMINATOR()
+{
+	return m_iMOVE_DENOMINATOR;
+}
+
+int CvGlobals::getFOOD_CONSUMPTION_PER_POPULATION()
+{
+	return m_iFOOD_CONSUMPTION_PER_POPULATION;
+}
+
+int CvGlobals::getMAX_HIT_POINTS()
+{
+	return m_iMAX_HIT_POINTS;
+}
+
+int CvGlobals::getHILLS_EXTRA_DEFENSE()
+{
+	return m_iHILLS_EXTRA_DEFENSE;
+}
+
+int CvGlobals::getRIVER_ATTACK_MODIFIER()
+{
+	return m_iRIVER_ATTACK_MODIFIER;
+}
+
+int CvGlobals::getAMPHIB_ATTACK_MODIFIER()
+{
+	return m_iAMPHIB_ATTACK_MODIFIER;
+}
+
+int CvGlobals::getHILLS_EXTRA_MOVEMENT()
+{
+	return m_iHILLS_EXTRA_MOVEMENT;
+}
+
+int CvGlobals::getPEAK_EXTRA_MOVEMENT()
+{
+	return m_iPEAK_EXTRA_MOVEMENT;
+}
+
+int CvGlobals::getMAX_PLOT_LIST_ROWS()
+{
+	return m_iMAX_PLOT_LIST_ROWS;
+}
+
+int CvGlobals::getUNIT_MULTISELECT_MAX()
+{
+	return m_iUNIT_MULTISELECT_MAX;
+}
+
+int CvGlobals::getEVENT_MESSAGE_TIME()
+{
+	return m_iEVENT_MESSAGE_TIME;
+}
+
+int CvGlobals::getROUTE_FEATURE_GROWTH_MODIFIER()
+{
+	return m_iROUTE_FEATURE_GROWTH_MODIFIER;
+}
+
+int CvGlobals::getFEATURE_GROWTH_MODIFIER()
+{
+	return m_iFEATURE_GROWTH_MODIFIER;
+}
+
+int CvGlobals::getMIN_CITY_RANGE()
+{
+	return m_iMIN_CITY_RANGE;
+}
+
+int CvGlobals::getCITY_MAX_NUM_BUILDINGS()
+{
+	return m_iCITY_MAX_NUM_BUILDINGS;
+}
+int CvGlobals::getLAKE_MAX_AREA_SIZE()
+{
+	return m_iLAKE_MAX_AREA_SIZE;
+}
+int CvGlobals::getMIN_WATER_SIZE_FOR_OCEAN()
+{
+	return m_iMIN_WATER_SIZE_FOR_OCEAN;
+}
+
+int CvGlobals::getFORTIFY_MODIFIER_PER_TURN()
+{
+	return m_iFORTIFY_MODIFIER_PER_TURN;
+}
+
+int CvGlobals::getMAX_CITY_DEFENSE_DAMAGE()
+{
+	return m_iMAX_CITY_DEFENSE_DAMAGE;
+}
+
+int CvGlobals::getPEAK_SEE_THROUGH_CHANGE()
+{
+	return m_iPEAK_SEE_THROUGH_CHANGE;
+}
+
+int CvGlobals::getHILLS_SEE_THROUGH_CHANGE()
+{
+	return m_iHILLS_SEE_THROUGH_CHANGE;
+}
+
+int CvGlobals::getSEAWATER_SEE_FROM_CHANGE()
+{
+	return m_iSEAWATER_SEE_FROM_CHANGE;
+}
+
+int CvGlobals::getPEAK_SEE_FROM_CHANGE()
+{
+	return m_iPEAK_SEE_FROM_CHANGE;
+}
+
+int CvGlobals::getHILLS_SEE_FROM_CHANGE()
+{
+	return m_iHILLS_SEE_FROM_CHANGE;
+}
+
+int CvGlobals::getMAX_REBEL_YIELD_MODIFIER()
+{
+	return m_iMAX_REBEL_YIELD_MODIFIER;
+}
+
+float CvGlobals::getCAMERA_MIN_YAW()
+{
+	return m_fCAMERA_MIN_YAW;
+}
+
+float CvGlobals::getCAMERA_MAX_YAW()
+{
+	return m_fCAMERA_MAX_YAW;
+}
+
+float CvGlobals::getCAMERA_FAR_CLIP_Z_HEIGHT()
+{
+	return m_fCAMERA_FAR_CLIP_Z_HEIGHT;
+}
+
+float CvGlobals::getCAMERA_MAX_TRAVEL_DISTANCE()
+{
+	return m_fCAMERA_MAX_TRAVEL_DISTANCE;
+}
+
+float CvGlobals::getCAMERA_START_DISTANCE()
+{
+	return m_fCAMERA_START_DISTANCE;
+}
+
+float CvGlobals::getPLOT_SIZE()
+{
+	return m_fPLOT_SIZE;
+}
+
+float CvGlobals::getCAMERA_SPECIAL_PITCH()
+{
+	return m_fCAMERA_SPECIAL_PITCH;
+}
+
+float CvGlobals::getCAMERA_MAX_TURN_OFFSET()
+{
+	return m_fCAMERA_MAX_TURN_OFFSET;
+}
+
+float CvGlobals::getCAMERA_MIN_DISTANCE()
+{
+	return m_fCAMERA_MIN_DISTANCE;
+}
+
+float CvGlobals::getCAMERA_UPPER_PITCH()
+{
+	return m_fCAMERA_UPPER_PITCH;
+}
+
+float CvGlobals::getCAMERA_LOWER_PITCH()
+{
+	return m_fCAMERA_LOWER_PITCH;
+}
+
+float CvGlobals::getFIELD_OF_VIEW()
+{
+	return m_fFIELD_OF_VIEW;
+}
+
+float CvGlobals::getUNIT_MULTISELECT_DISTANCE()
+{
+	return m_fUNIT_MULTISELECT_DISTANCE;
+}
+
+int CvGlobals::getUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK()
+{
+	return m_iUSE_CAN_FOUND_CITIES_ON_WATER_CALLBACK;
+}
+int CvGlobals::getUSE_CANNOT_DO_CIVIC_CALLBACK()
+{
+	return m_iUSE_CANNOT_DO_CIVIC_CALLBACK;
+}
+
+int CvGlobals::getUSE_CAN_DO_CIVIC_CALLBACK()
+{
+	return m_iUSE_CAN_DO_CIVIC_CALLBACK;
+}
+
+int CvGlobals::getUSE_CANNOT_CONSTRUCT_CALLBACK()
+{
+	return m_iUSE_CANNOT_CONSTRUCT_CALLBACK;
+}
+
+int CvGlobals::getUSE_CAN_CONSTRUCT_CALLBACK()
+{
+	return m_iUSE_CAN_CONSTRUCT_CALLBACK;
+}
+
+int CvGlobals::getUSE_CAN_DECLARE_WAR_CALLBACK()
+{
+	return m_iUSE_CAN_DECLARE_WAR_CALLBACK;
+}
+int CvGlobals::getUSE_GET_UNIT_COST_MOD_CALLBACK()
+{
+	return m_iUSE_GET_UNIT_COST_MOD_CALLBACK;
+}
+
+int CvGlobals::getUSE_GET_BUILDING_COST_MOD_CALLBACK()
+{
+	return m_iUSE_GET_BUILDING_COST_MOD_CALLBACK;
+}
+
+int CvGlobals::getUSE_GET_CITY_FOUND_VALUE_CALLBACK()
+{
+	return m_iUSE_GET_CITY_FOUND_VALUE_CALLBACK;
+}
+
+int CvGlobals::getUSE_CANNOT_HANDLE_ACTION_CALLBACK()
+{
+	return m_iUSE_CANNOT_HANDLE_ACTION_CALLBACK;
+}
+
+int CvGlobals::getUSE_CAN_BUILD_CALLBACK()
+{
+	return m_iUSE_CAN_BUILD_CALLBACK;
+}
+
+int CvGlobals::getUSE_CANNOT_TRAIN_CALLBACK()
+{
+	return m_iUSE_CANNOT_TRAIN_CALLBACK;
+}
+
+int CvGlobals::getUSE_CAN_TRAIN_CALLBACK()
+{
+	return m_iUSE_CAN_TRAIN_CALLBACK;
+}
+
+int CvGlobals::getUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK()
+{
+	return m_iUSE_UNIT_CANNOT_MOVE_INTO_CALLBACK;
+}
+
+int CvGlobals::getUSE_FINISH_TEXT_CALLBACK()
+{
+	return m_iUSE_FINISH_TEXT_CALLBACK;
+}
+
+int CvGlobals::getUSE_ON_UNIT_SET_XY_CALLBACK()
+{
+	return m_iUSE_ON_UNIT_SET_XY_CALLBACK;
+}
+
+int CvGlobals::getUSE_ON_UNIT_SELECTED_CALLBACK()
+{
+	return m_iUSE_ON_UNIT_SELECTED_CALLBACK;
+}
+
+int CvGlobals::getUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK()
+{
+	return m_iUSE_ON_MISSIONARY_CONVERTED_UNIT_CALLBACK;
+}
+
+int CvGlobals::getUSE_ON_UPDATE_CALLBACK()
+{
+	return m_iUSE_ON_UPDATE_CALLBACK;
+}
+
+int CvGlobals::getUSE_ON_UNIT_CREATED_CALLBACK()
+{
+	return m_iUSE_ON_UNIT_CREATED_CALLBACK;
+}
+
+int CvGlobals::getUSE_ON_UNIT_LOST_CALLBACK()
+{
+	return m_iUSE_ON_UNIT_LOST_CALLBACK;
+}
+
+int CvGlobals::getMAX_CIV_PLAYERS()
+{
+	return MAX_PLAYERS;
+}
+
+int CvGlobals::getMAX_PLAYERS()
+{
+	return MAX_PLAYERS;
+}
+
+int CvGlobals::getMAX_CIV_TEAMS()
+{
+	return MAX_TEAMS;
+}
+
+int CvGlobals::getMAX_TEAMS()
+{
+	return MAX_TEAMS;
+}
+
+int CvGlobals::getINVALID_PLOT_COORD()
+{
+	return INVALID_PLOT_COORD;
+}
+
+int CvGlobals::getNUM_CITY_PLOTS()
+{
+	return NUM_CITY_PLOTS;
+}
+
+int CvGlobals::getCITY_HOME_PLOT()
+{
+	return CITY_HOME_PLOT;
+}
+
+void CvGlobals::setDLLIFace(CvDLLUtilityIFaceBase* pDll)
+{
+	m_pDLL = pDll;
+}
+
+int CvGlobals::getNUM_ENGINE_DIRTY_BITS() const
+{
+	return NUM_ENGINE_DIRTY_BITS;
+}
+
+int CvGlobals::getNUM_INTERFACE_DIRTY_BITS() const
+{
+	return NUM_INTERFACE_DIRTY_BITS;
+}
+
+int CvGlobals::getNUM_YIELD_TYPES() const
+{
+	return NUM_YIELD_TYPES;
+}
+
+int CvGlobals::getNUM_FORCECONTROL_TYPES() const
+{
+	return NUM_FORCECONTROL_TYPES;
+}
+
+int CvGlobals::getNUM_INFOBAR_TYPES() const
+{
+	return NUM_INFOBAR_TYPES;
+}
+
+int CvGlobals::getNUM_HEALTHBAR_TYPES() const
+{
+	return NUM_HEALTHBAR_TYPES;
+}
+
+int CvGlobals::getNUM_CONTROL_TYPES() const
+{
+	return NUM_CONTROL_TYPES;
+}
+
+int CvGlobals::getNUM_LEADERANIM_TYPES() const
+{
+	return NUM_LEADERANIM_TYPES;
+}
+
+
+void CvGlobals::deleteInfoArrays()
+{
+	for(int i=0;i<(int)m_aInfoVectors.size();i++)
+	{
+		deleteInfoArray(*m_aInfoVectors[i]);
+	}
+    //Androrc UnitArtStyles
+	//this probably isn't necessary, due to the loop just before, which wasn't present in the BTS code; however, I want to be safe.
+	deleteInfoArray(m_paUnitArtStyleTypeInfo);
+	//Androrc End
+	SAFE_DELETE_ARRAY(GC.getEntityEventTypes());
+	SAFE_DELETE_ARRAY(GC.getAnimationOperatorTypes());
+	SAFE_DELETE_ARRAY(GC.getFunctionTypes());
+	SAFE_DELETE_ARRAY(GC.getArtStyleTypes());
+	SAFE_DELETE_ARRAY(GC.getCitySizeTypes());
+	SAFE_DELETE_ARRAY(GC.getContactTypes());
+	SAFE_DELETE_ARRAY(GC.getDiplomacyPowerTypes());
+	SAFE_DELETE_ARRAY(GC.getAutomateTypes());
+	///TKs Med
+	SAFE_DELETE_ARRAY(GC.getMedCityTypes());
+	SAFE_DELETE_ARRAY(GC.getTradeScreenTypes());
+	SAFE_DELETE_ARRAY(GC.getModCodeTypes());
+	///TKe
+	SAFE_DELETE_ARRAY(GC.getDirectionTypes());
+	SAFE_DELETE_ARRAY(GC.getFootstepAudioTypes());
+	SAFE_DELETE_ARRAY(GC.getFootstepAudioTags());
+
+	clearTypesMap();
+	m_aInfoVectors.clear();
+}
+
+
+//
+// Global Infos Hash Map
+//
+
+int CvGlobals::getInfoTypeForString(const char* szType, bool hideAssert) const
+{
+	FAssertMsg(szType, "null info type string");
+	InfosMap::const_iterator it = m_infosMap.find(szType);
+	if (it!=m_infosMap.end())
+	{
+		return it->second;
+	}
+
+	if(!hideAssert)
+	{
+		CvString szError;
+		szError.Format("info type %s not found, Current XML file is: %s", szType, GC.getCurrentXMLFile().GetCString());
+		FAssertMsg(strcmp(szType, "NONE")==0 || strcmp(szType, "")==0, szError.c_str());
+		gDLL->logMsg("xml.log", szError);
+	}
+
+	return -1;
+}
+
+void CvGlobals::setInfoTypeFromString(const char* szType, int idx)
+{
+	FAssertMsg(szType, "null info type string");
+#ifdef _DEBUG
+	InfosMap::const_iterator it = m_infosMap.find(szType);
+	int iExisting = (it!=m_infosMap.end()) ? it->second : -1;
+	FAssertMsg(iExisting==-1 || iExisting==idx || strcmp(szType, "ERROR")==0, CvString::format("xml info type entry %s already exists", szType).c_str());
+#endif
+	m_infosMap[szType] = idx;
+}
+
+void CvGlobals::infoTypeFromStringReset()
+{
+	m_infosMap.clear();
+}
+
+void CvGlobals::addToInfosVectors(void *infoVector)
+{
+	std::vector<CvInfoBase *> *infoBaseVector = (std::vector<CvInfoBase *> *) infoVector;
+	m_aInfoVectors.push_back(infoBaseVector);
+}
+
+void CvGlobals::infosReset()
+{
+	for(int i=0;i<(int)m_aInfoVectors.size();i++)
+	{
+		std::vector<CvInfoBase *> *infoBaseVector = m_aInfoVectors[i];
+		for(int j=0;j<(int)infoBaseVector->size();j++)
+			infoBaseVector->at(j)->reset();
+	}
+}
+
+int CvGlobals::getNumDirections() const { return NUM_DIRECTION_TYPES; }
+int CvGlobals::getNumResourceLayers() const { return NUM_RESOURCE_LAYERS; }
+int CvGlobals::getNumUnitLayerOptionTypes() const { return NUM_UNIT_LAYER_OPTION_TYPES; }
+int CvGlobals::getNumGameOptions() const { return NUM_GAMEOPTION_TYPES; }
+int CvGlobals::getNumMPOptions() const { return NUM_MPOPTION_TYPES; }
+int CvGlobals::getNumSpecialOptions() const { return NUM_SPECIALOPTION_TYPES; }
+int CvGlobals::getNumGraphicOptions() const { return NUM_GRAPHICOPTION_TYPES; }
+int CvGlobals::getNumTradeableItems() const { return NUM_TRADEABLE_ITEMS; }
+int CvGlobals::getNumBasicItems() const { return NUM_BASIC_ITEMS; }
+int CvGlobals::getNumTradeableHeadings() const { return NUM_TRADEABLE_HEADINGS; }
+int CvGlobals::getNumCommandInfos() const { return NUM_COMMAND_TYPES; }
+int CvGlobals::getNumControlInfos() const { return NUM_CONTROL_TYPES; }
+int CvGlobals::getNumMissionInfos() const { return NUM_MISSION_TYPES; }
+int CvGlobals::getNumPlayerOptionInfos() const { return NUM_PLAYEROPTION_TYPES; }
+int CvGlobals::getMaxNumSymbols() const { return MAX_NUM_SYMBOLS; }
+int CvGlobals::getNumGraphicLevels() const { return NUM_GRAPHICLEVELS; }
+
+
+//
+// non-inline versions
+//
+CvMap& CvGlobals::getMap() { return *m_map; }
+CvGameAI& CvGlobals::getGame() { return *m_game; }
+CvGameAI *CvGlobals::getGamePointer(){ return m_game; }
+
+int CvGlobals::getMaxCivPlayers() const
+{
+	return MAX_PLAYERS;
+}
+
+bool CvGlobals::IsGraphicsInitialized() const { return m_bGraphicsInitialized;}
+void CvGlobals::SetGraphicsInitialized(bool bVal) { m_bGraphicsInitialized = bVal;}
+void CvGlobals::setInterface(CvInterface* pVal) { m_interface = pVal; }
+void CvGlobals::setDiplomacyScreen(CvDiplomacyScreen* pVal) { m_diplomacyScreen = pVal; }
+void CvGlobals::setMPDiplomacyScreen(CMPDiplomacyScreen* pVal) { m_mpDiplomacyScreen = pVal; }
+void CvGlobals::setMessageQueue(CMessageQueue* pVal) { m_messageQueue = pVal; }
+void CvGlobals::setHotJoinMessageQueue(CMessageQueue* pVal) { m_hotJoinMsgQueue = pVal; }
+void CvGlobals::setMessageControl(CMessageControl* pVal) { m_messageControl = pVal; }
+void CvGlobals::setSetupData(CvSetupData* pVal) { m_setupData = pVal; }
+void CvGlobals::setMessageCodeTranslator(CvMessageCodeTranslator* pVal) { m_messageCodes = pVal; }
+void CvGlobals::setDropMgr(CvDropMgr* pVal) { m_dropMgr = pVal; }
+void CvGlobals::setPortal(CvPortal* pVal) { m_portal = pVal; }
+void CvGlobals::setStatsReport(CvStatsReporter* pVal) { m_statsReporter = pVal; }
+void CvGlobals::setPathFinder(FAStar* pVal) { m_pathFinder = pVal; }
+void CvGlobals::setInterfacePathFinder(FAStar* pVal) { m_interfacePathFinder = pVal; }
+void CvGlobals::setStepFinder(FAStar* pVal) { m_stepFinder = pVal; }
+void CvGlobals::setRouteFinder(FAStar* pVal) { m_routeFinder = pVal; }
+void CvGlobals::setBorderFinder(FAStar* pVal) { m_borderFinder = pVal; }
+void CvGlobals::setAreaFinder(FAStar* pVal) { m_areaFinder = pVal; }
+CvDLLUtilityIFaceBase* CvGlobals::getDLLIFaceNonInl() { return m_pDLL; }
+
+
+// XML enum check - start - Nightinggale
+
+/*
+ * Certain XML files have their types hardcoded in enums.
+ * While this certainly increase execution speed, it also adds the risk that the XML and DLL goes out of sync.
+ * The following code is to detect desyncs when the game starts as undetected desyncs can cause havoc.
+ *
+ * This code is autogenerated based on the enums.
+ *    Nightinggale
+ */
+
+void CvGlobals::CheckEnumInterfaceModeTypes() const
+{
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_SELECTION).getType(), "INTERFACEMODE_SELECTION"), CvString::format("XML error. Found %s instead of INTERFACEMODE_SELECTION at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_SELECTION).getType(), INTERFACEMODE_SELECTION).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_PING).getType(), "INTERFACEMODE_PING"), CvString::format("XML error. Found %s instead of INTERFACEMODE_PING at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_PING).getType(), INTERFACEMODE_PING).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_SIGN).getType(), "INTERFACEMODE_SIGN"), CvString::format("XML error. Found %s instead of INTERFACEMODE_SIGN at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_SIGN).getType(), INTERFACEMODE_SIGN).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_GRIP).getType(), "INTERFACEMODE_GRIP"), CvString::format("XML error. Found %s instead of INTERFACEMODE_GRIP at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_GRIP).getType(), INTERFACEMODE_GRIP).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_GLOBELAYER_INPUT).getType(), "INTERFACEMODE_GLOBELAYER_INPUT"), CvString::format("XML error. Found %s instead of INTERFACEMODE_GLOBELAYER_INPUT at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_GLOBELAYER_INPUT).getType(), INTERFACEMODE_GLOBELAYER_INPUT).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_GO_TO).getType(), "INTERFACEMODE_GO_TO"), CvString::format("XML error. Found %s instead of INTERFACEMODE_GO_TO at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_GO_TO).getType(), INTERFACEMODE_GO_TO).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_GO_TO_TYPE).getType(), "INTERFACEMODE_GO_TO_TYPE"), CvString::format("XML error. Found %s instead of INTERFACEMODE_GO_TO_TYPE at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_GO_TO_TYPE).getType(), INTERFACEMODE_GO_TO_TYPE).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_GO_TO_ALL).getType(), "INTERFACEMODE_GO_TO_ALL"), CvString::format("XML error. Found %s instead of INTERFACEMODE_GO_TO_ALL at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_GO_TO_ALL).getType(), INTERFACEMODE_GO_TO_ALL).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_ROUTE_TO).getType(), "INTERFACEMODE_ROUTE_TO"), CvString::format("XML error. Found %s instead of INTERFACEMODE_ROUTE_TO at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_ROUTE_TO).getType(), INTERFACEMODE_ROUTE_TO).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_PYTHON_PICK_PLOT).getType(), "INTERFACEMODE_PYTHON_PICK_PLOT"), CvString::format("XML error. Found %s instead of INTERFACEMODE_PYTHON_PICK_PLOT at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_PYTHON_PICK_PLOT).getType(), INTERFACEMODE_PYTHON_PICK_PLOT).c_str());
+	FAssertMsg(!strcmp(GC.getInterfaceModeInfo(INTERFACEMODE_SAVE_PLOT_NIFS).getType(), "INTERFACEMODE_SAVE_PLOT_NIFS"), CvString::format("XML error. Found %s instead of INTERFACEMODE_SAVE_PLOT_NIFS at index %d", GC.getInterfaceModeInfo(INTERFACEMODE_SAVE_PLOT_NIFS).getType(), INTERFACEMODE_SAVE_PLOT_NIFS).c_str());
+
+	FAssertMsg(GC.getInterfaceModeInfo().size() == NUM_INTERFACEMODE_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_INTERFACEMODE_TYPES, GC.getInterfaceModeInfo().size()));
+}
+
+void CvGlobals::CheckEnumWorldSizeTypes() const
+{
+	FAssertMsg(!strcmp(GC.getWorldInfo(WORLDSIZE_TINY).getType(), "WORLDSIZE_TINY"), CvString::format("XML error. Found %s instead of WORLDSIZE_TINY at index %d", GC.getWorldInfo(WORLDSIZE_TINY).getType(), WORLDSIZE_TINY).c_str());
+	FAssertMsg(!strcmp(GC.getWorldInfo(WORLDSIZE_SMALL).getType(), "WORLDSIZE_SMALL"), CvString::format("XML error. Found %s instead of WORLDSIZE_SMALL at index %d", GC.getWorldInfo(WORLDSIZE_SMALL).getType(), WORLDSIZE_SMALL).c_str());
+	FAssertMsg(!strcmp(GC.getWorldInfo(WORLDSIZE_STANDARD).getType(), "WORLDSIZE_STANDARD"), CvString::format("XML error. Found %s instead of WORLDSIZE_STANDARD at index %d", GC.getWorldInfo(WORLDSIZE_STANDARD).getType(), WORLDSIZE_STANDARD).c_str());
+	FAssertMsg(!strcmp(GC.getWorldInfo(WORLDSIZE_LARGE).getType(), "WORLDSIZE_LARGE"), CvString::format("XML error. Found %s instead of WORLDSIZE_LARGE at index %d", GC.getWorldInfo(WORLDSIZE_LARGE).getType(), WORLDSIZE_LARGE).c_str());
+	FAssertMsg(!strcmp(GC.getWorldInfo(WORLDSIZE_HUGE).getType(), "WORLDSIZE_HUGE"), CvString::format("XML error. Found %s instead of WORLDSIZE_HUGE at index %d", GC.getWorldInfo(WORLDSIZE_HUGE).getType(), WORLDSIZE_HUGE).c_str());
+
+	FAssertMsg(GC.getWorldInfo().size() == NUM_WORLDSIZE_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_WORLDSIZE_TYPES, GC.getWorldInfo().size()));
+}
+
+void CvGlobals::CheckEnumGameOptionTypes() const
+{
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_ADVANCED_START).getType(), "GAMEOPTION_ADVANCED_START"), CvString::format("XML error. Found %s instead of GAMEOPTION_ADVANCED_START at index %d", GC.getGameOptionInfo(GAMEOPTION_ADVANCED_START).getType(), GAMEOPTION_ADVANCED_START).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_NO_CITY_RAZING).getType(), "GAMEOPTION_NO_CITY_RAZING"), CvString::format("XML error. Found %s instead of GAMEOPTION_NO_CITY_RAZING at index %d", GC.getGameOptionInfo(GAMEOPTION_NO_CITY_RAZING).getType(), GAMEOPTION_NO_CITY_RAZING).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_AGGRESSIVE_AI).getType(), "GAMEOPTION_AGGRESSIVE_AI"), CvString::format("XML error. Found %s instead of GAMEOPTION_AGGRESSIVE_AI at index %d", GC.getGameOptionInfo(GAMEOPTION_AGGRESSIVE_AI).getType(), GAMEOPTION_AGGRESSIVE_AI).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_NO_WILD_LAND_ANIMALS).getType(), "GAMEOPTION_NO_WILD_LAND_ANIMALS"), CvString::format("XML error. Found %s instead of GAMEOPTION_NO_WILD_LAND_ANIMALS at index %d", GC.getGameOptionInfo(GAMEOPTION_NO_WILD_LAND_ANIMALS).getType(), GAMEOPTION_NO_WILD_LAND_ANIMALS).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_NO_WILD_SEA_ANIMALS).getType(), "GAMEOPTION_NO_WILD_SEA_ANIMALS"), CvString::format("XML error. Found %s instead of GAMEOPTION_NO_WILD_SEA_ANIMALS at index %d", GC.getGameOptionInfo(GAMEOPTION_NO_WILD_SEA_ANIMALS).getType(), GAMEOPTION_NO_WILD_SEA_ANIMALS).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_LEAD_ANY_CIV).getType(), "GAMEOPTION_LEAD_ANY_CIV"), CvString::format("XML error. Found %s instead of GAMEOPTION_LEAD_ANY_CIV at index %d", GC.getGameOptionInfo(GAMEOPTION_LEAD_ANY_CIV).getType(), GAMEOPTION_LEAD_ANY_CIV).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_PERMANENT_ALLIANCES).getType(), "GAMEOPTION_PERMANENT_ALLIANCES"), CvString::format("XML error. Found %s instead of GAMEOPTION_PERMANENT_ALLIANCES at index %d", GC.getGameOptionInfo(GAMEOPTION_PERMANENT_ALLIANCES).getType(), GAMEOPTION_PERMANENT_ALLIANCES).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_ALWAYS_WAR).getType(), "GAMEOPTION_ALWAYS_WAR"), CvString::format("XML error. Found %s instead of GAMEOPTION_ALWAYS_WAR at index %d", GC.getGameOptionInfo(GAMEOPTION_ALWAYS_WAR).getType(), GAMEOPTION_ALWAYS_WAR).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_ALWAYS_PEACE).getType(), "GAMEOPTION_ALWAYS_PEACE"), CvString::format("XML error. Found %s instead of GAMEOPTION_ALWAYS_PEACE at index %d", GC.getGameOptionInfo(GAMEOPTION_ALWAYS_PEACE).getType(), GAMEOPTION_ALWAYS_PEACE).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_ONE_CITY_CHALLENGE).getType(), "GAMEOPTION_ONE_CITY_CHALLENGE"), CvString::format("XML error. Found %s instead of GAMEOPTION_ONE_CITY_CHALLENGE at index %d", GC.getGameOptionInfo(GAMEOPTION_ONE_CITY_CHALLENGE).getType(), GAMEOPTION_ONE_CITY_CHALLENGE).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_NO_CHANGING_WAR_PEACE).getType(), "GAMEOPTION_NO_CHANGING_WAR_PEACE"), CvString::format("XML error. Found %s instead of GAMEOPTION_NO_CHANGING_WAR_PEACE at index %d", GC.getGameOptionInfo(GAMEOPTION_NO_CHANGING_WAR_PEACE).getType(), GAMEOPTION_NO_CHANGING_WAR_PEACE).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_NEW_RANDOM_SEED).getType(), "GAMEOPTION_NEW_RANDOM_SEED"), CvString::format("XML error. Found %s instead of GAMEOPTION_NEW_RANDOM_SEED at index %d", GC.getGameOptionInfo(GAMEOPTION_NEW_RANDOM_SEED).getType(), GAMEOPTION_NEW_RANDOM_SEED).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_LOCK_MODS).getType(), "GAMEOPTION_LOCK_MODS"), CvString::format("XML error. Found %s instead of GAMEOPTION_LOCK_MODS at index %d", GC.getGameOptionInfo(GAMEOPTION_LOCK_MODS).getType(), GAMEOPTION_LOCK_MODS).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_NO_GOODY_HUTS).getType(), "GAMEOPTION_NO_GOODY_HUTS"), CvString::format("XML error. Found %s instead of GAMEOPTION_NO_GOODY_HUTS at index %d", GC.getGameOptionInfo(GAMEOPTION_NO_GOODY_HUTS).getType(), GAMEOPTION_NO_GOODY_HUTS).c_str());
+	FAssertMsg(!strcmp(GC.getGameOptionInfo(GAMEOPTION_NO_EVENTS).getType(), "GAMEOPTION_NO_EVENTS"), CvString::format("XML error. Found %s instead of GAMEOPTION_NO_EVENTS at index %d", GC.getGameOptionInfo(GAMEOPTION_NO_EVENTS).getType(), GAMEOPTION_NO_EVENTS).c_str());
+
+	FAssertMsg(GC.getGameOptionInfo().size() == NUM_GAMEOPTION_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_GAMEOPTION_TYPES, GC.getGameOptionInfo().size()));
+}
+
+void CvGlobals::CheckEnumPlayerOptionTypes() const
+{
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_TUTORIAL).getType(), "PLAYEROPTION_TUTORIAL"), CvString::format("XML error. Found %s instead of PLAYEROPTION_TUTORIAL at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_TUTORIAL).getType(), PLAYEROPTION_TUTORIAL).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_ADVISOR_POPUPS).getType(), "PLAYEROPTION_ADVISOR_POPUPS"), CvString::format("XML error. Found %s instead of PLAYEROPTION_ADVISOR_POPUPS at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_ADVISOR_POPUPS).getType(), PLAYEROPTION_ADVISOR_POPUPS).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_ADVISOR_HELP).getType(), "PLAYEROPTION_ADVISOR_HELP"), CvString::format("XML error. Found %s instead of PLAYEROPTION_ADVISOR_HELP at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_ADVISOR_HELP).getType(), PLAYEROPTION_ADVISOR_HELP).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_WAIT_END_TURN).getType(), "PLAYEROPTION_WAIT_END_TURN"), CvString::format("XML error. Found %s instead of PLAYEROPTION_WAIT_END_TURN at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_WAIT_END_TURN).getType(), PLAYEROPTION_WAIT_END_TURN).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_MINIMIZE_POP_UPS).getType(), "PLAYEROPTION_MINIMIZE_POP_UPS"), CvString::format("XML error. Found %s instead of PLAYEROPTION_MINIMIZE_POP_UPS at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_MINIMIZE_POP_UPS).getType(), PLAYEROPTION_MINIMIZE_POP_UPS).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_SHOW_FRIENDLY_MOVES).getType(), "PLAYEROPTION_SHOW_FRIENDLY_MOVES"), CvString::format("XML error. Found %s instead of PLAYEROPTION_SHOW_FRIENDLY_MOVES at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_SHOW_FRIENDLY_MOVES).getType(), PLAYEROPTION_SHOW_FRIENDLY_MOVES).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_SHOW_ENEMY_MOVES).getType(), "PLAYEROPTION_SHOW_ENEMY_MOVES"), CvString::format("XML error. Found %s instead of PLAYEROPTION_SHOW_ENEMY_MOVES at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_SHOW_ENEMY_MOVES).getType(), PLAYEROPTION_SHOW_ENEMY_MOVES).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_QUICK_MOVES).getType(), "PLAYEROPTION_QUICK_MOVES"), CvString::format("XML error. Found %s instead of PLAYEROPTION_QUICK_MOVES at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_QUICK_MOVES).getType(), PLAYEROPTION_QUICK_MOVES).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_QUICK_ATTACK).getType(), "PLAYEROPTION_QUICK_ATTACK"), CvString::format("XML error. Found %s instead of PLAYEROPTION_QUICK_ATTACK at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_QUICK_ATTACK).getType(), PLAYEROPTION_QUICK_ATTACK).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_QUICK_DEFENSE).getType(), "PLAYEROPTION_QUICK_DEFENSE"), CvString::format("XML error. Found %s instead of PLAYEROPTION_QUICK_DEFENSE at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_QUICK_DEFENSE).getType(), PLAYEROPTION_QUICK_DEFENSE).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_STACK_ATTACK).getType(), "PLAYEROPTION_STACK_ATTACK"), CvString::format("XML error. Found %s instead of PLAYEROPTION_STACK_ATTACK at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_STACK_ATTACK).getType(), PLAYEROPTION_STACK_ATTACK).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_AUTO_PROMOTION).getType(), "PLAYEROPTION_AUTO_PROMOTION"), CvString::format("XML error. Found %s instead of PLAYEROPTION_AUTO_PROMOTION at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_AUTO_PROMOTION).getType(), PLAYEROPTION_AUTO_PROMOTION).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_SAFE_AUTOMATION).getType(), "PLAYEROPTION_SAFE_AUTOMATION"), CvString::format("XML error. Found %s instead of PLAYEROPTION_SAFE_AUTOMATION at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_SAFE_AUTOMATION).getType(), PLAYEROPTION_SAFE_AUTOMATION).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_NUMPAD_HELP).getType(), "PLAYEROPTION_NUMPAD_HELP"), CvString::format("XML error. Found %s instead of PLAYEROPTION_NUMPAD_HELP at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_NUMPAD_HELP).getType(), PLAYEROPTION_NUMPAD_HELP).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_NO_UNIT_CYCLING).getType(), "PLAYEROPTION_NO_UNIT_CYCLING"), CvString::format("XML error. Found %s instead of PLAYEROPTION_NO_UNIT_CYCLING at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_NO_UNIT_CYCLING).getType(), PLAYEROPTION_NO_UNIT_CYCLING).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_NO_UNIT_RECOMMENDATIONS).getType(), "PLAYEROPTION_NO_UNIT_RECOMMENDATIONS"), CvString::format("XML error. Found %s instead of PLAYEROPTION_NO_UNIT_RECOMMENDATIONS at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_NO_UNIT_RECOMMENDATIONS).getType(), PLAYEROPTION_NO_UNIT_RECOMMENDATIONS).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_RIGHT_CLICK_MENU).getType(), "PLAYEROPTION_RIGHT_CLICK_MENU"), CvString::format("XML error. Found %s instead of PLAYEROPTION_RIGHT_CLICK_MENU at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_RIGHT_CLICK_MENU).getType(), PLAYEROPTION_RIGHT_CLICK_MENU).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_LEAVE_FORESTS).getType(), "PLAYEROPTION_LEAVE_FORESTS"), CvString::format("XML error. Found %s instead of PLAYEROPTION_LEAVE_FORESTS at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_LEAVE_FORESTS).getType(), PLAYEROPTION_LEAVE_FORESTS).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_1).getType(), "PLAYEROPTION_MODDER_1"), CvString::format("XML error. Found %s instead of PLAYEROPTION_MODDER_1 at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_1).getType(), PLAYEROPTION_MODDER_1).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_2).getType(), "PLAYEROPTION_MODDER_2"), CvString::format("XML error. Found %s instead of PLAYEROPTION_MODDER_2 at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_2).getType(), PLAYEROPTION_MODDER_2).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_3).getType(), "PLAYEROPTION_MODDER_3"), CvString::format("XML error. Found %s instead of PLAYEROPTION_MODDER_3 at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_3).getType(), PLAYEROPTION_MODDER_3).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_4).getType(), "PLAYEROPTION_MODDER_4"), CvString::format("XML error. Found %s instead of PLAYEROPTION_MODDER_4 at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_4).getType(), PLAYEROPTION_MODDER_4).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_5).getType(), "PLAYEROPTION_MODDER_5"), CvString::format("XML error. Found %s instead of PLAYEROPTION_MODDER_5 at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_5).getType(), PLAYEROPTION_MODDER_5).c_str());
+	FAssertMsg(!strcmp(GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_6).getType(), "PLAYEROPTION_MODDER_6"), CvString::format("XML error. Found %s instead of PLAYEROPTION_MODDER_6 at index %d", GC.getPlayerOptionInfo(PLAYEROPTION_MODDER_6).getType(), PLAYEROPTION_MODDER_6).c_str());
+
+	FAssertMsg(GC.getPlayerOptionInfo().size() == NUM_PLAYEROPTION_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_PLAYEROPTION_TYPES, GC.getPlayerOptionInfo().size()));
+}
+
+void CvGlobals::CheckEnumGraphicOptionTypes() const
+{
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_HEALTH_BARS).getType(), "GRAPHICOPTION_HEALTH_BARS"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_HEALTH_BARS at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_HEALTH_BARS).getType(), GRAPHICOPTION_HEALTH_BARS).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_NO_COMBAT_ZOOM).getType(), "GRAPHICOPTION_NO_COMBAT_ZOOM"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_NO_COMBAT_ZOOM at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_NO_COMBAT_ZOOM).getType(), GRAPHICOPTION_NO_COMBAT_ZOOM).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_NO_ENEMY_GLOW).getType(), "GRAPHICOPTION_NO_ENEMY_GLOW"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_NO_ENEMY_GLOW at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_NO_ENEMY_GLOW).getType(), GRAPHICOPTION_NO_ENEMY_GLOW).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_FROZEN_ANIMATIONS).getType(), "GRAPHICOPTION_FROZEN_ANIMATIONS"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_FROZEN_ANIMATIONS at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_FROZEN_ANIMATIONS).getType(), GRAPHICOPTION_FROZEN_ANIMATIONS).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_EFFECTS_DISABLED).getType(), "GRAPHICOPTION_EFFECTS_DISABLED"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_EFFECTS_DISABLED at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_EFFECTS_DISABLED).getType(), GRAPHICOPTION_EFFECTS_DISABLED).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED).getType(), "GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED).getType(), GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_FULLSCREEN).getType(), "GRAPHICOPTION_FULLSCREEN"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_FULLSCREEN at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_FULLSCREEN).getType(), GRAPHICOPTION_FULLSCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_LOWRES_TEXTURES).getType(), "GRAPHICOPTION_LOWRES_TEXTURES"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_LOWRES_TEXTURES at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_LOWRES_TEXTURES).getType(), GRAPHICOPTION_LOWRES_TEXTURES).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_HIRES_TERRAIN).getType(), "GRAPHICOPTION_HIRES_TERRAIN"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_HIRES_TERRAIN at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_HIRES_TERRAIN).getType(), GRAPHICOPTION_HIRES_TERRAIN).c_str());
+	FAssertMsg(!strcmp(GC.getGraphicOptionInfo(GRAPHICOPTION_NO_MOVIES).getType(), "GRAPHICOPTION_NO_MOVIES"), CvString::format("XML error. Found %s instead of GRAPHICOPTION_NO_MOVIES at index %d", GC.getGraphicOptionInfo(GRAPHICOPTION_NO_MOVIES).getType(), GRAPHICOPTION_NO_MOVIES).c_str());
+
+	FAssertMsg(GC.getGraphicOptionInfo().size() == NUM_GRAPHICOPTION_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_GRAPHICOPTION_TYPES, GC.getGraphicOptionInfo().size()));
+}
+
+void CvGlobals::CheckEnumForceControlTypes() const
+{
+	FAssertMsg(!strcmp(GC.getForceControlInfo(FORCECONTROL_SPEED).getType(), "FORCECONTROL_SPEED"), CvString::format("XML error. Found %s instead of FORCECONTROL_SPEED at index %d", GC.getForceControlInfo(FORCECONTROL_SPEED).getType(), FORCECONTROL_SPEED).c_str());
+	FAssertMsg(!strcmp(GC.getForceControlInfo(FORCECONTROL_HANDICAP).getType(), "FORCECONTROL_HANDICAP"), CvString::format("XML error. Found %s instead of FORCECONTROL_HANDICAP at index %d", GC.getForceControlInfo(FORCECONTROL_HANDICAP).getType(), FORCECONTROL_HANDICAP).c_str());
+	FAssertMsg(!strcmp(GC.getForceControlInfo(FORCECONTROL_OPTIONS).getType(), "FORCECONTROL_OPTIONS"), CvString::format("XML error. Found %s instead of FORCECONTROL_OPTIONS at index %d", GC.getForceControlInfo(FORCECONTROL_OPTIONS).getType(), FORCECONTROL_OPTIONS).c_str());
+	FAssertMsg(!strcmp(GC.getForceControlInfo(FORCECONTROL_VICTORIES).getType(), "FORCECONTROL_VICTORIES"), CvString::format("XML error. Found %s instead of FORCECONTROL_VICTORIES at index %d", GC.getForceControlInfo(FORCECONTROL_VICTORIES).getType(), FORCECONTROL_VICTORIES).c_str());
+	FAssertMsg(!strcmp(GC.getForceControlInfo(FORCECONTROL_MAX_TURNS).getType(), "FORCECONTROL_MAX_TURNS"), CvString::format("XML error. Found %s instead of FORCECONTROL_MAX_TURNS at index %d", GC.getForceControlInfo(FORCECONTROL_MAX_TURNS).getType(), FORCECONTROL_MAX_TURNS).c_str());
+	FAssertMsg(!strcmp(GC.getForceControlInfo(FORCECONTROL_MAX_CITY_ELIMINATION).getType(), "FORCECONTROL_MAX_CITY_ELIMINATION"), CvString::format("XML error. Found %s instead of FORCECONTROL_MAX_CITY_ELIMINATION at index %d", GC.getForceControlInfo(FORCECONTROL_MAX_CITY_ELIMINATION).getType(), FORCECONTROL_MAX_CITY_ELIMINATION).c_str());
+	FAssertMsg(!strcmp(GC.getForceControlInfo(FORCECONTROL_ADVANCED_START).getType(), "FORCECONTROL_ADVANCED_START"), CvString::format("XML error. Found %s instead of FORCECONTROL_ADVANCED_START at index %d", GC.getForceControlInfo(FORCECONTROL_ADVANCED_START).getType(), FORCECONTROL_ADVANCED_START).c_str());
+
+	FAssertMsg(GC.getForceControlInfo().size() == NUM_FORCECONTROL_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_FORCECONTROL_TYPES, GC.getForceControlInfo().size()));
+}
+
+void CvGlobals::CheckEnumDenialTypes() const
+{
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_UNKNOWN).getType(), "DENIAL_UNKNOWN"), CvString::format("XML error. Found %s instead of DENIAL_UNKNOWN at index %d", GC.getDenialInfo(DENIAL_UNKNOWN).getType(), DENIAL_UNKNOWN).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_NEVER).getType(), "DENIAL_NEVER"), CvString::format("XML error. Found %s instead of DENIAL_NEVER at index %d", GC.getDenialInfo(DENIAL_NEVER).getType(), DENIAL_NEVER).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_TOO_MUCH).getType(), "DENIAL_TOO_MUCH"), CvString::format("XML error. Found %s instead of DENIAL_TOO_MUCH at index %d", GC.getDenialInfo(DENIAL_TOO_MUCH).getType(), DENIAL_TOO_MUCH).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_MYSTERY).getType(), "DENIAL_MYSTERY"), CvString::format("XML error. Found %s instead of DENIAL_MYSTERY at index %d", GC.getDenialInfo(DENIAL_MYSTERY).getType(), DENIAL_MYSTERY).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_JOKING).getType(), "DENIAL_JOKING"), CvString::format("XML error. Found %s instead of DENIAL_JOKING at index %d", GC.getDenialInfo(DENIAL_JOKING).getType(), DENIAL_JOKING).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_CONTACT_THEM).getType(), "DENIAL_CONTACT_THEM"), CvString::format("XML error. Found %s instead of DENIAL_CONTACT_THEM at index %d", GC.getDenialInfo(DENIAL_CONTACT_THEM).getType(), DENIAL_CONTACT_THEM).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_VICTORY).getType(), "DENIAL_VICTORY"), CvString::format("XML error. Found %s instead of DENIAL_VICTORY at index %d", GC.getDenialInfo(DENIAL_VICTORY).getType(), DENIAL_VICTORY).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_ATTITUDE).getType(), "DENIAL_ATTITUDE"), CvString::format("XML error. Found %s instead of DENIAL_ATTITUDE at index %d", GC.getDenialInfo(DENIAL_ATTITUDE).getType(), DENIAL_ATTITUDE).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_ATTITUDE_THEM).getType(), "DENIAL_ATTITUDE_THEM"), CvString::format("XML error. Found %s instead of DENIAL_ATTITUDE_THEM at index %d", GC.getDenialInfo(DENIAL_ATTITUDE_THEM).getType(), DENIAL_ATTITUDE_THEM).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_POWER_US).getType(), "DENIAL_POWER_US"), CvString::format("XML error. Found %s instead of DENIAL_POWER_US at index %d", GC.getDenialInfo(DENIAL_POWER_US).getType(), DENIAL_POWER_US).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_POWER_YOU).getType(), "DENIAL_POWER_YOU"), CvString::format("XML error. Found %s instead of DENIAL_POWER_YOU at index %d", GC.getDenialInfo(DENIAL_POWER_YOU).getType(), DENIAL_POWER_YOU).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_POWER_THEM).getType(), "DENIAL_POWER_THEM"), CvString::format("XML error. Found %s instead of DENIAL_POWER_THEM at index %d", GC.getDenialInfo(DENIAL_POWER_THEM).getType(), DENIAL_POWER_THEM).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_TOO_MANY_WARS).getType(), "DENIAL_TOO_MANY_WARS"), CvString::format("XML error. Found %s instead of DENIAL_TOO_MANY_WARS at index %d", GC.getDenialInfo(DENIAL_TOO_MANY_WARS).getType(), DENIAL_TOO_MANY_WARS).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_NO_GAIN).getType(), "DENIAL_NO_GAIN"), CvString::format("XML error. Found %s instead of DENIAL_NO_GAIN at index %d", GC.getDenialInfo(DENIAL_NO_GAIN).getType(), DENIAL_NO_GAIN).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_NOT_INTERESTED).getType(), "DENIAL_NOT_INTERESTED"), CvString::format("XML error. Found %s instead of DENIAL_NOT_INTERESTED at index %d", GC.getDenialInfo(DENIAL_NOT_INTERESTED).getType(), DENIAL_NOT_INTERESTED).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_NOT_ALLIED).getType(), "DENIAL_NOT_ALLIED"), CvString::format("XML error. Found %s instead of DENIAL_NOT_ALLIED at index %d", GC.getDenialInfo(DENIAL_NOT_ALLIED).getType(), DENIAL_NOT_ALLIED).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_RECENT_CANCEL).getType(), "DENIAL_RECENT_CANCEL"), CvString::format("XML error. Found %s instead of DENIAL_RECENT_CANCEL at index %d", GC.getDenialInfo(DENIAL_RECENT_CANCEL).getType(), DENIAL_RECENT_CANCEL).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_WORST_ENEMY).getType(), "DENIAL_WORST_ENEMY"), CvString::format("XML error. Found %s instead of DENIAL_WORST_ENEMY at index %d", GC.getDenialInfo(DENIAL_WORST_ENEMY).getType(), DENIAL_WORST_ENEMY).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_POWER_YOUR_ENEMIES).getType(), "DENIAL_POWER_YOUR_ENEMIES"), CvString::format("XML error. Found %s instead of DENIAL_POWER_YOUR_ENEMIES at index %d", GC.getDenialInfo(DENIAL_POWER_YOUR_ENEMIES).getType(), DENIAL_POWER_YOUR_ENEMIES).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_TOO_FAR).getType(), "DENIAL_TOO_FAR"), CvString::format("XML error. Found %s instead of DENIAL_TOO_FAR at index %d", GC.getDenialInfo(DENIAL_TOO_FAR).getType(), DENIAL_TOO_FAR).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_WAR_NOT_POSSIBLE_US).getType(), "DENIAL_WAR_NOT_POSSIBLE_US"), CvString::format("XML error. Found %s instead of DENIAL_WAR_NOT_POSSIBLE_US at index %d", GC.getDenialInfo(DENIAL_WAR_NOT_POSSIBLE_US).getType(), DENIAL_WAR_NOT_POSSIBLE_US).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_WAR_NOT_POSSIBLE_YOU).getType(), "DENIAL_WAR_NOT_POSSIBLE_YOU"), CvString::format("XML error. Found %s instead of DENIAL_WAR_NOT_POSSIBLE_YOU at index %d", GC.getDenialInfo(DENIAL_WAR_NOT_POSSIBLE_YOU).getType(), DENIAL_WAR_NOT_POSSIBLE_YOU).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_PEACE_NOT_POSSIBLE_US).getType(), "DENIAL_PEACE_NOT_POSSIBLE_US"), CvString::format("XML error. Found %s instead of DENIAL_PEACE_NOT_POSSIBLE_US at index %d", GC.getDenialInfo(DENIAL_PEACE_NOT_POSSIBLE_US).getType(), DENIAL_PEACE_NOT_POSSIBLE_US).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_PEACE_NOT_POSSIBLE_YOU).getType(), "DENIAL_PEACE_NOT_POSSIBLE_YOU"), CvString::format("XML error. Found %s instead of DENIAL_PEACE_NOT_POSSIBLE_YOU at index %d", GC.getDenialInfo(DENIAL_PEACE_NOT_POSSIBLE_YOU).getType(), DENIAL_PEACE_NOT_POSSIBLE_YOU).c_str());
+	FAssertMsg(!strcmp(GC.getDenialInfo(DENIAL_CULTURE_YOU).getType(), "DENIAL_CULTURE_YOU"), CvString::format("XML error. Found %s instead of DENIAL_CULTURE_YOU at index %d", GC.getDenialInfo(DENIAL_CULTURE_YOU).getType(), DENIAL_CULTURE_YOU).c_str());
+
+	FAssertMsg(GC.getDenialInfo().size() == NUM_DENIAL_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_DENIAL_TYPES, GC.getDenialInfo().size()));
+}
+
+void CvGlobals::CheckEnumDomainTypes() const
+{
+	FAssertMsg(!strcmp(GC.getDomainInfo(DOMAIN_SEA).getType(), "DOMAIN_SEA"), CvString::format("XML error. Found %s instead of DOMAIN_SEA at index %d", GC.getDomainInfo(DOMAIN_SEA).getType(), DOMAIN_SEA).c_str());
+	FAssertMsg(!strcmp(GC.getDomainInfo(DOMAIN_LAND).getType(), "DOMAIN_LAND"), CvString::format("XML error. Found %s instead of DOMAIN_LAND at index %d", GC.getDomainInfo(DOMAIN_LAND).getType(), DOMAIN_LAND).c_str());
+	FAssertMsg(!strcmp(GC.getDomainInfo(DOMAIN_IMMOBILE).getType(), "DOMAIN_IMMOBILE"), CvString::format("XML error. Found %s instead of DOMAIN_IMMOBILE at index %d", GC.getDomainInfo(DOMAIN_IMMOBILE).getType(), DOMAIN_IMMOBILE).c_str());
+
+	FAssertMsg(GC.getDomainInfo().size() == NUM_DOMAIN_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_DOMAIN_TYPES, GC.getDomainInfo().size()));
+}
+
+void CvGlobals::CheckEnumUnitAITypes() const
+{
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_UNKNOWN).getType(), "UNITAI_UNKNOWN"), CvString::format("XML error. Found %s instead of UNITAI_UNKNOWN at index %d", GC.getUnitAIInfo(UNITAI_UNKNOWN).getType(), UNITAI_UNKNOWN).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_ANIMAL).getType(), "UNITAI_ANIMAL"), CvString::format("XML error. Found %s instead of UNITAI_ANIMAL at index %d", GC.getUnitAIInfo(UNITAI_ANIMAL).getType(), UNITAI_ANIMAL).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_COLONIST).getType(), "UNITAI_COLONIST"), CvString::format("XML error. Found %s instead of UNITAI_COLONIST at index %d", GC.getUnitAIInfo(UNITAI_COLONIST).getType(), UNITAI_COLONIST).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_SETTLER).getType(), "UNITAI_SETTLER"), CvString::format("XML error. Found %s instead of UNITAI_SETTLER at index %d", GC.getUnitAIInfo(UNITAI_SETTLER).getType(), UNITAI_SETTLER).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_WORKER).getType(), "UNITAI_WORKER"), CvString::format("XML error. Found %s instead of UNITAI_WORKER at index %d", GC.getUnitAIInfo(UNITAI_WORKER).getType(), UNITAI_WORKER).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_MISSIONARY).getType(), "UNITAI_MISSIONARY"), CvString::format("XML error. Found %s instead of UNITAI_MISSIONARY at index %d", GC.getUnitAIInfo(UNITAI_MISSIONARY).getType(), UNITAI_MISSIONARY).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_SCOUT).getType(), "UNITAI_SCOUT"), CvString::format("XML error. Found %s instead of UNITAI_SCOUT at index %d", GC.getUnitAIInfo(UNITAI_SCOUT).getType(), UNITAI_SCOUT).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_WAGON).getType(), "UNITAI_WAGON"), CvString::format("XML error. Found %s instead of UNITAI_WAGON at index %d", GC.getUnitAIInfo(UNITAI_WAGON).getType(), UNITAI_WAGON).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_TREASURE).getType(), "UNITAI_TREASURE"), CvString::format("XML error. Found %s instead of UNITAI_TREASURE at index %d", GC.getUnitAIInfo(UNITAI_TREASURE).getType(), UNITAI_TREASURE).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_YIELD).getType(), "UNITAI_YIELD"), CvString::format("XML error. Found %s instead of UNITAI_YIELD at index %d", GC.getUnitAIInfo(UNITAI_YIELD).getType(), UNITAI_YIELD).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_GENERAL).getType(), "UNITAI_GENERAL"), CvString::format("XML error. Found %s instead of UNITAI_GENERAL at index %d", GC.getUnitAIInfo(UNITAI_GENERAL).getType(), UNITAI_GENERAL).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_DEFENSIVE).getType(), "UNITAI_DEFENSIVE"), CvString::format("XML error. Found %s instead of UNITAI_DEFENSIVE at index %d", GC.getUnitAIInfo(UNITAI_DEFENSIVE).getType(), UNITAI_DEFENSIVE).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_OFFENSIVE).getType(), "UNITAI_OFFENSIVE"), CvString::format("XML error. Found %s instead of UNITAI_OFFENSIVE at index %d", GC.getUnitAIInfo(UNITAI_OFFENSIVE).getType(), UNITAI_OFFENSIVE).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_COUNTER).getType(), "UNITAI_COUNTER"), CvString::format("XML error. Found %s instead of UNITAI_COUNTER at index %d", GC.getUnitAIInfo(UNITAI_COUNTER).getType(), UNITAI_COUNTER).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_TRANSPORT_SEA).getType(), "UNITAI_TRANSPORT_SEA"), CvString::format("XML error. Found %s instead of UNITAI_TRANSPORT_SEA at index %d", GC.getUnitAIInfo(UNITAI_TRANSPORT_SEA).getType(), UNITAI_TRANSPORT_SEA).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_ASSAULT_SEA).getType(), "UNITAI_ASSAULT_SEA"), CvString::format("XML error. Found %s instead of UNITAI_ASSAULT_SEA at index %d", GC.getUnitAIInfo(UNITAI_ASSAULT_SEA).getType(), UNITAI_ASSAULT_SEA).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_COMBAT_SEA).getType(), "UNITAI_COMBAT_SEA"), CvString::format("XML error. Found %s instead of UNITAI_COMBAT_SEA at index %d", GC.getUnitAIInfo(UNITAI_COMBAT_SEA).getType(), UNITAI_COMBAT_SEA).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_PIRATE_SEA).getType(), "UNITAI_PIRATE_SEA"), CvString::format("XML error. Found %s instead of UNITAI_PIRATE_SEA at index %d", GC.getUnitAIInfo(UNITAI_PIRATE_SEA).getType(), UNITAI_PIRATE_SEA).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_TRADER).getType(), "UNITAI_TRADER"), CvString::format("XML error. Found %s instead of UNITAI_TRADER at index %d", GC.getUnitAIInfo(UNITAI_TRADER).getType(), UNITAI_TRADER).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_HUNTSMAN).getType(), "UNITAI_HUNTSMAN"), CvString::format("XML error. Found %s instead of UNITAI_HUNTSMAN at index %d", GC.getUnitAIInfo(UNITAI_HUNTSMAN).getType(), UNITAI_HUNTSMAN).c_str());
+	FAssertMsg(!strcmp(GC.getUnitAIInfo(UNITAI_MARAUDER).getType(), "UNITAI_MARAUDER"), CvString::format("XML error. Found %s instead of UNITAI_MARAUDER at index %d", GC.getUnitAIInfo(UNITAI_MARAUDER).getType(), UNITAI_MARAUDER).c_str());
+
+	FAssertMsg(GC.getUnitAIInfo().size() == NUM_UNITAI_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_UNITAI_TYPES, GC.getUnitAIInfo().size()));
+}
+
+void CvGlobals::CheckEnumMissionTypes() const
+{
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_MOVE_TO).getType(), "MISSION_MOVE_TO"), CvString::format("XML error. Found %s instead of MISSION_MOVE_TO at index %d", GC.getMissionInfo(MISSION_MOVE_TO).getType(), MISSION_MOVE_TO).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_ROUTE_TO).getType(), "MISSION_ROUTE_TO"), CvString::format("XML error. Found %s instead of MISSION_ROUTE_TO at index %d", GC.getMissionInfo(MISSION_ROUTE_TO).getType(), MISSION_ROUTE_TO).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_MOVE_TO_UNIT).getType(), "MISSION_MOVE_TO_UNIT"), CvString::format("XML error. Found %s instead of MISSION_MOVE_TO_UNIT at index %d", GC.getMissionInfo(MISSION_MOVE_TO_UNIT).getType(), MISSION_MOVE_TO_UNIT).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_SKIP).getType(), "MISSION_SKIP"), CvString::format("XML error. Found %s instead of MISSION_SKIP at index %d", GC.getMissionInfo(MISSION_SKIP).getType(), MISSION_SKIP).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_SLEEP).getType(), "MISSION_SLEEP"), CvString::format("XML error. Found %s instead of MISSION_SLEEP at index %d", GC.getMissionInfo(MISSION_SLEEP).getType(), MISSION_SLEEP).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_FORTIFY).getType(), "MISSION_FORTIFY"), CvString::format("XML error. Found %s instead of MISSION_FORTIFY at index %d", GC.getMissionInfo(MISSION_FORTIFY).getType(), MISSION_FORTIFY).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_HEAL).getType(), "MISSION_HEAL"), CvString::format("XML error. Found %s instead of MISSION_HEAL at index %d", GC.getMissionInfo(MISSION_HEAL).getType(), MISSION_HEAL).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_SENTRY).getType(), "MISSION_SENTRY"), CvString::format("XML error. Found %s instead of MISSION_SENTRY at index %d", GC.getMissionInfo(MISSION_SENTRY).getType(), MISSION_SENTRY).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_BOMBARD).getType(), "MISSION_BOMBARD"), CvString::format("XML error. Found %s instead of MISSION_BOMBARD at index %d", GC.getMissionInfo(MISSION_BOMBARD).getType(), MISSION_BOMBARD).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_PILLAGE).getType(), "MISSION_PILLAGE"), CvString::format("XML error. Found %s instead of MISSION_PILLAGE at index %d", GC.getMissionInfo(MISSION_PILLAGE).getType(), MISSION_PILLAGE).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_FOUND).getType(), "MISSION_FOUND"), CvString::format("XML error. Found %s instead of MISSION_FOUND at index %d", GC.getMissionInfo(MISSION_FOUND).getType(), MISSION_FOUND).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_JOIN_CITY).getType(), "MISSION_JOIN_CITY"), CvString::format("XML error. Found %s instead of MISSION_JOIN_CITY at index %d", GC.getMissionInfo(MISSION_JOIN_CITY).getType(), MISSION_JOIN_CITY).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_BUILD).getType(), "MISSION_BUILD"), CvString::format("XML error. Found %s instead of MISSION_BUILD at index %d", GC.getMissionInfo(MISSION_BUILD).getType(), MISSION_BUILD).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_LEAD).getType(), "MISSION_LEAD"), CvString::format("XML error. Found %s instead of MISSION_LEAD at index %d", GC.getMissionInfo(MISSION_LEAD).getType(), MISSION_LEAD).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_BEGIN_COMBAT).getType(), "MISSION_BEGIN_COMBAT"), CvString::format("XML error. Found %s instead of MISSION_BEGIN_COMBAT at index %d", GC.getMissionInfo(MISSION_BEGIN_COMBAT).getType(), MISSION_BEGIN_COMBAT).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_END_COMBAT).getType(), "MISSION_END_COMBAT"), CvString::format("XML error. Found %s instead of MISSION_END_COMBAT at index %d", GC.getMissionInfo(MISSION_END_COMBAT).getType(), MISSION_END_COMBAT).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_SURRENDER).getType(), "MISSION_SURRENDER"), CvString::format("XML error. Found %s instead of MISSION_SURRENDER at index %d", GC.getMissionInfo(MISSION_SURRENDER).getType(), MISSION_SURRENDER).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_CAPTURED).getType(), "MISSION_CAPTURED"), CvString::format("XML error. Found %s instead of MISSION_CAPTURED at index %d", GC.getMissionInfo(MISSION_CAPTURED).getType(), MISSION_CAPTURED).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_IDLE).getType(), "MISSION_IDLE"), CvString::format("XML error. Found %s instead of MISSION_IDLE at index %d", GC.getMissionInfo(MISSION_IDLE).getType(), MISSION_IDLE).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_DIE).getType(), "MISSION_DIE"), CvString::format("XML error. Found %s instead of MISSION_DIE at index %d", GC.getMissionInfo(MISSION_DIE).getType(), MISSION_DIE).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_DAMAGE).getType(), "MISSION_DAMAGE"), CvString::format("XML error. Found %s instead of MISSION_DAMAGE at index %d", GC.getMissionInfo(MISSION_DAMAGE).getType(), MISSION_DAMAGE).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_MULTI_SELECT).getType(), "MISSION_MULTI_SELECT"), CvString::format("XML error. Found %s instead of MISSION_MULTI_SELECT at index %d", GC.getMissionInfo(MISSION_MULTI_SELECT).getType(), MISSION_MULTI_SELECT).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_MULTI_DESELECT).getType(), "MISSION_MULTI_DESELECT"), CvString::format("XML error. Found %s instead of MISSION_MULTI_DESELECT at index %d", GC.getMissionInfo(MISSION_MULTI_DESELECT).getType(), MISSION_MULTI_DESELECT).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_FOUND_MONASTERY).getType(), "MISSION_FOUND_MONASTERY"), CvString::format("XML error. Found %s instead of MISSION_FOUND_MONASTERY at index %d", GC.getMissionInfo(MISSION_FOUND_MONASTERY).getType(), MISSION_FOUND_MONASTERY).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_FOUND_OUTPOST).getType(), "MISSION_FOUND_OUTPOST"), CvString::format("XML error. Found %s instead of MISSION_FOUND_OUTPOST at index %d", GC.getMissionInfo(MISSION_FOUND_OUTPOST).getType(), MISSION_FOUND_OUTPOST).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_COLLECT_TAXES).getType(), "MISSION_COLLECT_TAXES"), CvString::format("XML error. Found %s instead of MISSION_COLLECT_TAXES at index %d", GC.getMissionInfo(MISSION_COLLECT_TAXES).getType(), MISSION_COLLECT_TAXES).c_str());
+	FAssertMsg(!strcmp(GC.getMissionInfo(MISSION_HUNT).getType(), "MISSION_HUNT"), CvString::format("XML error. Found %s instead of MISSION_HUNT at index %d", GC.getMissionInfo(MISSION_HUNT).getType(), MISSION_HUNT).c_str());
+
+	FAssertMsg(GC.getMissionInfo().size() == NUM_MISSION_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_MISSION_TYPES, GC.getMissionInfo().size()));
+}
+
+void CvGlobals::CheckEnumCommandTypes() const
+{
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_PROMOTION).getType(), "COMMAND_PROMOTION"), CvString::format("XML error. Found %s instead of COMMAND_PROMOTION at index %d", GC.getCommandInfo(COMMAND_PROMOTION).getType(), COMMAND_PROMOTION).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_UPGRADE).getType(), "COMMAND_UPGRADE"), CvString::format("XML error. Found %s instead of COMMAND_UPGRADE at index %d", GC.getCommandInfo(COMMAND_UPGRADE).getType(), COMMAND_UPGRADE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_AUTOMATE).getType(), "COMMAND_AUTOMATE"), CvString::format("XML error. Found %s instead of COMMAND_AUTOMATE at index %d", GC.getCommandInfo(COMMAND_AUTOMATE).getType(), COMMAND_AUTOMATE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_WAKE).getType(), "COMMAND_WAKE"), CvString::format("XML error. Found %s instead of COMMAND_WAKE at index %d", GC.getCommandInfo(COMMAND_WAKE).getType(), COMMAND_WAKE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_CANCEL).getType(), "COMMAND_CANCEL"), CvString::format("XML error. Found %s instead of COMMAND_CANCEL at index %d", GC.getCommandInfo(COMMAND_CANCEL).getType(), COMMAND_CANCEL).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_CANCEL_ALL).getType(), "COMMAND_CANCEL_ALL"), CvString::format("XML error. Found %s instead of COMMAND_CANCEL_ALL at index %d", GC.getCommandInfo(COMMAND_CANCEL_ALL).getType(), COMMAND_CANCEL_ALL).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_STOP_AUTOMATION).getType(), "COMMAND_STOP_AUTOMATION"), CvString::format("XML error. Found %s instead of COMMAND_STOP_AUTOMATION at index %d", GC.getCommandInfo(COMMAND_STOP_AUTOMATION).getType(), COMMAND_STOP_AUTOMATION).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_DELETE).getType(), "COMMAND_DELETE"), CvString::format("XML error. Found %s instead of COMMAND_DELETE at index %d", GC.getCommandInfo(COMMAND_DELETE).getType(), COMMAND_DELETE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_GIFT).getType(), "COMMAND_GIFT"), CvString::format("XML error. Found %s instead of COMMAND_GIFT at index %d", GC.getCommandInfo(COMMAND_GIFT).getType(), COMMAND_GIFT).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_LOAD).getType(), "COMMAND_LOAD"), CvString::format("XML error. Found %s instead of COMMAND_LOAD at index %d", GC.getCommandInfo(COMMAND_LOAD).getType(), COMMAND_LOAD).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_LOAD_UNIT).getType(), "COMMAND_LOAD_UNIT"), CvString::format("XML error. Found %s instead of COMMAND_LOAD_UNIT at index %d", GC.getCommandInfo(COMMAND_LOAD_UNIT).getType(), COMMAND_LOAD_UNIT).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_LOAD_CARGO).getType(), "COMMAND_LOAD_CARGO"), CvString::format("XML error. Found %s instead of COMMAND_LOAD_CARGO at index %d", GC.getCommandInfo(COMMAND_LOAD_CARGO).getType(), COMMAND_LOAD_CARGO).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_LOAD_YIELD).getType(), "COMMAND_LOAD_YIELD"), CvString::format("XML error. Found %s instead of COMMAND_LOAD_YIELD at index %d", GC.getCommandInfo(COMMAND_LOAD_YIELD).getType(), COMMAND_LOAD_YIELD).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_UNLOAD).getType(), "COMMAND_UNLOAD"), CvString::format("XML error. Found %s instead of COMMAND_UNLOAD at index %d", GC.getCommandInfo(COMMAND_UNLOAD).getType(), COMMAND_UNLOAD).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_UNLOAD_ALL).getType(), "COMMAND_UNLOAD_ALL"), CvString::format("XML error. Found %s instead of COMMAND_UNLOAD_ALL at index %d", GC.getCommandInfo(COMMAND_UNLOAD_ALL).getType(), COMMAND_UNLOAD_ALL).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_LEARN).getType(), "COMMAND_LEARN"), CvString::format("XML error. Found %s instead of COMMAND_LEARN at index %d", GC.getCommandInfo(COMMAND_LEARN).getType(), COMMAND_LEARN).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_KING_TRANSPORT).getType(), "COMMAND_KING_TRANSPORT"), CvString::format("XML error. Found %s instead of COMMAND_KING_TRANSPORT at index %d", GC.getCommandInfo(COMMAND_KING_TRANSPORT).getType(), COMMAND_KING_TRANSPORT).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_ESTABLISH_MISSION).getType(), "COMMAND_ESTABLISH_MISSION"), CvString::format("XML error. Found %s instead of COMMAND_ESTABLISH_MISSION at index %d", GC.getCommandInfo(COMMAND_ESTABLISH_MISSION).getType(), COMMAND_ESTABLISH_MISSION).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_SPEAK_WITH_CHIEF).getType(), "COMMAND_SPEAK_WITH_CHIEF"), CvString::format("XML error. Found %s instead of COMMAND_SPEAK_WITH_CHIEF at index %d", GC.getCommandInfo(COMMAND_SPEAK_WITH_CHIEF).getType(), COMMAND_SPEAK_WITH_CHIEF).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_YIELD_TRADE).getType(), "COMMAND_YIELD_TRADE"), CvString::format("XML error. Found %s instead of COMMAND_YIELD_TRADE at index %d", GC.getCommandInfo(COMMAND_YIELD_TRADE).getType(), COMMAND_YIELD_TRADE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_SAIL_TO_EUROPE).getType(), "COMMAND_SAIL_TO_EUROPE"), CvString::format("XML error. Found %s instead of COMMAND_SAIL_TO_EUROPE at index %d", GC.getCommandInfo(COMMAND_SAIL_TO_EUROPE).getType(), COMMAND_SAIL_TO_EUROPE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_CHOOSE_TRADE_ROUTES).getType(), "COMMAND_CHOOSE_TRADE_ROUTES"), CvString::format("XML error. Found %s instead of COMMAND_CHOOSE_TRADE_ROUTES at index %d", GC.getCommandInfo(COMMAND_CHOOSE_TRADE_ROUTES).getType(), COMMAND_CHOOSE_TRADE_ROUTES).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_ASSIGN_TRADE_ROUTE).getType(), "COMMAND_ASSIGN_TRADE_ROUTE"), CvString::format("XML error. Found %s instead of COMMAND_ASSIGN_TRADE_ROUTE at index %d", GC.getCommandInfo(COMMAND_ASSIGN_TRADE_ROUTE).getType(), COMMAND_ASSIGN_TRADE_ROUTE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_PROMOTE).getType(), "COMMAND_PROMOTE"), CvString::format("XML error. Found %s instead of COMMAND_PROMOTE at index %d", GC.getCommandInfo(COMMAND_PROMOTE).getType(), COMMAND_PROMOTE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_PROFESSION).getType(), "COMMAND_PROFESSION"), CvString::format("XML error. Found %s instead of COMMAND_PROFESSION at index %d", GC.getCommandInfo(COMMAND_PROFESSION).getType(), COMMAND_PROFESSION).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_CLEAR_SPECIALTY).getType(), "COMMAND_CLEAR_SPECIALTY"), CvString::format("XML error. Found %s instead of COMMAND_CLEAR_SPECIALTY at index %d", GC.getCommandInfo(COMMAND_CLEAR_SPECIALTY).getType(), COMMAND_CLEAR_SPECIALTY).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_HOTKEY).getType(), "COMMAND_HOTKEY"), CvString::format("XML error. Found %s instead of COMMAND_HOTKEY at index %d", GC.getCommandInfo(COMMAND_HOTKEY).getType(), COMMAND_HOTKEY).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_CONVERT_UNIT).getType(), "COMMAND_CONVERT_UNIT"), CvString::format("XML error. Found %s instead of COMMAND_CONVERT_UNIT at index %d", GC.getCommandInfo(COMMAND_CONVERT_UNIT).getType(), COMMAND_CONVERT_UNIT).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_HOLD_FEAST).getType(), "COMMAND_HOLD_FEAST"), CvString::format("XML error. Found %s instead of COMMAND_HOLD_FEAST at index %d", GC.getCommandInfo(COMMAND_HOLD_FEAST).getType(), COMMAND_HOLD_FEAST).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_TRAVEL_TO_FAIR).getType(), "COMMAND_TRAVEL_TO_FAIR"), CvString::format("XML error. Found %s instead of COMMAND_TRAVEL_TO_FAIR at index %d", GC.getCommandInfo(COMMAND_TRAVEL_TO_FAIR).getType(), COMMAND_TRAVEL_TO_FAIR).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_SAIL_SPICE_ROUTE).getType(), "COMMAND_SAIL_SPICE_ROUTE"), CvString::format("XML error. Found %s instead of COMMAND_SAIL_SPICE_ROUTE at index %d", GC.getCommandInfo(COMMAND_SAIL_SPICE_ROUTE).getType(), COMMAND_SAIL_SPICE_ROUTE).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_TRAVEL_SILK_ROAD).getType(), "COMMAND_TRAVEL_SILK_ROAD"), CvString::format("XML error. Found %s instead of COMMAND_TRAVEL_SILK_ROAD at index %d", GC.getCommandInfo(COMMAND_TRAVEL_SILK_ROAD).getType(), COMMAND_TRAVEL_SILK_ROAD).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_ASSIGN_HOME_CITY).getType(), "COMMAND_ASSIGN_HOME_CITY"), CvString::format("XML error. Found %s instead of COMMAND_ASSIGN_HOME_CITY at index %d", GC.getCommandInfo(COMMAND_ASSIGN_HOME_CITY).getType(), COMMAND_ASSIGN_HOME_CITY).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_HIRE_GUARD).getType(), "COMMAND_HIRE_GUARD"), CvString::format("XML error. Found %s instead of COMMAND_HIRE_GUARD at index %d", GC.getCommandInfo(COMMAND_HIRE_GUARD).getType(), COMMAND_HIRE_GUARD).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_CALL_BANNERS).getType(), "COMMAND_CALL_BANNERS"), CvString::format("XML error. Found %s instead of COMMAND_CALL_BANNERS at index %d", GC.getCommandInfo(COMMAND_CALL_BANNERS).getType(), COMMAND_CALL_BANNERS).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_BUILD_HOME).getType(), "COMMAND_BUILD_HOME"), CvString::format("XML error. Found %s instead of COMMAND_BUILD_HOME at index %d", GC.getCommandInfo(COMMAND_BUILD_HOME).getType(), COMMAND_BUILD_HOME).c_str());
+	FAssertMsg(!strcmp(GC.getCommandInfo(COMMAND_BUILD_TRADINGPOST).getType(), "COMMAND_BUILD_TRADINGPOST"), CvString::format("XML error. Found %s instead of COMMAND_BUILD_TRADINGPOST at index %d", GC.getCommandInfo(COMMAND_BUILD_TRADINGPOST).getType(), COMMAND_BUILD_TRADINGPOST).c_str());
+
+	FAssertMsg(GC.getCommandInfo().size() == NUM_COMMAND_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_COMMAND_TYPES, GC.getCommandInfo().size()));
+}
+
+void CvGlobals::CheckEnumControlTypes() const
+{
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CENTERONSELECTION).getType(), "CONTROL_CENTERONSELECTION"), CvString::format("XML error. Found %s instead of CONTROL_CENTERONSELECTION at index %d", GC.getControlInfo(CONTROL_CENTERONSELECTION).getType(), CONTROL_CENTERONSELECTION).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SELECTYUNITTYPE).getType(), "CONTROL_SELECTYUNITTYPE"), CvString::format("XML error. Found %s instead of CONTROL_SELECTYUNITTYPE at index %d", GC.getControlInfo(CONTROL_SELECTYUNITTYPE).getType(), CONTROL_SELECTYUNITTYPE).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SELECTYUNITALL).getType(), "CONTROL_SELECTYUNITALL"), CvString::format("XML error. Found %s instead of CONTROL_SELECTYUNITALL at index %d", GC.getControlInfo(CONTROL_SELECTYUNITALL).getType(), CONTROL_SELECTYUNITALL).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SELECTCITY).getType(), "CONTROL_SELECTCITY"), CvString::format("XML error. Found %s instead of CONTROL_SELECTCITY at index %d", GC.getControlInfo(CONTROL_SELECTCITY).getType(), CONTROL_SELECTCITY).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SELECTCAPITAL).getType(), "CONTROL_SELECTCAPITAL"), CvString::format("XML error. Found %s instead of CONTROL_SELECTCAPITAL at index %d", GC.getControlInfo(CONTROL_SELECTCAPITAL).getType(), CONTROL_SELECTCAPITAL).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_NEXTCITY).getType(), "CONTROL_NEXTCITY"), CvString::format("XML error. Found %s instead of CONTROL_NEXTCITY at index %d", GC.getControlInfo(CONTROL_NEXTCITY).getType(), CONTROL_NEXTCITY).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_PREVCITY).getType(), "CONTROL_PREVCITY"), CvString::format("XML error. Found %s instead of CONTROL_PREVCITY at index %d", GC.getControlInfo(CONTROL_PREVCITY).getType(), CONTROL_PREVCITY).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_NEXTUNIT).getType(), "CONTROL_NEXTUNIT"), CvString::format("XML error. Found %s instead of CONTROL_NEXTUNIT at index %d", GC.getControlInfo(CONTROL_NEXTUNIT).getType(), CONTROL_NEXTUNIT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_PREVUNIT).getType(), "CONTROL_PREVUNIT"), CvString::format("XML error. Found %s instead of CONTROL_PREVUNIT at index %d", GC.getControlInfo(CONTROL_PREVUNIT).getType(), CONTROL_PREVUNIT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CYCLEUNIT).getType(), "CONTROL_CYCLEUNIT"), CvString::format("XML error. Found %s instead of CONTROL_CYCLEUNIT at index %d", GC.getControlInfo(CONTROL_CYCLEUNIT).getType(), CONTROL_CYCLEUNIT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CYCLEUNIT_ALT).getType(), "CONTROL_CYCLEUNIT_ALT"), CvString::format("XML error. Found %s instead of CONTROL_CYCLEUNIT_ALT at index %d", GC.getControlInfo(CONTROL_CYCLEUNIT_ALT).getType(), CONTROL_CYCLEUNIT_ALT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_LASTUNIT).getType(), "CONTROL_LASTUNIT"), CvString::format("XML error. Found %s instead of CONTROL_LASTUNIT at index %d", GC.getControlInfo(CONTROL_LASTUNIT).getType(), CONTROL_LASTUNIT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_ENDTURN).getType(), "CONTROL_ENDTURN"), CvString::format("XML error. Found %s instead of CONTROL_ENDTURN at index %d", GC.getControlInfo(CONTROL_ENDTURN).getType(), CONTROL_ENDTURN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_ENDTURN_ALT).getType(), "CONTROL_ENDTURN_ALT"), CvString::format("XML error. Found %s instead of CONTROL_ENDTURN_ALT at index %d", GC.getControlInfo(CONTROL_ENDTURN_ALT).getType(), CONTROL_ENDTURN_ALT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_FORCEENDTURN).getType(), "CONTROL_FORCEENDTURN"), CvString::format("XML error. Found %s instead of CONTROL_FORCEENDTURN at index %d", GC.getControlInfo(CONTROL_FORCEENDTURN).getType(), CONTROL_FORCEENDTURN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_AUTOMOVES).getType(), "CONTROL_AUTOMOVES"), CvString::format("XML error. Found %s instead of CONTROL_AUTOMOVES at index %d", GC.getControlInfo(CONTROL_AUTOMOVES).getType(), CONTROL_AUTOMOVES).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_PING).getType(), "CONTROL_PING"), CvString::format("XML error. Found %s instead of CONTROL_PING at index %d", GC.getControlInfo(CONTROL_PING).getType(), CONTROL_PING).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SIGN).getType(), "CONTROL_SIGN"), CvString::format("XML error. Found %s instead of CONTROL_SIGN at index %d", GC.getControlInfo(CONTROL_SIGN).getType(), CONTROL_SIGN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_GRID).getType(), "CONTROL_GRID"), CvString::format("XML error. Found %s instead of CONTROL_GRID at index %d", GC.getControlInfo(CONTROL_GRID).getType(), CONTROL_GRID).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_BARE_MAP).getType(), "CONTROL_BARE_MAP"), CvString::format("XML error. Found %s instead of CONTROL_BARE_MAP at index %d", GC.getControlInfo(CONTROL_BARE_MAP).getType(), CONTROL_BARE_MAP).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_YIELDS).getType(), "CONTROL_YIELDS"), CvString::format("XML error. Found %s instead of CONTROL_YIELDS at index %d", GC.getControlInfo(CONTROL_YIELDS).getType(), CONTROL_YIELDS).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_RESOURCE_ALL).getType(), "CONTROL_RESOURCE_ALL"), CvString::format("XML error. Found %s instead of CONTROL_RESOURCE_ALL at index %d", GC.getControlInfo(CONTROL_RESOURCE_ALL).getType(), CONTROL_RESOURCE_ALL).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_UNIT_ICONS).getType(), "CONTROL_UNIT_ICONS"), CvString::format("XML error. Found %s instead of CONTROL_UNIT_ICONS at index %d", GC.getControlInfo(CONTROL_UNIT_ICONS).getType(), CONTROL_UNIT_ICONS).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_GLOBELAYER).getType(), "CONTROL_GLOBELAYER"), CvString::format("XML error. Found %s instead of CONTROL_GLOBELAYER at index %d", GC.getControlInfo(CONTROL_GLOBELAYER).getType(), CONTROL_GLOBELAYER).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SCORES).getType(), "CONTROL_SCORES"), CvString::format("XML error. Found %s instead of CONTROL_SCORES at index %d", GC.getControlInfo(CONTROL_SCORES).getType(), CONTROL_SCORES).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_LOAD_GAME).getType(), "CONTROL_LOAD_GAME"), CvString::format("XML error. Found %s instead of CONTROL_LOAD_GAME at index %d", GC.getControlInfo(CONTROL_LOAD_GAME).getType(), CONTROL_LOAD_GAME).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_OPTIONS_SCREEN).getType(), "CONTROL_OPTIONS_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_OPTIONS_SCREEN at index %d", GC.getControlInfo(CONTROL_OPTIONS_SCREEN).getType(), CONTROL_OPTIONS_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_RETIRE).getType(), "CONTROL_RETIRE"), CvString::format("XML error. Found %s instead of CONTROL_RETIRE at index %d", GC.getControlInfo(CONTROL_RETIRE).getType(), CONTROL_RETIRE).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SAVE_GROUP).getType(), "CONTROL_SAVE_GROUP"), CvString::format("XML error. Found %s instead of CONTROL_SAVE_GROUP at index %d", GC.getControlInfo(CONTROL_SAVE_GROUP).getType(), CONTROL_SAVE_GROUP).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SAVE_NORMAL).getType(), "CONTROL_SAVE_NORMAL"), CvString::format("XML error. Found %s instead of CONTROL_SAVE_NORMAL at index %d", GC.getControlInfo(CONTROL_SAVE_NORMAL).getType(), CONTROL_SAVE_NORMAL).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_QUICK_SAVE).getType(), "CONTROL_QUICK_SAVE"), CvString::format("XML error. Found %s instead of CONTROL_QUICK_SAVE at index %d", GC.getControlInfo(CONTROL_QUICK_SAVE).getType(), CONTROL_QUICK_SAVE).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_QUICK_LOAD).getType(), "CONTROL_QUICK_LOAD"), CvString::format("XML error. Found %s instead of CONTROL_QUICK_LOAD at index %d", GC.getControlInfo(CONTROL_QUICK_LOAD).getType(), CONTROL_QUICK_LOAD).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_ORTHO_CAMERA).getType(), "CONTROL_ORTHO_CAMERA"), CvString::format("XML error. Found %s instead of CONTROL_ORTHO_CAMERA at index %d", GC.getControlInfo(CONTROL_ORTHO_CAMERA).getType(), CONTROL_ORTHO_CAMERA).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CYCLE_CAMERA_FLYING_MODES).getType(), "CONTROL_CYCLE_CAMERA_FLYING_MODES"), CvString::format("XML error. Found %s instead of CONTROL_CYCLE_CAMERA_FLYING_MODES at index %d", GC.getControlInfo(CONTROL_CYCLE_CAMERA_FLYING_MODES).getType(), CONTROL_CYCLE_CAMERA_FLYING_MODES).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_ISOMETRIC_CAMERA_LEFT).getType(), "CONTROL_ISOMETRIC_CAMERA_LEFT"), CvString::format("XML error. Found %s instead of CONTROL_ISOMETRIC_CAMERA_LEFT at index %d", GC.getControlInfo(CONTROL_ISOMETRIC_CAMERA_LEFT).getType(), CONTROL_ISOMETRIC_CAMERA_LEFT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_ISOMETRIC_CAMERA_RIGHT).getType(), "CONTROL_ISOMETRIC_CAMERA_RIGHT"), CvString::format("XML error. Found %s instead of CONTROL_ISOMETRIC_CAMERA_RIGHT at index %d", GC.getControlInfo(CONTROL_ISOMETRIC_CAMERA_RIGHT).getType(), CONTROL_ISOMETRIC_CAMERA_RIGHT).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_FLYING_CAMERA).getType(), "CONTROL_FLYING_CAMERA"), CvString::format("XML error. Found %s instead of CONTROL_FLYING_CAMERA at index %d", GC.getControlInfo(CONTROL_FLYING_CAMERA).getType(), CONTROL_FLYING_CAMERA).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_MOUSE_FLYING_CAMERA).getType(), "CONTROL_MOUSE_FLYING_CAMERA"), CvString::format("XML error. Found %s instead of CONTROL_MOUSE_FLYING_CAMERA at index %d", GC.getControlInfo(CONTROL_MOUSE_FLYING_CAMERA).getType(), CONTROL_MOUSE_FLYING_CAMERA).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_TOP_DOWN_CAMERA).getType(), "CONTROL_TOP_DOWN_CAMERA"), CvString::format("XML error. Found %s instead of CONTROL_TOP_DOWN_CAMERA at index %d", GC.getControlInfo(CONTROL_TOP_DOWN_CAMERA).getType(), CONTROL_TOP_DOWN_CAMERA).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CIVILOPEDIA).getType(), "CONTROL_CIVILOPEDIA"), CvString::format("XML error. Found %s instead of CONTROL_CIVILOPEDIA at index %d", GC.getControlInfo(CONTROL_CIVILOPEDIA).getType(), CONTROL_CIVILOPEDIA).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_FOREIGN_SCREEN).getType(), "CONTROL_FOREIGN_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_FOREIGN_SCREEN at index %d", GC.getControlInfo(CONTROL_FOREIGN_SCREEN).getType(), CONTROL_FOREIGN_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CONGRESS_SCREEN).getType(), "CONTROL_CONGRESS_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_CONGRESS_SCREEN at index %d", GC.getControlInfo(CONTROL_CONGRESS_SCREEN).getType(), CONTROL_CONGRESS_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_REVOLUTION_SCREEN).getType(), "CONTROL_REVOLUTION_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_REVOLUTION_SCREEN at index %d", GC.getControlInfo(CONTROL_REVOLUTION_SCREEN).getType(), CONTROL_REVOLUTION_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_EUROPE_SCREEN).getType(), "CONTROL_EUROPE_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_EUROPE_SCREEN at index %d", GC.getControlInfo(CONTROL_EUROPE_SCREEN).getType(), CONTROL_EUROPE_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_MILITARY_SCREEN).getType(), "CONTROL_MILITARY_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_MILITARY_SCREEN at index %d", GC.getControlInfo(CONTROL_MILITARY_SCREEN).getType(), CONTROL_MILITARY_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_FATHER_SCREEN).getType(), "CONTROL_FATHER_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_FATHER_SCREEN at index %d", GC.getControlInfo(CONTROL_FATHER_SCREEN).getType(), CONTROL_FATHER_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_TECHNOLOGY_SCREEN).getType(), "CONTROL_TECHNOLOGY_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_TECHNOLOGY_SCREEN at index %d", GC.getControlInfo(CONTROL_TECHNOLOGY_SCREEN).getType(), CONTROL_TECHNOLOGY_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_TRADE_SCREEN).getType(), "CONTROL_TRADE_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_TRADE_SCREEN at index %d", GC.getControlInfo(CONTROL_TRADE_SCREEN).getType(), CONTROL_TRADE_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SPICE_ROUTE_SCREEN).getType(), "CONTROL_SPICE_ROUTE_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_SPICE_ROUTE_SCREEN at index %d", GC.getControlInfo(CONTROL_SPICE_ROUTE_SCREEN).getType(), CONTROL_SPICE_ROUTE_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SILK_ROAD_SCREEN).getType(), "CONTROL_SILK_ROAD_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_SILK_ROAD_SCREEN at index %d", GC.getControlInfo(CONTROL_SILK_ROAD_SCREEN).getType(), CONTROL_SILK_ROAD_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_TRADE_FAIR_SCREEN).getType(), "CONTROL_TRADE_FAIR_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_TRADE_FAIR_SCREEN at index %d", GC.getControlInfo(CONTROL_TRADE_FAIR_SCREEN).getType(), CONTROL_TRADE_FAIR_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_IMMIGRATION_SCREEN).getType(), "CONTROL_IMMIGRATION_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_IMMIGRATION_SCREEN at index %d", GC.getControlInfo(CONTROL_IMMIGRATION_SCREEN).getType(), CONTROL_IMMIGRATION_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_TURN_LOG).getType(), "CONTROL_TURN_LOG"), CvString::format("XML error. Found %s instead of CONTROL_TURN_LOG at index %d", GC.getControlInfo(CONTROL_TURN_LOG).getType(), CONTROL_TURN_LOG).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CHAT_ALL).getType(), "CONTROL_CHAT_ALL"), CvString::format("XML error. Found %s instead of CONTROL_CHAT_ALL at index %d", GC.getControlInfo(CONTROL_CHAT_ALL).getType(), CONTROL_CHAT_ALL).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_CHAT_TEAM).getType(), "CONTROL_CHAT_TEAM"), CvString::format("XML error. Found %s instead of CONTROL_CHAT_TEAM at index %d", GC.getControlInfo(CONTROL_CHAT_TEAM).getType(), CONTROL_CHAT_TEAM).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_DOMESTIC_SCREEN).getType(), "CONTROL_DOMESTIC_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_DOMESTIC_SCREEN at index %d", GC.getControlInfo(CONTROL_DOMESTIC_SCREEN).getType(), CONTROL_DOMESTIC_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_VICTORY_SCREEN).getType(), "CONTROL_VICTORY_SCREEN"), CvString::format("XML error. Found %s instead of CONTROL_VICTORY_SCREEN at index %d", GC.getControlInfo(CONTROL_VICTORY_SCREEN).getType(), CONTROL_VICTORY_SCREEN).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_INFO).getType(), "CONTROL_INFO"), CvString::format("XML error. Found %s instead of CONTROL_INFO at index %d", GC.getControlInfo(CONTROL_INFO).getType(), CONTROL_INFO).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_GLOBE_VIEW).getType(), "CONTROL_GLOBE_VIEW"), CvString::format("XML error. Found %s instead of CONTROL_GLOBE_VIEW at index %d", GC.getControlInfo(CONTROL_GLOBE_VIEW).getType(), CONTROL_GLOBE_VIEW).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_DETAILS).getType(), "CONTROL_DETAILS"), CvString::format("XML error. Found %s instead of CONTROL_DETAILS at index %d", GC.getControlInfo(CONTROL_DETAILS).getType(), CONTROL_DETAILS).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_ADMIN_DETAILS).getType(), "CONTROL_ADMIN_DETAILS"), CvString::format("XML error. Found %s instead of CONTROL_ADMIN_DETAILS at index %d", GC.getControlInfo(CONTROL_ADMIN_DETAILS).getType(), CONTROL_ADMIN_DETAILS).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_HALL_OF_FAME).getType(), "CONTROL_HALL_OF_FAME"), CvString::format("XML error. Found %s instead of CONTROL_HALL_OF_FAME at index %d", GC.getControlInfo(CONTROL_HALL_OF_FAME).getType(), CONTROL_HALL_OF_FAME).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_WORLD_BUILDER).getType(), "CONTROL_WORLD_BUILDER"), CvString::format("XML error. Found %s instead of CONTROL_WORLD_BUILDER at index %d", GC.getControlInfo(CONTROL_WORLD_BUILDER).getType(), CONTROL_WORLD_BUILDER).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_DIPLOMACY).getType(), "CONTROL_DIPLOMACY"), CvString::format("XML error. Found %s instead of CONTROL_DIPLOMACY at index %d", GC.getControlInfo(CONTROL_DIPLOMACY).getType(), CONTROL_DIPLOMACY).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_SELECT_HEALTHY).getType(), "CONTROL_SELECT_HEALTHY"), CvString::format("XML error. Found %s instead of CONTROL_SELECT_HEALTHY at index %d", GC.getControlInfo(CONTROL_SELECT_HEALTHY).getType(), CONTROL_SELECT_HEALTHY).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_FREE_COLONY).getType(), "CONTROL_FREE_COLONY"), CvString::format("XML error. Found %s instead of CONTROL_FREE_COLONY at index %d", GC.getControlInfo(CONTROL_FREE_COLONY).getType(), CONTROL_FREE_COLONY).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_AI_AUTOPLAY).getType(), "CONTROL_AI_AUTOPLAY"), CvString::format("XML error. Found %s instead of CONTROL_AI_AUTOPLAY at index %d", GC.getControlInfo(CONTROL_AI_AUTOPLAY).getType(), CONTROL_AI_AUTOPLAY).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_AI_AUTOPLAY5).getType(), "CONTROL_AI_AUTOPLAY5"), CvString::format("XML error. Found %s instead of CONTROL_AI_AUTOPLAY5 at index %d", GC.getControlInfo(CONTROL_AI_AUTOPLAY5).getType(), CONTROL_AI_AUTOPLAY5).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_AI_AUTOPLAY25).getType(), "CONTROL_AI_AUTOPLAY25"), CvString::format("XML error. Found %s instead of CONTROL_AI_AUTOPLAY25 at index %d", GC.getControlInfo(CONTROL_AI_AUTOPLAY25).getType(), CONTROL_AI_AUTOPLAY25).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_AI_AUTOPLAY100).getType(), "CONTROL_AI_AUTOPLAY100"), CvString::format("XML error. Found %s instead of CONTROL_AI_AUTOPLAY100 at index %d", GC.getControlInfo(CONTROL_AI_AUTOPLAY100).getType(), CONTROL_AI_AUTOPLAY100).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_AI_AUTOPLAY_REV).getType(), "CONTROL_AI_AUTOPLAY_REV"), CvString::format("XML error. Found %s instead of CONTROL_AI_AUTOPLAY_REV at index %d", GC.getControlInfo(CONTROL_AI_AUTOPLAY_REV).getType(), CONTROL_AI_AUTOPLAY_REV).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_LEARN_TECH).getType(), "CONTROL_LEARN_TECH"), CvString::format("XML error. Found %s instead of CONTROL_LEARN_TECH at index %d", GC.getControlInfo(CONTROL_LEARN_TECH).getType(), CONTROL_LEARN_TECH).c_str());
+	FAssertMsg(!strcmp(GC.getControlInfo(CONTROL_FOR_TESTING).getType(), "CONTROL_FOR_TESTING"), CvString::format("XML error. Found %s instead of CONTROL_FOR_TESTING at index %d", GC.getControlInfo(CONTROL_FOR_TESTING).getType(), CONTROL_FOR_TESTING).c_str());
+
+	FAssertMsg(GC.getControlInfo().size() == NUM_CONTROL_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_CONTROL_TYPES, GC.getControlInfo().size()));
+}
+
+void CvGlobals::CheckEnumMemoryTypes() const
+{
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_DECLARED_WAR).getType(), "MEMORY_DECLARED_WAR"), CvString::format("XML error. Found %s instead of MEMORY_DECLARED_WAR at index %d", GC.getMemoryInfo(MEMORY_DECLARED_WAR).getType(), MEMORY_DECLARED_WAR).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_DECLARED_WAR_ON_FRIEND).getType(), "MEMORY_DECLARED_WAR_ON_FRIEND"), CvString::format("XML error. Found %s instead of MEMORY_DECLARED_WAR_ON_FRIEND at index %d", GC.getMemoryInfo(MEMORY_DECLARED_WAR_ON_FRIEND).getType(), MEMORY_DECLARED_WAR_ON_FRIEND).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_HIRED_WAR_ALLY).getType(), "MEMORY_HIRED_WAR_ALLY"), CvString::format("XML error. Found %s instead of MEMORY_HIRED_WAR_ALLY at index %d", GC.getMemoryInfo(MEMORY_HIRED_WAR_ALLY).getType(), MEMORY_HIRED_WAR_ALLY).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_RAZED_CITY).getType(), "MEMORY_RAZED_CITY"), CvString::format("XML error. Found %s instead of MEMORY_RAZED_CITY at index %d", GC.getMemoryInfo(MEMORY_RAZED_CITY).getType(), MEMORY_RAZED_CITY).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_GIVE_HELP).getType(), "MEMORY_GIVE_HELP"), CvString::format("XML error. Found %s instead of MEMORY_GIVE_HELP at index %d", GC.getMemoryInfo(MEMORY_GIVE_HELP).getType(), MEMORY_GIVE_HELP).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_REFUSED_HELP).getType(), "MEMORY_REFUSED_HELP"), CvString::format("XML error. Found %s instead of MEMORY_REFUSED_HELP at index %d", GC.getMemoryInfo(MEMORY_REFUSED_HELP).getType(), MEMORY_REFUSED_HELP).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_ACCEPT_DEMAND).getType(), "MEMORY_ACCEPT_DEMAND"), CvString::format("XML error. Found %s instead of MEMORY_ACCEPT_DEMAND at index %d", GC.getMemoryInfo(MEMORY_ACCEPT_DEMAND).getType(), MEMORY_ACCEPT_DEMAND).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_REJECTED_DEMAND).getType(), "MEMORY_REJECTED_DEMAND"), CvString::format("XML error. Found %s instead of MEMORY_REJECTED_DEMAND at index %d", GC.getMemoryInfo(MEMORY_REJECTED_DEMAND).getType(), MEMORY_REJECTED_DEMAND).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_ACCEPTED_JOIN_WAR).getType(), "MEMORY_ACCEPTED_JOIN_WAR"), CvString::format("XML error. Found %s instead of MEMORY_ACCEPTED_JOIN_WAR at index %d", GC.getMemoryInfo(MEMORY_ACCEPTED_JOIN_WAR).getType(), MEMORY_ACCEPTED_JOIN_WAR).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_DENIED_JOIN_WAR).getType(), "MEMORY_DENIED_JOIN_WAR"), CvString::format("XML error. Found %s instead of MEMORY_DENIED_JOIN_WAR at index %d", GC.getMemoryInfo(MEMORY_DENIED_JOIN_WAR).getType(), MEMORY_DENIED_JOIN_WAR).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_ACCEPTED_STOP_TRADING).getType(), "MEMORY_ACCEPTED_STOP_TRADING"), CvString::format("XML error. Found %s instead of MEMORY_ACCEPTED_STOP_TRADING at index %d", GC.getMemoryInfo(MEMORY_ACCEPTED_STOP_TRADING).getType(), MEMORY_ACCEPTED_STOP_TRADING).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_DENIED_STOP_TRADING).getType(), "MEMORY_DENIED_STOP_TRADING"), CvString::format("XML error. Found %s instead of MEMORY_DENIED_STOP_TRADING at index %d", GC.getMemoryInfo(MEMORY_DENIED_STOP_TRADING).getType(), MEMORY_DENIED_STOP_TRADING).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_STOPPED_TRADING).getType(), "MEMORY_STOPPED_TRADING"), CvString::format("XML error. Found %s instead of MEMORY_STOPPED_TRADING at index %d", GC.getMemoryInfo(MEMORY_STOPPED_TRADING).getType(), MEMORY_STOPPED_TRADING).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_STOPPED_TRADING_RECENT).getType(), "MEMORY_STOPPED_TRADING_RECENT"), CvString::format("XML error. Found %s instead of MEMORY_STOPPED_TRADING_RECENT at index %d", GC.getMemoryInfo(MEMORY_STOPPED_TRADING_RECENT).getType(), MEMORY_STOPPED_TRADING_RECENT).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_HIRED_TRADE_EMBARGO).getType(), "MEMORY_HIRED_TRADE_EMBARGO"), CvString::format("XML error. Found %s instead of MEMORY_HIRED_TRADE_EMBARGO at index %d", GC.getMemoryInfo(MEMORY_HIRED_TRADE_EMBARGO).getType(), MEMORY_HIRED_TRADE_EMBARGO).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_MADE_DEMAND).getType(), "MEMORY_MADE_DEMAND"), CvString::format("XML error. Found %s instead of MEMORY_MADE_DEMAND at index %d", GC.getMemoryInfo(MEMORY_MADE_DEMAND).getType(), MEMORY_MADE_DEMAND).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_MADE_DEMAND_RECENT).getType(), "MEMORY_MADE_DEMAND_RECENT"), CvString::format("XML error. Found %s instead of MEMORY_MADE_DEMAND_RECENT at index %d", GC.getMemoryInfo(MEMORY_MADE_DEMAND_RECENT).getType(), MEMORY_MADE_DEMAND_RECENT).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_CANCELLED_OPEN_BORDERS).getType(), "MEMORY_CANCELLED_OPEN_BORDERS"), CvString::format("XML error. Found %s instead of MEMORY_CANCELLED_OPEN_BORDERS at index %d", GC.getMemoryInfo(MEMORY_CANCELLED_OPEN_BORDERS).getType(), MEMORY_CANCELLED_OPEN_BORDERS).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_EVENT_GOOD_TO_US).getType(), "MEMORY_EVENT_GOOD_TO_US"), CvString::format("XML error. Found %s instead of MEMORY_EVENT_GOOD_TO_US at index %d", GC.getMemoryInfo(MEMORY_EVENT_GOOD_TO_US).getType(), MEMORY_EVENT_GOOD_TO_US).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_EVENT_BAD_TO_US).getType(), "MEMORY_EVENT_BAD_TO_US"), CvString::format("XML error. Found %s instead of MEMORY_EVENT_BAD_TO_US at index %d", GC.getMemoryInfo(MEMORY_EVENT_BAD_TO_US).getType(), MEMORY_EVENT_BAD_TO_US).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_LIBERATED_CITIES).getType(), "MEMORY_LIBERATED_CITIES"), CvString::format("XML error. Found %s instead of MEMORY_LIBERATED_CITIES at index %d", GC.getMemoryInfo(MEMORY_LIBERATED_CITIES).getType(), MEMORY_LIBERATED_CITIES).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_REFUSED_TAX).getType(), "MEMORY_REFUSED_TAX"), CvString::format("XML error. Found %s instead of MEMORY_REFUSED_TAX at index %d", GC.getMemoryInfo(MEMORY_REFUSED_TAX).getType(), MEMORY_REFUSED_TAX).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_REVENGE_TAKEN).getType(), "MEMORY_REVENGE_TAKEN"), CvString::format("XML error. Found %s instead of MEMORY_REVENGE_TAKEN at index %d", GC.getMemoryInfo(MEMORY_REVENGE_TAKEN).getType(), MEMORY_REVENGE_TAKEN).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_MISSIONARY_FAIL).getType(), "MEMORY_MISSIONARY_FAIL"), CvString::format("XML error. Found %s instead of MEMORY_MISSIONARY_FAIL at index %d", GC.getMemoryInfo(MEMORY_MISSIONARY_FAIL).getType(), MEMORY_MISSIONARY_FAIL).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_INSULTED).getType(), "MEMORY_INSULTED"), CvString::format("XML error. Found %s instead of MEMORY_INSULTED at index %d", GC.getMemoryInfo(MEMORY_INSULTED).getType(), MEMORY_INSULTED).c_str());
+	FAssertMsg(!strcmp(GC.getMemoryInfo(MEMORY_MADE_VASSAL_DEMAND).getType(), "MEMORY_MADE_VASSAL_DEMAND"), CvString::format("XML error. Found %s instead of MEMORY_MADE_VASSAL_DEMAND at index %d", GC.getMemoryInfo(MEMORY_MADE_VASSAL_DEMAND).getType(), MEMORY_MADE_VASSAL_DEMAND).c_str());
+
+	FAssertMsg(GC.getMemoryInfo().size() == NUM_MEMORY_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_MEMORY_TYPES, GC.getMemoryInfo().size()));
+}
+
+void CvGlobals::CheckEnumAttitudeTypes() const
+{
+	FAssertMsg(!strcmp(GC.getAttitudeInfo(ATTITUDE_FURIOUS).getType(), "ATTITUDE_FURIOUS"), CvString::format("XML error. Found %s instead of ATTITUDE_FURIOUS at index %d", GC.getAttitudeInfo(ATTITUDE_FURIOUS).getType(), ATTITUDE_FURIOUS).c_str());
+	FAssertMsg(!strcmp(GC.getAttitudeInfo(ATTITUDE_ANNOYED).getType(), "ATTITUDE_ANNOYED"), CvString::format("XML error. Found %s instead of ATTITUDE_ANNOYED at index %d", GC.getAttitudeInfo(ATTITUDE_ANNOYED).getType(), ATTITUDE_ANNOYED).c_str());
+	FAssertMsg(!strcmp(GC.getAttitudeInfo(ATTITUDE_CAUTIOUS).getType(), "ATTITUDE_CAUTIOUS"), CvString::format("XML error. Found %s instead of ATTITUDE_CAUTIOUS at index %d", GC.getAttitudeInfo(ATTITUDE_CAUTIOUS).getType(), ATTITUDE_CAUTIOUS).c_str());
+	FAssertMsg(!strcmp(GC.getAttitudeInfo(ATTITUDE_PLEASED).getType(), "ATTITUDE_PLEASED"), CvString::format("XML error. Found %s instead of ATTITUDE_PLEASED at index %d", GC.getAttitudeInfo(ATTITUDE_PLEASED).getType(), ATTITUDE_PLEASED).c_str());
+	FAssertMsg(!strcmp(GC.getAttitudeInfo(ATTITUDE_FRIENDLY).getType(), "ATTITUDE_FRIENDLY"), CvString::format("XML error. Found %s instead of ATTITUDE_FRIENDLY at index %d", GC.getAttitudeInfo(ATTITUDE_FRIENDLY).getType(), ATTITUDE_FRIENDLY).c_str());
+
+	FAssertMsg(GC.getAttitudeInfo().size() == NUM_ATTITUDE_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_ATTITUDE_TYPES, GC.getAttitudeInfo().size()));
+}
+// XML enum check - end - Nightinggale
+
+// cache XML - start - Nightinggale
+void CvGlobals::setXMLCache()
+{
+	if (m_cache_WEEKS_PER_MONTHS > 0)
+	{
+		// cache is already set.
+		return;
+	}
+
+	m_cache_ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES = getDefineINT("ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES");
+	m_cache_ADVANCED_START_CITY_COST = getDefineINT("ADVANCED_START_CITY_COST");
+	m_cache_ADVANCED_START_CITY_COST_INCREASE = getDefineINT("ADVANCED_START_CITY_COST_INCREASE");
+	m_cache_ADVANCED_START_CITY_PLACEMENT_MAX_RANGE = getDefineINT("ADVANCED_START_CITY_PLACEMENT_MAX_RANGE");
+	m_cache_ADVANCED_START_CULTURE_COST = getDefineINT("ADVANCED_START_CULTURE_COST"); 
+	m_cache_ADVANCED_START_MAX_UNITS_PER_CITY = getDefineINT("ADVANCED_START_MAX_UNITS_PER_CITY");
+	m_cache_ADVANCED_START_POPULATION_COST = getDefineINT("ADVANCED_START_POPULATION_COST");
+	m_cache_ADVANCED_START_POPULATION_COST_INCREASE = getDefineINT("ADVANCED_START_POPULATION_COST_INCREASE");
+	m_cache_ADVANCED_START_SIGHT_RANGE = getDefineINT("ADVANCED_START_SIGHT_RANGE");
+	m_cache_ADVANCED_START_VISIBILITY_COST = getDefineINT("ADVANCED_START_VISIBILITY_COST");
+	m_cache_ADVANCED_START_VISIBILITY_COST_INCREASE = getDefineINT("ADVANCED_START_VISIBILITY_COST_INCREASE");
+	m_cache_AI_ADVANCED_TECH_START = getDefineINT("AI_ADVANCED_TECH_START");
+	m_cache_AI_CAN_DISBAND_UNITS = getDefineINT("AI_CAN_DISBAND_UNITS");
+	m_cache_AI_CHEAT_AUTO_BUY = getDefineINT("AI_CHEAT_AUTO_BUY");
+	m_cache_AI_CHEAT_NEEDED_DEFENDERS = getDefineINT("AI_CHEAT_NEEDED_DEFENDERS");
+	m_cache_AI_CHEAT_SPICE = getDefineINT("AI_CHEAT_SPICE");
+	m_cache_AI_CHEAT_SPICE_BUY = getDefineINT("AI_CHEAT_SPICE_BUY");
+	m_cache_AI_CHEAT_SPICE_MULTIPLE = getDefineINT("AI_CHEAT_SPICE_MULTIPLE");
+	m_cache_AI_FAVORED_TERRAIN_MOD = getDefineINT("AI_FAVORED_TERRAIN_MOD");
+	m_cache_AI_HANDICAP_CASTLE = getDefineINT("AI_HANDICAP_CASTLE");
+	m_cache_AI_HANDICAP_MOTTE = getDefineINT("AI_HANDICAP_MOTTE");
+	m_cache_AI_MILITARY_PROFESSION_HACK = getDefineINT("AI_MILITARY_PROFESSION_HACK");
+	m_cache_AI_WAREHOUSE_MOD = getDefineINT("AI_WAREHOUSE_MOD");
+	m_cache_ALLIANCE_CULTURE_PERCENT_DENIAL = getDefineINT("ALLIANCE_CULTURE_PERCENT_DENIAL");
+	m_cache_ALLIANCE_PACT_PEACE_DENIAL = getDefineINT("ALLIANCE_PACT_PEACE_DENIAL");
+	m_cache_ANIMAL_BANDITS_GUARD_GOODY_TIMER = getDefineINT("ANIMAL_BANDITS_GUARD_GOODY_TIMER");
+	m_cache_AUTORESEARCH_ALL = getDefineINT("AUTORESEARCH_ALL");
+	m_cache_BANQUET_YIELD_AMOUNT = getDefineINT("BANQUET_YIELD_AMOUNT");
+	m_cache_BARBARIAN_CIVILIZATION = getDefineINT("BARBARIAN_CIVILIZATION");
+	m_cache_BARBARIAN_LEADER = getDefineINT("BARBARIAN_LEADER");
+	m_cache_BASE_CITY_GROWTH_THRESHOLD = getDefineINT("BASE_CITY_GROWTH_THRESHOLD");
+	m_cache_BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD = getDefineINT("BASE_CITY_LUXURY_FOOD_THRESHOLD_MOD");
+	m_cache_BASE_OCCUPATION_TURNS = getDefineINT("BASE_OCCUPATION_TURNS");
+	m_cache_BASE_UNIT_UPGRADE_COST = getDefineINT("BASE_UNIT_UPGRADE_COST");
+	m_cache_BUILDINGCLASS_TRAVEL_TO_FAIR = getDefineINT("BUILDINGCLASS_TRAVEL_TO_FAIR");
+	m_cache_BUILDING_PRODUCTION_DECAY_PERCENT = getDefineINT("BUILDING_PRODUCTION_DECAY_PERCENT");
+	m_cache_BUILDING_PRODUCTION_DECAY_TIME = getDefineINT("BUILDING_PRODUCTION_DECAY_TIME");
+	m_cache_BUILDING_PRODUCTION_PERCENT = getDefineINT("BUILDING_PRODUCTION_PERCENT");
+	m_cache_BUY_PLOT_BASE_CULTURE_COST = getDefineINT("BUY_PLOT_BASE_CULTURE_COST");
+	m_cache_BUY_PLOT_CULTURE_RANGE = getDefineINT("BUY_PLOT_CULTURE_RANGE");
+	m_cache_BUY_PLOT_MIN_CULTURE = getDefineINT("BUY_PLOT_MIN_CULTURE");
+	m_cache_BUY_PLOT_OWNED_COST_MODIFIER = getDefineINT("BUY_PLOT_OWNED_COST_MODIFIER");
+	m_cache_BUY_PLOT_SELLER_INCOME_PERCENT = getDefineINT("BUY_PLOT_SELLER_INCOME_PERCENT");
+	m_cache_CALENDER_YEAR_FIRST_CHANGE_TURN = getDefineINT("CALENDER_YEAR_FIRST_CHANGE_TURN");
+	m_cache_CALENDER_YEAR_FIRST_MULTIPLIER = getDefineINT("CALENDER_YEAR_FIRST_MULTIPLIER");
+	m_cache_CALENDER_YEAR_SECOND_CHANGE_TURN = getDefineINT("CALENDER_YEAR_SECOND_CHANGE_TURN");
+	m_cache_CALENDER_YEAR_SECOND_MULTIPLIER = getDefineINT("CALENDER_YEAR_SECOND_MULTIPLIER");
+	m_cache_CALENDER_YEAR_THIRD_MULTIPLIER = getDefineINT("CALENDER_YEAR_THIRD_MULTIPLIER");
+	m_cache_CAPITAL_BUILDINGCLASS = getDefineINT("CAPITAL_BUILDINGCLASS");
+	m_cache_CAPTURED_CARGO_RANDOM_AMOUNT = getDefineINT("CAPTURED_CARGO_RANDOM_AMOUNT");
+	m_cache_CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT = getDefineINT("CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT");
+	m_cache_CASTLES_TO_VILLAGES_RATIO = getDefineINT("CASTLES_TO_VILLAGES_RATIO");
+	m_cache_CHANCE_TO_CAPTURE_CRIMINALS = getDefineINT("CHANCE_TO_CAPTURE_CRIMINALS");
+	m_cache_CHEAT_TRAVEL_ALL = getDefineINT("CHEAT_TRAVEL_ALL");
+	m_cache_CITY_DEFENSE_DAMAGE_HEAL_RATE = getDefineINT("CITY_DEFENSE_DAMAGE_HEAL_RATE");
+	m_cache_CITY_FREE_CULTURE_GROWTH_FACTOR = getDefineINT("CITY_FREE_CULTURE_GROWTH_FACTOR");
+	m_cache_CITY_GROWTH_MULTIPLIER = getDefineINT("CITY_GROWTH_MULTIPLIER");
+	m_cache_CITY_HEAL_RATE = getDefineINT("CITY_HEAL_RATE");
+	m_cache_CITY_PILGRAM_RANDOM = getDefineINT("CITY_PILGRAM_RANDOM");
+	m_cache_CITY_SCREEN_FOG_ENABLED = getDefineINT("CITY_SCREEN_FOG_ENABLED");
+	m_cache_CITY_YIELD_CAPACITY = getDefineINT("CITY_YIELD_CAPACITY");
+	m_cache_CITY_YIELD_DECAY_PERCENT = getDefineINT("CITY_YIELD_DECAY_PERCENT");
+	m_cache_CIVICOPTION_INVENTIONS = getDefineINT("CIVICOPTION_INVENTIONS");
+	m_cache_COLONIAL_FORCED_PEACE_TURNS = getDefineINT("COLONIAL_FORCED_PEACE_TURNS");
+	m_cache_COMBAT_DAMAGE = getDefineINT("COMBAT_DAMAGE");
+	m_cache_COMBAT_DIE_SIDES = getDefineINT("COMBAT_DIE_SIDES");
+	m_cache_COMBAT_EXPERIENCE_IN_BORDERS_PERCENT = getDefineINT("COMBAT_EXPERIENCE_IN_BORDERS_PERCENT");
+	m_cache_CONSUME_EQUIPMENT_ON_FOUND = getDefineINT("CONSUME_EQUIPMENT_ON_FOUND");
+	m_cache_CONTACT_YIELD_GIFT_ENCOMEIDA_TIMER = getDefineINT("CONTACT_YIELD_GIFT_ENCOMEIDA_TIMER");
+	m_cache_CONTACT_YIELD_GIFT_TECH = getDefineINT("CONTACT_YIELD_GIFT_TECH");
+	m_cache_CULTURE_YIELD = getDefineINT("CULTURE_YIELD");
+	m_cache_DEAL_TRADE_RELATIONS_POINTS = getDefineINT("DEAL_TRADE_RELATIONS_POINTS");
+	m_cache_DEEP_WATER_TERRAIN = getDefineINT("DEEP_WATER_TERRAIN");
+	m_cache_DEFAULT_BUILD_CASTLE = getDefineINT("DEFAULT_BUILD_CASTLE");
+	m_cache_DEFAULT_BUILD_MOTTE_AND_BAILEY = getDefineINT("DEFAULT_BUILD_MOTTE_AND_BAILEY");
+	m_cache_DEFAULT_CENSURETYPE_ANATHEMA = getDefineINT("DEFAULT_CENSURETYPE_ANATHEMA");
+	m_cache_DEFAULT_CENSURETYPE_ANATHEMA_COUNT = getDefineINT("DEFAULT_CENSURETYPE_ANATHEMA_COUNT");
+	m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION = getDefineINT("DEFAULT_CENSURETYPE_EXCOMMUNICATION");
+	m_cache_DEFAULT_CENSURETYPE_EXCOMMUNICATION_COUNT = getDefineINT("DEFAULT_CENSURETYPE_EXCOMMUNICATION_COUNT");
+	m_cache_DEFAULT_CENSURETYPE_INTERDICT = getDefineINT("DEFAULT_CENSURETYPE_INTERDICT");
+	m_cache_DEFAULT_CENSURETYPE_INTERDICT_COUNT = getDefineINT("DEFAULT_CENSURETYPE_INTERDICT_COUNT");
+	m_cache_DEFAULT_COMBAT_FOR_TRAINING = getDefineINT("DEFAULT_COMBAT_FOR_TRAINING");
+	m_cache_DEFAULT_DAWN_POPULATION_UNIT = getDefineINT("DEFAULT_DAWN_POPULATION_UNIT");
+	m_cache_DEFAULT_FUEDALISM_TECH = getDefineINT("DEFAULT_FUEDALISM_TECH");
+	m_cache_DEFAULT_GRAIN_GROWTH_UNIT_CLASS = getDefineINT("DEFAULT_GRAIN_GROWTH_UNIT_CLASS");
+	m_cache_DEFAULT_HUNTSMAN_PROFESSION = getDefineINT("DEFAULT_HUNTSMAN_PROFESSION");
+	m_cache_DEFAULT_INVENTOR_CLASS = getDefineINT("DEFAULT_INVENTOR_CLASS");
+	m_cache_DEFAULT_KNIGHT_PROFESSION_PROMOTION = getDefineINT("DEFAULT_KNIGHT_PROFESSION_PROMOTION");
+	m_cache_DEFAULT_KNIGHT_PROMOTION = getDefineINT("DEFAULT_KNIGHT_PROMOTION");
+	m_cache_DEFAULT_MARAUDER_CLASS = getDefineINT("DEFAULT_MARAUDER_CLASS");
+	m_cache_DEFAULT_MARUADER_SEA_PROFESSION = getDefineINT("DEFAULT_MARUADER_SEA_PROFESSION");
+	m_cache_DEFAULT_NOBLEMAN_CLASS = getDefineINT("DEFAULT_NOBLEMAN_CLASS");
+	m_cache_DEFAULT_NOBLE_GROWTH_UNIT_CLASS = getDefineINT("DEFAULT_NOBLE_GROWTH_UNIT_CLASS");
+	m_cache_DEFAULT_PILGRAM_CLASS = getDefineINT("DEFAULT_PILGRAM_CLASS");
+	m_cache_DEFAULT_POPULATION_UNIT = getDefineINT("DEFAULT_POPULATION_UNIT");
+	m_cache_DEFAULT_SHRINE_CLASS = getDefineINT("DEFAULT_SHRINE_CLASS");
+	m_cache_DEFAULT_SLAVE_CLASS = getDefineINT("DEFAULT_SLAVE_CLASS");
+	m_cache_DEFAULT_SPECIALBUILDING_COURTHOUSE = getDefineINT("DEFAULT_SPECIALBUILDING_COURTHOUSE");
+	m_cache_DEFAULT_TEST_DEFINE = getDefineINT("DEFAULT_TEST_DEFINE");
+	m_cache_DEFAULT_TRAINED_PROMOTION = getDefineINT("DEFAULT_TRAINED_PROMOTION");
+	m_cache_DEFAULT_TREASURE_YIELD = getDefineINT("DEFAULT_TREASURE_YIELD");
+	m_cache_DEFAULT_UNTRAINED_PROMOTION = getDefineINT("DEFAULT_UNTRAINED_PROMOTION");
+	m_cache_DEFAULT_VIKING_ERA = getDefineINT("DEFAULT_VIKING_ERA");
+	m_cache_DEFAULT_YIELD_ARMOR_TYPE = getDefineINT("DEFAULT_YIELD_ARMOR_TYPE");
+	m_cache_DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT = getDefineINT("DIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT");
+	m_cache_DIPLOMACY_VALUE_REMAINDER = getDefineINT("DIPLOMACY_VALUE_REMAINDER");
+	m_cache_DOCKS_NEXT_UNITS = getDefineINT("DOCKS_NEXT_UNITS");
+	m_cache_EDUCATION_BASE_TUITION = getDefineINT("EDUCATION_BASE_TUITION");
+	m_cache_EDUCATION_THRESHOLD = getDefineINT("EDUCATION_THRESHOLD");
+	m_cache_EDUCATION_THRESHOLD_INCREASE = getDefineINT("EDUCATION_THRESHOLD_INCREASE");
+	m_cache_ENABLE_ALLIANCE_TRADING = getDefineINT("ENABLE_ALLIANCE_TRADING");
+	m_cache_ENABLE_DEFENSIVE_PACT_TRADING = getDefineINT("ENABLE_DEFENSIVE_PACT_TRADING");
+	m_cache_ENABLE_GOLD_TRADING = getDefineINT("ENABLE_GOLD_TRADING");
+	m_cache_ENABLE_MAP_TRADING = getDefineINT("ENABLE_MAP_TRADING");
+	m_cache_ENABLE_OPEN_BORDERS = getDefineINT("ENABLE_OPEN_BORDERS");
+	m_cache_END_GAME_DISPLAY_WARNING = getDefineINT("END_GAME_DISPLAY_WARNING");
+	m_cache_ENEMY_HEAL_RATE = getDefineINT("ENEMY_HEAL_RATE");
+	m_cache_ESTABLISH_TRADEPOST_COST = getDefineINT("ESTABLISH_TRADEPOST_COST");
+	m_cache_EUROPE_EAST = getDefineINT("EUROPE_EAST");
+	m_cache_EUROPE_MARKET_CORRELATION_PERCENT = getDefineINT("EUROPE_MARKET_CORRELATION_PERCENT");
+	m_cache_EVENT_PROBABILITY_ROLL_SIDES = getDefineINT("EVENT_PROBABILITY_ROLL_SIDES");
+	m_cache_EXPERIENCE_FROM_WITHDRAWL = getDefineINT("EXPERIENCE_FROM_WITHDRAWL");
+	m_cache_EXTRA_YIELD = getDefineINT("EXTRA_YIELD");
+	m_cache_FATHER_COST_EXTRA_TEAM_MEMBER_MODIFIER = getDefineINT("FATHER_COST_EXTRA_TEAM_MEMBER_MODIFIER");
+	m_cache_FATHER_POINT_REAL_TRADE = getDefineINT("FATHER_POINT_REAL_TRADE");
+	m_cache_FEATURE_PRODUCTION_YIELD_MAX_DISTANCE = getDefineINT("FEATURE_PRODUCTION_YIELD_MAX_DISTANCE");
+	m_cache_FIRST_EVENT_DELAY_TURNS = getDefineINT("FIRST_EVENT_DELAY_TURNS");
+	m_cache_FOUND_MONASTERY_NUMBER = getDefineINT("FOUND_MONASTERY_NUMBER");
+	m_cache_FOUND_MOTTE_AND_BAILEY_NUMBER = getDefineINT("FOUND_MOTTE_AND_BAILEY_NUMBER");
+	m_cache_FOUND_OUTPOST_NUMBER = getDefineINT("FOUND_OUTPOST_NUMBER");
+	m_cache_FOUND_VILLAGE_NUMBER = getDefineINT("FOUND_VILLAGE_NUMBER");
+	m_cache_FREE_CITY_ADJACENT_CULTURE = getDefineINT("FREE_CITY_ADJACENT_CULTURE");
+	m_cache_FREE_CITY_CULTURE = getDefineINT("FREE_CITY_CULTURE");
+	m_cache_FREE_PEASANT_CIVIC = getDefineINT("FREE_PEASANT_CIVIC");
+	m_cache_FRIENDLY_HEAL_RATE = getDefineINT("FRIENDLY_HEAL_RATE");
+	m_cache_GREAT_GENERALS_THRESHOLD = getDefineINT("GREAT_GENERALS_THRESHOLD");
+	m_cache_GREAT_GENERALS_THRESHOLD_INCREASE = getDefineINT("GREAT_GENERALS_THRESHOLD_INCREASE");
+	m_cache_GREAT_GENERALS_THRESHOLD_INCREASE_TEAM = getDefineINT("GREAT_GENERALS_THRESHOLD_INCREASE_TEAM");
+	m_cache_HIRE_GUARD_COST = getDefineINT("HIRE_GUARD_COST");
+	m_cache_HIRE_GUARD_PROMOTION = getDefineINT("HIRE_GUARD_PROMOTION");
+	m_cache_IMMIGRATION_MAX_CITY_DISTANCE = getDefineINT("IMMIGRATION_MAX_CITY_DISTANCE");
+	m_cache_IMMIGRATION_THRESHOLD = getDefineINT("IMMIGRATION_THRESHOLD");
+	m_cache_IMMIGRATION_THRESHOLD_INCREASE = getDefineINT("IMMIGRATION_THRESHOLD_INCREASE");
+	m_cache_IMMIGRATION_TRAVEL_MOD = getDefineINT("IMMIGRATION_TRAVEL_MOD");
+	m_cache_INDUSTRIAL_VICTORY_SINGLE_YIELD = getDefineINT("INDUSTRIAL_VICTORY_SINGLE_YIELD");
+	m_cache_INITIAL_AI_CITY_PRODUCTION = getDefineINT("INITIAL_AI_CITY_PRODUCTION");
+	m_cache_INITIAL_CITY_POPULATION = getDefineINT("INITIAL_CITY_POPULATION");
+	m_cache_INITIAL_CITY_ROUTE_TYPE = getDefineINT("INITIAL_CITY_ROUTE_TYPE");
+	m_cache_JUNGLE_FEATURE = getDefineINT("JUNGLE_FEATURE");
+	m_cache_KING_BUY_UNIT_PRICE_MODIFIER = getDefineINT("KING_BUY_UNIT_PRICE_MODIFIER");
+	m_cache_KING_INITIAL_UNIT_INCREASE = getDefineINT("KING_INITIAL_UNIT_INCREASE");
+	m_cache_KING_TRANSPORT_TREASURE_COMISSION = getDefineINT("KING_TRANSPORT_TREASURE_COMISSION");
+	m_cache_KNIGHT_RANSOM_MOD = getDefineINT("KNIGHT_RANSOM_MOD");
+	m_cache_LAKE_PLOT_RAND = getDefineINT("LAKE_PLOT_RAND");
+	m_cache_LAND_IMPROVEMENT = getDefineINT("LAND_IMPROVEMENT");
+	m_cache_LAND_TERRAIN = getDefineINT("LAND_TERRAIN");
+	m_cache_MARAUDERS_DAYSOUT_RANDOM = getDefineINT("MARAUDERS_DAYSOUT_RANDOM");
+	m_cache_MARAUDERS_TOWER_RANGE = getDefineINT("MARAUDERS_TOWER_RANGE");
+	m_cache_MARAUDER_CRUMBS_EVENT = getDefineINT("MARAUDER_CRUMBS_EVENT");
+	m_cache_MARAUDER_EVENT_DEFAULT_TURNS = getDefineINT("MARAUDER_EVENT_DEFAULT_TURNS");
+	m_cache_MAX_CITY_POPULATION_COMMUNE = getDefineINT("MAX_CITY_POPULATION_COMMUNE");
+	m_cache_MAX_CITY_POPULATION_VILLAGE = getDefineINT("MAX_CITY_POPULATION_VILLAGE");
+	m_cache_MAX_EXPERIENCE_AFTER_UPGRADE = getDefineINT("MAX_EXPERIENCE_AFTER_UPGRADE");
+	m_cache_MAX_EXPERIENCE_PER_COMBAT = getDefineINT("MAX_EXPERIENCE_PER_COMBAT");
+	m_cache_MAX_FORTIFY_TURNS = getDefineINT("MAX_FORTIFY_TURNS");
+	m_cache_MAX_INSULT_MODIFIER = getDefineINT("MAX_INSULT_MODIFIER");
+	m_cache_MAX_LEVEL_FROM_ANIMAL_XP = getDefineINT("MAX_LEVEL_FROM_ANIMAL_XP");
+	m_cache_MAX_MARAUDERS = getDefineINT("MAX_MARAUDERS");
+	m_cache_MAX_NUM_LANGUAGES = getDefineINT("MAX_NUM_LANGUAGES");
+	m_cache_MAX_PLOT_LIST_SIZE = getDefineINT("MAX_PLOT_LIST_SIZE");
+	m_cache_MAX_REBEL_COMBAT_MULTIPLER = getDefineINT("MAX_REBEL_COMBAT_MULTIPLER");
+	m_cache_MAX_TRAINED_EXPERIENCE = getDefineINT("MAX_TRAINED_EXPERIENCE");
+	m_cache_MAX_WITHDRAWAL_PROBABILITY = getDefineINT("MAX_WITHDRAWAL_PROBABILITY");
+	m_cache_MEDIEVAL_CENSURE = getDefineINT("MEDIEVAL_CENSURE");
+	m_cache_MEDIEVAL_TRADE_TECH = getDefineINT("MEDIEVAL_TRADE_TECH");
+	m_cache_MINIMAP_RENDER_SIZE = getDefineINT("MINIMAP_RENDER_SIZE");
+	m_cache_MIN_ANIMAL_STARTING_DISTANCE = getDefineINT("MIN_ANIMAL_STARTING_DISTANCE");
+	m_cache_MIN_CITY_YIELD_DECAY = getDefineINT("MIN_CITY_YIELD_DECAY");
+	m_cache_MIN_CIV_STARTING_DISTANCE = getDefineINT("MIN_CIV_STARTING_DISTANCE");
+	m_cache_MIN_EXPERIENCE_PER_COMBAT = getDefineINT("MIN_EXPERIENCE_PER_COMBAT");
+	m_cache_MIN_TIMER_UNIT_DOUBLE_MOVES = getDefineINT("MIN_TIMER_UNIT_DOUBLE_MOVES");
+	m_cache_MIN_WATER_SIZE_FOR_OCEAN = getDefineINT("MIN_WATER_SIZE_FOR_OCEAN");
+	m_cache_MISSIONARY_RATE_EFFECT_ON_SUCCESS = getDefineINT("MISSIONARY_RATE_EFFECT_ON_SUCCESS");
+	m_cache_MISSIONARY_THRESHOLD = getDefineINT("MISSIONARY_THRESHOLD");
+	m_cache_MISSIONARY_THRESHOLD_INCREASE = getDefineINT("MISSIONARY_THRESHOLD_INCREASE");
+	m_cache_MONASTERIES_TO_VILLAGES_RATIO = getDefineINT("MONASTERIES_TO_VILLAGES_RATIO");
+	m_cache_NATIVE_AUTO_SELL_PERCENT = getDefineINT("NATIVE_AUTO_SELL_PERCENT");
+	m_cache_NATIVE_GOODS_RAID_PERCENT = getDefineINT("NATIVE_GOODS_RAID_PERCENT");
+	m_cache_NATIVE_GROWTH_THRESHOLD_MULTIPLIER = getDefineINT("NATIVE_GROWTH_THRESHOLD_MULTIPLIER");
+	m_cache_NATIVE_HORSES_FOR_SALE = getDefineINT("NATIVE_HORSES_FOR_SALE");
+	m_cache_NATIVE_HORSES_FOR_SALE_PERCENT = getDefineINT("NATIVE_HORSES_FOR_SALE_PERCENT");
+	m_cache_NATIVE_TEACH_THRESHOLD_INCREASE = getDefineINT("NATIVE_TEACH_THRESHOLD_INCREASE");
+	m_cache_NATIVE_TECH = getDefineINT("NATIVE_TECH");
+	m_cache_NATIVE_TRADING_TRADEPOST = getDefineINT("NATIVE_TRADING_TRADEPOST");
+	m_cache_NEUTRAL_HEAL_RATE = getDefineINT("NEUTRAL_HEAL_RATE");
+	m_cache_NEW_CITY_BUILDING_VALUE_MODIFIER = getDefineINT("NEW_CITY_BUILDING_VALUE_MODIFIER");
+	m_cache_NEW_HURRY_MODIFIER = getDefineINT("NEW_HURRY_MODIFIER");
+	m_cache_NOBLE_FIELD_LABOR_PENALTY = getDefineINT("NOBLE_FIELD_LABOR_PENALTY");
+	m_cache_NO_BAD_GOODIES_EXPERIENCE_PERCENT = getDefineINT("NO_BAD_GOODIES_EXPERIENCE_PERCENT");
+	m_cache_NO_BAD_GOODIES_GOLD_PERCENT = getDefineINT("NO_BAD_GOODIES_GOLD_PERCENT");
+	m_cache_NO_CITY_SHORTAGE_MESSAGES = getDefineINT("NO_CITY_SHORTAGE_MESSAGES");
+	m_cache_NO_STARTING_PLOTS_IN_JUNGLE = getDefineINT("NO_STARTING_PLOTS_IN_JUNGLE");
+	m_cache_OCCUPATION_CULTURE_PERCENT_THRESHOLD = getDefineINT("OCCUPATION_CULTURE_PERCENT_THRESHOLD");
+	m_cache_OCCUPATION_TURNS_POPULATION_PERCENT = getDefineINT("OCCUPATION_TURNS_POPULATION_PERCENT");
+	m_cache_OWNERSHIP_SCORE_DURATION_THRESHOLD = getDefineINT("OWNERSHIP_SCORE_DURATION_THRESHOLD");
+	m_cache_OWN_TEAM_STARTING_MODIFIER = getDefineINT("OWN_TEAM_STARTING_MODIFIER");
+	m_cache_PEACE_TREATY_LENGTH = getDefineINT("PEACE_TREATY_LENGTH");
+	m_cache_PERCENT_TAX_ON_AUTOSELL_GOODS = getDefineINT("PERCENT_TAX_ON_AUTOSELL_GOODS");
+	m_cache_PILGRAM_OFFER_GOLD = getDefineINT("PILGRAM_OFFER_GOLD");
+	m_cache_PILGRAM_OFFER_GOLD_DISTANCE_MOD = getDefineINT("PILGRAM_OFFER_GOLD_DISTANCE_MOD");
+	m_cache_PLAYER_ALWAYS_RAZES_CITIES = getDefineINT("PLAYER_ALWAYS_RAZES_CITIES");
+	m_cache_PLOTS_PER_RIVER_EDGE = getDefineINT("PLOTS_PER_RIVER_EDGE");
+	m_cache_PLOT_VISIBILITY_RANGE = getDefineINT("PLOT_VISIBILITY_RANGE");
+	m_cache_PROFESSION_COAL_BURNER = getDefineINT("PROFESSION_COAL_BURNER");
+	m_cache_PROFESSION_INVENTOR = getDefineINT("PROFESSION_INVENTOR");
+	m_cache_PROLIFIC_INVENTOR_THRESHOLD_INCREASE = getDefineINT("PROLIFIC_INVENTOR_THRESHOLD_INCREASE");
+	m_cache_PROMOTION_BUILD_HOME = getDefineINT("PROMOTION_BUILD_HOME");
+	m_cache_RANDOM_TURNS_LOST_AT_SEA = getDefineINT("RANDOM_TURNS_LOST_AT_SEA");
+	m_cache_RAZING_CULTURAL_PERCENT_THRESHOLD = getDefineINT("RAZING_CULTURAL_PERCENT_THRESHOLD");
+	m_cache_REBEL_PERCENT_FOR_REVOLUTION = getDefineINT("REBEL_PERCENT_FOR_REVOLUTION");
+	m_cache_REBEL_SENTIMENT_BELLS_FACTOR = getDefineINT("REBEL_SENTIMENT_BELLS_FACTOR");
+	m_cache_REBEL_SENTIMENT_TURN_WEIGHT = getDefineINT("REBEL_SENTIMENT_TURN_WEIGHT");
+	m_cache_REVOLUTION_EUROPE_UNIT_SHIP_MODIFIER = getDefineINT("REVOLUTION_EUROPE_UNIT_SHIP_MODIFIER");
+	m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD = getDefineINT("REVOLUTION_EUROPE_UNIT_THRESHOLD");
+	m_cache_REVOLUTION_EUROPE_UNIT_THRESHOLD_INCREASE = getDefineINT("REVOLUTION_EUROPE_UNIT_THRESHOLD_INCREASE");
+	m_cache_RIVAL_TEAM_STARTING_MODIFIER = getDefineINT("RIVAL_TEAM_STARTING_MODIFIER");
+	m_cache_RIVER_SOURCE_MIN_RIVER_RANGE = getDefineINT("RIVER_SOURCE_MIN_RIVER_RANGE");
+	m_cache_RIVER_SOURCE_MIN_SEAWATER_RANGE = getDefineINT("RIVER_SOURCE_MIN_SEAWATER_RANGE");
+	m_cache_RUINS_IMPROVEMENT = getDefineINT("RUINS_IMPROVEMENT");
+	m_cache_SCORE_FATHER_FACTOR = getDefineINT("SCORE_FATHER_FACTOR");
+	m_cache_SCORE_LAND_FACTOR = getDefineINT("SCORE_LAND_FACTOR");
+	m_cache_SCORE_POPULATION_FACTOR = getDefineINT("SCORE_POPULATION_FACTOR");
+	m_cache_SCORE_TAX_FACTOR = getDefineINT("SCORE_TAX_FACTOR");
+	m_cache_SETTLEMENT_TREASURE_YIELD = getDefineINT("SETTLEMENT_TREASURE_YIELD");
+	m_cache_SHALLOW_WATER_TERRAIN = getDefineINT("SHALLOW_WATER_TERRAIN");
+	m_cache_SLAVE_FOOD_CONSUMPTION_PER_POPULATION = getDefineINT("SLAVE_FOOD_CONSUMPTION_PER_POPULATION");
+	m_cache_STANDARD_CALENDAR = getDefineINT("STANDARD_CALENDAR");
+	m_cache_STANDARD_CLIMATE = getDefineINT("STANDARD_CLIMATE");
+	m_cache_STANDARD_ERA = getDefineINT("STANDARD_ERA");
+	m_cache_STANDARD_GAMESPEED = getDefineINT("STANDARD_GAMESPEED");
+	m_cache_STANDARD_HANDICAP = getDefineINT("STANDARD_HANDICAP");
+	m_cache_STANDARD_SEALEVEL = getDefineINT("STANDARD_SEALEVEL");
+	m_cache_STANDARD_TURNTIMER = getDefineINT("STANDARD_TURNTIMER");
+	m_cache_STARTING_DISTANCE_PERCENT = getDefineINT("STARTING_DISTANCE_PERCENT");
+	m_cache_START_YEAR = getDefineINT("START_YEAR");
+	m_cache_STEAMWORKS_BUILDING = getDefineINT("STEAMWORKS_BUILDING");
+	m_cache_STEAMWORKS_CLASS_TYPE = getDefineINT("STEAMWORKS_CLASS_TYPE");
+	m_cache_TAX_INCREASE_CHANCE = getDefineINT("TAX_INCREASE_CHANCE");
+	m_cache_TAX_RATE_MAX_INCREASE = getDefineINT("TAX_RATE_MAX_INCREASE");
+	m_cache_TAX_TRADE_THRESHOLD = getDefineINT("TAX_TRADE_THRESHOLD");
+	m_cache_TAX_TRADE_THRESHOLD_ATTITUDE_PERCENT = getDefineINT("TAX_TRADE_THRESHOLD_ATTITUDE_PERCENT");
+	m_cache_TAX_TRADE_THRESHOLD_TAX_RATE_PERCENT = getDefineINT("TAX_TRADE_THRESHOLD_TAX_RATE_PERCENT");
+	m_cache_TK_AI_RESEARCH_COST_MOD_PERCENT = getDefineINT("TK_AI_RESEARCH_COST_MOD_PERCENT");
+	m_cache_TK_HUMAN_RESEARCH_COST_MOD_PERCENT = getDefineINT("TK_HUMAN_RESEARCH_COST_MOD_PERCENT");
+	m_cache_TK_IDEAS_CITY_VALUE = getDefineINT("TK_IDEAS_CITY_VALUE");
+	m_cache_TK_MAX_FORTS_PER_CITY = getDefineINT("TK_MAX_FORTS_PER_CITY");
+	m_cache_TK_PIONEER_COAL_FURNACE_BONUS = getDefineINT("TK_PIONEER_COAL_FURNACE_BONUS");
+	m_cache_TK_PROLIFIC_INVENTOR_PROGRESS = getDefineINT("TK_PROLIFIC_INVENTOR_PROGRESS");
+	m_cache_TK_PROLIFIC_INVENTOR_THRESHOLD = getDefineINT("TK_PROLIFIC_INVENTOR_THRESHOLD");
+	m_cache_TK_RESEARCH_PACT_IDEAS_THRESHOLD = getDefineINT("TK_RESEARCH_PACT_IDEAS_THRESHOLD");
+	m_cache_TK_RESEARCH_TRADE_VALUE = getDefineINT("TK_RESEARCH_TRADE_VALUE");
+	m_cache_TK_STEAMWORKS_MODIFIER = getDefineINT("TK_STEAMWORKS_MODIFIER");
+	m_cache_TRADE_POINTS_FOR_ROUTE = getDefineINT("TRADE_POINTS_FOR_ROUTE");
+	m_cache_TRADE_ROUTE_SPICE = getDefineINT("TRADE_ROUTE_SPICE");
+	m_cache_TRADE_STIMULATES_RESEARCH_MIN_VALUE = getDefineINT("TRADE_STIMULATES_RESEARCH_MIN_VALUE");
+	m_cache_TRADE_STIMULATES_RESEARCH_PERCENT = getDefineINT("TRADE_STIMULATES_RESEARCH_PERCENT");
+	m_cache_TRADING_POINTS_MOD_PERCENT = getDefineINT("TRADING_POINTS_MOD_PERCENT");
+	m_cache_TREASURE_UNITCLASS = getDefineINT("TREASURE_UNITCLASS");
+	m_cache_TREASURE_UNITS_ONLY_SELECT_COASTAL = getDefineINT("TREASURE_UNITS_ONLY_SELECT_COASTAL");
+	m_cache_TURNS_TO_TRAIN = getDefineINT("TURNS_TO_TRAIN");
+	m_cache_UNITARMOR_LEATHER = getDefineINT("UNITARMOR_LEATHER");
+	m_cache_UNITARMOR_MAIL = getDefineINT("UNITARMOR_MAIL");
+	m_cache_UNITARMOR_PLATE = getDefineINT("UNITARMOR_PLATE");
+	m_cache_UNITARMOR_SCALE = getDefineINT("UNITARMOR_SCALE");
+	m_cache_UNITARMOR_SHIELD = getDefineINT("UNITARMOR_SHIELD");
+	m_cache_UNITCLASS_PIONEER = getDefineINT("UNITCLASS_PIONEER");
+	m_cache_UNITTACTIC_PARRY = getDefineINT("UNITTACTIC_PARRY");
+	m_cache_UNITWEAPON_BLUNT = getDefineINT("UNITWEAPON_BLUNT");
+	m_cache_UNIT_PRODUCTION_DECAY_PERCENT = getDefineINT("UNIT_PRODUCTION_DECAY_PERCENT");
+	m_cache_UNIT_PRODUCTION_DECAY_TIME = getDefineINT("UNIT_PRODUCTION_DECAY_TIME");
+	m_cache_UNIT_PRODUCTION_PERCENT = getDefineINT("UNIT_PRODUCTION_PERCENT");
+	m_cache_UNIT_UPGRADE_COST_PER_PRODUCTION = getDefineINT("UNIT_UPGRADE_COST_PER_PRODUCTION");
+	m_cache_UNIT_VISIBILITY_RANGE = getDefineINT("UNIT_VISIBILITY_RANGE");
+	m_cache_USE_MEDIEVAL_CALENDER = getDefineINT("USE_MEDIEVAL_CALENDER");
+	m_cache_VASSAL_CIVILIZATION = getDefineINT("VASSAL_CIVILIZATION");
+	m_cache_VASSAL_LEADER = getDefineINT("VASSAL_LEADER");
+	m_cache_WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT = getDefineINT("WARLORD_EXTRA_EXPERIENCE_PER_UNIT_PERCENT");
+	m_cache_WAR_SUCCESS_ATTACKING = getDefineINT("WAR_SUCCESS_ATTACKING");
+	m_cache_WAR_SUCCESS_CITY_CAPTURING = getDefineINT("WAR_SUCCESS_CITY_CAPTURING");
+	m_cache_WAR_SUCCESS_DEFENDING = getDefineINT("WAR_SUCCESS_DEFENDING");
+	m_cache_WAR_SUCCESS_UNIT_CAPTURING = getDefineINT("WAR_SUCCESS_UNIT_CAPTURING");
+	m_cache_WATER_IMPROVEMENT = getDefineINT("WATER_IMPROVEMENT");
+	m_cache_WATER_UNIT_FACING_DIRECTION = getDefineINT("WATER_UNIT_FACING_DIRECTION");
+	m_cache_WEEKS_PER_MONTHS = getDefineINT("WEEKS_PER_MONTHS");
+	m_cache_WILD_ANIMAL_ATTACK_WEIGHT = getDefineINT("WILD_ANIMAL_ATTACK_WEIGHT");
+	m_cache_WILD_ANIMAL_LAND_BONUS_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_BONUS_NATIVE_WEIGHT");
+	m_cache_WILD_ANIMAL_LAND_FEATURE_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_FEATURE_NATIVE_WEIGHT");
+	m_cache_WILD_ANIMAL_LAND_PATROL_BASE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_PATROL_BASE_WEIGHT");
+	m_cache_WILD_ANIMAL_LAND_TERRAIN_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_TERRAIN_NATIVE_WEIGHT");
+	m_cache_WILD_ANIMAL_LAND_UNIT_VARIATION_WEIGHT = getDefineINT("WILD_ANIMAL_LAND_UNIT_VARIATION_WEIGHT");
+	m_cache_WILD_ANIMAL_SEA_BONUS_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_BONUS_NATIVE_WEIGHT");
+	m_cache_WILD_ANIMAL_SEA_FEATURE_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_FEATURE_NATIVE_WEIGHT");
+	m_cache_WILD_ANIMAL_SEA_PATROL_BASE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_PATROL_BASE_WEIGHT");
+	m_cache_WILD_ANIMAL_SEA_TERRAIN_NATIVE_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_TERRAIN_NATIVE_WEIGHT");
+	m_cache_WILD_ANIMAL_SEA_UNIT_VARIATION_WEIGHT = getDefineINT("WILD_ANIMAL_SEA_UNIT_VARIATION_WEIGHT");
+}
+// cache XML - end - Nightinggale
diff --git a/DLL_Sources/CvGlobals.h b/DLL_Sources/CvGlobals.h
index 9deb481..f65bb9f 100644
--- a/DLL_Sources/CvGlobals.h
+++ b/DLL_Sources/CvGlobals.h
@@ -736,7 +736,21 @@ public:
 	void deleteInfoArrays();
 
 	// XML enum check - start - Nightinggale
-	void CheckEnumYields() const;
+	void CheckEnumInterfaceModeTypes() const;
+	void CheckEnumWorldSizeTypes() const;
+	void CheckEnumYieldTypes() const;
+	void CheckEnumGameOptionTypes() const;
+	void CheckEnumPlayerOptionTypes() const;
+	void CheckEnumGraphicOptionTypes() const;
+	void CheckEnumForceControlTypes() const;
+	void CheckEnumDenialTypes() const;
+	void CheckEnumDomainTypes() const;
+	void CheckEnumUnitAITypes() const;
+	void CheckEnumMissionTypes() const;
+	void CheckEnumCommandTypes() const;
+	void CheckEnumControlTypes() const;
+	void CheckEnumMemoryTypes() const;
+	void CheckEnumAttitudeTypes() const;
 	// XML enum check - end - Nightinggale
 
 	// cache XML - start - Nightinggale
diff --git a/DLL_Sources/CvPlayerAI.cpp b/DLL_Sources/CvPlayerAI.cpp
index 7133417..b0ed44b 100644
--- a/DLL_Sources/CvPlayerAI.cpp
+++ b/DLL_Sources/CvPlayerAI.cpp
@@ -1,14931 +1,15037 @@
-// playerAI.cpp
-
-#include "CvGameCoreDLL.h"
-#include "CvPlayerAI.h"
-#include "CvRandom.h"
-#include "CvGlobals.h"
-#include "CvGameCoreUtils.h"
-#include "CvMap.h"
-#include "CvArea.h"
-#include "CvPlot.h"
-#include "CvGameAI.h"
-#include "CvTeamAI.h"
-#include "CvGameCoreUtils.h"
-#include "CvDiploParameters.h"
-#include "CvInitCore.h"
-#include "CyArgsList.h"
-#include "CvDLLInterfaceIFaceBase.h"
-#include "CvDLLEntityIFaceBase.h"
-#include "CvDLLPythonIFaceBase.h"
-#include "CvDLLEngineIFaceBase.h"
-#include "CvDLLEventReporterIFaceBase.h"
-#include "CvInfos.h"
-#include "CvPopupInfo.h"
-#include "FProfiler.h"
-#include "CvDLLFAStarIFaceBase.h"
-#include "FAStarNode.h"
-#include "CvTradeRoute.h"
-
-#define DANGER_RANGE				(4)
-#define GREATER_FOUND_RANGE			(5)
-#define CIVIC_CHANGE_DELAY			(25)
-
-// statics
-
-CvPlayerAI* CvPlayerAI::m_aPlayers = NULL;
-
-void CvPlayerAI::initStatics()
-{
-	m_aPlayers = new CvPlayerAI[MAX_PLAYERS];
-	for (int iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		m_aPlayers[iI].m_eID = ((PlayerTypes)iI);
-	}
-}
-
-void CvPlayerAI::freeStatics()
-{
-	SAFE_DELETE_ARRAY(m_aPlayers);
-}
-
-bool CvPlayerAI::areStaticsInitialized()
-{
-	if(m_aPlayers == NULL)
-	{
-		return false;
-	}
-
-	return true;
-}
-
-DllExport CvPlayerAI& CvPlayerAI::getPlayerNonInl(PlayerTypes ePlayer)
-{
-	return getPlayer(ePlayer);
-}
-
-// Public Functions...
-
-CvPlayerAI::CvPlayerAI()
-{
-	m_aiNumTrainAIUnits = new int[NUM_UNITAI_TYPES];
-	m_aiNumAIUnits = new int[NUM_UNITAI_TYPES];
-	m_aiNumRetiredAIUnits = new int[NUM_UNITAI_TYPES];
-	m_aiUnitAIStrategyWeights = new int[NUM_UNITAI_TYPES];
-	m_aiPeacetimeTradeValue = new int[MAX_PLAYERS];
-	m_aiPeacetimeGrantValue = new int[MAX_PLAYERS];
-	m_aiGoldTradedTo = new int[MAX_PLAYERS];
-	m_aiAttitudeExtra = new int[MAX_PLAYERS];
-
-	m_abFirstContact = new bool[MAX_PLAYERS];
-
-	m_aaiContactTimer = new int*[MAX_PLAYERS];
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		m_aaiContactTimer[i] = new int[NUM_CONTACT_TYPES];
-	}
-
-	m_aaiMemoryCount = new int*[MAX_PLAYERS];
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		m_aaiMemoryCount[i] = new int[NUM_MEMORY_TYPES];
-	}
-
-	m_aiAverageYieldMultiplier = new int[NUM_YIELD_TYPES];
-
-	m_aiUnitClassWeights = NULL;
-	m_aiUnitCombatWeights = NULL;
-	m_aiEmotions = new int[NUM_EMOTION_TYPES];
-	m_aiStrategyStartedTurn = new int[NUM_STRATEGY_TYPES];
-	m_aiStrategyData = new int[NUM_STRATEGY_TYPES];
-
-	m_aiBestWorkedYieldPlots = new int[NUM_YIELD_TYPES];
-	m_aiBestUnworkedYieldPlots = new int[NUM_YIELD_TYPES];
-	m_aiYieldValuesTimes100 = new int[NUM_YIELD_TYPES];
-
-	m_aiCloseBordersAttitudeCache = new int[MAX_PLAYERS];
-	m_aiStolenPlotsAttitudeCache = new int[MAX_PLAYERS];
-	///Tks Med
-	//m_aiInsultedAttitudeCache = new int[MAX_PLAYERS];
-	//tkend
-
-	AI_reset();
-}
-
-
-CvPlayerAI::~CvPlayerAI()
-{
-	AI_uninit();
-
-	SAFE_DELETE_ARRAY(m_aiNumTrainAIUnits);
-	SAFE_DELETE_ARRAY(m_aiNumAIUnits);
-	SAFE_DELETE_ARRAY(m_aiNumRetiredAIUnits);
-	SAFE_DELETE_ARRAY(m_aiUnitAIStrategyWeights);
-	SAFE_DELETE_ARRAY(m_aiPeacetimeTradeValue);
-	SAFE_DELETE_ARRAY(m_aiPeacetimeGrantValue);
-	SAFE_DELETE_ARRAY(m_aiGoldTradedTo);
-	SAFE_DELETE_ARRAY(m_aiAttitudeExtra);
-	SAFE_DELETE_ARRAY(m_abFirstContact);
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		SAFE_DELETE_ARRAY(m_aaiContactTimer[i]);
-	}
-	SAFE_DELETE_ARRAY(m_aaiContactTimer);
-
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		SAFE_DELETE_ARRAY(m_aaiMemoryCount[i]);
-	}
-	SAFE_DELETE_ARRAY(m_aaiMemoryCount);
-
-	SAFE_DELETE_ARRAY(m_aiAverageYieldMultiplier);
-	SAFE_DELETE_ARRAY(m_aiCloseBordersAttitudeCache);
-	SAFE_DELETE_ARRAY(m_aiStolenPlotsAttitudeCache);
-	///TKs Med
-	//SAFE_DELETE_ARRAY(m_aiInsultedAttitudeCache);
-	//tkend
-	SAFE_DELETE_ARRAY(m_aiEmotions);
-	SAFE_DELETE_ARRAY(m_aiStrategyStartedTurn);
-	SAFE_DELETE_ARRAY(m_aiStrategyData);
-
-	SAFE_DELETE_ARRAY(m_aiBestWorkedYieldPlots);
-	SAFE_DELETE_ARRAY(m_aiBestUnworkedYieldPlots);
-	SAFE_DELETE_ARRAY(m_aiYieldValuesTimes100);
-}
-
-
-void CvPlayerAI::AI_init()
-{
-	AI_reset();
-
-	//--------------------------------
-	// Init other game data
-	if ((GC.getInitCore().getSlotStatus(getID()) == SS_TAKEN) || (GC.getInitCore().getSlotStatus(getID()) == SS_COMPUTER))
-	{
-		FAssert(getPersonalityType() != NO_LEADER);
-	}
-}
-
-
-void CvPlayerAI::AI_uninit()
-{
-	SAFE_DELETE_ARRAY(m_aiUnitClassWeights);
-	SAFE_DELETE_ARRAY(m_aiUnitCombatWeights);
-}
-
-
-void CvPlayerAI::AI_reset()
-{
-	int iI;
-
-	AI_uninit();
-
-	m_iAttackOddsChange = 0;
-	m_iExtraGoldTarget = 0;
-
-	m_eNextBuyUnit = NO_UNIT;
-	m_eNextBuyUnitAI = NO_UNITAI;
-	m_iNextBuyUnitValue = 0;
-
-	m_eNextBuyProfession = NO_PROFESSION;
-	m_eNextBuyProfessionUnit = NO_UNIT;
-	m_eNextBuyProfessionAI = NO_UNITAI;
-	m_iNextBuyProfessionValue = 0;
-
-	m_iTotalIncome = 0;
-	m_iHurrySpending = 0;
-
-	for (iI = 0; iI < NUM_UNITAI_TYPES; iI++)
-	{
-		m_aiNumTrainAIUnits[iI] = 0;
-		m_aiNumAIUnits[iI] = 0;
-		m_aiNumRetiredAIUnits[iI] = 0;
-		m_aiUnitAIStrategyWeights[iI] = 0;
-	}
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		m_aiPeacetimeTradeValue[iI] = 0;
-		m_aiPeacetimeGrantValue[iI] = 0;
-		m_aiGoldTradedTo[iI] = 0;
-		m_aiAttitudeExtra[iI] = 0;
-	}
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		m_abFirstContact[iI] = false;
-	}
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		for (int iJ = 0; iJ < NUM_CONTACT_TYPES; iJ++)
-		{
-			m_aaiContactTimer[iI][iJ] = 0;
-		}
-	}
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		for (int iJ = 0; iJ < NUM_MEMORY_TYPES; iJ++)
-		{
-			m_aaiMemoryCount[iI][iJ] = 0;
-		}
-	}
-
-	for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
-	{
-		m_aiAverageYieldMultiplier[iI] = 0;
-		m_aiBestWorkedYieldPlots[iI] = -1;
-		m_aiBestUnworkedYieldPlots[iI] = -1;
-		m_aiYieldValuesTimes100[iI] = 0;
-	}
-	m_iAveragesCacheTurn = -1;
-
-	m_iTurnLastProductionDirty = -1;
-	m_iTurnLastManagedPop = -1;
-	m_iMoveQueuePasses = 0;
-
-	m_iUpgradeUnitsCacheTurn = -1;
-	m_iUpgradeUnitsCachedExpThreshold = 0;
-	m_iUpgradeUnitsCachedGold = 0;
-
-	m_aiAICitySites.clear();
-
-	FAssert(m_aiUnitClassWeights == NULL);
-	m_aiUnitClassWeights = new int[GC.getNumUnitClassInfos()];
-	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		m_aiUnitClassWeights[iI] = 0;
-	}
-
-	FAssert(m_aiUnitCombatWeights == NULL);
-	m_aiUnitCombatWeights = new int[GC.getNumUnitCombatInfos()];
-	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
-	{
-		m_aiUnitCombatWeights[iI] = 0;
-	}
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		m_aiCloseBordersAttitudeCache[iI] = 0;
-		m_aiStolenPlotsAttitudeCache[iI] = 0;
-		///Tks Med
-		//m_aiInsultedAttitudeCache[iI] = 0;
-		//tkend
-	}
-
-
-	for (iI = 0; iI < NUM_EMOTION_TYPES; iI++)
-	{
-		m_aiEmotions[iI] = 0;
-	}
-
-	for (iI = 0; iI < NUM_STRATEGY_TYPES; iI++)
-	{
-		m_aiStrategyStartedTurn[iI] = -1;
-		m_aiStrategyData[iI] = -1;
-	}
-
-	m_iDistanceMapDistance = -1;
-	m_distanceMap.clear();
-	m_unitPriorityHeap.clear();
-}
-
-void CvPlayerAI::AI_doTurnPre()
-{
-	PROFILE_FUNC();
-
-	FAssertMsg(getPersonalityType() != NO_LEADER, "getPersonalityType() is not expected to be equal with NO_LEADER");
-	FAssertMsg(getLeaderType() != NO_LEADER, "getLeaderType() is not expected to be equal with NO_LEADER");
-	FAssertMsg(getCivilizationType() != NO_CIVILIZATION, "getCivilizationType() is not expected to be equal with NO_CIVILIZATION");
-
-	AI_invalidateCloseBordersAttitudeCache();
-
-	AI_doCounter();
-
-	AI_doEnemyUnitData();
-
-	if (isHuman())
-	{
-		return;
-	}
-
-	m_unitPriorityHeap.clear();
-	int iLoop;
-	for (CvUnit* pUnit = firstUnit(&iLoop); pUnit != NULL; pUnit = nextUnit(&iLoop))
-	{
-		pUnit->AI_setMovePriority(0);
-	}
-
-	AI_doEmotions();
-
-	AI_doUnitAIWeights();
-
-	AI_doMilitary();
-
-	AI_doStrategy();
-
-	AI_updateYieldValues();
-}
-
-
-void CvPlayerAI::AI_doTurnPost()
-{
-	PROFILE_FUNC();
-
-	if (isHuman())
-	{
-		return;
-	}
-
-	AI_doTradeRoutes();
-
-	AI_doDiplo();
-}
-
-
-void CvPlayerAI::AI_doTurnUnitsPre()
-{
-	PROFILE_FUNC();
-	AI_updateBestYieldPlots();
-	AI_updateFoundValues();
-	AI_doEmotions();
-
-	if (!isHuman())
-	{
-		if (getParent() != NO_PLAYER)
-		{
-			AI_doProfessions();
-			AI_doEurope();
-		}
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(8, "AI Update Area Targets") == 0) // XXX personality???
-	{
-		AI_updateAreaTargets();
-	}
-
-	if (!isHuman())
-	{
-		AI_doMilitaryStrategy();
-		AI_doSuppressRevolution();
-	}
-
-	if (isHuman())
-	{
-		return;
-	}
-}
-
-
-void CvPlayerAI::AI_doTurnUnitsPost()
-{
-	PROFILE_FUNC();
-
-	CvUnit* pLoopUnit;
-	int iLoop;
-	if (!isHuman() || isOption(PLAYEROPTION_AUTO_PROMOTION))
-	{
-		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-		{
-			pLoopUnit->AI_promote();
-		}
-	}
-
-	if (isHuman())
-	{
-		return;
-	}
-}
-
-
-void CvPlayerAI::AI_doPeace()
-{
-	PROFILE_FUNC();
-
-	CvDiploParameters* pDiplo;
-	CvCity* pBestReceiveCity;
-	CvCity* pBestGiveCity;
-	CvCity* pLoopCity;
-	CLinkList<TradeData> ourList;
-	CLinkList<TradeData> theirList;
-	bool abContacted[MAX_TEAMS];
-	TradeData item;
-	int iReceiveGold;
-	int iGiveGold;
-	int iGold;
-	int iValue;
-	int iBestValue;
-	int iOurValue;
-	int iTheirValue;
-	int iLoop;
-	int iI;
-	FAssert(!isHuman());
-
-	for (iI = 0; iI < MAX_TEAMS; iI++)
-	{
-		abContacted[iI] = false;
-	}
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			if (iI != getID())
-			{
-				if (canContact((PlayerTypes)iI) && AI_isWillingToTalk((PlayerTypes)iI))
-				{
-					if (!(GET_TEAM(getTeam()).isHuman()) && (GET_PLAYER((PlayerTypes)iI).isHuman() || !(GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).isHuman())))
-					{
-						if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER((PlayerTypes)iI).getTeam()))
-						{
-							if (!(GET_PLAYER((PlayerTypes)iI).isHuman()) || (GET_TEAM(getTeam()).getLeaderID() == getID()))
-							{
-								FAssertMsg(iI != getID(), "iI is not expected to be equal with getID()");
-								FAssert(GET_PLAYER((PlayerTypes)iI).getTeam() != getTeam());
-
-								if (GET_TEAM(getTeam()).AI_getAtWarCounter(GET_PLAYER((PlayerTypes)iI).getTeam()) > 10)
-								{
-									if (AI_getContactTimer(((PlayerTypes)iI), CONTACT_PEACE_TREATY) == 0)
-									{
-										bool bOffered = false;
-										if (!bOffered)
-										{
-											if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_PEACE_TREATY), "AI Diplo Peace Treaty") == 0)
-											{
-												setTradeItem(&item, TRADE_PEACE_TREATY, 0, NULL);
-
-												if (canTradeItem(((PlayerTypes)iI), item, true) && GET_PLAYER((PlayerTypes)iI).canTradeItem(getID(), item, true))
-												{
-													iOurValue = GET_TEAM(getTeam()).AI_endWarVal(GET_PLAYER((PlayerTypes)iI).getTeam());
-													iTheirValue = GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).AI_endWarVal(getTeam());
-													iReceiveGold = 0;
-													iGiveGold = 0;
-
-													pBestReceiveCity = NULL;
-													pBestGiveCity = NULL;
-
-													if (iTheirValue > iOurValue)
-													{
-														if (iTheirValue > iOurValue)
-														{
-															iBestValue = 0;
-														}
-
-														iGold = std::min((iTheirValue - iOurValue), GET_PLAYER((PlayerTypes)iI).AI_maxGoldTrade(getID()));
-
-														if (iGold > 0)
-														{
-															setTradeItem(&item, TRADE_GOLD, iGold, NULL);
-
-															if (GET_PLAYER((PlayerTypes)iI).canTradeItem(getID(), item, true))
-															{
-																iReceiveGold = iGold;
-																iOurValue += iGold;
-															}
-														}
-
-														if (iTheirValue > iOurValue)
-														{
-															iBestValue = 0;
-
-															for (pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
-															{
-																setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
-
-																if (GET_PLAYER((PlayerTypes)iI).canTradeItem(getID(), item, true))
-																{
-																	iValue = pLoopCity->plot()->calculateCulturePercent(getID());
-
-																	if (iValue > iBestValue)
-																	{
-																		iBestValue = iValue;
-																		pBestReceiveCity = pLoopCity;
-																	}
-																}
-															}
-
-															if (pBestReceiveCity != NULL)
-															{
-																iOurValue += AI_cityTradeVal(pBestReceiveCity);
-															}
-														}
-													}
-													else if (iOurValue > iTheirValue)
-													{
-														iBestValue = 0;
-														iGold = std::min((iOurValue - iTheirValue), AI_maxGoldTrade((PlayerTypes)iI));
-
-														if (iGold > 0)
-														{
-															setTradeItem(&item, TRADE_GOLD, iGold, NULL);
-
-															if (canTradeItem(((PlayerTypes)iI), item, true))
-															{
-																iGiveGold = iGold;
-																iTheirValue += iGold;
-															}
-														}
-
-														iBestValue = 0;
-
-														for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-														{
-															setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
-
-															if (canTradeItem(((PlayerTypes)iI), item, true))
-															{
-																if (GET_PLAYER((PlayerTypes)iI).AI_cityTradeVal(pLoopCity) <= (iOurValue - iTheirValue))
-																{
-																	iValue = pLoopCity->plot()->calculateCulturePercent((PlayerTypes)iI);
-
-																	if (iValue > iBestValue)
-																	{
-																		iBestValue = iValue;
-																		pBestGiveCity = pLoopCity;
-																	}
-																}
-															}
-														}
-
-														if (pBestGiveCity != NULL)
-														{
-															iTheirValue += GET_PLAYER((PlayerTypes)iI).AI_cityTradeVal(pBestGiveCity);
-														}
-													}
-
-													if ((GET_PLAYER((PlayerTypes)iI).isHuman()) ? (iOurValue >= iTheirValue) : ((iOurValue > ((iTheirValue * 3) / 5)) && (iTheirValue > ((iOurValue * 3) / 5))))
-													{
-														ourList.clear();
-														theirList.clear();
-
-														setTradeItem(&item, TRADE_PEACE_TREATY, 0, NULL);
-
-														ourList.insertAtEnd(item);
-														theirList.insertAtEnd(item);
-														if (iGiveGold != 0)
-														{
-															setTradeItem(&item, TRADE_GOLD, iGiveGold, NULL);
-															ourList.insertAtEnd(item);
-														}
-
-														if (iReceiveGold != 0)
-														{
-															setTradeItem(&item, TRADE_GOLD, iReceiveGold, NULL);
-															theirList.insertAtEnd(item);
-														}
-
-														if (pBestGiveCity != NULL)
-														{
-															setTradeItem(&item, TRADE_CITIES, pBestGiveCity->getID(), NULL);
-															ourList.insertAtEnd(item);
-														}
-
-														if (pBestReceiveCity != NULL)
-														{
-															setTradeItem(&item, TRADE_CITIES, pBestReceiveCity->getID(), NULL);
-															theirList.insertAtEnd(item);
-														}
-
-														if (GET_PLAYER((PlayerTypes)iI).isHuman())
-														{
-															if (!(abContacted[GET_PLAYER((PlayerTypes)iI).getTeam()]))
-															{
-																AI_changeContactTimer(((PlayerTypes)iI), CONTACT_PEACE_TREATY, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_PEACE_TREATY));
-																pDiplo = new CvDiploParameters(getID());
-																FAssertMsg(pDiplo != NULL, "pDiplo must be valid");
-																pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_PEACE"));
-																pDiplo->setAIContact(true);
-																pDiplo->setOurOfferList(theirList);
-																pDiplo->setTheirOfferList(ourList);
-																gDLL->beginDiplomacy(pDiplo, (PlayerTypes)iI);
-																abContacted[GET_PLAYER((PlayerTypes)iI).getTeam()] = true;
-															}
-														}
-														else
-														{
-															GC.getGameINLINE().implementDeal(getID(), ((PlayerTypes)iI), &ourList, &theirList);
-														}
-													}
-												}
-											}
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-
-void CvPlayerAI::AI_updateFoundValues(bool bStartingLoc)
-{
-	PROFILE_FUNC();
-
-	int iLoop;
-	for(CvArea* pLoopArea = GC.getMapINLINE().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMapINLINE().nextArea(&iLoop))
-	{
-		pLoopArea->setBestFoundValue(getID(), 0);
-	}
-
-	if (bStartingLoc)
-	{
-		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-		{
-			GC.getMapINLINE().plotByIndexINLINE(iI)->setFoundValue(getID(), -1);
-		}
-	}
-	else
-	{
-		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-		{
-			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-
-			int iValue = 0;
-			if (pLoopPlot->isRevealed(getTeam(), false))
-			{
-				long lResult=-1;
-				if(GC.getUSE_GET_CITY_FOUND_VALUE_CALLBACK())
-				{
-					CyArgsList argsList;
-					argsList.add((int)getID());
-					argsList.add(pLoopPlot->getX());
-					argsList.add(pLoopPlot->getY());
-					gDLL->getPythonIFace()->callFunction(PYGameModule, "getCityFoundValue", argsList.makeFunctionArgs(), &lResult);
-				}
-
-				if (lResult == -1)
-				{
-					iValue = AI_foundValue(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
-				}
-				else
-				{
-					iValue = lResult;
-				}
-			}
-
-			pLoopPlot->setFoundValue(getID(), iValue);
-
-			CvArea* pArea = pLoopPlot->area();
-			if (iValue > pArea->getBestFoundValue(getID()))
-			{
-				pArea->setBestFoundValue(getID(), iValue);
-			}
-		}
-	}
-}
-
-
-void CvPlayerAI::AI_updateAreaTargets()
-{
-	CvArea* pLoopArea;
-	int iLoop;
-
-	for(pLoopArea = GC.getMapINLINE().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMapINLINE().nextArea(&iLoop))
-	{
-		if (!(pLoopArea->isWater()))
-		{
-			if (GC.getGameINLINE().getSorenRandNum(3, "AI Target City") == 0)
-			{
-				pLoopArea->setTargetCity(getID(), NULL);
-			}
-			else
-			{
-				pLoopArea->setTargetCity(getID(), AI_findTargetCity(pLoopArea));
-			}
-		}
-	}
-}
-
-
-// Returns priority for unit movement (lower values move first...)
-int CvPlayerAI::AI_movementPriority(CvSelectionGroup* pGroup)
-{
-	CvUnit* pHeadUnit;
-	int iCurrCombat;
-	int iBestCombat;
-
-	pHeadUnit = pGroup->getHeadUnit();
-
-	if (pHeadUnit != NULL)
-	{
-		if (pHeadUnit->hasCargo())
-		{
-			if (pHeadUnit->specialCargo() == NO_SPECIALUNIT)
-			{
-				return 0;
-			}
-			else
-			{
-				return 1;
-			}
-		}
-
-		if (pHeadUnit->AI_getUnitAIType() == UNITAI_SETTLER)
-		{
-			return 2;
-		}
-
-		if (pHeadUnit->AI_getUnitAIType() == UNITAI_WORKER)
-		{
-			return 3;
-		}
-
-		if (pHeadUnit->AI_getUnitAIType() == UNITAI_SCOUT)
-		{
-			return 4;
-		}
-
-		if (pHeadUnit->bombardRate() > 0)
-		{
-			return 5;
-		}
-
-		if (pHeadUnit->canFight())
-		{
-			if (pHeadUnit->withdrawalProbability() > 20)
-			{
-				return 7;
-			}
-
-			if (pHeadUnit->withdrawalProbability() > 0)
-			{
-				return 8;
-			}
-
-			iCurrCombat = pHeadUnit->currCombatStr(NULL, NULL);
-			iBestCombat = (GC.getGameINLINE().getBestLandUnitCombat() * 100);
-
-			if (pHeadUnit->noDefensiveBonus())
-			{
-				iCurrCombat *= 3;
-				iCurrCombat /= 2;
-			}
-
-			if (pHeadUnit->AI_isCityAIType())
-			{
-				iCurrCombat /= 2;
-			}
-
-			if (iCurrCombat > iBestCombat)
-			{
-				return 9;
-			}
-			else if (iCurrCombat > ((iBestCombat * 4) / 5))
-			{
-				return 10;
-			}
-			else if (iCurrCombat > ((iBestCombat * 3) / 5))
-			{
-				return 11;
-			}
-			else if (iCurrCombat > ((iBestCombat * 2) / 5))
-			{
-				return 12;
-			}
-			else if (iCurrCombat > ((iBestCombat * 1) / 5))
-			{
-				return 13;
-			}
-			else
-			{
-				return 14;
-			}
-		}
-
-		return 15;
-	}
-
-	return 16;
-}
-
-void CvPlayerAI::AI_unitUpdate()
-{
-	PROFILE_FUNC();
-
-	CLLNode<int>* pCurrUnitNode;
-	CvSelectionGroup* pLoopSelectionGroup;
-	CLinkList<int> tempGroupCycle;
-	CLinkList<int> finalGroupCycle;
-
-
-	if (GC.getGameINLINE().getGameTurn() != m_iTurnLastManagedPop)
-	{
-		//This should only be done once a turn, but must be done right before
-		//units are moved else it's unfair on the AI.
-		if (!isHuman())
-		{
-			int iLoop;
-			CvCity* pLoopCity;
-			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-			{
-				if (isNative())
-				{
-					pLoopCity->AI_doNative();
-				}
-				else if (pLoopCity->getPopulation() > 1)
-				{
-					int iValue = std::max(1, 11 / (1 + pLoopCity->getPopulation()));
-					if (((GC.getGameINLINE().getGameTurn() + iLoop) % iValue) == 0)
-					{
-						bool bRemove = true;
-						CvUnit* pRemoveUnit = pLoopCity->getPopulationUnitByIndex(0);
-
-						if (pRemoveUnit->getProfession() != NO_PROFESSION)
-						{
-							CvProfessionInfo& kProfession = GC.getProfessionInfo(pRemoveUnit->getProfession());
-							// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-							YieldTypes eYieldProducedType = (YieldTypes)kProfession.getYieldsProduced(0);
-							// MultipleYieldsProduced End
-							if (eYieldProducedType == YIELD_EDUCATION)
-							{
-								bRemove = false;
-							}
-
-							if (bRemove && (pRemoveUnit->AI_getIdealProfession() != NO_PROFESSION) && (pRemoveUnit->getProfession() == pRemoveUnit->AI_getIdealProfession()))
-							{
-								bRemove = false;
-								// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-								YieldTypes eYieldProducedType = (YieldTypes)kProfession.getYieldsProduced(0);
-								// MultipleYieldsProduced End
-								if (kProfession.isWorkPlot())
-								{
-									CvPlot* pWorkedPlot = pLoopCity->getPlotWorkedByUnit(pRemoveUnit);
-									if (pWorkedPlot == NULL)
-									{
-										bRemove = true;
-									}
-									else
-									{
-										if ((pWorkedPlot->getBonusType() == NO_BONUS) || (GC.getBonusInfo(pWorkedPlot->getBonusType()).getYieldChange(eYieldProducedType) <= 0))
-										{
-											bRemove = true;
-										}
-										else
-										{
-											CvPlot* pBestWorkedPlot = AI_getBestWorkedYieldPlot(eYieldProducedType);
-											if ((pBestWorkedPlot == NULL) || (pWorkedPlot->calculateBestNatureYield(eYieldProducedType, getTeam()) < pBestWorkedPlot->calculateBestNatureYield(eYieldProducedType, getTeam())))
-											{
-												bRemove = true;
-											}
-										}
-									}
-								}
-								else
-								{
-									if (pLoopCity->AI_getYieldAdvantage(eYieldProducedType) < 100)
-									{
-										bRemove = true;
-									}
-								}
-							}
-						}
-						if (bRemove)
-						{
-							pLoopCity->removePopulationUnit(pRemoveUnit, false, (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession());
-						}
-					}
-				}
-			}
-
-			for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-			{
-				if (pLoopUnit->AI_getMovePriority() == 0)
-				{
-					pLoopUnit->AI_doInitialMovePriority();
-				}
-				else
-				{
-					FAssert(std::find(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), pLoopUnit->getID()) != m_unitPriorityHeap.end());
-				}
-			}
-			m_iTurnLastManagedPop = GC.getGameINLINE().getGameTurn();
-			m_iMoveQueuePasses = 0;
-		}
-	}
-
-	if (!hasBusyUnit())
-	{
-		pCurrUnitNode = headGroupCycleNode();
-
-		while (pCurrUnitNode != NULL)
-		{
-			pLoopSelectionGroup = getSelectionGroup(pCurrUnitNode->m_data);
-			pCurrUnitNode = nextGroupCycleNode(pCurrUnitNode);
-
-			if (pLoopSelectionGroup->AI_isForceSeparate())
-			{
-				// do not split groups that are in the midst of attacking
-				if (pLoopSelectionGroup->isForceUpdate() || !pLoopSelectionGroup->AI_isGroupAttack())
-				{
-					pLoopSelectionGroup->AI_separate();	// pointers could become invalid...
-				}
-			}
-		}
-
-		if (isHuman())
-		{
-			pCurrUnitNode = headGroupCycleNode();
-
-			while (pCurrUnitNode != NULL)
-			{
-				pLoopSelectionGroup = getSelectionGroup(pCurrUnitNode->m_data);
-				pCurrUnitNode = nextGroupCycleNode(pCurrUnitNode);
-
-				if (pLoopSelectionGroup == NULL || pLoopSelectionGroup->AI_update())
-				{
-					break; // pointers could become invalid...
-				}
-			}
-		}
-        else
-		{
-			int iLoop;
-
-			//Continue existing missions.
-			for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-			{
-				pLoopSelectionGroup->autoMission();
-			}
-			///TKs Test
-			///if (getID() == 9)
-			///{
-				//int test = 0;
-			//}
-
-			while (!m_unitPriorityHeap.empty())
-			{
-				AI_verifyMoveQueue();
-				CvUnit* pUnit = AI_getNextMoveUnit();
-//				///TKs Test
-//				int iID = pUnit->getID();
-//				///Kailric DeBug
-//				char szTKdebug[1024];
-//				sprintf( szTKdebug, "Unit Id = %d\n", iID);
-//				gDLL->messageControlLog(szTKdebug);
-				///TKS Med Testing
-
-				//if (pUnit != NULL)
-				//{
-					//if (pUnit->getID() == 8 && getID() == 0 && pUnit->getUnitTravelState() == UNIT_TRAVEL_STATE_IN_EUROPE)
-					//{
-						//FAssert(false);
-					//}
-				//}
-				///TKe
-
-				if ((pUnit != NULL) && shouldUnitMove(pUnit))
-				{
-					int iOriginalPriority = pUnit->AI_getMovePriority();
-					if (iOriginalPriority > 0)
-					{
-						if (!pUnit->getGroup()->isBusy() && !pUnit->getGroup()->isCargoBusy())
-						{
-							pUnit->AI_update();
-						}
-						else
-						{
-							m_iMoveQueuePasses++;
-							if (m_iMoveQueuePasses > 100)
-							{
-								FAssertMsg(false, "Forcing AI to abort turn");
-								return;
-							}
-							AI_addUnitToMoveQueue(pUnit);
-							return;
-						}
-					}
-				}
-			}
-
-			for (CvSelectionGroup*pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-			{
-				if (pLoopSelectionGroup->readyToMove())
-				{
-					pLoopSelectionGroup->pushMission(MISSION_SKIP);
-				}
-			}
-		}
-	}
-}
-
-
-void CvPlayerAI::AI_makeAssignWorkDirty()
-{
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		pLoopCity->AI_setAssignWorkDirty(true);
-	}
-}
-
-
-void CvPlayerAI::AI_assignWorkingPlots()
-{
-	AI_manageEconomy();
-
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		pLoopCity->AI_assignWorkingPlots();
-	}
-}
-
-
-void CvPlayerAI::AI_updateAssignWork()
-{
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		pLoopCity->AI_updateAssignWork();
-	}
-}
-
-
-void CvPlayerAI::AI_makeProductionDirty()
-{
-	FAssertMsg(!isHuman(), "isHuman did not return false as expected");
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		pLoopCity->AI_setChooseProductionDirty(true);
-	}
-}
-
-
-void CvPlayerAI::AI_conquerCity(CvCity* pCity)
-{
-	bool bRaze = false;
-	if (canRaze(pCity))
-	{
-		bRaze = isNative();
-
-		if (!bRaze)
-		{
-			CvCity* pNearestCity;
-			int iRazeValue;
-
-			iRazeValue = 0;
-			if (GC.getGameINLINE().getElapsedGameTurns() > 20)
-			{
-				if (getNumCities() > 4)
-				{
-					pNearestCity = GC.getMapINLINE().findCity(pCity->getX_INLINE(), pCity->getY_INLINE(), NO_PLAYER, getTeam(), true, false, NO_TEAM, NO_DIRECTION, pCity);
-
-					if (pNearestCity == NULL)
-					{
-						if (pCity->getPreviousOwner() != NO_PLAYER)
-						{
-							if (GET_TEAM(GET_PLAYER(pCity->getPreviousOwner()).getTeam()).countNumCitiesByArea(pCity->area()) > 3)
-							{
-								iRazeValue += 30;
-							}
-						}
-					}
-					else
-					{
-						int iDistance = plotDistance(pCity->getX_INLINE(), pCity->getY_INLINE(), pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE());
-						if ( iDistance > 12)
-						{
-							iRazeValue += iDistance * 2;
-						}
-					}
-
-					int iCloseness = pCity->AI_playerCloseness(getID());
-					if (iCloseness > 0)
-					{
-						iRazeValue -= 25;
-						iRazeValue -= iCloseness * 2;
-					}
-					else
-					{
-						iRazeValue += 60;
-					}
-
-					if (pCity->area()->getCitiesPerPlayer(getID()) > 0)
-					{
-						iRazeValue += GC.getLeaderHeadInfo(getPersonalityType()).getRazeCityProb();
-					}
-
-					if (iRazeValue > 0)
-					{
-						if (GC.getGameINLINE().getSorenRandNum(100, "AI Raze City") < iRazeValue)
-						{
-							bRaze = true;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (bRaze)
-	{
-		pCity->doTask(TASK_RAZE);
-	}
-	else
-	{
-		gDLL->getEventReporterIFace()->cityAcquiredAndKept(GC.getGameINLINE().getActivePlayer(), pCity);
-	}
-}
-
-
-bool CvPlayerAI::AI_acceptUnit(CvUnit* pUnit)
-{
-	return true;
-}
-
-
-bool CvPlayerAI::AI_captureUnit(UnitTypes eUnit, CvPlot* pPlot)
-{
-	CvCity* pNearestCity;
-
-	FAssert(!isHuman());
-
-	if (pPlot->getTeam() == getTeam())
-	{
-		return true;
-	}
-
-	pNearestCity = GC.getMapINLINE().findCity(pPlot->getX_INLINE(), pPlot->getY_INLINE(), NO_PLAYER, getTeam());
-
-	if (pNearestCity != NULL)
-	{
-		if (plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE()) <= 4)
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-
-DomainTypes CvPlayerAI::AI_unitAIDomainType(UnitAITypes eUnitAI)
-{
-	switch (eUnitAI)
-	{
-	case UNITAI_UNKNOWN:
-		return NO_DOMAIN;
-		break;
-
-	case UNITAI_COLONIST:
-	case UNITAI_SETTLER:
-	case UNITAI_WORKER:
-	case UNITAI_MISSIONARY:
-	case UNITAI_SCOUT:
-	case UNITAI_WAGON:
-	case UNITAI_TREASURE:
-	case UNITAI_YIELD:
-	case UNITAI_GENERAL:
-	case UNITAI_DEFENSIVE:
-	case UNITAI_OFFENSIVE:
-	case UNITAI_COUNTER:
-	///TKs Med
-	case UNITAI_ANIMAL:
-	case UNITAI_HUNTSMAN:
-	case UNITAI_MARAUDER:
-	case UNITAI_TRADER:
-	///TKe
-		return DOMAIN_LAND;
-		break;
-
-	case UNITAI_TRANSPORT_SEA:
-	case UNITAI_ASSAULT_SEA:
-	case UNITAI_COMBAT_SEA:
-	case UNITAI_PIRATE_SEA:
-		return DOMAIN_SEA;
-		break;
-
-	default:
-		FAssert(false);
-		break;
-	}
-
-	return NO_DOMAIN;
-}
-
-bool CvPlayerAI::AI_unitAIIsCombat(UnitAITypes eUnitAI)
-{
-	switch (eUnitAI)
-	{
-	case UNITAI_UNKNOWN:
-		return false;
-		break;
-
-	case UNITAI_COLONIST:
-	case UNITAI_SETTLER:
-	case UNITAI_WORKER:
-	case UNITAI_MISSIONARY:
-	case UNITAI_SCOUT:
-	case UNITAI_WAGON:
-	case UNITAI_TREASURE:
-	case UNITAI_YIELD:
-	case UNITAI_GENERAL:
-	///TKs Med
-	case UNITAI_TRADER:
-	///TKe
-		return false;
-		break;
-
-	case UNITAI_DEFENSIVE:
-	case UNITAI_OFFENSIVE:
-	case UNITAI_COUNTER:
-	///TKs Med
-	case UNITAI_ANIMAL:
-	case UNITAI_HUNTSMAN:
-	case UNITAI_MARAUDER:
-	///TKe
-		return true;
-		break;
-
-	case UNITAI_TRANSPORT_SEA:
-	case UNITAI_ASSAULT_SEA:
-	case UNITAI_COMBAT_SEA:
-	case UNITAI_PIRATE_SEA:
-		return true;
-		break;
-
-	default:
-		FAssert(false);
-		break;
-	}
-	return false;
-}
-
-
-int CvPlayerAI::AI_yieldWeight(YieldTypes eYield)
-{
-	return GC.getYieldInfo(eYield).getAIWeightPercent();
-}
-
-int CvPlayerAI::AI_estimatedColonistIncome(CvPlot* pPlot, CvUnit* pColonist)
-{
-	FAssert(pPlot != NULL);
-
-	int iX = pPlot->getX_INLINE();
-	int iY = pPlot->getY_INLINE();
-
-	bool bFound = pColonist->canFound(pPlot);
-	bool bJoin = pColonist->canJoinCity(pPlot);
-
-	FAssert(!(bFound && bJoin));
-
-	if (!(bFound || bJoin))
-	{
-		return -1;
-	}
-
-	if (!pPlot->isRevealed(getTeam(), false))
-	{
-		return -1;
-	}
-
-	//Calculate the income from the city tile plus the most profitable plot.
-	int iTotal = 0;
-
-	CvPlayer& kPlayerEurope = GET_PLAYER(getParent());
-
-	if (bFound)
-	{
-		//cities get food and one other yield
-		YieldTypes bestYield = NO_YIELD;
-		int bestOutput = 0;
-		for (int i = 0; i < NUM_YIELD_TYPES; i++)
-		{
-			//ignore food and lumber
-			if ((i != YIELD_FOOD) && (i != YIELD_LUMBER))
-			{
-				int natureYield = pPlot->calculateNatureYield((YieldTypes) i, getTeam(), false);
-				if (natureYield > bestOutput)
-				{
-					bestYield = (YieldTypes) i;
-					bestOutput = natureYield;
-				}
-			}
-		}
-
-		if (bestYield != NO_YIELD)
-		{
-			if (isYieldEuropeTradable(bestYield))
-			{
-				iTotal += kPlayerEurope.getYieldSellPrice(bestYield) * bestOutput;
-			}
-		}
-	}
-
-	int iBestValue = 0;
-	for (int i = 0; i < NUM_CITY_PLOTS; i++)
-	{
-		CvPlot* pLoopPlot = plotCity(iX, iY, i);
-
-		if (pLoopPlot != NULL)
-		{
-			if (!pLoopPlot->isBeingWorked())
-			{
-				YieldTypes bestYield = NO_YIELD;
-				int bestOutput = 0;
-				for (int j = 0; j < GC.getNumProfessionInfos(); j++)
-				{
-					ProfessionTypes loopProfession = (ProfessionTypes)j;
-					if (GC.getCivilizationInfo(getCivilizationType()).isValidProfession(loopProfession))
-					{
-						CvProfessionInfo& kProfession = GC.getProfessionInfo(loopProfession);
-
-						if (GC.getProfessionInfo(loopProfession).isWorkPlot())
-						{
-							CvProfessionInfo& kProfession = GC.getProfessionInfo(loopProfession);
-							// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-							YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
-							// MultipleYieldsProduced End
-							if ((eYield != NO_YIELD) && isYieldEuropeTradable(eYield))
-							{
-								int iValue = 0;
-								int yield = pPlot->calculatePotentialProfessionYieldAmount(loopProfession, pColonist, false);
-								if (eYield == YIELD_LUMBER)
-								{
-									iValue += (yield * kPlayerEurope.getYieldSellPrice(eYield)) / 2;
-								}
-								else
-								{
-									iValue += yield * kPlayerEurope.getYieldBuyPrice(eYield);
-								}
-
-								iBestValue = std::max(iValue, iBestValue);
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	iTotal += iBestValue;
-
-	if (bFound)
-	{
-		iTotal *= 7;
-		iTotal /= 6 + getNumCities();
-	}
-
-	return iTotal;
-}
-
-int CvPlayerAI::AI_foundValue(int iX, int iY, int iMinRivalRange, bool bStartingLoc)
-{
-	PROFILE_FUNC();
-	CvPlot* pPlot = GC.getMapINLINE().plotINLINE(iX, iY);
-
-	if (!canFound(iX, iY))
-	{
-		return 0;
-	}
-    ///TKs Med
-    bool bWaterStartNoCity = (!GC.getCivilizationInfo(getCivilizationType()).isWaterStart() && getNumCities() == 0);
-    int iTerrainMod = 1;
-    int iFinalMod = 1;
-	if (!bStartingLoc && !bWaterStartNoCity)
-	{
-		if (!pPlot->isRevealed(getTeam(), false))
-		{
-			return 0;
-		}
-//		if (!GC.getGameINLINE().isFinalInitialized() && isNative())
-//		{
-//            for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
-//            {
-//                CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes) iPlayer);
-//                if ((iPlayer != getID()) && otherPlayer.isAlive())
-//                {
-//                    CvPlot* pOtherPlot = otherPlayer.getStartingPlot();
-//                    if(pOtherPlot == pPlot)
-//                    {
-//                        return 0;
-//                    }
-//                    if(pOtherPlot != NULL)
-//                    {
-//                        int iRange = GC.getMIN_CITY_RANGE();
-//
-//                        for (int iDX = -(iRange); iDX <= iRange; iDX++)
-//                        {
-//                            for (int iDY = -(iRange); iDY <= iRange; iDY++)
-//                            {
-//                                CvPlot* pLoopPlot	= plotXY(pOtherPlot->getX_INLINE(), pOtherPlot->getY_INLINE(), iDX, iDY);
-//
-//                                if (pLoopPlot != NULL)
-//                                {
-//                                    if (pPlot == pLoopPlot)
-//                                    {
-//                                        return 0;
-//                                    }
-//                                }
-//                            }
-//                        }
-//                    }
-//                }
-//            }
-//		}
-
-	}
-	else
-	{
-	    if (pPlot->isCity())
-	    {
-	        return 0;
-	    }
-        if (pPlot->isCityRadius())
-	    {
-	        iFinalMod = 10;
-	    }
-	    if (!isNative() && GC.getCache_NO_STARTING_PLOTS_IN_JUNGLE() >= 1)
-	    {
-	        bool bReduceNoZones = false;
-	        for (int iWorld=0; iWorld<NUM_WORLDSIZE_TYPES; iWorld++)
-            {
-                if (GC.getMapINLINE().getWorldSize() == (WorldSizeTypes)iWorld)
-                {
-                    if (iWorld == 0 || iWorld == 1 || iWorld == 2)
-                    {
-                        bReduceNoZones = true;
-                        break;
-                    }
-                }
-            }
-	       // if (pPlot->getFeatureType() == (FeatureTypes)GC.getDefineINT("JUNGLE_FEATURE"))
-	       // {
-	         //   iFinalMod = 10;
-	       // }
-	        if (pPlot->getImprovementType() != NO_IMPROVEMENT)
-            {
-                if (GC.getImprovementInfo(pPlot->getImprovementType()).isGoody())
-                {
-                    iFinalMod = 5;
-                }
-            }
-            if (!bReduceNoZones)
-            {
-                int iSearchRange = GC.getCache_NO_STARTING_PLOTS_IN_JUNGLE();
-                int iDX, iDY;
-                for (iDX = -(iSearchRange); iDX <= iSearchRange; iDX++)
-                {
-                    for (iDY = -(iSearchRange); iDY <= iSearchRange; iDY++)
-                    {
-                        CvPlot* pLoopPlot = ::plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-
-                        if (pLoopPlot != NULL)
-                        {
-                            if (!pLoopPlot->isWater() && pLoopPlot->isEurope())
-                            {
-                                return 0;
-                            }
-                            if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
-                            {
-                                if (GC.getImprovementInfo(pLoopPlot->getImprovementType()).isGoody())
-                                {
-                                    iFinalMod = 2;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-	    }
-	    int iMinPlotDistance = startingPlotRange();
-        for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
-        {
-            CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes) iPlayer);
-            if ((iPlayer != getID()) && otherPlayer.isAlive())
-            {
-                CvPlot* pOtherPlot = otherPlayer.getStartingPlot();
-                if(pOtherPlot == pPlot)
-                {
-                    return 0;
-                }
-                if (!otherPlayer.isNative() && pOtherPlot != NULL)
-                {
-                    if(!GC.getCivilizationInfo(otherPlayer.getCivilizationType()).isWaterStart())
-                    {
-                        int iPlotDistance = plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pOtherPlot->getX_INLINE(), pOtherPlot->getY_INLINE());
-                        if (iPlotDistance < iMinPlotDistance)
-                        {
-                            return iPlotDistance;
-                        }
-                    }
-//                    int iSearchRange = GC.getDefineINT("NO_STARTING_PLOTS_IN_JUNGLE");
-//                    int iDX, iDY;
-//                    for (iDX = -(iSearchRange); iDX <= iSearchRange; iDX++)
-//                    {
-//                        for (iDY = -(iSearchRange); iDY <= iSearchRange; iDY++)
-//                        {
-//                            CvPlot* pLoopPlot = ::plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-//
-//                            if (pLoopPlot != NULL)
-//                            {
-//                                if(pOtherPlot == pLoopPlot)
-//                                {
-//                                    return 1;
-//                                }
-//
-//                            }
-//                        }
-//                    }
-                }
-            }
-        }
-//        TerrainTypes eFavoredTerrain = NO_TERRAIN;
-//        if (!isNative() && getNumCities() == 0)
-//        {
-//            eFavoredTerrain = (TerrainTypes)GC.getCivilizationInfo(getCivilizationType()).getFavoredTerrain();
-//            if (eFavoredTerrain != NO_TERRAIN)
-//            {
-//                if (pPlot->getTerrainType() == eFavoredTerrain)
-//                {
-//                    iTerrainMod = GC.getDefineINT("AI_FAVORED_TERRAIN_MOD");
-//                }
-//            }
-//        }
-	}
-    ///TKe
-
-	bool bNeedMoreExploring = false;
-	if (getNumCities() == 0 && (pPlot->area()->getNumRevealedTiles(getTeam()) < 10))
-	{
-		bNeedMoreExploring = true;
-	}
-
-	if (isNative() && getNumCities() > 0)
-	{
-		int iRange = CITY_PLOTS_RADIUS * 2 - 1;
-
-		int iCityDistance = AI_cityDistance(pPlot);
-		if (iCityDistance == -1)
-		{
-			return 0;
-		}
-		if (iCityDistance < iRange || iCityDistance > (iRange * 3))
-		{
-			return 0;
-		}
-
-		for (int iDX = -iRange; iDX <= iRange; ++iDX)
-		{
-			for (int iDY = -iRange; iDY <= iRange; ++iDY)
-			{
-				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
-
-				if (pLoopPlot != NULL)
-				{
-					if (pLoopPlot->isOwned())
-					{
-						return 0;
-					}
-				}
-			}
-		}
-	}
-
-	bool bIsCoastal = pPlot->isCoastalLand(GC.getMIN_WATER_SIZE_FOR_OCEAN());
-	CvArea* pArea = pPlot->area();
-	int iNumAreaCities = pArea->getCitiesPerPlayer(getID());
-
-	bool bAdvancedStart = (getAdvancedStartPoints() >= 0);
-
-	if (!bStartingLoc && !bAdvancedStart)
-	{
-		if (iNumAreaCities == 0)
-		{
-			if (getParent() != NO_PLAYER)
-			{
-				if (pPlot->getNearestEurope() == NO_EUROPE)
-				{
-					return 0;
-				}
-			}
-		}
-	}
-
-	if (!bStartingLoc)
-	{
-		if (getNumCities() == 0)
-		{
-			if (pArea->getNumTiles() < (NUM_CITY_PLOTS * 3))
-			{
-				return 0;
-			}
-		}
-	}
-
-	if (bAdvancedStart)
-	{
-		//FAssert(!bStartingLoc);
-		FAssert(GC.getGameINLINE().isOption(GAMEOPTION_ADVANCED_START) || GC.getCivilizationInfo(getCivilizationType()).getAdvancedStartPoints() > 0);
-		if (bStartingLoc)
-		{
-			bAdvancedStart = false;
-		}
-	}
-
-	if (iMinRivalRange != -1)
-	{
-		for (int iDX = -(iMinRivalRange); iDX <= iMinRivalRange; iDX++)
-		{
-			for (int iDY = -(iMinRivalRange); iDY <= iMinRivalRange; iDY++)
-			{
-				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
-
-				if (pLoopPlot != NULL)
-				{
-					if (pLoopPlot->plotCheck(PUF_isOtherTeam, getID()) != NULL)
-					{
-						return 0;
-					}
-				}
-			}
-		}
-	}
-
-	int iOwnedTiles = 0;
-
-	for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
-	{
-		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
-
-		if (pLoopPlot == NULL)
-		{
-			iOwnedTiles++;
-		}
-		else if (pLoopPlot->isOwned() && !GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative())
-        {
-            if (pLoopPlot->getTeam() != getTeam())
-            {
-                iOwnedTiles++;
-            }
-        }
-	}
-
-	if (iOwnedTiles > (NUM_CITY_PLOTS / 3))
-	{
-		return 0;
-	}
-
-	int iBadTile = 0;
-	int iNativeTile = 0;
-	int iFriendlyTile = 0;
-	int iColonialTile = 0;
-
-	std::vector<int> aiFood(NUM_CITY_PLOTS, 0);
-
-	for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
-	{
-		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
-
-		if (pLoopPlot != NULL)
-		{
-			if (iI != CITY_HOME_PLOT)
-			{
-				if (pLoopPlot->isImpassable())
-				{
-					iBadTile += 2;
-				}
-				else if (!pLoopPlot->isOwned() || GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative())
-				{
-					if (!pLoopPlot->isHills() && !pLoopPlot->isWater())
-					{
-						if ((pLoopPlot->calculateBestNatureYield(YIELD_FOOD, getTeam()) == 0) || (pLoopPlot->calculateTotalBestNatureYield(getTeam()) <= 2))
-						{
-							iBadTile++;
-						}
-						else if (pLoopPlot->isWater() && !bIsCoastal && (pLoopPlot->calculateBestNatureYield(YIELD_FOOD, getTeam()) <= 1))
-						{
-							iBadTile++;
-						}
-					}
-				}
-			}
-			if (pLoopPlot->isOwned())
-			{
-				if (GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative())
-				{
-					iNativeTile++;
-				}
-				else if (GET_PLAYER(pLoopPlot->getOwnerINLINE()).getParent() != NO_PLAYER)
-				{
-					iColonialTile += pLoopPlot->getCityRadiusCount();
-					if (pLoopPlot->getTeam() == getTeam())
-					{
-						iFriendlyTile++;
-					}
-				}
-			}
-		}
-		else
-		{
-			iBadTile++;
-		}
-
-	}
-
-	if(!bStartingLoc)
-	{
-		if (bNeedMoreExploring)
-		{
-			if (iBadTile >= (NUM_CITY_PLOTS / 2))
-			{
-				return 0;
-			}
-		}
-	}
-
-
-	int aiBestWorkedYield[NUM_YIELD_TYPES];
-	int aiBestUnworkedYield[NUM_YIELD_TYPES];
-
-	for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-	{
-		CvPlot* pWorkedPlot = AI_getBestWorkedYieldPlot((YieldTypes)iYield);
-		if (pWorkedPlot == NULL)
-		{
-			aiBestWorkedYield[iYield] = 0;
-		}
-		else
-		{
-			aiBestWorkedYield[iYield] = pWorkedPlot->calculateBestNatureYield((YieldTypes)iYield, getTeam());
-		}
-
-		CvPlot* pUnworkedPlot = AI_getBestUnworkedYieldPlot((YieldTypes)iYield);
-		if (pUnworkedPlot == NULL)
-		{
-			aiBestUnworkedYield[iYield] = 0;
-		}
-		else
-		{
-			aiBestUnworkedYield[iYield] = pUnworkedPlot->calculateBestNatureYield((YieldTypes)iYield, getTeam());
-		}
-	}
-
-	int iTakenTiles = 0;
-	int iTeammateTakenTiles = 0;
-	int iValue = 1000;
-
-	int iBestPlotValue = 0;
-	for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
-	{
-		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
-
-		if (pLoopPlot == NULL)
-		{
-			iTakenTiles++;
-		}
-		else
-		{
-			if (pLoopPlot->isCityRadius())
-			{
-				iTakenTiles++;
-
-				if (pLoopPlot->getTeam() == getTeam() && pLoopPlot->getOwner() != getID())
-				{
-					iTeammateTakenTiles++;
-				}
-			}
-
-			if (!pLoopPlot->isCityRadius() || (pLoopPlot->isOwned() && GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative()))
-			{
-				int iBestBonusAmount = 0;
-				YieldTypes eBestBonusYield = NO_YIELD;
-
-				int aiYield[NUM_YIELD_TYPES];
-
-				for (int iYieldType = 0; iYieldType < NUM_YIELD_TYPES; ++iYieldType)
-				{
-
-
-					YieldTypes eYield = (YieldTypes)iYieldType;
-					int iYield = pLoopPlot->calculateBestNatureYield(eYield, getTeam());
-
-
-
-					if (iI == CITY_HOME_PLOT)
-					{
-						iYield += GC.getYieldInfo(eYield).getCityChange();
-						//XXX make sure this reflects reality of Col
-						iYield = std::max(iYield, GC.getYieldInfo(eYield).getMinCity());
-					}
-
-					aiYield[eYield] = iYield;
-					if (eYield == YIELD_FOOD)
-					{
-						aiFood[iI] = iYield;
-					}
-				}
-
-				if (iI == CITY_HOME_PLOT)
-				{
-					iValue += 2 * aiYield[YIELD_FOOD] * AI_yieldValue(YIELD_FOOD);
-
-					YieldTypes bestYield = NO_YIELD;
-					int bestOutput = 0;
-					for (int i = 0; i < NUM_YIELD_TYPES; i++)
-					{
-						//ignore food and lumber
-						if ((i != YIELD_FOOD) && (i != YIELD_LUMBER))
-						{
-							int natureYield = pPlot->calculateNatureYield((YieldTypes) i, getTeam(), false);
-							if (natureYield > bestOutput)
-							{
-								bestYield = (YieldTypes) i;
-								bestOutput = natureYield;
-							}
-						}
-					}
-					if (bestYield != NO_YIELD)
-					{
-						iValue += 2 * bestOutput * AI_yieldValue(bestYield);
-					}
-				}
-				else
-				{
-					YieldTypes eBestYield = NO_YIELD;
-					int iBestValue = 0;
-					for (int iYieldType = 0; iYieldType < NUM_YIELD_TYPES; ++iYieldType)
-					{
-						YieldTypes eYield = (YieldTypes)iYieldType;
-
-						if (aiYield[eYield] > 0)
-						{
-							int iYieldValue = aiYield[eYield] * AI_yieldValue(eYield);
-
-							if (pLoopPlot->isWater())
-							{
-								iYieldValue /= 2;
-							}
-
-							if (getNumCities() > 0)
-							{
-								if (aiYield[eYield] > aiBestUnworkedYield[eYield])
-								{
-									iYieldValue *= (4 + aiYield[eYield]);
-									iYieldValue /= (2 + aiBestUnworkedYield[eYield]);
-
-									if (aiBestWorkedYield[eYield] == 0)
-									{
-										iYieldValue *= 2;
-										if (aiBestUnworkedYield[eYield] == 0)
-										{
-											if (eYield == YIELD_LUMBER)
-											{
-												iYieldValue *= 4;
-											}
-										}
-									}
-								}
-							}
-							else
-							{
-								if (eYield == YIELD_LUMBER)
-								{
-									iYieldValue *= 2;
-								}
-							}
-
-							iValue += iYieldValue / ((getNumCities() == 0) ? 3 : 8);
-							if (iYieldValue > iBestValue)
-							{
-								iBestValue = iYieldValue;
-								eBestYield = eYield;
-							}
-						}
-					}
-
-					if (getNumCities() == 0)
-					{
-						if (eBestYield == YIELD_FOOD)
-						{
-							iBestValue *= 150;
-							iBestValue /= 100;
-						}
-					}
-
-					iValue += iBestValue;
-
-					iBestPlotValue = std::max(iBestPlotValue, iBestValue);
-
-					if (pLoopPlot->getBonusType() != NO_BONUS && eBestYield != NO_YIELD)
-					{
-						iValue += iBestValue;
-						if (GC.getBonusInfo(pLoopPlot->getBonusType()).getYieldChange(eBestYield) > 0)
-						{
-							iValue += iBestValue;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	iValue += iBestPlotValue;
-
-	if (iTeammateTakenTiles > 1)
-	{
-		return 0;
-	}
-
-	if (pPlot->isCoastalLand(GC.getMIN_WATER_SIZE_FOR_OCEAN()))
-	{
-		iValue *= 125;
-		iValue /= 100;
-	}
-
-	if (bStartingLoc)
-	{
-		int iRange = GREATER_FOUND_RANGE;
-		int iGreaterBadTile = 0;
-
-		for (int iDX = -(iRange); iDX <= iRange; iDX++)
-		{
-			for (int iDY = -(iRange); iDY <= iRange; iDY++)
-			{
-				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
-
-				if (pLoopPlot != NULL)
-				{
-					if (pLoopPlot->isWater() || (pLoopPlot->area() == pArea))
-					{
-						if (plotDistance(iX, iY, pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE()) <= iRange)
-						{
-						    int iTempValue = 0;
-							iTempValue += (pLoopPlot->calculatePotentialYield(YIELD_FOOD, NULL, false) * 15);
-							///TKs Med
-							iValue += (iTempValue * iTerrainMod);
-							if (iTempValue < 21 && iTerrainMod == 1)
-							{
-                            ///TKe
-								iGreaterBadTile += 2;
-								if (pLoopPlot->getFeatureType() != NO_FEATURE)
-								{
-							    	if (pLoopPlot->calculateBestNatureYield(YIELD_FOOD, getTeam()) > 1)
-							    	{
-										iGreaterBadTile--;
-							    	}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-
-		if (!pPlot->isStartingPlot())
-		{
-			iGreaterBadTile /= 2;
-			if (iGreaterBadTile > 12)
-			{
-				iValue *= 11;
-				iValue /= iGreaterBadTile;
-			}
-		}
-
-		int iWaterCount = 0;
-
-		for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
-		{
-		    CvPlot* pLoopPlot = plotCity(iX, iY, iI);
-
-            if (pLoopPlot != NULL)
-		    {
-		        if (pLoopPlot->isWater())
-		        {
-		            iWaterCount ++;
-		            if (pLoopPlot->calculatePotentialYield(YIELD_FOOD, NULL, false) <= 1)
-		            {
-		                iWaterCount++;
-					}
-				}
-			}
-		}
-		iWaterCount /= 2;
-
-		int iLandCount = (NUM_CITY_PLOTS - iWaterCount);
-
-		if (iLandCount < (NUM_CITY_PLOTS / 2))
-		{
-		    //discourage very water-heavy starts.
-		    iValue *= 1 + iLandCount;
-		    iValue /= (1 + (NUM_CITY_PLOTS / 2));
-		}
-	}
-
-	if (bStartingLoc)
-	{
-		if (pPlot->getMinOriginalStartDist() == -1)
-		{
-			iValue += (GC.getMapINLINE().maxStepDistance() * 100);
-		}
-		else
-		{
-			iValue *= (1 + 4 * pPlot->getMinOriginalStartDist());
-			iValue /= (1 + 2 * GC.getMapINLINE().maxStepDistance());
-		}
-
-		//nice hacky way to avoid this messing with normalizer, use elsewhere?
-		if (!pPlot->isStartingPlot())
-		{
-			int iMinDistanceFactor = MAX_INT;
-			int iMinRange = startingPlotRange();
-
-			iValue *= 100;
-			for (int iJ = 0; iJ < MAX_PLAYERS; iJ++)
-			{
-				if (GET_PLAYER((PlayerTypes)iJ).isAlive())
-				{
-					if (iJ != getID())
-					{
-						int iClosenessFactor = GET_PLAYER((PlayerTypes)iJ).startingPlotDistanceFactor(pPlot, getID(), iMinRange);
-						iMinDistanceFactor = std::min(iClosenessFactor, iMinDistanceFactor);
-
-						if (iClosenessFactor < 1000)
-						{
-							iValue *= 2000 + iClosenessFactor;
-							iValue /= 3000;
-						}
-					}
-				}
-			}
-
-			if (iMinDistanceFactor > 1000)
-			{
-				if (isNative())
-				{
-					iValue *= 500 + iMinDistanceFactor;
-					iValue /= 1500;
-				}
-				else
-				{
-					//give a maximum boost of 25% for somewhat distant locations, don't go overboard.
-					iMinDistanceFactor = std::min(1500, iMinDistanceFactor);
-					iValue *= (1000 + iMinDistanceFactor);
-					iValue /= 2000;
-				}
-			}
-			else if (iMinDistanceFactor < 1000)
-			{
-				//this is too close so penalize again.
-				iValue *= iMinDistanceFactor;
-				iValue /= 1000;
-				iValue *= iMinDistanceFactor;
-				iValue /= 1000;
-			}
-
-			iValue /= 10;
-		}
-	}
-
-	if (getNumCities() > 0)
-	{
-		//Friendly City Distance Modifier
-		if (isNative())
-		{
-			int iCityDistance = AI_cityDistance(pPlot);
-
-			iCityDistance = std::min(iCityDistance, 15);
-
-			iValue *= 10;
-			iValue /= 6 + iCityDistance;
-
-			if (iCityDistance < 4)
-			{
-				iValue /= 4 - iCityDistance;
-			}
-		}
-		else
-		{
-			int iCityDistance = AI_cityDistance(pPlot);
-
-			iCityDistance = std::min(iCityDistance, 10);
-
-			int iMinDistance = GC.getMIN_CITY_RANGE() + 1;
-			int iMaxDistance = iMinDistance + 2;
-
-			if (iCityDistance < iMinDistance)
-			{
-				int iFactor = AI_isStrategy(STRATEGY_DENSE_CITY_SPACING) ? 4 : 1;
-				iValue *= iFactor + iCityDistance;
-				iValue /= iFactor + iMinDistance;
-			}
-
-			if (iCityDistance > iMaxDistance)
-			{
-				iValue *= iMaxDistance;
-				iValue /= iCityDistance;
-			}
-
-			CvCity* pPrimaryCity = AI_getPrimaryCity();
-			if (pPrimaryCity != NULL)
-			{
-				int iDistance = stepDistance(iX, iY, pPrimaryCity->getX_INLINE(), pPrimaryCity->getY_INLINE());
-
-				iValue *= 6;
-				iValue /= 3 + iDistance;
-				if (iDistance > 9)
-				{
-					iValue *= 3;
-					iValue /= iDistance - 6;
-				}
-			}
-		}
-	}
-	///TKs Med
-	else if (!isNative() && GC.getCivilizationInfo(getCivilizationType()).isWaterStart())
-	{// Ocean Distance Modifier
-		iValue *= 8;
-		iValue /= std::max(1, pPlot->getDistanceToOcean());
-	}
-    ///TKe
-	if (iValue <= 0)
-	{
-		return 1;
-	}
-
-	if (bNeedMoreExploring)
-	{
-		int iBonusCount = 0;
-		int iLandCount = 0;
-		for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
-		{
-			CvPlot* pLoopPlot = plotCity(iX, iY, iI);
-
-			if (iI != CITY_HOME_PLOT)
-			{
-				if ((pLoopPlot == NULL) || pLoopPlot->isImpassable())
-				{
-					return 1;
-				}
-				else
-				{
-					if (pLoopPlot->getBonusType() != NO_BONUS)
-					{
-						iBonusCount++;
-					}
-				}
-				if (!pLoopPlot->isWater())
-				{
-					iLandCount++;
-				}
-			}
-
-		}
-
-		if (iBonusCount == 0)
-		{
-			return 1;
-		}
-		else if (iBonusCount == 1)
-		{
-			if (pPlot->getYield(YIELD_FOOD) < GC.getFOOD_CONSUMPTION_PER_POPULATION())
-			{
-				return 1;
-			}
-			if (iLandCount < (NUM_CITY_PLOTS / 2))
-			{
-				return 1;
-			}
-			iValue /= 4;
-		}
-	}
-
-	//Modify value according to easily attainable food.
-	//Making this more important for early cities.
-	{
-		int iFood = aiFood[CITY_HOME_PLOT];
-
-		std::sort(aiFood.begin(), aiFood.end(), std::greater<int>());
-
-		iFood += aiFood[0];
-
-		int iConsumption = 4 * GC.getFOOD_CONSUMPTION_PER_POPULATION();
-
-		if (iFood < iConsumption)
-		{
-			if (getNumCities() == 0)
-			{
-				return 1;
-			}
-			iValue *= 100 - 4 * (100 - 100 * iFood / iConsumption) / (4 + getNumCities());
-			iValue /= 100;
-		}
-		else if (iFood > iConsumption)
-		{
-			iValue *= 100 + ((100 * iFood / iConsumption) - 100) / (1 + getNumCities());
-			iValue /= 100;
-		}
-
-		if (isNative())
-		{
-			iValue *= iFood;
-			iValue /= iConsumption;
-		}
-	}
-
-	if (pPlot->getBonusType() != NO_BONUS)
-	{
-		iValue *= 2;
-		iValue /= 3;
-	}
-
-	//Modify values according to other player culture
-	if (!isNative())
-	{
-		iValue *= (NUM_CITY_PLOTS - iNativeTile);
-		iValue /= NUM_CITY_PLOTS;
-
-		if (iColonialTile > 0)
-		{
-			iValue *= std::max(1, (NUM_CITY_PLOTS - iColonialTile));
-			iValue /= NUM_CITY_PLOTS;
-
-			if (iFriendlyTile == 0)
-			{
-				iValue /= 2;
-			}
-		}
-	}
-
-	///Tks Med
-	if (iValue > iFinalMod)
-	{
-        iValue /= iFinalMod;
-	}
-	///Tke
-
-	return std::max(1, iValue);
-}
-
-int CvPlayerAI::AI_foundValueNative(int iX, int iY)
-{
-	CvPlot* pPlot = plotXY(iX, iY, 0, 0);
-	FAssert(pPlot != NULL);
-
-	if (pPlot->isWater())
-	{
-		return 0;
-	}
-
-	if (pPlot->getOwnerINLINE() != getID())
-	{
-		return 0;
-	}
-
-	if (!canFound(iX, iY, false))
-	{
-		return 0;
-	}
-    ///TKs Med
-    //if (!GC.getGameINLINE().isFinalInitialized() && isNative())
-    //{
-        for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
-        {
-            CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes) iPlayer);
-            if ((iPlayer != getID()) && otherPlayer.isAlive() && !otherPlayer.isNative())
-            {
-                CvPlot* pOtherPlot = otherPlayer.getStartingPlot();
-                if(pOtherPlot->isWater())
-                {
-                    continue;
-                }
-                if(pOtherPlot == pPlot)
-                {
-                    return 0;
-                }
-                if(pOtherPlot != NULL)
-                {
-                    int iRange = GC.getMIN_CITY_RANGE();
-
-                    for (int iDX = -(iRange); iDX <= iRange; iDX++)
-                    {
-                        for (int iDY = -(iRange); iDY <= iRange; iDY++)
-                        {
-                            CvPlot* pLoopPlot	= plotXY(pOtherPlot->getX_INLINE(), pOtherPlot->getY_INLINE(), iDX, iDY);
-
-                            if (pLoopPlot != NULL)
-                            {
-                                if (pPlot == pLoopPlot)
-                                {
-                                    return 0;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-   /// }
-    ///TKe
-	int iYields = 0;
-	for (int i = 0; i < NUM_YIELD_TYPES; i++)
-	{
-		if (i != YIELD_FOOD)
-		{
-			iYields += pPlot->getYield((YieldTypes)i);
-		}
-	}
-	if (iYields == 0)
-	{
-		return 0;
-	}
-
-	int iWaterCount = 0;
-	for (int iDirection = 0; iDirection < NUM_DIRECTION_TYPES; iDirection++)
-	{
-		CvPlot* pLoopPlot = plotDirection(iX, iY, (DirectionTypes)iDirection);
-		if (pLoopPlot != NULL)
-		{
-			if (pLoopPlot->isWater() && !pLoopPlot->isLake())
-			{
-				iWaterCount++;
-			}
-		}
-	}
-	if (iWaterCount > 4)
-	{
-		return 0;
-	}
-
-	int iBadTileCount = 0;
-	for (int iI = 0; iI < NUM_CITY_PLOTS; ++iI)
-	{
-		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
-		if (pLoopPlot != NULL)
-		{
-			if (pLoopPlot->isImpassable())
-			{
-				iBadTileCount++;
-			}
-			else if (pLoopPlot->getYield(YIELD_FOOD) < 2)
-			{
-				iBadTileCount++;
-			}
-		}
-	}
-	if (iBadTileCount > (NUM_CITY_PLOTS * 2) / 3)
-	{
-		return 0;
-	}
-
-	int iValue = 0;
-	int iCityCount = 0;
-	int iRange = 3;
-
-	for (int iDX = -iRange; iDX <= iRange; iDX++)
-	{
-		for (int iDY = -iRange; iDY <= iRange; iDY++)
-		{
-			int iDistance = plotDistance(iDX, iDY, 0, 0);
-			if (iDistance <= iRange)
-			{
-				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
-				if (pLoopPlot != NULL)
-				{
-					if (pLoopPlot->isCity())
-					{
-						iCityCount++;
-						if (iDistance == 1)
-						{
-							iCityCount++;
-						}
-					}
-					else if (!pLoopPlot->isCityRadius())
-					{
-						if (pLoopPlot->isWater())
-						{
-							iValue ++;
-						}
-						else if (pLoopPlot->getOwnerINLINE() == getID())
-						{
-							iValue++;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (iCityCount > 1)
-	{
-		return 0;
-	}
-
-	if (iValue < (27 / (std::max(1, 3 - getNumCities()))))
-	{
-		return 0;
-	}
-	iValue *= 100;
-	iValue += GC.getGame().getSorenRandNum(300, "AI native city found value");
-	return iValue;
-}
-
-
-bool CvPlayerAI::AI_isAreaAlone(CvArea* pArea)
-{
-	return ((pArea->getNumCities()) == GET_TEAM(getTeam()).countNumCitiesByArea(pArea));
-}
-
-
-bool CvPlayerAI::AI_isCapitalAreaAlone()
-{
-	CvCity* pCapitalCity;
-
-	pCapitalCity = getPrimaryCity();
-
-	if (pCapitalCity != NULL)
-	{
-		return AI_isAreaAlone(pCapitalCity->area());
-	}
-
-	return false;
-}
-
-
-bool CvPlayerAI::AI_isPrimaryArea(CvArea* pArea)
-{
-	CvCity* pCapitalCity;
-
-	if (pArea->isWater())
-	{
-		return false;
-	}
-
-	if (pArea->getCitiesPerPlayer(getID()) > 2)
-	{
-		return true;
-	}
-
-	pCapitalCity = getPrimaryCity();
-
-	if (pCapitalCity != NULL)
-	{
-		if (pCapitalCity->area() == pArea)
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-
-int CvPlayerAI::AI_militaryWeight(CvArea* pArea)
-{
-	return (pArea->getPopulationPerPlayer(getID()) + pArea->getCitiesPerPlayer(getID()) + 1);
-}
-
-
-int CvPlayerAI::AI_targetCityValue(CvCity* pCity, bool bRandomize, bool bIgnoreAttackers)
-{
-	PROFILE_FUNC();
-
-	CvCity* pNearestCity;
-	CvPlot* pLoopPlot;
-	int iValue;
-	int iI;
-
-	FAssertMsg(pCity != NULL, "City is not assigned a valid value");
-
-	iValue = 1;
-
-	iValue += ((pCity->getPopulation() * (50 + pCity->calculateCulturePercent(getID()))) / 100);
-
-	if (pCity->getDefenseDamage() > 0)
-	{
-		iValue += ((pCity->getDefenseDamage() / 30) + 1);
-	}
-
-	if (pCity->isCoastal(GC.getMIN_WATER_SIZE_FOR_OCEAN()))
-	{
-		iValue++;
-	}
-
-	if (pCity->isEverOwned(getID()))
-	{
-		iValue += 3;
-	}
-	if (!bIgnoreAttackers)
-	{
-	iValue += AI_adjacentPotentialAttackers(pCity->plot());
-	}
-
-	for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
-	{
-		pLoopPlot = plotCity(pCity->getX_INLINE(), pCity->getY_INLINE(), iI);
-
-		if (pLoopPlot != NULL)
-		{
-			if (pLoopPlot->getBonusType() != NO_BONUS)
-			{
-				iValue++;
-			}
-
-			if (pLoopPlot->getOwnerINLINE() == getID())
-			{
-				iValue++;
-			}
-
-			if (pLoopPlot->isAdjacentPlayer(getID(), true))
-			{
-				iValue++;
-			}
-		}
-	}
-
-	pNearestCity = GC.getMapINLINE().findCity(pCity->getX_INLINE(), pCity->getY_INLINE(), getID());
-
-	if (pNearestCity != NULL)
-	{
-		iValue += std::max(1, ((GC.getMapINLINE().maxStepDistance() * 2) - GC.getMapINLINE().calculatePathDistance(pNearestCity->plot(), pCity->plot())));
-	}
-
-	if (bRandomize)
-	{
-		iValue += GC.getGameINLINE().getSorenRandNum(((pCity->getPopulation() / 2) + 1), "AI Target City Value");
-	}
-
-	return iValue;
-}
-
-
-CvCity* CvPlayerAI::AI_findTargetCity(CvArea* pArea)
-{
-	CvCity* pLoopCity;
-	CvCity* pBestCity;
-	int iValue;
-	int iBestValue;
-	int iLoop;
-	int iI;
-
-	iBestValue = 0;
-	pBestCity = NULL;
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			if (isPotentialEnemy(getTeam(), GET_PLAYER((PlayerTypes)iI).getTeam()))
-			{
-				for (pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
-				{
-					if (pLoopCity->area() == pArea)
-					{
-						iValue = AI_targetCityValue(pLoopCity, true);
-
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							pBestCity = pLoopCity;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return pBestCity;
-}
-
-
-int CvPlayerAI::AI_getPlotDanger(CvPlot* pPlot, int iRange, bool bTestMoves, bool bOffensive)
-{
-	PROFILE_FUNC();
-
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	CvPlot* pLoopPlot;
-	int iCount;
-	int iDistance;
-	int iBorderDanger;
-	int iDX, iDY;
-	CvArea *pPlotArea = pPlot->area();
-
-	iCount = 0;
-	iBorderDanger = 0;
-
-	if (iRange == -1)
-	{
-		iRange = DANGER_RANGE;
-	}
-
-	for (iDX = -(iRange); iDX <= iRange; iDX++)
-	{
-		for (iDY = -(iRange); iDY <= iRange; iDY++)
-		{
-			pLoopPlot	= plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-
-			if (pLoopPlot != NULL)
-			{
-				if (pLoopPlot->area() == pPlotArea)
-				{
-				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
-				    if (atWar(pLoopPlot->getTeam(), getTeam()))
-				    {
-				        if (iDistance == 1)
-				        {
-				            iBorderDanger++;
-				        }
-				        else if ((iDistance == 2) && (pLoopPlot->isRoute()))
-				        {
-				            iBorderDanger++;
-				        }
-				    }
-
-
-					pUnitNode = pLoopPlot->headUnitNode();
-
-					while (pUnitNode != NULL)
-					{
-						pLoopUnit = ::getUnit(pUnitNode->m_data);
-						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-						if (pLoopUnit->isEnemy(getTeam()))
-						{
-						    //TKs Med
-						    bool bDangerousBarb = true;
-						    //if (pLoopUnit->isBarbarian() && !pLoopUnit->isOnlyDefensive())
-						    if (isHuman() && pLoopUnit->isBarbarian())
-						    {
-						        bDangerousBarb = false;
-						    }
-
-							if (bDangerousBarb && (bOffensive || pLoopUnit->canAttack()))
-							{
-								if (!(pLoopUnit->isInvisible(getTeam(), false)))
-								{
-								    if (bOffensive || bDangerousBarb || pLoopUnit->canMoveOrAttackInto(pPlot))
-								    {
-								        ///Tke
-                                        if (!bTestMoves)
-                                        {
-                                            iCount++;
-                                        }
-                                        else
-                                        {
-                                            int iDangerRange = pLoopUnit->baseMoves();
-                                            iDangerRange += ((pLoopPlot->isValidRoute(pLoopUnit)) ? 1 : 0);
-                                            if (iDangerRange >= iDistance)
-											{
-												iCount++;
-											}
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (iBorderDanger > 0)
-	{
-	    if (!isHuman() && (!pPlot->isCity() || bOffensive))
-	    {
-            iCount += iBorderDanger;
-	    }
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_getUnitDanger(CvUnit* pUnit, int iRange, bool bTestMoves, bool bAnyDanger)
-{
-	PROFILE_FUNC();
-
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	CvPlot* pLoopPlot;
-	int iCount;
-	int iDistance;
-	int iBorderDanger;
-	int iDX, iDY;
-
-    CvPlot* pPlot = pUnit->plot();
-	iCount = 0;
-	iBorderDanger = 0;
-
-	if (iRange == -1)
-	{
-		iRange = DANGER_RANGE;
-	}
-
-	for (iDX = -(iRange); iDX <= iRange; iDX++)
-	{
-		for (iDY = -(iRange); iDY <= iRange; iDY++)
-		{
-			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-
-			if (pLoopPlot != NULL)
-			{
-				if (pLoopPlot->area() == pPlot->area())
-				{
-				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
-				    if (atWar(pLoopPlot->getTeam(), getTeam()))
-				    {
-				        if (iDistance == 1)
-				        {
-				            iBorderDanger++;
-				        }
-				        else if ((iDistance == 2) && (pLoopPlot->isRoute()))
-				        {
-				            iBorderDanger++;
-				        }
-				    }
-
-
-					pUnitNode = pLoopPlot->headUnitNode();
-
-					while (pUnitNode != NULL)
-					{
-						pLoopUnit = ::getUnit(pUnitNode->m_data);
-						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-						if (atWar(pLoopUnit->getTeam(), getTeam()))
-						{
-							if (pLoopUnit->canAttack())
-							{
-								if (!(pLoopUnit->isInvisible(getTeam(), false)))
-								{
-								    if (pLoopUnit->canMoveOrAttackInto(pPlot))
-								    {
-                                        if (!bTestMoves)
-                                        {
-                                            iCount++;
-                                        }
-                                        else
-                                        {
-                                            int iDangerRange = pLoopUnit->baseMoves();
-                                            iDangerRange += ((pLoopPlot->isValidRoute(pLoopUnit)) ? 1 : 0);
-                                            if (iDangerRange >= iDistance)
-                                            {
-                                                iCount++;
-                                            }
-                                        }
-								    }
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (iBorderDanger > 0)
-	{
-	    if (!isHuman() || pUnit->isAutomated())
-	    {
-            iCount += iBorderDanger;
-	    }
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_getWaterDanger(CvPlot* pPlot, int iRange, bool bTestMoves)
-{
-	PROFILE_FUNC();
-
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	CvPlot* pLoopPlot;
-	int iCount;
-	int iDX, iDY;
-
-	iCount = 0;
-
-	if (iRange == -1)
-	{
-		iRange = DANGER_RANGE;
-	}
-
-	CvArea* pWaterArea = pPlot->waterArea();
-
-	for (iDX = -(iRange); iDX <= iRange; iDX++)
-	{
-		for (iDY = -(iRange); iDY <= iRange; iDY++)
-		{
-			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-
-			if (pLoopPlot != NULL)
-			{
-				if (pLoopPlot->isWater())
-				{
-					if (pPlot->isAdjacentToArea(pLoopPlot->getArea()))
-					{
-						pUnitNode = pLoopPlot->headUnitNode();
-
-						while (pUnitNode != NULL)
-						{
-							pLoopUnit = ::getUnit(pUnitNode->m_data);
-							pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-							if (pLoopUnit->isEnemy(getTeam()))
-							{
-								if (pLoopUnit->canAttack())
-								{
-									if (!(pLoopUnit->isInvisible(getTeam(), false)))
-									{
-										iCount++;
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_goldTarget()
-{
-	int iGold = 0;
-
-	if (GC.getGameINLINE().getElapsedGameTurns() >= 40)
-	{
-		int iMultiplier = 0;
-		iMultiplier += GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getFatherPercent();
-		iMultiplier += GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();
-		iMultiplier += GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getConstructPercent();
-		iMultiplier /= 3;
-
-		iGold += ((getNumCities() * 3) + (getTotalPopulation() / 3));
-
-		iGold += (GC.getGameINLINE().getElapsedGameTurns() / 2);
-
-		iGold *= iMultiplier;
-		iGold /= 100;
-
-		bool bAnyWar = GET_TEAM(getTeam()).getAnyWarPlanCount() > 0;
-		if (bAnyWar)
-		{
-			iGold *= 3;
-			iGold /= 2;
-		}
-		iGold += (AI_goldToUpgradeAllUnits() / (bAnyWar ? 1 : 2));
-	}
-
-	return iGold + AI_getExtraGoldTarget();
-}
-
-DiploCommentTypes CvPlayerAI::AI_getGreeting(PlayerTypes ePlayer)
-{
-	TeamTypes eWorstEnemy;
-
-	if (GET_PLAYER(ePlayer).getTeam() != getTeam())
-	{
-		eWorstEnemy = GET_TEAM(getTeam()).AI_getWorstEnemy();
-
-		if ((eWorstEnemy != NO_TEAM) && (eWorstEnemy != GET_PLAYER(ePlayer).getTeam()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eWorstEnemy) && (GC.getASyncRand().get(4) == 0))
-		{
-			if (GET_PLAYER(ePlayer).AI_hasTradedWithTeam(eWorstEnemy) && !atWar(GET_PLAYER(ePlayer).getTeam(), eWorstEnemy))
-			{
-				return (DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_WORST_ENEMY_TRADING");
-			}
-			else
-			{
-				return (DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_WORST_ENEMY");
-			}
-		}
-	}
-
-	return (DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_GREETINGS");
-}
-
-
-bool CvPlayerAI::AI_isWillingToTalk(PlayerTypes ePlayer)
-{
-	FAssertMsg(getPersonalityType() != NO_LEADER, "getPersonalityType() is not expected to be equal with NO_LEADER");
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-
-	if (GET_PLAYER(ePlayer).getTeam() == getTeam())
-	{
-		return true;
-	}
-
-	if (GET_TEAM(getTeam()).isHuman())
-	{
-		return false;
-	}
-
-	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-	{
-		if (GET_TEAM(getTeam()).isParentOf(GET_PLAYER(ePlayer).getTeam()))
-		{
-			return false;
-		}
-
-		int iRefuseDuration = (GC.getLeaderHeadInfo(getPersonalityType()).getRefuseToTalkWarThreshold());
-
-		if  (GET_TEAM(getTeam()).AI_isChosenWar(GET_PLAYER(ePlayer).getTeam()))
-		{
-			if (!isNative())
-			{
-				iRefuseDuration *= 2;
-			}
-		}
-		else
-		{
-			if (isNative())
-			{
-				iRefuseDuration *= 2;
-			}
-		}
-
-		int iOurSuccess = 1 + GET_TEAM(getTeam()).AI_getWarSuccess(GET_PLAYER(ePlayer).getTeam());
-		int iTheirSuccess = 1 + GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_getWarSuccess(getTeam());
-		if (iTheirSuccess > iOurSuccess * 2)
-		{
-			iRefuseDuration *= 50 + ((50 * iOurSuccess * 2) / iTheirSuccess);
-			iRefuseDuration /= 100;
-		}
-
-		if (isNative())
-		{
-			iRefuseDuration *= 2;
-			int iGameTurns = GC.getGameINLINE().getEstimateEndTurn();
-			int iCurrentTurn = GC.getGameINLINE().getGameTurn();
-
-			if (!GET_TEAM(getTeam()).AI_isChosenWar((GET_PLAYER(ePlayer).getTeam())))
-			{
-				iCurrentTurn += iGameTurns / 2;
-			}
-
-			iRefuseDuration *= std::max(0, iCurrentTurn - iGameTurns / 12);
-			iRefuseDuration /= iGameTurns;
-		}
-
-		if (GET_TEAM(getTeam()).AI_getAtWarCounter(GET_PLAYER(ePlayer).getTeam()) < iRefuseDuration)
-		{
-			return false;
-		}
-	}
-	else
-	{
-		if (AI_getMemoryCount(ePlayer, MEMORY_STOPPED_TRADING_RECENT) > 0)
-		{
-			return false;
-		}
-	}
-
-	return true;
-}
-
-
-// XXX what if already at war???
-// Returns true if the AI wants to sneak attack...
-bool CvPlayerAI::AI_demandRebukedSneak(PlayerTypes ePlayer)
-{
-	FAssertMsg(!isHuman(), "isHuman did not return false as expected");
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-
-	FAssert(!(GET_TEAM(getTeam()).isHuman()));
-
-	if (GC.getGameINLINE().getSorenRandNum(100, "AI Demand Rebuked") < GC.getLeaderHeadInfo(getPersonalityType()).getDemandRebukedSneakProb())
-	{
-		if (GET_TEAM(getTeam()).getPower() > GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getDefensivePower())
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-
-// XXX what if already at war???
-// Returns true if the AI wants to declare war...
-bool CvPlayerAI::AI_demandRebukedWar(PlayerTypes ePlayer)
-{
-	FAssertMsg(!isHuman(), "isHuman did not return false as expected");
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-
-	FAssert(!(GET_TEAM(getTeam()).isHuman()));
-
-	// needs to be async because it only happens on the computer of the player who is in diplomacy...
-	if (GC.getASyncRand().get(100, "AI Demand Rebuked ASYNC") < GC.getLeaderHeadInfo(getPersonalityType()).getDemandRebukedWarProb())
-	{
-		if (GET_TEAM(getTeam()).getPower() > GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getDefensivePower())
-		{
-			if (GET_TEAM(getTeam()).AI_isAllyLandTarget(GET_PLAYER(ePlayer).getTeam()))
-			{
-				return true;
-			}
-		}
-	}
-
-	return false;
-}
-
-
-// XXX maybe make this a little looser (by time...)
-bool CvPlayerAI::AI_hasTradedWithTeam(TeamTypes eTeam)
-{
-	int iI;
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			if (GET_PLAYER((PlayerTypes)iI).getTeam() == eTeam)
-			{
-				if ((AI_getPeacetimeGrantValue((PlayerTypes)iI) + AI_getPeacetimeTradeValue((PlayerTypes)iI)) > 0)
-				{
-					return true;
-				}
-			}
-		}
-	}
-
-	return false;
-}
-
-// static
-AttitudeTypes CvPlayerAI::AI_getAttitude(int iAttitudeVal)
-{
-	if (iAttitudeVal >= 10)
-	{
-		return ATTITUDE_FRIENDLY;
-	}
-	else if (iAttitudeVal >= 3)
-	{
-		return ATTITUDE_PLEASED;
-	}
-	else if (iAttitudeVal <= -10)
-	{
-		return ATTITUDE_FURIOUS;
-	}
-	else if (iAttitudeVal <= -3)
-	{
-		return ATTITUDE_ANNOYED;
-	}
-	else
-	{
-		return ATTITUDE_CAUTIOUS;
-	}
-}
-
-AttitudeTypes CvPlayerAI::AI_getAttitude(PlayerTypes ePlayer, bool bForced)
-{
-	PROFILE_FUNC();
-
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-
-	return (AI_getAttitude(AI_getAttitudeVal(ePlayer, bForced)));
-}
-
-
-int CvPlayerAI::AI_getAttitudeVal(PlayerTypes ePlayer, bool bForced)
-{
-	PROFILE_FUNC();
-
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-
-	if (bForced)
-	{
-		if (getTeam() == GET_PLAYER(ePlayer).getTeam())
-		{
-			return 100;
-		}
-	}
-
-	int iAttitude = GC.getLeaderHeadInfo(getPersonalityType()).getBaseAttitude();
-
-	if (GET_PLAYER(ePlayer).isNative())
-	{
-		iAttitude += GC.getLeaderHeadInfo(getPersonalityType()).getNativeAttitude();
-	}
-
-	iAttitude += GC.getHandicapInfo(GET_PLAYER(ePlayer).getHandicapType()).getAttitudeChange();
-
-	iAttitude -= std::max(0, (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getNumMembers() - GET_TEAM(getTeam()).getNumMembers()));
-
-	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_getWarSuccess(getTeam()) > GET_TEAM(getTeam()).AI_getWarSuccess(GET_PLAYER(ePlayer).getTeam()))
-	{
-		iAttitude += GC.getLeaderHeadInfo(getPersonalityType()).getLostWarAttitudeChange();
-	}
-
-	iAttitude += AI_getCloseBordersAttitude(ePlayer);
-	iAttitude += AI_getStolenPlotsAttitude(ePlayer);
-	iAttitude += AI_getAlarmAttitude(ePlayer);
-	iAttitude += AI_getRebelAttitude(ePlayer);
-	iAttitude += AI_getWarAttitude(ePlayer);
-	iAttitude += AI_getPeaceAttitude(ePlayer);
-	iAttitude += AI_getOpenBordersAttitude(ePlayer);
-	iAttitude += AI_getDefensivePactAttitude(ePlayer);
-	iAttitude += AI_getRivalDefensivePactAttitude(ePlayer);
-	iAttitude += AI_getShareWarAttitude(ePlayer);
-	iAttitude += AI_getTradeAttitude(ePlayer);
-	iAttitude += AI_getRivalTradeAttitude(ePlayer);
-
-	for (int iI = 0; iI < NUM_MEMORY_TYPES; iI++)
-	{
-		iAttitude += AI_getMemoryAttitude(ePlayer, ((MemoryTypes)iI));
-	}
-
-	iAttitude += AI_getAttitudeExtra(ePlayer);
-
-	return range(iAttitude, -100, 100);
-}
-
-
-int CvPlayerAI::AI_calculateStolenCityRadiusPlots(PlayerTypes ePlayer)
-{
-	PROFILE_FUNC();
-
-	CvPlot* pLoopPlot;
-	int iCount;
-	int iI;
-
-	FAssert(ePlayer != getID());
-
-	iCount = 0;
-
-	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-	{
-		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-
-		if (pLoopPlot->getOwnerINLINE() == ePlayer)
-		{
-			if (pLoopPlot->isPlayerCityRadius(getID()))
-			{
-				iCount++;
-			}
-		}
-	}
-
-	return iCount;
-}
-
-
-int CvPlayerAI::AI_getCloseBordersAttitude(PlayerTypes ePlayer)
-{
-	if (m_aiCloseBordersAttitudeCache[ePlayer] == MAX_INT)
-	{
-		if (isNative())
-		{
-			return 0;
-		}
-
-		if (getTeam() == GET_PLAYER(ePlayer).getTeam())
-		{
-			return 0;
-		}
-
-		int iPercent = std::min(60, (AI_calculateStolenCityRadiusPlots(ePlayer) * 3));
-
-		if (GET_TEAM(getTeam()).AI_isLandTarget(GET_PLAYER(ePlayer).getTeam()))
-		{
-			iPercent += 40;
-		}
-
-		m_aiCloseBordersAttitudeCache[ePlayer] = ((GC.getLeaderHeadInfo(getPersonalityType()).getCloseBordersAttitudeChange() * iPercent) / 100);
-	}
-
-	return m_aiCloseBordersAttitudeCache[ePlayer];
-}
-
-
-int CvPlayerAI::AI_getStolenPlotsAttitude(PlayerTypes ePlayer)
-{
-	if (m_aiStolenPlotsAttitudeCache[ePlayer] == MAX_INT)
-	{
-		if (getTeam() == GET_PLAYER(ePlayer).getTeam())
-		{
-			return 0;
-		}
-
-		if (!isNative())
-		{
-			return 0;
-		}
-
-		int iStolenPlots = 0;
-		for(int i=0;i<GC.getMapINLINE().numPlotsINLINE();i++)
-		{
-			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(i);
-			if(pLoopPlot->getOwnerINLINE() == ePlayer && pLoopPlot->getCulture(getID()) > pLoopPlot->getCulture(ePlayer))
-			{
-				++iStolenPlots;
-			}
-		}
-
-		// change attitude by stolen plots per city
-		m_aiStolenPlotsAttitudeCache[ePlayer] = GC.getLeaderHeadInfo(getPersonalityType()).getCloseBordersAttitudeChange() * iStolenPlots / std::max(getNumCities(), 1);
-	}
-
-	return m_aiStolenPlotsAttitudeCache[ePlayer];
-}
-
-
-int CvPlayerAI::AI_getAlarmAttitude(PlayerTypes ePlayer)
-{
-	if (getTeam() == GET_PLAYER(ePlayer).getTeam())
-	{
-		return 0;
-	}
-
-	AlarmTypes eAlarm = (AlarmTypes) GC.getLeaderHeadInfo(getLeaderType()).getAlarmType();
-	if (eAlarm == NO_ALARM)
-	{
-		return 0;
-	}
-
-	int iAlarm = GET_PLAYER(ePlayer).getNumCities() * GC.getAlarmInfo(eAlarm).getNumColonies();
-	iAlarm *= std::max(0, 100 + GET_PLAYER(ePlayer).getNativeAngerModifier());
-	iAlarm /= 100;
-
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		iAlarm += pLoopCity->AI_calculateAlarm(ePlayer);
-	}
-
-	iAlarm *= GC.getLeaderHeadInfo(getPersonalityType()).getAlarmAttitudeChange();
-	iAlarm /= std::max(1, GC.getAlarmInfo(eAlarm).getAttitudeDivisor());
-
-	return std::min(iAlarm, 0);
-}
-
-int CvPlayerAI::AI_getRebelAttitude(PlayerTypes ePlayer)
-{
-	if (GET_PLAYER(ePlayer).getParent() != getID())
-	{
-		return 0;
-	}
-
-	if (GC.getLeaderHeadInfo(getPersonalityType()).getRebelAttitudeDivisor() == 0)
-	{
-		return 0;
-	}
-
-	int iBells = GET_PLAYER(ePlayer).getBellsStored();
-
-	iBells *= 100;
-	iBells /= std::max(1, GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent());
-	iBells /= GC.getLeaderHeadInfo(getPersonalityType()).getRebelAttitudeDivisor();
-
-	return iBells;
-
-}
-
-int CvPlayerAI::AI_getWarAttitude(PlayerTypes ePlayer)
-{
-	int iAttitude = 0;
-
-	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-	{
-		iAttitude -= 3;
-	}
-
-	if (GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeDivisor() != 0)
-	{
-		int iAttitudeChange = (GET_TEAM(getTeam()).AI_getAtWarCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeDivisor());
-		iAttitude += range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeChangeLimit()));
-	}
-
-	return iAttitude;
-}
-
-
-int CvPlayerAI::AI_getPeaceAttitude(PlayerTypes ePlayer)
-{
-	if (GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeDivisor() != 0)
-	{
-		int iAttitudeChange = (GET_TEAM(getTeam()).AI_getAtPeaceCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeDivisor());
-		return range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeChangeLimit()));
-	}
-
-	return 0;
-}
-
-
-int CvPlayerAI::AI_getOpenBordersAttitude(PlayerTypes ePlayer)
-{
-	if (!atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-	{
-		if (GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeDivisor() != 0)
-		{
-			int iAttitudeChange = (GET_TEAM(getTeam()).AI_getOpenBordersCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeDivisor());
-			return range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeChangeLimit()));
-		}
-	}
-
-	return 0;
-}
-
-
-int CvPlayerAI::AI_getDefensivePactAttitude(PlayerTypes ePlayer)
-{
-	if (!atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-	{
-		if (GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeDivisor() != 0)
-		{
-			int iAttitudeChange = (GET_TEAM(getTeam()).AI_getDefensivePactCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeDivisor());
-			return range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeChangeLimit()));
-		}
-	}
-
-	return 0;
-}
-
-
-int CvPlayerAI::AI_getRivalDefensivePactAttitude(PlayerTypes ePlayer)
-{
-	int iAttitude = 0;
-
-	if (getTeam() == GET_PLAYER(ePlayer).getTeam())
-	{
-		return iAttitude;
-	}
-
-	if (!(GET_TEAM(getTeam()).isDefensivePact(GET_PLAYER(ePlayer).getTeam())))
-	{
-		iAttitude -= ((4 * GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getDefensivePactCount(GET_PLAYER(ePlayer).getTeam())) / std::max(1, (GC.getGameINLINE().countCivTeamsAlive() - 2)));
-	}
-
-	return iAttitude;
-}
-
-
-int CvPlayerAI::AI_getShareWarAttitude(PlayerTypes ePlayer)
-{
-
-	int iAttitudeChange;
-	int iAttitude;
-
-	iAttitude = 0;
-	if (!atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-	{
-		if (GET_TEAM(getTeam()).AI_shareWar(GET_PLAYER(ePlayer).getTeam()))
-		{
-			iAttitude += GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeChange();
-		}
-
-		if (GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeDivisor() != 0)
-		{
-			iAttitudeChange = (GET_TEAM(getTeam()).AI_getShareWarCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeDivisor());
-			iAttitude += range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeChangeLimit()));
-		}
-	}
-
-	return iAttitude;
-}
-
-int CvPlayerAI::AI_getTradeAttitude(PlayerTypes ePlayer)
-{
-	// XXX human only?
-	return range(((AI_getPeacetimeGrantValue(ePlayer) + std::max(0, (AI_getPeacetimeTradeValue(ePlayer) - GET_PLAYER(ePlayer).AI_getPeacetimeTradeValue(getID())))) / ((GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 1) * 5)), 0, 4);
-}
-
-int CvPlayerAI::AI_getRivalTradeAttitude(PlayerTypes ePlayer)
-{
-	// XXX human only?
-	return -(range(((GET_TEAM(getTeam()).AI_getEnemyPeacetimeGrantValue(GET_PLAYER(ePlayer).getTeam()) + (GET_TEAM(getTeam()).AI_getEnemyPeacetimeTradeValue(GET_PLAYER(ePlayer).getTeam()) / 3)) / ((GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 1) * 10)), 0, 4));
-}
-
-
-int CvPlayerAI::AI_getMemoryAttitude(PlayerTypes ePlayer, MemoryTypes eMemory)
-{
-	return ((AI_getMemoryCount(ePlayer, eMemory) * GC.getLeaderHeadInfo(getPersonalityType()).getMemoryAttitudePercent(eMemory)) / 100);
-}
-
-int CvPlayerAI::AI_dealVal(PlayerTypes ePlayer, const CLinkList<TradeData>* pList, bool bIgnoreAnnual, int iChange)
-{
-	int iValue = 0;
-
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-
-	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-	{
-		iValue += GET_TEAM(getTeam()).AI_endWarVal(GET_PLAYER(ePlayer).getTeam());
-	}
-
-	for (CLLNode<TradeData>* pNode = pList->head(); pNode; pNode = pList->next(pNode))
-	{
-		FAssertMsg(!(pNode->m_data.m_bHidden), "(pNode->m_data.m_bHidden) did not return false as expected");
-
-		switch (pNode->m_data.m_eItemType)
-		{
-        ///TKs Invention Core Mod v 1.0
-        case TRADE_RESEARCH:
-        {
-            iValue += GC.getCache_TK_RESEARCH_TRADE_VALUE() + GC.getCivicInfo((CivicTypes)pNode->m_data.m_iData1).getAIWeight();
-
-//            if (getCurrentResearch() != NO_CIVIC)
-//            {
-//                int iCurrentResearch = 1;
-//                if (getCurrentResearchProgress(true) > 0)
-//                {
-//                    iCurrentResearch = getCurrentResearchProgress(true);
-//                }
-//                iValue += (GC.getDefineINT("TK_RESEARCH_TRADE_VALUE") + GC.getCivicInfo(getCurrentResearch()).getAIWeight()) / iCurrentResearch;
-//            }
-//            else if (GET_PLAYER(ePlayer).getCurrentResearch() != NO_CIVIC)
-//            {
-//                int iCurrentResearch = 1;
-//                if (GET_PLAYER(ePlayer).getCurrentResearchProgress(true) > 0)
-//                {
-//                    iCurrentResearch = GET_PLAYER(ePlayer).getCurrentResearchProgress(true);
-//                }
-//                iValue += (GC.getDefineINT("TK_RESEARCH_TRADE_VALUE") + GC.getCivicInfo(GET_PLAYER(ePlayer).getCurrentResearch()).getAIWeight()) / iCurrentResearch;
-//            }
-//            else
-//            {
-//                iValue = 0;
-//            }
-        }
-			break;
-        case TRADE_IDEAS:
-            iValue += GC.getCache_TK_RESEARCH_TRADE_VALUE() + GC.getCivicInfo((CivicTypes)pNode->m_data.m_iData1).getCostToResearch() * 5;
-			break;
-        ///TKe
-		case TRADE_CITIES:
-			iValue += AI_cityTradeVal(GET_PLAYER(ePlayer).getCity(pNode->m_data.m_iData1));
-			break;
-		case TRADE_GOLD:
-			iValue += (pNode->m_data.m_iData1 * AI_goldTradeValuePercent()) / 100;
-			break;
-		case TRADE_YIELD:
-			iValue += AI_yieldTradeVal((YieldTypes) pNode->m_data.m_iData1, pNode->m_data.m_kTransport, ePlayer);
-			break;
-		case TRADE_MAPS:
-			iValue += GET_TEAM(getTeam()).AI_mapTradeVal(GET_PLAYER(ePlayer).getTeam());
-			break;
-		case TRADE_OPEN_BORDERS:
-			iValue += GET_TEAM(getTeam()).AI_openBordersTradeVal(GET_PLAYER(ePlayer).getTeam());
-			break;
-		case TRADE_DEFENSIVE_PACT:
-			iValue += GET_TEAM(getTeam()).AI_defensivePactTradeVal(GET_PLAYER(ePlayer).getTeam());
-			break;
-		case TRADE_PEACE:
-			iValue += GET_TEAM(getTeam()).AI_makePeaceTradeVal(((TeamTypes)(pNode->m_data.m_iData1)), GET_PLAYER(ePlayer).getTeam());
-			break;
-		case TRADE_WAR:
-			iValue += GET_TEAM(getTeam()).AI_declareWarTradeVal(((TeamTypes)(pNode->m_data.m_iData1)), GET_PLAYER(ePlayer).getTeam());
-			break;
-		case TRADE_EMBARGO:
-			iValue += AI_stopTradingTradeVal(((TeamTypes)(pNode->m_data.m_iData1)), ePlayer);
-			break;
-		}
-	}
-
-	return iValue;
-}
-
-
-bool CvPlayerAI::AI_goldDeal(const CLinkList<TradeData>* pList)
-{
-	CLLNode<TradeData>* pNode;
-
-	for (pNode = pList->head(); pNode; pNode = pList->next(pNode))
-	{
-		FAssert(!(pNode->m_data.m_bHidden));
-
-		switch (pNode->m_data.m_eItemType)
-		{
-		case TRADE_GOLD:
-			return true;
-			break;
-		}
-	}
-
-	return false;
-}
-
-
-bool CvPlayerAI::AI_considerOffer(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, int iChange)
-{
-	CLLNode<TradeData>* pNode;
-	int iThreshold;
-
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-
-	if (AI_goldDeal(pTheirList) && AI_goldDeal(pOurList))
-	{
-		return false;
-	}
-
-	if (iChange > -1)
-	{
-		for (pNode = pOurList->head(); pNode; pNode = pOurList->next(pNode))
-		{
-			if (getTradeDenial(ePlayer, pNode->m_data) != NO_DENIAL)
-			{
-				return false;
-			}
-		}
-	}
-///Tks Med
-//	if (GET_PLAYER(ePlayer).getTeam() == getTeam())
-//	{
-//		return true;
-//	}
-///Tke
-
-	if ((pOurList->getLength() == 0) && (pTheirList->getLength() > 0))
-	{
-		return true;
-	}
-
-	int iOurValue = GET_PLAYER(ePlayer).AI_dealVal(getID(), pOurList, false, iChange);
-	int iTheirValue = AI_dealVal(ePlayer, pTheirList, false, iChange);
-
-	if (iOurValue > 0 && 0 == pTheirList->getLength() && 0 == iTheirValue)
-	{
-		if (AI_getAttitude(ePlayer) < ATTITUDE_PLEASED)
-		{
-			if (GET_TEAM(getTeam()).getPower() > ((GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPower() * 4) / 3))
-			{
-				return false;
-			}
-		}
-
-		if (AI_getMemoryCount(ePlayer, MEMORY_MADE_DEMAND_RECENT) > 0)
-		{
-			return false;
-		}
-
-		iThreshold = (GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 50);
-
-		iThreshold *= 2;
-
-		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_isLandTarget(getTeam()))
-		{
-			iThreshold *= 3;
-		}
-
-		iThreshold *= (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPower() + 100);
-		iThreshold /= (GET_TEAM(getTeam()).getPower() + 100);
-
-		iThreshold -= GET_PLAYER(ePlayer).AI_getPeacetimeGrantValue(getID());
-
-		return (iOurValue < iThreshold);
-	}
-
-	if (iChange < 0)
-	{
-		return (iTheirValue * 110 >= iOurValue * 100);
-	}
-
-	return (iTheirValue >= iOurValue);
-}
-
-int CvPlayerAI::AI_militaryHelp(PlayerTypes ePlayer, int& iNumUnits, UnitTypes& eUnit, ProfessionTypes& eProfession)
-{
-	FAssert(GET_PLAYER(ePlayer).getParent() == getID());
-
-	iNumUnits = 0;
-	eUnit = NO_UNIT;
-	eProfession = NO_PROFESSION;
-
-	if (AI_getAttitude(ePlayer) < ATTITUDE_CAUTIOUS)
-	{
-		return -1;
-	}
-
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-	int iBestValue = MAX_INT;
-	for (int i = 0; i < GC.getNumUnitClassInfos(); ++i)
-	{
-		UnitTypes eLoopUnit = (UnitTypes) GC.getCivilizationInfo(kPlayer.getCivilizationType()).getCivilizationUnits(i);
-		if (eLoopUnit != NO_UNIT)
-		{
-			CvUnitInfo& kUnit = GC.getUnitInfo(eLoopUnit);
-			if (kUnit.getDomainType() == DOMAIN_LAND && kPlayer.getEuropeUnitBuyPrice(eLoopUnit) > 0)
-			{
-				bool bValid = (kUnit.getCombat() > 0);
-				for (int j = 0; j < GC.getNumPromotionInfos() && !bValid; ++j)
-				{
-					if (kUnit.getFreePromotions(j))
-					{
-						bValid = true;
-					}
-				}
-
-				if (bValid)
-				{
-					int iValue = kPlayer.getUnitClassCount((UnitClassTypes) i);
-					if (iValue < iBestValue)
-					{
-						iBestValue = iValue;
-						eUnit = eLoopUnit;
-					}
-				}
-			}
-		}
-	}
-
-	if (eUnit == NO_UNIT)
-	{
-		return -1;
-	}
-
-	iNumUnits = 1;
-	eProfession = (ProfessionTypes) GC.getUnitInfo(eUnit).getDefaultProfession();
-
-	return kPlayer.getEuropeUnitBuyPrice(eUnit) * GC.getCache_KING_BUY_UNIT_PRICE_MODIFIER() / 100;
-}
-
-bool CvPlayerAI::AI_counterPropose(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, CLinkList<TradeData>* pTheirInventory, CLinkList<TradeData>* pOurInventory, CLinkList<TradeData>* pTheirCounter, CLinkList<TradeData>* pOurCounter, const IDInfo& kTransport)
-{
-	CLLNode<TradeData>* pNode;
-	CLLNode<TradeData>* pBestNode;
-	CLLNode<TradeData>* pGoldNode;
-	CvCity* pCity;
-	bool bTheirGoldDeal;
-	bool bOurGoldDeal;
-	int iHumanDealWeight;
-	int iAIDealWeight;
-	int iGoldData;
-	int iGoldWeight;
-	int iWeight;
-	int iBestWeight;
-	int iValue;
-	int iBestValue;
-
-	bTheirGoldDeal = AI_goldDeal(pTheirList);
-	bOurGoldDeal = AI_goldDeal(pOurList);
-
-	if (bOurGoldDeal && bTheirGoldDeal)
-	{
-		return false;
-	}
-
-	pGoldNode = NULL;
-
-	iHumanDealWeight = AI_dealVal(ePlayer, pTheirList);
-	iAIDealWeight = GET_PLAYER(ePlayer).AI_dealVal(getID(), pOurList);
-
-	int iGoldValuePercent = AI_goldTradeValuePercent();
-
-	pTheirCounter->clear();
-	pOurCounter->clear();
-
-	if (iAIDealWeight > iHumanDealWeight)
-	{
-		if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-		{
-			iBestValue = 0;
-			iBestWeight = 0;
-			pBestNode = NULL;
-
-			for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
-			{
-				if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-				{
-					if (pNode->m_data.m_eItemType == TRADE_CITIES)
-					{
-						FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
-
-						if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
-						{
-							pCity = GET_PLAYER(ePlayer).getCity(pNode->m_data.m_iData1);
-
-							if (pCity != NULL)
-							{
-								iWeight = AI_cityTradeVal(pCity);
-
-								if (iWeight > 0)
-								{
-									iValue = AI_targetCityValue(pCity, false);
-
-									if (iValue > iBestValue)
-									{
-										iBestValue = iValue;
-										iBestWeight = iWeight;
-										pBestNode = pNode;
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-
-			if (pBestNode != NULL)
-			{
-				iHumanDealWeight += iBestWeight;
-				pTheirCounter->insertAtEnd(pBestNode->m_data);
-			}
-		}
-
-		for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
-		{
-			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-			{
-				FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
-
-				if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
-				{
-					switch (pNode->m_data.m_eItemType)
-					{
-					case TRADE_GOLD:
-						if (!bOurGoldDeal)
-						{
-							pGoldNode = pNode;
-						}
-						break;
-					}
-				}
-			}
-		}
-
-		///TKs Invention Core Mod v 1.0
-		for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
-		{
-			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-			{
-			    if (pNode->m_data.m_eItemType == TRADE_IDEAS)
-				{
-					FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
-
-					if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
-					{
-					    //int iOurValue = GET_PLAYER(ePlayer).AI_dealVal(getID(), pOurList, false, iChange);
-						iWeight = GC.getCivicInfo((CivicTypes)pNode->m_data.m_iData1).getAIWeight() + GC.getCache_TK_RESEARCH_TRADE_VALUE();
-
-						if (iWeight > 0)
-						{
-							iHumanDealWeight += iWeight;
-							pTheirCounter->insertAtEnd(pNode->m_data);
-						}
-					}
-				}
-
-			}
-		}
-		///Tke
-        int iGoldWeight = iAIDealWeight - iHumanDealWeight;
-		if (iGoldWeight > 0)
-		{
-			if (pGoldNode)
-			{
-				iGoldData = iGoldWeight * 100;
-				iGoldData /= iGoldValuePercent;
-				if ((iGoldData * iGoldValuePercent) < iGoldWeight)
-				{
-					iGoldData++;
-				}
-				if (GET_PLAYER(ePlayer).getMaxGoldTrade(getID(), kTransport) >= iGoldData)
-				{
-					pGoldNode->m_data.m_iData1 = iGoldData;
-					iHumanDealWeight += (iGoldData * iGoldValuePercent) / 100;
-					pTheirCounter->insertAtEnd(pGoldNode->m_data);
-					pGoldNode = NULL;
-				}
-			}
-		}
-
-		for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
-		{
-			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-			{
-				if (pNode->m_data.m_eItemType == TRADE_MAPS)
-				{
-					FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
-
-					if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
-					{
-						iWeight = GET_TEAM(getTeam()).AI_mapTradeVal(GET_PLAYER(ePlayer).getTeam());
-
-						if (iWeight > 0)
-						{
-							iHumanDealWeight += iWeight;
-							pTheirCounter->insertAtEnd(pNode->m_data);
-						}
-					}
-				}
-			}
-		}
-
-
-		iGoldWeight = iAIDealWeight - iHumanDealWeight;
-
-		if (iGoldWeight > 0)
-		{
-			if (pGoldNode)
-			{
-				iGoldData = iGoldWeight * 100;
-				iGoldData /= iGoldValuePercent;
-
-				if ((iGoldWeight * 100) > (iGoldData * iGoldValuePercent))
-				{
-					iGoldData++;
-				}
-
-				iGoldData = std::min(iGoldData, GET_PLAYER(ePlayer).getMaxGoldTrade(getID(), kTransport));
-
-				if (iGoldData > 0)
-				{
-					pGoldNode->m_data.m_iData1 = iGoldData;
-					iHumanDealWeight += (iGoldData * iGoldValuePercent) / 100;
-					pTheirCounter->insertAtEnd(pGoldNode->m_data);
-					pGoldNode = NULL;
-				}
-			}
-		}
-	}
-	else if (iHumanDealWeight > iAIDealWeight)
-	{
-		if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-		{
-				for (pNode = pOurInventory->head(); pNode; pNode = pOurInventory->next(pNode))
-				{
-					if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-					{
-						if (pNode->m_data.m_eItemType == TRADE_PEACE_TREATY)
-						{
-							pOurCounter->insertAtEnd(pNode->m_data);
-							break;
-						}
-					}
-				}
-
-			iBestValue = 0;
-			iBestWeight = 0;
-			pBestNode = NULL;
-
-			for (pNode = pOurInventory->head(); pNode && iHumanDealWeight > iAIDealWeight; pNode = pOurInventory->next(pNode))
-			{
-				if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-				{
-					if (pNode->m_data.m_eItemType == TRADE_CITIES)
-					{
-						FAssert(canTradeItem(ePlayer, pNode->m_data));
-
-						if (getTradeDenial(ePlayer, pNode->m_data) == NO_DENIAL)
-						{
-							pCity = getCity(pNode->m_data.m_iData1);
-
-							if (pCity != NULL)
-							{
-								iWeight = GET_PLAYER(ePlayer).AI_cityTradeVal(pCity);
-
-								if (iWeight > 0)
-								{
-									iValue = GET_PLAYER(ePlayer).AI_targetCityValue(pCity, false);
-
-									if (iValue > iBestValue)
-									{
-										if (iHumanDealWeight >= (iAIDealWeight + iWeight))
-										{
-											iBestValue = iValue;
-											iBestWeight = iWeight;
-											pBestNode = pNode;
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-
-			if (pBestNode != NULL)
-			{
-				iAIDealWeight += iBestWeight;
-				pOurCounter->insertAtEnd(pBestNode->m_data);
-			}
-		}
-
-		for (pNode = pOurInventory->head(); pNode && iHumanDealWeight > iAIDealWeight; pNode = pOurInventory->next(pNode))
-		{
-			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-			{
-				FAssert(canTradeItem(ePlayer, pNode->m_data));
-
-				if (getTradeDenial(ePlayer, pNode->m_data) == NO_DENIAL)
-				{
-					switch (pNode->m_data.m_eItemType)
-					{
-					case TRADE_GOLD:
-						if (!bTheirGoldDeal)
-						{
-							pGoldNode = pNode;
-						}
-						break;
-					}
-				}
-			}
-		}
-
-		iGoldWeight = iHumanDealWeight - iAIDealWeight;
-
-		if (iGoldWeight > 0)
-		{
-			if (pGoldNode)
-			{
-				int iGoldData = iGoldWeight * 100;
-				iGoldData /= iGoldValuePercent;
-
-				if (getMaxGoldTrade(ePlayer, kTransport) >= iGoldData)
-				{
-					pGoldNode->m_data.m_iData1 = iGoldData;
-					iAIDealWeight += ((iGoldData * iGoldValuePercent) / 100);
-					pOurCounter->insertAtEnd(pGoldNode->m_data);
-					pGoldNode = NULL;
-				}
-			}
-		}
-
-		for (pNode = pOurInventory->head(); pNode && iHumanDealWeight > iAIDealWeight; pNode = pOurInventory->next(pNode))
-		{
-			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
-			{
-				if (pNode->m_data.m_eItemType == TRADE_MAPS)
-				{
-					FAssert(canTradeItem(ePlayer, pNode->m_data));
-
-					if (getTradeDenial(ePlayer, pNode->m_data) == NO_DENIAL)
-					{
-						iWeight = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_mapTradeVal(getTeam());
-
-						if (iWeight > 0)
-						{
-							if (iHumanDealWeight >= (iAIDealWeight + iWeight))
-							{
-								iAIDealWeight += iWeight;
-								pOurCounter->insertAtEnd(pNode->m_data);
-							}
-						}
-					}
-				}
-			}
-		}
-
-		iGoldWeight = iHumanDealWeight - iAIDealWeight;
-		if (iGoldWeight > 0)
-		{
-			if (pGoldNode)
-			{
-				iGoldData = iGoldWeight * 100;
-				iGoldData /= AI_goldTradeValuePercent();
-
-				iGoldData = std::min(iGoldData, getMaxGoldTrade(ePlayer, kTransport));
-
-				if (iGoldData > 0)
-				{
-					pGoldNode->m_data.m_iData1 = iGoldData;
-					iAIDealWeight += (iGoldData * AI_goldTradeValuePercent()) / 100;
-					pOurCounter->insertAtEnd(pGoldNode->m_data);
-					pGoldNode = NULL;
-				}
-			}
-		}
-	}
-
-	return ((iAIDealWeight <= iHumanDealWeight) && ((pOurList->getLength() > 0) || (pOurCounter->getLength() > 0) || (pTheirCounter->getLength() > 0)));
-}
-
-
-int CvPlayerAI::AI_maxGoldTrade(PlayerTypes ePlayer) const
-{
-	int iMaxGold;
-
-	FAssert(ePlayer != getID());
-
-	if (isHuman() || (GET_PLAYER(ePlayer).getTeam() == getTeam()))
-	{
-		iMaxGold = getGold();
-	}
-	else
-	{
-		iMaxGold = getTotalPopulation() * 10;
-
-		iMaxGold *= (GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 10);
-
-		iMaxGold *= GC.getLeaderHeadInfo(getPersonalityType()).getMaxGoldTradePercent();
-		iMaxGold /= 100;
-
-		iMaxGold -= AI_getGoldTradedTo(ePlayer);
-		iMaxGold += GET_PLAYER(ePlayer).AI_getGoldTradedTo(getID());
-
-		iMaxGold = std::min(iMaxGold, getGold());
-
-		iMaxGold -= (iMaxGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-	}
-
-	return std::max(0, iMaxGold);
-}
-
-int CvPlayerAI::AI_cityTradeVal(CvCity* pCity, PlayerTypes eOwner)
-{
-	if (pCity == NULL)
-	{
-		return 0;
-	}
-
-	if (eOwner == NO_PLAYER)
-	{
-		eOwner = pCity->getOwnerINLINE();
-	}
-	FAssert(eOwner != getID());
-
-	int iValue = 300;
-
-	iValue += (pCity->getPopulation() * 50);
-	iValue += (pCity->getCultureLevel() * 200);
-	iValue += (((((pCity->getPopulation() * 50) + GC.getGameINLINE().getElapsedGameTurns() + 100) * 4) * pCity->plot()->calculateCulturePercent(eOwner)) / 100);
-
-	if (!(pCity->isEverOwned(getID())))
-	{
-		iValue *= 3;
-		iValue /= 2;
-	}
-
-	iValue -= (iValue % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-
-	if (isHuman())
-	{
-		return std::max(iValue, GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-	}
-	else
-	{
-		return iValue;
-	}
-}
-
-
-DenialTypes CvPlayerAI::AI_cityTrade(CvCity* pCity, PlayerTypes ePlayer) const
-{
-	FAssert(pCity->getOwnerINLINE() == getID());
-
-	if (pCity->getLiberationPlayer(false) == ePlayer)
-	{
-		return NO_DENIAL;
-	}
-
-	if (!(GET_PLAYER(ePlayer).isHuman()))
-	{
-		if (GET_PLAYER(ePlayer).getTeam() != getTeam())
-		{
-			if ((pCity->plot()->calculateCulturePercent(ePlayer) == 0) && !(pCity->isEverOwned(ePlayer)) && (GET_PLAYER(ePlayer).getNumCities() > 3))
-			{
-				CvCity* pNearestCity = GC.getMapINLINE().findCity(pCity->getX_INLINE(), pCity->getY_INLINE(), ePlayer, NO_TEAM, true, false, NO_TEAM, NO_DIRECTION, pCity);
-				if ((pNearestCity == NULL) || (plotDistance(pCity->getX_INLINE(), pCity->getY_INLINE(), pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE()) > 9))
-				{
-					return DENIAL_UNKNOWN;
-				}
-			}
-		}
-	}
-
-	if (isHuman())
-	{
-		return NO_DENIAL;
-	}
-
-	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
-	{
-		return NO_DENIAL;
-	}
-
-	if (isNative() && !GET_PLAYER(ePlayer).isNative())
-	{
-		return NO_DENIAL;
-	}
-
-	if (GET_PLAYER(ePlayer).getTeam() != getTeam())
-	{
-		return DENIAL_NEVER;
-	}
-
-	if (pCity->calculateCulturePercent(getID()) > 50)
-	{
-		return DENIAL_TOO_MUCH;
-	}
-
-	return NO_DENIAL;
-}
-
-
-int CvPlayerAI::AI_stopTradingTradeVal(TeamTypes eTradeTeam, PlayerTypes ePlayer)
-{
-	CvDeal* pLoopDeal;
-	int iModifier;
-	int iValue;
-	int iLoop;
-
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-	FAssertMsg(GET_PLAYER(ePlayer).getTeam() != getTeam(), "shouldn't call this function on ourselves");
-	FAssertMsg(eTradeTeam != getTeam(), "shouldn't call this function on ourselves");
-	FAssertMsg(GET_TEAM(eTradeTeam).isAlive(), "GET_TEAM(eWarTeam).isAlive is expected to be true");
-	FAssertMsg(!atWar(eTradeTeam, GET_PLAYER(ePlayer).getTeam()), "eTeam should be at peace with eWarTeam");
-
-	iValue = (50 + (GC.getGameINLINE().getGameTurn() / 2));
-	iValue += (GET_TEAM(eTradeTeam).getNumCities() * 5);
-
-	iModifier = 0;
-
-	switch (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_getAttitude(eTradeTeam))
-	{
-	case ATTITUDE_FURIOUS:
-		break;
-
-	case ATTITUDE_ANNOYED:
-		iModifier += 25;
-		break;
-
-	case ATTITUDE_CAUTIOUS:
-		iModifier += 50;
-		break;
-
-	case ATTITUDE_PLEASED:
-		iModifier += 100;
-		break;
-
-	case ATTITUDE_FRIENDLY:
-		iModifier += 200;
-		break;
-
-	default:
-		FAssert(false);
-		break;
-	}
-
-	iValue *= std::max(0, (iModifier + 100));
-	iValue /= 100;
-
-	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isOpenBorders(eTradeTeam))
-	{
-		iValue *= 2;
-	}
-
-	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isDefensivePact(eTradeTeam))
-	{
-		iValue *= 3;
-	}
-
-	for(pLoopDeal = GC.getGameINLINE().firstDeal(&iLoop); pLoopDeal != NULL; pLoopDeal = GC.getGameINLINE().nextDeal(&iLoop))
-	{
-		if (pLoopDeal->isCancelable(getID()) && !(pLoopDeal->isPeaceDeal()))
-		{
-			if (GET_PLAYER(pLoopDeal->getFirstPlayer()).getTeam() == GET_PLAYER(ePlayer).getTeam())
-			{
-				if (pLoopDeal->getLengthSecondTrades() > 0)
-				{
-					iValue += (GET_PLAYER(pLoopDeal->getFirstPlayer()).AI_dealVal(pLoopDeal->getSecondPlayer(), pLoopDeal->getSecondTrades()) * ((pLoopDeal->getLengthFirstTrades() == 0) ? 2 : 1));
-				}
-			}
-
-			if (GET_PLAYER(pLoopDeal->getSecondPlayer()).getTeam() == GET_PLAYER(ePlayer).getTeam())
-			{
-				if (pLoopDeal->getLengthFirstTrades() > 0)
-				{
-					iValue += (GET_PLAYER(pLoopDeal->getSecondPlayer()).AI_dealVal(pLoopDeal->getFirstPlayer(), pLoopDeal->getFirstTrades()) * ((pLoopDeal->getLengthSecondTrades() == 0) ? 2 : 1));
-				}
-			}
-		}
-	}
-
-	iValue -= (iValue % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-
-	if (isHuman())
-	{
-		return std::max(iValue, GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-	}
-	else
-	{
-		return iValue;
-	}
-}
-
-
-DenialTypes CvPlayerAI::AI_stopTradingTrade(TeamTypes eTradeTeam, PlayerTypes ePlayer) const
-{
-	AttitudeTypes eAttitude;
-	AttitudeTypes eAttitudeThem;
-	int iI;
-
-	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
-	FAssertMsg(GET_PLAYER(ePlayer).getTeam() != getTeam(), "shouldn't call this function on ourselves");
-	FAssertMsg(eTradeTeam != getTeam(), "shouldn't call this function on ourselves");
-	FAssertMsg(GET_TEAM(eTradeTeam).isAlive(), "GET_TEAM(eTradeTeam).isAlive is expected to be true");
-	FAssertMsg(!atWar(getTeam(), eTradeTeam), "should be at peace with eTradeTeam");
-
-	if (isHuman())
-	{
-		return NO_DENIAL;
-	}
-
-	eAttitude = GET_TEAM(getTeam()).AI_getAttitude(GET_PLAYER(ePlayer).getTeam());
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			if (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
-			{
-				if (eAttitude <= GC.getLeaderHeadInfo(GET_PLAYER((PlayerTypes)iI).getPersonalityType()).getStopTradingRefuseAttitudeThreshold())
-				{
-					return DENIAL_ATTITUDE;
-				}
-			}
-		}
-	}
-
-	eAttitudeThem = GET_TEAM(getTeam()).AI_getAttitude(eTradeTeam);
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			if (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
-			{
-				if (eAttitudeThem > GC.getLeaderHeadInfo(GET_PLAYER((PlayerTypes)iI).getPersonalityType()).getStopTradingThemRefuseAttitudeThreshold())
-				{
-					return DENIAL_ATTITUDE_THEM;
-				}
-			}
-		}
-	}
-
-	return NO_DENIAL;
-}
-
-int CvPlayerAI::AI_yieldTradeVal(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer)
-{
-	int iValue = 0;
-	CvPlayerAI& kTradePlayer = GET_PLAYER(ePlayer);
-	CvUnit* pTransport = ::getUnit(kTransport);
-	if (pTransport != NULL)
-	{
-		int iAmount = kTradePlayer.getTradeYieldAmount(eYield, pTransport);
-		if (isNative())
-		{
-
-			int iTotalStored = countTotalYieldStored(eYield);
-			int iMaxStored;
-			if (eYield == YIELD_FOOD)
-			{
-				iMaxStored = getNumCities() * getGrowthThreshold(1);
-			}
-			///Tks Med
-//			else if (eYield == YIELD_HORSES && iAmount > 0)
-//			{
-//               int iRandomHorses = GC.getGame().getSorenRandNum(GC.getDefineINT("NATIVE_HORSES_FOR_SALE"), "AI Native Horses for sale");
-//			   iAmount = std::min(iRandomHorses, (iAmount * GC.getDefineINT("NATIVE_HORSES_FOR_SALE_PERCENT")) / 100);
-//			}
-            ///tke
-			else
-			{
-				iMaxStored = getNumCities() * GC.getGameINLINE().getCargoYieldCapacity();
-			}
-
-			int iNativeConsumptionPercent = GC.getYieldInfo(eYield).getNativeConsumptionPercent();
-			if (iNativeConsumptionPercent > 0)
-			{
-				iMaxStored *= iNativeConsumptionPercent;
-				iMaxStored /= 80;
-			}
-			else
-			{
-				iMaxStored *= 2;
-			}
-			int iBuyPrice = GC.getYieldInfo(eYield).getNativeBuyPrice();
-			CvCity* pCity = pTransport->plot()->getPlotCity();
-			if (pCity != NULL)
-			{
-				if (eYield == pCity->AI_getDesiredYield())
-				{
-					iBuyPrice *= 125;
-					iBuyPrice /= 100;
-				}
-			}
-
-			int iHighPricePercent = std::max(25, 100 - ((100 * iTotalStored) / iMaxStored));
-			int iLowPricePercent = std::max(25, 100 - ((100 * std::min(iMaxStored, iTotalStored + iAmount)) / iMaxStored));
-
-			iValue += (iAmount * iBuyPrice * (iHighPricePercent + iLowPricePercent)) / 200;
-		}
-		else if (kTradePlayer.isNative())
-		{
-			int iTotalStored = kTradePlayer.countTotalYieldStored(eYield);
-			int iMaxStored;
-			if (eYield == YIELD_FOOD)
-			{
-				iMaxStored = kTradePlayer.getNumCities() * getGrowthThreshold(1);
-			}
-			else
-			{
-				iMaxStored = kTradePlayer.getNumCities() * GC.getGameINLINE().getCargoYieldCapacity();
-			}
-
-			int iNativeConsumptionPercent = GC.getYieldInfo(eYield).getNativeConsumptionPercent();
-			if (iNativeConsumptionPercent > 0)
-			{
-				iMaxStored *= iNativeConsumptionPercent;
-				iMaxStored /= 80;
-			}
-			else
-			{
-				iMaxStored *= 2;
-			}
-			int iSellPrice = GC.getYieldInfo(eYield).getNativeSellPrice();
-
-			int iHighPricePercent = std::max(25, 100 - ((100 * iTotalStored) / std::max(1, iMaxStored)));
-			int iLowPricePercent = std::max(25, 100 - ((100 * std::max(0, iTotalStored - iAmount)) / std::max(1, iMaxStored)));
-
-			iValue += (iAmount * iSellPrice * (iHighPricePercent + iLowPricePercent)) / 200;
-			///TKe Med
-			if (iValue < 0)
-            {
-                iValue = 0;
-                CvCity* pCity = pTransport->plot()->getPlotCity();
-                if (pCity != NULL)
-                {
-                    if (ePlayer != pCity->getOwnerINLINE())
-                    {
-                        if (AI_isYieldFinalProduct(eYield))
-                        {
-                            iValue += GET_PLAYER(pCity->getOwnerINLINE()).getSellToEuropeProfit(eYield, iAmount) * 95 / 100;
-                        }
-                        else
-                        {
-                            iValue += GET_PLAYER(pCity->getOwnerINLINE()).AI_yieldValue(eYield, true, iAmount);
-                        }
-                    }
-                }
-            }
-			///TKe
-
-		}
-		else
-		{
-			CvCity* pCity = pTransport->plot()->getPlotCity();
-			if (pCity != NULL)
-			{
-				if (ePlayer == pCity->getOwnerINLINE())
-				{
-					if (AI_isYieldFinalProduct(eYield))
-					{
-						iValue += kTradePlayer.getSellToEuropeProfit(eYield, iAmount) * 95 / 100;
-					}
-					else
-					{
-						iValue += kTradePlayer.AI_yieldValue(eYield, true, iAmount);
-					}
-				}
-				else
-				{
-					iValue += kTradePlayer.AI_yieldValue(eYield, false, iAmount);
-				}
-			}
-		}
-	}
-
-	return iValue;
-}
-
-DenialTypes CvPlayerAI::AI_yieldTrade(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer) const
-{
-    ///TKs Invention Core Mod v 1.0
-    if (eYield == YIELD_IDEAS)
-    {
-        TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
-        if (isHuman())
-        {
-            return NO_DENIAL;
-        }
-
-        if (GET_TEAM(getTeam()).AI_shareWar(eTeam))
-        {
-            return NO_DENIAL;
-        }
-
-        if (GET_TEAM(getTeam()).AI_getMemoryCount(eTeam, MEMORY_CANCELLED_OPEN_BORDERS) > 0)
-        {
-            return DENIAL_RECENT_CANCEL;
-        }
-
-        if (GET_TEAM(getTeam()).AI_getWorstEnemy() == eTeam)
-        {
-            return DENIAL_WORST_ENEMY;
-        }
-        //TK Update 1.1
-        if (!isNative())
-        {
-            AttitudeTypes eAttitude = GET_TEAM(getTeam()).AI_getAttitude(eTeam);
-
-            if (eAttitude <= (AttitudeTypes)GC.getLeaderHeadInfo(getPersonalityType()).getNoGiveHelpAttitudeThreshold())
-            {
-    //            if (GET_PLAYER(ePlayer).isHuman())
-    //            {
-    //                 char szOut[1024];
-    //                sprintf(szOut, "######################## Player %d %S You Suck cause %S == %d\n", getID(), getNameKey(), GC.getAttitudeInfo(AI_getAttitude(ePlayer)).getTextKeyWide(), eAttitude);
-    //                gDLL->messageControlLog(szOut);
-    //            }
-                return DENIAL_ATTITUDE;
-            }
-        }
-        //TKe
-
-        return NO_DENIAL;
-    }
-
-    ///TKe
-	CvUnit* pTransport = ::getUnit(kTransport);
-	CvCity* pCity = pTransport->plot()->getPlotCity();
-	if (pCity != NULL)
-	{
-		CvPlayer& kPlayer = GET_PLAYER(pCity->getOwnerINLINE());
-		if (kPlayer.isNative())
-		{
-			if (getID() == pCity->getOwnerINLINE())
-			{
-				if (GC.getYieldInfo(eYield).getNativeSellPrice() == -1)
-				{
-					return DENIAL_NEVER;
-				}
-			}
-			else
-			{
-				if (pCity->AI_getDesiredYield() == eYield)
-				{
-					return NO_DENIAL;
-				}
-				if (GC.getYieldInfo(eYield).getNativeBuyPrice() == -1)
-				{
-					return DENIAL_NOT_INTERESTED;
-				}
-			}
-
-			bool bCanProduce = pCity->canProduceYield(eYield);
-			///TKs
-			if (GC.isEquipmentType(eYield, EQUIPMENT_ARMOR_HORSES))
-			{
-				bCanProduce = false;
-			}
-
-
-			if (getID() == pCity->getOwnerINLINE())
-			{
-				if (!bCanProduce)
-				{
-				    if (eYield != YIELD_HORSES)
-				    {
-                        return DENIAL_UNKNOWN;
-				    }
-				}
-				///TKe
-			}
-			else
-			{
-				if (bCanProduce)
-				{
-					return DENIAL_NO_GAIN;
-				}
-			}
-		}
-		else
-		{
-			if (getID() == pCity->getOwnerINLINE())
-			{
-			    ///Tks
-				if (GC.isEquipmentType(eYield, EQUIPMENT_ANY))
-				{
-					return DENIAL_NEVER;
-				}
-				if (pCity->AI_getDesiredYield() == eYield)
-				{
-					return DENIAL_NEVER;
-				}
-				///Tke
-				if (AI_shouldBuyFromEurope(eYield))
-				{
-					return DENIAL_NO_GAIN;
-				}
-				if (pCity->calculateActualYieldConsumed(eYield) > 0)
-				{
-					return DENIAL_NO_GAIN;
-				}
-			}
-		}
-	}
-
-	return NO_DENIAL;
-}
-
-int CvPlayerAI::AI_calculateDamages(TeamTypes eTeam)
-{
-	int iValue = 0;
-
-	int iStolenPlotCost = 0;
-	int iPopulationCost = 0;
-	for (int iI = 0; iI < MAX_PLAYERS; ++iI)
-	{
-		PlayerTypes ePlayer = (PlayerTypes)iI;
-		CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-		if (kPlayer.isAlive())
-		{
-			if (kPlayer.getTeam() == eTeam)
-			{
-				int iStolenPlots = 0;
-				for(int i=0;i<GC.getMapINLINE().numPlotsINLINE();i++)
-				{
-					CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(i);
-					if(pLoopPlot->getOwnerINLINE() == ePlayer && pLoopPlot->getCulture(getID()) > pLoopPlot->getCulture(ePlayer))
-					{
-						iStolenPlotCost += pLoopPlot->getBuyPrice(ePlayer);
-					}
-				}
-
-				iPopulationCost += kPlayer.getTotalPopulation() * 100;
-			}
-		}
-	}
-
-	iPopulationCost += 250;
-
-	iValue += iPopulationCost;
-
-	iValue += iStolenPlotCost / 4;
-
-	return iValue;
-}
-
-int CvPlayerAI::AI_unitImpassableCount(UnitTypes eUnit)
-{
-	int iCount = 0;
-	for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
-	{
-		if (GC.getUnitInfo(eUnit).getTerrainImpassable(iI))
-		{
-				iCount++;
-			}
-		}
-
-	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
-	{
-		if (GC.getUnitInfo(eUnit).getFeatureImpassable(iI))
-		{
-				iCount++;
-			}
-		}
-
-	return iCount;
-}
-
-//Calculates the value of the unit as "Profit generated in 20 turns" in pCity,
-//or if pCity is NULL it assumes that it will either found somewhere
-//or has some other role.
-int CvPlayerAI::AI_unitEconomicValue(UnitTypes eUnit, UnitAITypes* peUnitAI, CvCity* pCity)
-{
-	UnitAITypes eBestUnitAI = NO_UNITAI;
-
-	if (getNumCities() == 0)
-	{
-		return 1;
-	}
-
-	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
-	int iBestValue = 0;
-	if (kUnitInfo.getUnitAIType(UNITAI_COLONIST))
-	{
-		if (pCity == NULL)
-		{
-			//Do we have an ideal profession?
-			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
-			{
-				YieldTypes eYield = (YieldTypes)iI;
-
-				if (kUnitInfo.getYieldModifier(eYield) > 0)
-				{
-					for (int iJ = 0; iJ < GC.getNumProfessionInfos(); iJ++)
-					{
-						if (GC.getCivilizationInfo(getCivilizationType()).isValidProfession(iJ))
-						{
-							CvProfessionInfo& kProfessionInfo = GC.getProfessionInfo((ProfessionTypes)iJ);
-							// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-							if (kProfessionInfo.getYieldsProduced(0) == eYield)
-							{
-								if (kProfessionInfo.getYieldsConsumed(0, getID()) == NO_YIELD)
-								{
-									// MultipleYieldsProduced End
-									if (kProfessionInfo.isWorkPlot())
-									{
-										CvPlot* pCenter = AI_getTerritoryCenter();
-										int iRadius = AI_getTerritoryRadius();
-										for (int iX = -iRadius; iX <= iRadius; iX++)
-										{
-											for (int iY = -iRadius; iY <= iRadius; iY++)
-											{
-												CvPlot* pLoopPlot = plotXY(pCenter->getX_INLINE(), pCenter->getY_INLINE(), iX, iY);
-												if ((pLoopPlot != NULL) && (pLoopPlot->getOwnerINLINE() == getID()) && (!pLoopPlot->isCity()))
-												{
-													int iAmount = pLoopPlot->calculatePotentialYield(eYield, NULL, false);
-
-													iAmount *= 100 + kUnitInfo.getYieldModifier(eYield);
-													iAmount /= 100;
-
-													int iValue = 20 * AI_yieldValue(eYield) * iAmount;
-													bool bValid = true;
-													if (pLoopPlot->isBeingWorked())
-													{
-														iValue *= 75;
-														iValue /= 100;
-
-														CvCity* pCity = pLoopPlot->getWorkingCity();
-														FAssert(pCity!= NULL);
-
-														CvUnit* pWorkingUnit = pCity->getUnitWorkingPlot(pLoopPlot);
-														FAssert(pWorkingUnit != NULL);
-
-														if (pWorkingUnit != NULL)
-														{
-															FAssert(pWorkingUnit->getProfession() != NO_PROFESSION);
-															// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-															YieldTypes eTempYield = (YieldTypes)GC.getProfessionInfo(pWorkingUnit->getProfession()).getYieldsProduced(0);
-															// MultipleYieldsProduced End
-															int iTempAmount = pLoopPlot->getYield(eYield);
-															int iTempValue = 20 * AI_yieldValue(eTempYield) * iTempAmount;
-
-															if (iValue > (iTempValue * 4) / 3)
-															{
-																bValid = false;
-															}
-														}
-													}
-
-													if (bValid)
-													{
-														if (iValue > iBestValue)
-														{
-															iBestValue = iValue;
-															eBestUnitAI = UNITAI_COLONIST;
-														}
-													}
-												}
-											}
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (kUnitInfo.getUnitAIType(UNITAI_WAGON))
-	{
-		int iValue = 0;
-		if (pCity != NULL)
-		{
-			int iCityCount = pCity->area()->getCitiesPerPlayer(getID());
-			int iWagonCount = AI_totalAreaUnitAIs(pCity->area(), UNITAI_WAGON);
-
-			int iNeededWagons = iCityCount / 2;
-			if (iNeededWagons < iWagonCount)
-			{
-				iValue += 100 * kUnitInfo.getCargoSpace();
-			}
-		}
-
-		if (iValue > iBestValue)
-		{
-			iBestValue = iValue;
-			eBestUnitAI = UNITAI_WAGON;
-		}
-	}
-
-	if (peUnitAI != NULL)
-	{
-		*peUnitAI = eBestUnitAI;
-	}
-
-	return iBestValue;
-}
-
-int CvPlayerAI::AI_unitValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea)
-{
-	bool bValid;
-	int iCombatValue;
-	int iValue;
-
-	FAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
-	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
-	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
-
-	if (kUnitInfo.getDomainType() != AI_unitAIDomainType(eUnitAI))
-	{
-		return 0;
-	}
-
-	if (kUnitInfo.getNotUnitAIType(eUnitAI))
-	{
-		return 0;
-	}
-
-	bValid = kUnitInfo.getUnitAIType(eUnitAI);
-
-	if (!bValid)
-	{
-		switch (eUnitAI)
-		{
-		case UNITAI_UNKNOWN:
-        ///TKs Med
-        case UNITAI_ANIMAL:
-        ///TKe
-			break;
-		case UNITAI_COLONIST:
-			break;
-		case UNITAI_SETTLER:
-			break;
-		case UNITAI_WORKER:
-			break;
-		case UNITAI_MISSIONARY:
-			break;
-        ///TKs Med
-		case UNITAI_SCOUT:
-        case UNITAI_HUNTSMAN:
-			break;
-		case UNITAI_WAGON:
-        case UNITAI_MARAUDER:
-		case UNITAI_TRADER:
-		///TKe
-			break;
-		case UNITAI_TREASURE:
-			break;
-		case UNITAI_YIELD:
-			break;
-		case UNITAI_GENERAL:
-			break;
-		case UNITAI_DEFENSIVE:
-			break;
-		case UNITAI_OFFENSIVE:
-			break;
-		case UNITAI_COUNTER:
-			break;
-		case UNITAI_TRANSPORT_SEA:
-			break;
-		case UNITAI_ASSAULT_SEA:
-			if ((kUnitInfo.getCargoSpace() > 0) && kUnitInfo.getMoves() > 0)
-			{
-				bValid = true;
-			}
-			break;
-		case UNITAI_COMBAT_SEA:
-			break;
-		case UNITAI_PIRATE_SEA:
-			if (kUnitInfo.isHiddenNationality())
-			{
-				if ((kUnitInfo.getCombat() > 0) && kUnitInfo.getMoves() > 0)
-				{
-					bValid = true;
-				}
-			}
-			break;
-
-		default:
-			FAssert(false);
-			break;
-		}
-	}
-
-	if (!bValid)
-	{
-		return 0;
-	}
-
-	iCombatValue = GC.getGameINLINE().AI_combatValue(eUnit);
-
-	iValue = 100;
-
-	iValue += kUnitInfo.getAIWeight();
-
-	int iEuropeCost = getEuropeUnitBuyPrice(eUnit);
-	if (iEuropeCost > 0)
-	{
-		iValue += iEuropeCost;
-	}
-
-	return std::max(0, iValue);
-}
-
-
-//This function attempts to return how much gold this unit is worth.
-int CvPlayerAI::AI_unitGoldValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea)
-{
-	bool bValid = false;
-	int iValue = 0;
-
-	FAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
-	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
-	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
-
-	if (kUnitInfo.getDomainType() != AI_unitAIDomainType(eUnitAI))
-	{
-		return 0;
-	}
-
-	if (kUnitInfo.getNotUnitAIType(eUnitAI))
-	{
-		return 0;
-	}
-
-	bValid = kUnitInfo.getUnitAIType(eUnitAI);
-
-	if (!bValid)
-	{
-		switch (eUnitAI)
-		{
-		case UNITAI_UNKNOWN:
-		///TKs Animal
-		case UNITAI_ANIMAL:
-        case UNITAI_MARAUDER:
-		///Tke
-			break;
-
-		case UNITAI_COLONIST:
-		case UNITAI_SETTLER:
-		case UNITAI_WORKER:
-		case UNITAI_MISSIONARY:
-		case UNITAI_SCOUT:
-		///TKs Med
-        case UNITAI_HUNTSMAN:
-        ///TKe
-			if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
-			{
-				bValid = true;
-			}
-			break;
-
-		case UNITAI_WAGON:
-		///Tks Med
-		case UNITAI_TRADER:
-			if (kUnitInfo.getCargoSpace() > 0)
-			{
-				bValid = true;
-			}
-			break;
-        ///TKe
-		case UNITAI_TREASURE:
-			break;
-
-		case UNITAI_YIELD:
-			break;
-
-		case UNITAI_GENERAL:
-			break;
-
-		case UNITAI_DEFENSIVE:
-			if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
-			{
-				bValid = true;
-			}
-			break;
-
-		case UNITAI_OFFENSIVE:
-			if (kUnitInfo.getBombardRate() > 0)
-			{
-				bValid = true;
-			}
-			break;
-
-		case UNITAI_COUNTER:
-			if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
-			{
-				bValid = true;
-			}
-			break;
-
-		case UNITAI_TRANSPORT_SEA:
-			if (kUnitInfo.getCargoSpace() > 0)
-			{
-				bValid = true;
-			}
-			break;
-
-		case UNITAI_ASSAULT_SEA:
-			if ((kUnitInfo.getCargoSpace() > 0) && kUnitInfo.getMoves() > 0)
-			{
-				bValid = true;
-			}
-			break;
-
-		case UNITAI_COMBAT_SEA:
-			if (!kUnitInfo.isOnlyDefensive() && (kUnitInfo.getCombat() > 0) && kUnitInfo.getMoves() > 0)
-			{
-				bValid = true;
-			}
-			break;
-		case UNITAI_PIRATE_SEA:
-		///TKs Med
-        //case UNITAI_MARAUDER:
-        ///TKe
-			if (kUnitInfo.isHiddenNationality())
-			{
-				if ((kUnitInfo.getCombat() > 0) && kUnitInfo.getMoves() > 0)
-				{
-					bValid = true;
-				}
-			}
-			break;
-
-		default:
-			FAssert(false);
-			break;
-		}
-	}
-
-	if (!bValid)
-	{
-		return 0;
-	}
-	//This function specifically tries to estimate the gold value of a unit.
-
-	int iOffenseCombatValue = kUnitInfo.getCombat() * 100;
-	int iDefenseCombatValue = kUnitInfo.getCombat() * 100;
-
-	if (kUnitInfo.isOnlyDefensive())
-	{
-		iOffenseCombatValue /= 4;
-	}
-
-	int iCargoValue = kUnitInfo.getCargoSpace() * 250;
-
-	if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
-	{
-		iValue += std::max(0, kUnitInfo.getEuropeCost());
-	}
-
-	int iTempValue;
-
-	switch (eUnitAI)
-	{
-	case UNITAI_UNKNOWN:
-	///TKs Med
-    case UNITAI_ANIMAL:
-    ///TKe
-		break;
-
-	case UNITAI_COLONIST:
-	case UNITAI_SETTLER:
-	case UNITAI_WORKER:
-	case UNITAI_MISSIONARY:
-	case UNITAI_SCOUT:
-	///TKs Med
-    case UNITAI_HUNTSMAN:
-    case UNITAI_MARAUDER:
-    ///TKe
-		break;
-
-	case UNITAI_WAGON:
-	///TKs Med
-	case UNITAI_TRADER:
-		iTempValue = iCargoValue + iDefenseCombatValue / 2;
-		iTempValue *= 1 + kUnitInfo.getMoves();
-		iTempValue /= 2;
-		iValue += iTempValue;
-		break;
-    ///Tke
-	case UNITAI_TREASURE:
-		break;
-
-	case UNITAI_YIELD:
-		break;
-
-	case UNITAI_GENERAL:
-		break;
-
-	case UNITAI_DEFENSIVE:
-		iTempValue = iOffenseCombatValue / 2;
-		iTempValue += iDefenseCombatValue;
-		iTempValue += kUnitInfo.getBombardRate() * 50;
-		iValue += iTempValue;
-		break;
-
-	case UNITAI_OFFENSIVE:
-		iTempValue = iOffenseCombatValue;
-		iTempValue += iDefenseCombatValue / 2;
-		iTempValue += kUnitInfo.getBombardRate() * 50;
-
-		iTempValue *= 2 + kUnitInfo.getMoves();
-		iTempValue /= 3;
-		iValue += iTempValue;
-		break;
-
-	case UNITAI_COUNTER:
-		iTempValue = iOffenseCombatValue * 2 / 3;
-		iTempValue += iDefenseCombatValue * 2 / 3;
-		iTempValue += kUnitInfo.getBombardRate() * 50;
-
-		iTempValue *= 2 + kUnitInfo.getMoves();
-		iTempValue /= 3;
-		iValue += iTempValue;
-		break;
-
-	case UNITAI_TRANSPORT_SEA:
-
-		iValue += ((4 + kUnitInfo.getMoves()) * (iCargoValue + iDefenseCombatValue / 2)) / 7;
-
-		break;
-
-	case UNITAI_ASSAULT_SEA:
-		iTempValue = iDefenseCombatValue + iCargoValue;
-		iTempValue *= 4 + kUnitInfo.getMoves();
-		iTempValue /= 7;
-		if (kUnitInfo.isHiddenNationality())
-		{
-			iTempValue /= 2;
-		}
-		iValue += iTempValue;
-		break;
-
-	case UNITAI_COMBAT_SEA:
-		iTempValue = iOffenseCombatValue * 2 + iDefenseCombatValue;
-		iTempValue *= 4 + kUnitInfo.getMoves();
-		iTempValue /= 8;
-		if (kUnitInfo.isHiddenNationality())
-		{
-			iTempValue /= 2;
-		}
-		iValue += iTempValue;
-		break;
-
-	case UNITAI_PIRATE_SEA:
-		iTempValue = iOffenseCombatValue + iDefenseCombatValue + iCargoValue / 2;
-		iTempValue *= 3 + kUnitInfo.getMoves();
-		iTempValue /= 6;
-		iValue += iTempValue;
-		break;
-
-	default:
-		FAssert(false);
-		break;
-	}
-
-
-	iValue +=  kUnitInfo.getAIWeight();
-
-	return std::max(0, iValue);
-}
-
-//This function indicates how worthwhile the unit is to buy.
-int CvPlayerAI::AI_unitValuePercent(UnitTypes eUnit, UnitAITypes* peUnitAI, CvArea* pArea)
-{
-	FAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
-	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
-
-	int iValue = 0;
-
-	int iGoldCost = getEuropeUnitBuyPrice(eUnit);
-
-	if (iGoldCost <= 0)
-	{
-		return -1;
-	}
-
-
-	//Transport Sea
-	int iCargoSpace = kUnitInfo.getCargoSpace();
-	if ((iCargoSpace > 1) && (kUnitInfo.getDomainType() == DOMAIN_SEA))
-	{
-		//Do we need a transport, period?
-		int iTransportCount = AI_totalUnitAIs(UNITAI_TRANSPORT_SEA);
-		if (iTransportCount == 0)
-		{
-			iValue += 200 + 50 * iCargoSpace;
-		}
-		else if (AI_totalUnitAIs(UNITAI_TREASURE) > 0) //Do we need a treasure transport?
-		{
-			int iLargestTreasureUnit = 0;
-			int iTotalTreasure = 0;
-			bool bValid = true;
-
-			int iLoop;
-			CvUnit* pLoopUnit;
-			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-			{
-				if (pLoopUnit->canMove())
-				{
-					if (pLoopUnit->cargoSpace() > 0)
-					{
-						if (pLoopUnit->cargoSpace() >= iCargoSpace)
-						{
-							bValid = false;
-							break;
-						}
-					}
-					if (pLoopUnit->AI_getUnitAIType() == UNITAI_TREASURE)
-					{
-						int iSize = pLoopUnit->getUnitInfo().getRequiredTransportSize();
-						if (iSize > 1)
-						{
-							iLargestTreasureUnit = std::max(iLargestTreasureUnit, iSize);
-							if (iCargoSpace >= iSize)
-							{
-								iTotalTreasure += pLoopUnit->getYield();
-							}
-						}
-					}
-				}
-			}
-
-			if (kUnitInfo.getCargoSpace() >= iLargestTreasureUnit)
-			{
-				iValue += 100 + ((100 * iTotalTreasure) / iGoldCost);
-			}
-		}
-
-		if (iTransportCount < (1 + getNumCities() / 3))
-		{
-			int iBestTransportSize = 0;
-			int iLoop;
-			CvUnit* pLoopUnit;
-			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-			{
-				int iBestTransportSize = 1;
-				if (pLoopUnit->AI_getUnitAIType() == UNITAI_TRANSPORT_SEA)
-				{
-					iBestTransportSize = std::max(iBestTransportSize, pLoopUnit->cargoSpace());
-				}
-			}
-
-			if (iCargoSpace == iBestTransportSize)
-			{
-				iValue += 25;
-			}
-			else if (iCargoSpace > iBestTransportSize)
-			{
-				iValue += 50 + 10 * (iCargoSpace - iBestTransportSize);
-			}
-		}
-	}
-
-	//Warships
-	if (kUnitInfo.getDomainType() == DOMAIN_SEA)
-	{
-		if (kUnitInfo.getCombat() > 0)
-		{
-			//Pirate
-			if (getTotalPopulation() > 12)
-			{
-				if (kUnitInfo.isHiddenNationality())
-				{
-					if (AI_totalUnitAIs(UNITAI_PIRATE_SEA) <= (getNumCities() / 9))
-					{
-						iValue += 50 + getNumCities() * 5;
-					}
-				}
-			}
-		}
-	}
-	return iValue;
-}
-
-int CvPlayerAI::AI_totalUnitAIs(UnitAITypes eUnitAI)
-{
-	return (AI_getNumTrainAIUnits(eUnitAI) + AI_getNumAIUnits(eUnitAI));
-}
-
-
-int CvPlayerAI::AI_totalAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI)
-{
-	return (pArea->getNumTrainAIUnits(getID(), eUnitAI) + pArea->getNumAIUnits(getID(), eUnitAI));
-}
-
-
-int CvPlayerAI::AI_totalWaterAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI)
-{
-	CvCity* pLoopCity;
-	int iCount;
-	int iLoop;
-	int iI;
-
-	iCount = AI_totalAreaUnitAIs(pArea, eUnitAI);
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			for (pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
-			{
-				if (pLoopCity->waterArea() == pArea)
-				{
-					iCount += pLoopCity->plot()->plotCount(PUF_isUnitAIType, eUnitAI, -1, getID());
-
-					if (pLoopCity->getOwnerINLINE() == getID())
-					{
-						iCount += pLoopCity->getNumTrainUnitAI(eUnitAI);
-					}
-				}
-			}
-		}
-	}
-
-
-	return iCount;
-}
-
-bool CvPlayerAI::AI_hasSeaTransport(const CvUnit* pCargo) const
-{
-	int iLoop;
-	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-	{
-		if (pLoopUnit != pCargo && pLoopUnit->getDomainType() == DOMAIN_SEA)
-		{
-			if (pLoopUnit->cargoSpace() >= pCargo->getUnitInfo().getRequiredTransportSize())
-			{
-				return true;
-			}
-
-		}
-	}
-	return false;
-}
-
-int CvPlayerAI::AI_neededExplorers(CvArea* pArea)
-{
-	FAssert(pArea != NULL);
-	int iNeeded = 0;
-
-	if (pArea->isWater())
-	{
-		iNeeded = std::min(iNeeded + (pArea->getNumUnrevealedTiles(getTeam()) / 400), std::min(2, ((getNumCities() / 2) + 1)));
-	}
-	else
-	{
-		iNeeded = std::min(iNeeded + (pArea->getNumUnrevealedTiles(getTeam()) / 150), std::min(3, ((getNumCities() / 3) + 2)));
-	}
-
-	if (0 == iNeeded)
-	{
-		if ((GC.getGameINLINE().countCivTeamsAlive() - 1) > GET_TEAM(getTeam()).getHasMetCivCount())
-		{
-			if (pArea->isWater())
-			{
-				if (GC.getMap().findBiggestArea(true) == pArea)
-				{
-					iNeeded++;
-				}
-			}
-			else
-			{
-			    if (getPrimaryCity() != NULL && pArea->getID() == getPrimaryCity()->getArea())
-			    {
-                    for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
-                    {
-                        CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
-                        if (kPlayer.isAlive() && kPlayer.getTeam() != getTeam())
-                        {
-                            if (!GET_TEAM(getTeam()).isHasMet(kPlayer.getTeam()))
-                            {
-                                if (pArea->getCitiesPerPlayer(kPlayer.getID()) > 0)
-                                {
-                                    iNeeded++;
-                                    break;
-                                }
-                            }
-                        }
-                    }
-			    }
-			}
-		}
-	}
-	return iNeeded;
-
-}
-
-
-int CvPlayerAI::AI_neededWorkers(CvArea* pArea)
-{
-	CvCity* pLoopCity;
-	int iCount;
-	int iLoop;
-
-	iCount = 0;
-
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if ((pArea == NULL) || (pLoopCity->getArea() == pArea->getID()))
-		{
-			iCount += pLoopCity->AI_getWorkersNeeded();
-		}
-	}
-
-	if (iCount == 0)
-	{
-		return 0;
-	}
-
-	return std::max(1, (iCount * 2) / 3);
-}
-
-int CvPlayerAI::AI_adjacentPotentialAttackers(CvPlot* pPlot, bool bTestCanMove)
-{
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	CvPlot* pLoopPlot;
-	int iCount;
-	int iI;
-
-	iCount = 0;
-
-	for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
-	{
-		pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), ((DirectionTypes)iI));
-
-		if (pLoopPlot != NULL)
-		{
-			if (pLoopPlot->area() == pPlot->area())
-			{
-				pUnitNode = pLoopPlot->headUnitNode();
-
-				while (pUnitNode != NULL)
-				{
-					pLoopUnit = ::getUnit(pUnitNode->m_data);
-					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-					if (pLoopUnit->getOwnerINLINE() == getID())
-					{
-						if (pLoopUnit->getDomainType() == ((pPlot->isWater()) ? DOMAIN_SEA : DOMAIN_LAND))
-						{
-							if (pLoopUnit->canAttack())
-							{
-								if (!bTestCanMove || pLoopUnit->canMove())
-								{
-									if (!(pLoopUnit->AI_isCityAIType()))
-									{
-										iCount++;
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-
-int CvPlayerAI::AI_totalMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
-{
-	PROFILE_FUNC();
-
-	CvSelectionGroup* pLoopSelectionGroup;
-	int iCount;
-	int iLoop;
-
-	iCount = 0;
-
-	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-	{
-		if (pLoopSelectionGroup != pSkipSelectionGroup)
-		{
-			if (pLoopSelectionGroup->AI_getMissionAIType() == eMissionAI)
-			{
-				iCount += pLoopSelectionGroup->getNumUnits();
-			}
-		}
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_areaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
-{
-	PROFILE_FUNC();
-
-	CvSelectionGroup* pLoopSelectionGroup;
-	CvPlot* pMissionPlot;
-	int iCount;
-	int iLoop;
-
-	iCount = 0;
-
-	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-	{
-		if (pLoopSelectionGroup != pSkipSelectionGroup)
-		{
-			if (pLoopSelectionGroup->AI_getMissionAIType() == eMissionAI)
-			{
-				pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
-
-				if (pMissionPlot != NULL)
-				{
-					if (pMissionPlot->getArea() == pArea->getID())
-					{
-						iCount += pLoopSelectionGroup->getNumUnits();
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-
-int CvPlayerAI::AI_adjacantToAreaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
-{
-	PROFILE_FUNC();
-
-	CvSelectionGroup* pLoopSelectionGroup;
-	CvPlot* pMissionPlot;
-	int iCount;
-	int iLoop;
-
-	iCount = 0;
-
-	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-	{
-		if (pLoopSelectionGroup != pSkipSelectionGroup)
-		{
-			if (pLoopSelectionGroup->AI_getMissionAIType() == eMissionAI)
-			{
-				pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
-
-				if (pMissionPlot != NULL)
-				{
-					if (pMissionPlot->isAdjacentToArea(pArea->getID()))
-					{
-						iCount += pLoopSelectionGroup->getNumUnits();
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-
-int CvPlayerAI::AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup, int iRange)
-{
-	int iClosestTargetRange;
-	return AI_plotTargetMissionAIs(pPlot, &eMissionAI, 1, iClosestTargetRange, pSkipSelectionGroup, iRange);
-}
-
-int CvPlayerAI::AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup, int iRange)
-{
-	return AI_plotTargetMissionAIs(pPlot, &eMissionAI, 1, iClosestTargetRange, pSkipSelectionGroup, iRange);
-}
-
-int CvPlayerAI::AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes* aeMissionAI, int iMissionAICount, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup, int iRange)
-{
-	PROFILE_FUNC();
-
-	int iCount = 0;
-	iClosestTargetRange = MAX_INT;
-
-	CvSelectionGroup* pTransportSelectionGroup = NULL;
-	if (pSkipSelectionGroup != NULL)
-	{
-		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
-		if (pHeadUnit->getTransportUnit() != NULL)
-		{
-			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
-		}
-	}
-	int iLoop;
-	for(CvSelectionGroup* pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-	{
-		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
-		{
-			CvPlot* pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
-
-			if (pMissionPlot != NULL)
-			{
-				MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
-				int iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pMissionPlot->getX_INLINE(), pMissionPlot->getY_INLINE());
-
-				if (iDistance <= iRange)
-				{
-					for (int iMissionAIIndex = 0; iMissionAIIndex < iMissionAICount; iMissionAIIndex++)
-					{
-						if (eGroupMissionAI == aeMissionAI[iMissionAIIndex] || aeMissionAI[iMissionAIIndex] == NO_MISSIONAI)
-						{
-							iCount += pLoopSelectionGroup->getNumUnits();
-
-							if (iDistance < iClosestTargetRange)
-							{
-								iClosestTargetRange = iDistance;
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-
-int CvPlayerAI::AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
-{
-	return AI_unitTargetMissionAIs(pUnit, &eMissionAI, 1, pSkipSelectionGroup);
-}
-
-int CvPlayerAI::AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup)
-{
-	PROFILE_FUNC();
-
-	CvSelectionGroup* pLoopSelectionGroup;
-	int iCount;
-	int iLoop;
-
-	CvSelectionGroup* pTransportSelectionGroup = NULL;
-	if (pSkipSelectionGroup != NULL)
-	{
-		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
-		if (pHeadUnit->getTransportUnit() != NULL)
-		{
-			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
-		}
-	}
-
-	iCount = 0;
-	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-	{
-		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
-		{
-			if (pLoopSelectionGroup->AI_getMissionAIUnit() == pUnit)
-			{
-				MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
-				for (int iMissionAIIndex = 0; iMissionAIIndex < iMissionAICount; iMissionAIIndex++)
-				{
-					if (eGroupMissionAI == aeMissionAI[iMissionAIIndex] || NO_MISSIONAI == aeMissionAI[iMissionAIIndex])
-					{
-						iCount += pLoopSelectionGroup->getNumUnits();
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_enemyTargetMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
-{
-	return AI_enemyTargetMissionAIs(&eMissionAI, 1, pSkipSelectionGroup);
-}
-
-int CvPlayerAI::AI_enemyTargetMissionAIs(MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup)
-{
-	PROFILE_FUNC();
-
-	CvSelectionGroup* pTransportSelectionGroup = NULL;
-	if (pSkipSelectionGroup != NULL)
-	{
-		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
-		if (pHeadUnit->getTransportUnit() != NULL)
-		{
-			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
-		}
-	}
-
-	int iCount = 0;
-	int iLoop;
-	for(CvSelectionGroup* pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-	{
-		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
-		{
-			CvPlot* pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
-
-			if (NULL != pMissionPlot && pMissionPlot->isOwned())
-			{
-				MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
-				for (int iMissionAIIndex = 0; iMissionAIIndex < iMissionAICount; iMissionAIIndex++)
-				{
-						if (eGroupMissionAI == aeMissionAI[iMissionAIIndex] || NO_MISSIONAI == aeMissionAI[iMissionAIIndex])
-					{
-						if (GET_TEAM(getTeam()).AI_isChosenWar(pMissionPlot->getTeam()))
-						{
-							iCount += pLoopSelectionGroup->getNumUnits();
-							iCount += pLoopSelectionGroup->getCargo();
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_wakePlotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
-{
-	PROFILE_FUNC();
-
-	FAssert(pPlot != NULL);
-
-	CvSelectionGroup* pTransportSelectionGroup = NULL;
-	if (pSkipSelectionGroup != NULL)
-	{
-		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
-		if (pHeadUnit->getTransportUnit() != NULL)
-		{
-			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
-		}
-	}
-
-	int iCount = 0;
-
-	int iLoop;
-	for(CvSelectionGroup* pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
-	{
-		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
-		{
-			MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
-			if (eMissionAI == NO_MISSIONAI || eMissionAI == eGroupMissionAI)
-			{
-				CvPlot* pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
-				if (pMissionPlot != NULL && pMissionPlot == pPlot)
-				{
-					iCount += pLoopSelectionGroup->getNumUnits();
-					pLoopSelectionGroup->setActivityType(ACTIVITY_AWAKE);
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
- ///TKs Med
-CivicTypes CvPlayerAI::AI_bestCivic(CivicOptionTypes eCivicOption)
-{
-	CivicTypes eBestCivic;
-	int iValue;
-	int iBestValue;
-	int iI;
-
-	iBestValue = MIN_INT;
-	eBestCivic = NO_CIVIC;
-
-	for (iI = 0; iI < GC.getNumCivicInfos(); iI++)
-	{
-		if (GC.getCivicInfo((CivicTypes)iI).getCivicOptionType() == eCivicOption)
-		{
-			if (canDoCivics((CivicTypes)iI))
-			{
-				iValue = AI_civicValue((CivicTypes)iI);
-
-				if (isCivic((CivicTypes)iI))
-				{
-					iValue *= 16;
-					iValue /= 15;
-				}
-
-				if (iValue > iBestValue)
-				{
-					iBestValue = iValue;
-					eBestCivic = ((CivicTypes)iI);
-				}
-			}
-		}
-	}
-
-	return eBestCivic;
-}
-///TKe
-
-int CvPlayerAI::AI_civicValue(CivicTypes eCivic)
-{
-	PROFILE_FUNC();
-
-	FAssertMsg(eCivic < GC.getNumCivicInfos(), "eCivic is expected to be within maximum bounds (invalid Index)");
-	FAssertMsg(eCivic >= 0, "eCivic is expected to be non-negative (invalid Index)");
-
-	CvCivicInfo& kCivic = GC.getCivicInfo(eCivic);
-
-	int iValue = (getNumCities() * 6);
-
-	iValue += (GC.getCivicInfo(eCivic).getAIWeight() * getNumCities());
-
-	iValue *= 10 + GC.getGameINLINE().getSorenRandNum(90, "AI choose revolution civics");
-
-	return iValue;
-}
-
-int CvPlayerAI::AI_getAttackOddsChange()
-{
-	return m_iAttackOddsChange;
-}
-
-
-void CvPlayerAI::AI_setAttackOddsChange(int iNewValue)
-{
-	m_iAttackOddsChange = iNewValue;
-}
-
-int CvPlayerAI::AI_getExtraGoldTarget() const
-{
-	return m_iExtraGoldTarget;
-}
-
-void CvPlayerAI::AI_setExtraGoldTarget(int iNewValue)
-{
-	m_iExtraGoldTarget = iNewValue;
-}
-
-void CvPlayerAI::AI_chooseCivic(CivicOptionTypes eCivicOption)
-{
-	int iBestValue = MIN_INT;
-	CivicTypes eBestCivic = NO_CIVIC;
-
-	for (int iCivic = 0; iCivic < GC.getNumCivicInfos(); ++iCivic)
-	{
-		if (GC.getCivicInfo((CivicTypes) iCivic).getCivicOptionType() == eCivicOption)
-		{
-			if (canDoCivics((CivicTypes) iCivic))
-			{
-				int iValue = AI_civicValue((CivicTypes) iCivic);
-				if (iValue > iBestValue)
-				{
-					iBestValue = iValue;
-					eBestCivic = (CivicTypes) iCivic;
-				}
-			}
-		}
-	}
-
-	if (eBestCivic != NO_CIVIC)
-	{
-		setCivic(eCivicOption, eBestCivic);
-	}
-}
-
-bool CvPlayerAI::AI_chooseGoody(GoodyTypes eGoody)
-{
-	return true;
-}
-
-CvCity* CvPlayerAI::AI_findBestCity() const
-{
-	CvCity* pBestCity = NULL;
-	int iBestValue = 0;
-
-	CvPlot* pTerritoryCenter = AI_getTerritoryCenter();
-
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		int iValue = 1000 * (1 + pLoopCity->getPopulation());
-		iValue *= 100 + 20 * (pLoopCity->plot()->getYield(YIELD_FOOD) - GC.getFOOD_CONSUMPTION_PER_POPULATION());
-		iValue /= std::max(1, pLoopCity->plot()->getDistanceToOcean());
-
-		iValue *= 1 + pLoopCity->area()->getCitiesPerPlayer(getID());
-		iValue /= 4 + stepDistance(pTerritoryCenter->getX_INLINE(), pTerritoryCenter->getY_INLINE(), pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE());
-
-		if (iValue > iBestValue)
-		{
-			pBestCity = pLoopCity;
-			iBestValue = iValue;
-		}
-	}
-
-	FAssert(pBestCity != NULL);
-	return pBestCity;
-}
-
-CvCity* CvPlayerAI::AI_findBestPort() const
-{
-	if (getParent() == NO_PLAYER)
-	{
-		return NULL;
-	}
-
-	CvCity* pBestCity = NULL;
-	int iBestValue = 0;
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity->plot()->getNearestEurope() != NO_EUROPE)
-		{
-			int iPortValue = 100000 / std::max(2, pLoopCity->plot()->getDistanceToOcean());
-			iPortValue /= 100 + pLoopCity->getGameTurnFounded();
-
-			if (iPortValue > iBestValue)
-			{
-				pBestCity = pLoopCity;
-				iBestValue = iPortValue;
-			}
-		}
-	}
-
-	return pBestCity;
-}
-
-
-int CvPlayerAI::AI_getNumTrainAIUnits(UnitAITypes eIndex)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_aiNumTrainAIUnits[eIndex];
-}
-
-
-void CvPlayerAI::AI_changeNumTrainAIUnits(UnitAITypes eIndex, int iChange)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
-	m_aiNumTrainAIUnits[eIndex] += iChange;
-	FAssert(AI_getNumTrainAIUnits(eIndex) >= 0);
-}
-
-
-int CvPlayerAI::AI_getNumAIUnits(UnitAITypes eIndex)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_aiNumAIUnits[eIndex];
-}
-
-
-void CvPlayerAI::AI_changeNumAIUnits(UnitAITypes eIndex, int iChange)
-{
-	if (eIndex != NO_UNITAI)
-	{
-		m_aiNumAIUnits[eIndex] += iChange;
-		FAssert(AI_getNumAIUnits(eIndex) >= 0);
-
-#ifdef _DEBUG
-		if (iChange > 0)
-		{
-			int iLoop;
-			int iNumUnitAI = 0;
-			for (CvUnit* pLoopUnit = firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = nextUnit(&iLoop))
-			{
-				if (pLoopUnit->AI_getUnitAIType() == eIndex)
-				{
-					++iNumUnitAI;
-				}
-			}
-			for (uint i = 0; i < m_aEuropeUnits.size(); ++i)
-			{
-				if (m_aEuropeUnits[i]->AI_getUnitAIType() == eIndex)
-				{
-					++iNumUnitAI;
-				}
-			}
-			for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-			{
-				for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-				{
-					CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
-					if (pLoopUnit->AI_getUnitAIType() == eIndex)
-					{
-						++iNumUnitAI;
-					}
-				}
-			}
-			FAssert(AI_getNumAIUnits(eIndex) == iNumUnitAI);
-		}
-#endif
-	}
-}
-
-int CvPlayerAI::AI_getNumRetiredAIUnits(UnitAITypes eIndex)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_aiNumRetiredAIUnits[eIndex];
-}
-
-
-void CvPlayerAI::AI_changeNumRetiredAIUnits(UnitAITypes eIndex, int iChange)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
-	m_aiNumRetiredAIUnits[eIndex] += iChange;
-	FAssert(AI_getNumRetiredAIUnits(eIndex) >= 0);
-}
-
-int CvPlayerAI::AI_getPeacetimeTradeValue(PlayerTypes eIndex)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_aiPeacetimeTradeValue[eIndex];
-}
-
-
-void CvPlayerAI::AI_changePeacetimeTradeValue(PlayerTypes eIndex, int iChange)
-{
-	PROFILE_FUNC();
-
-	int iI;
-
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-
-	if (iChange != 0)
-	{
-		m_aiPeacetimeTradeValue[eIndex] = (m_aiPeacetimeTradeValue[eIndex] + iChange);
-		FAssert(AI_getPeacetimeTradeValue(eIndex) >= 0);
-
-		FAssert(iChange > 0);
-
-		if (iChange > 0)
-		{
-			if (GET_PLAYER(eIndex).getTeam() != getTeam())
-			{
-				for (iI = 0; iI < MAX_TEAMS; iI++)
-				{
-					if (GET_TEAM((TeamTypes)iI).isAlive())
-					{
-						if (GET_TEAM((TeamTypes)iI).AI_getWorstEnemy() == getTeam())
-						{
-							GET_TEAM((TeamTypes)iI).AI_changeEnemyPeacetimeTradeValue(GET_PLAYER(eIndex).getTeam(), iChange);
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-
-int CvPlayerAI::AI_getPeacetimeGrantValue(PlayerTypes eIndex)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_aiPeacetimeGrantValue[eIndex];
-}
-
-
-void CvPlayerAI::AI_changePeacetimeGrantValue(PlayerTypes eIndex, int iChange)
-{
-	PROFILE_FUNC();
-
-	int iI;
-
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-
-	if (iChange != 0)
-	{
-		m_aiPeacetimeGrantValue[eIndex] = (m_aiPeacetimeGrantValue[eIndex] + iChange);
-		FAssert(AI_getPeacetimeGrantValue(eIndex) >= 0);
-
-		FAssert(iChange > 0);
-
-		if (iChange > 0)
-		{
-			if (GET_PLAYER(eIndex).getTeam() != getTeam())
-			{
-				for (iI = 0; iI < MAX_TEAMS; iI++)
-				{
-					if (GET_TEAM((TeamTypes)iI).isAlive())
-					{
-						if (GET_TEAM((TeamTypes)iI).AI_getWorstEnemy() == getTeam())
-						{
-							GET_TEAM((TeamTypes)iI).AI_changeEnemyPeacetimeGrantValue(GET_PLAYER(eIndex).getTeam(), iChange);
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-
-int CvPlayerAI::AI_getGoldTradedTo(PlayerTypes eIndex) const
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_aiGoldTradedTo[eIndex];
-}
-
-
-void CvPlayerAI::AI_changeGoldTradedTo(PlayerTypes eIndex, int iChange)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	m_aiGoldTradedTo[eIndex] = (m_aiGoldTradedTo[eIndex] + iChange);
-	FAssert(AI_getGoldTradedTo(eIndex) >= 0);
-}
-
-
-int CvPlayerAI::AI_getAttitudeExtra(PlayerTypes eIndex)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_aiAttitudeExtra[eIndex];
-}
-
-
-void CvPlayerAI::AI_setAttitudeExtra(PlayerTypes eIndex, int iNewValue)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	m_aiAttitudeExtra[eIndex] = iNewValue;
-}
-
-
-void CvPlayerAI::AI_changeAttitudeExtra(PlayerTypes eIndex, int iChange)
-{
-	AI_setAttitudeExtra(eIndex, (AI_getAttitudeExtra(eIndex) + iChange));
-}
-
-
-bool CvPlayerAI::AI_isFirstContact(PlayerTypes eIndex)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	return m_abFirstContact[eIndex];
-}
-
-
-void CvPlayerAI::AI_setFirstContact(PlayerTypes eIndex, bool bNewValue)
-{
-	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
-	m_abFirstContact[eIndex] = bNewValue;
-}
-
-
-int CvPlayerAI::AI_getContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2)
-{
-	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
-	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex2 < NUM_CONTACT_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
-	return m_aaiContactTimer[eIndex1][eIndex2];
-}
-
-
-void CvPlayerAI::AI_changeContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2, int iChange)
-{
-	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
-	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex2 < NUM_CONTACT_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
-	m_aaiContactTimer[eIndex1][eIndex2] = (AI_getContactTimer(eIndex1, eIndex2) + iChange);
-	FAssert(AI_getContactTimer(eIndex1, eIndex2) >= 0);
-}
-
-
-int CvPlayerAI::AI_getMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2)
-{
-	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
-	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex2 < NUM_MEMORY_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
-	return m_aaiMemoryCount[eIndex1][eIndex2];
-}
-
-
-void CvPlayerAI::AI_changeMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2, int iChange)
-{
-	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
-	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
-	FAssertMsg(eIndex2 < NUM_MEMORY_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
-	m_aaiMemoryCount[eIndex1][eIndex2] += iChange;
-	FAssert(AI_getMemoryCount(eIndex1, eIndex2) >= 0);
-}
-
-// Protected Functions...
-
-void CvPlayerAI::AI_doTradeRoutes()
-{
-	//Yields are divided into several classes:
-	//1) Final Products - Port cities import these and export to europe. Other cities, export them.
-	//2) Utility such as Lumber, Tools - These are set Import/Export with the Maintain Level used to indicate how much are needed.
-	//3) Raw Materials - Cities which consume these to produce final products, Import/Export, with a high maintain level.
-	//	 Port cities Import/Export with no maintain level.
-
-	//Generally, utility yields are set to Import/Export
-
-	//Best Yield Destinations
-	std::vector<CvCity*> yield_dests(NUM_YIELD_TYPES, NULL);
-
-	for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-	{
-		YieldTypes eLoopYield = (YieldTypes)iYield;
-///TKs Med
-		if (GC.getYieldInfo(eLoopYield).isCargo() && (eLoopYield != YIELD_FOOD && eLoopYield != YIELD_GRAIN))
-		{
-			if (AI_isYieldFinalProduct(eLoopYield))
-			{
-				yield_dests[eLoopYield] = NULL;
-			}
-			else if ((eLoopYield == YIELD_TOOLS) || (eLoopYield == YIELD_LUMBER))
-			{
-				yield_dests[eLoopYield] = NULL;
-			}
-
-			else if (GC.isEquipmentType(eLoopYield, EQUIPMENT_ANY))
-			{
-				yield_dests[eLoopYield] = NULL;
-			}
-			///TKe
-			else
-			{
-				CvCity* pBestYieldCity = NULL;
-				int iBestCityValue = 0;
-
-				int iLoop;
-				CvCity* pLoopCity;
-				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-				{
-					for (int iProfession = 0; iProfession < GC.getNumProfessionInfos(); ++iProfession)
-					{
-						CvProfessionInfo& kLoopProfession = GC.getProfessionInfo((ProfessionTypes)iProfession);
-						if (kLoopProfession.getYieldsConsumed(0, getID()) == eLoopYield || kLoopProfession.getYieldsConsumed(1, getID()) == eLoopYield)
-						{
-							int iValue = pLoopCity->getProfessionOutput((ProfessionTypes)iProfession, NULL);
-							if (iValue > 0)
-							{
-								iValue *= 100;
-								iValue += pLoopCity->getPopulation();
-								if (iValue > iBestCityValue)
-								{
-									iBestCityValue = iValue;
-									pBestYieldCity = pLoopCity;
-								}
-							}
-						}
-					}
-				}
-				yield_dests[eLoopYield] = pBestYieldCity;
-				///Tks Med
-				FAssert(pBestYieldCity != NULL);
-				if (GC.getGameINLINE().getGameTurn() > 50 && pBestYieldCity != NULL)
-				{
-					pBestYieldCity->setMaintainLevel(eLoopYield, pBestYieldCity->getMaxYieldCapacity(eLoopYield) / 2);
-				}
-				///Tke
-			}
-		}
-	}
-
-	CvCity* pLoopCity;
-	int iLoop;
-	//Setup export trade routes.
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		int aiYields[NUM_YIELD_TYPES];
-		pLoopCity->calculateNetYields(aiYields);
-        ///TKs Med
-		//int iCapacity = pLoopCity->getMaxYieldCapacity();
-		for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-		{
-		    YieldTypes eLoopYield = (YieldTypes)iYield;
-		    int iCapacity = pLoopCity->getMaxYieldCapacity(eLoopYield);
-			bool bAvailable = (aiYields[eLoopYield] > 0) || (pLoopCity->getYieldStored(eLoopYield) > 0);
-			bool bShouldImport = false;
-			bool bShouldExport = false;
-			if (GC.getYieldInfo(eLoopYield).isCargo())
-			{
-				if (eLoopYield == YIELD_FOOD)
-				{
-					int iThreshold = pLoopCity->growthThreshold() / (2 + std::max(0, aiYields[eLoopYield]));
-                    pLoopCity->setMaintainLevel(eLoopYield, iThreshold);
-                    if (aiYields[eLoopYield] > 0)
-                    {
-                        bShouldExport = true;
-                        pLoopCity->AI_setAvoidGrowth(false);
-                    }
-                    else
-                    {
-                        bShouldImport = true;
-                        pLoopCity->AI_setAvoidGrowth(true);
-                    }
-				}
-				else if (eLoopYield == YIELD_GRAIN)
-				{
-					int iThreshold = pLoopCity->growthThreshold();
-                    if (pLoopCity->canProduceYield(YIELD_GRAIN))
-                    {
-                        pLoopCity->setMaintainLevel(eLoopYield, iThreshold);
-                        bShouldExport = false;
-                        bShouldImport = true;
-                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, true);
-                    }
-                    else
-                    {
-                        bShouldImport = false;
-                        bShouldExport = true;
-                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, false);
-                    }
-				}
-				else if (eLoopYield == YIELD_SPICES || eLoopYield == YIELD_CATTLE)
-				{
-					int iThreshold = pLoopCity->growthThreshold() * 50 / 100;
-                    if (pLoopCity->canProduceYield(YIELD_GRAIN))
-                    {
-                        pLoopCity->setMaintainLevel(eLoopYield, iThreshold);
-                        bShouldExport = false;
-                        bShouldImport = true;
-                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, true);
-                    }
-                    else
-                    {
-                        bShouldImport = false;
-                        bShouldExport = true;
-                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, false);
-                    }
-				}
-				else
-				{
-					if ((AI_isYieldFinalProduct(eLoopYield)) || AI_isYieldForSale(eLoopYield))
-					{
-						if (pLoopCity->AI_isPort())
-						{
-							bShouldImport = true;
-						}
-						else if (bAvailable)
-						{
-							bShouldExport = true;
-						}
-					}
-
-					if (pLoopCity->AI_isPort())
-					{
-					    ///TKs
-						if ((eLoopYield == YIELD_TOOLS) || GC.isEquipmentType(eLoopYield, EQUIPMENT_ANY))
-						{
-							bShouldExport = true;
-						}
-						///Tke
-					}
-
-					if (yield_dests[eLoopYield] == pLoopCity)
-					{
-						bShouldImport = true;
-					}
-					else if (yield_dests[eLoopYield] != NULL)
-					{
-						if (bAvailable)
-						{
-							bShouldExport = true;
-						}
-					}
-					else
-					{
-						int iMaintainLevel = pLoopCity->getMaintainLevel(eLoopYield);
-						int iStored = pLoopCity->getYieldStored(eLoopYield);
-
-						if (iStored > iMaintainLevel)
-						{
-							if ((aiYields[eLoopYield] > 0) || (iStored > (iCapacity * 90) / 100) || pLoopCity->AI_isPort())
-							{
-								bShouldExport = true;
-							}
-						}
-						else if (iMaintainLevel > 0 && iStored < iMaintainLevel)
-						{
-							bShouldImport = true;
-						}
-					}
-				}
-				if (bShouldImport)
-				{
-					pLoopCity->addImport(eLoopYield);
-				}
-				else
-				{
-					pLoopCity->removeImport(eLoopYield);
-				}
-				if (bShouldExport)
-				{
-					pLoopCity->addExport(eLoopYield);
-				}
-				else
-				{
-					pLoopCity->removeExport(eLoopYield);
-				}
-			}
-		}
-	}
-}
-
-void CvPlayerAI::AI_doCounter()
-{
-	int iI, iJ;
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			for (iJ = 0; iJ < NUM_CONTACT_TYPES; iJ++)
-			{
-				if (AI_getContactTimer(((PlayerTypes)iI), ((ContactTypes)iJ)) > 0)
-				{
-					AI_changeContactTimer(((PlayerTypes)iI), ((ContactTypes)iJ), -1);
-				}
-			}
-		}
-	}
-
-	for (iI = 0; iI < MAX_PLAYERS; iI++)
-	{
-		if (GET_PLAYER((PlayerTypes)iI).isAlive())
-		{
-			for (iJ = 0; iJ < NUM_MEMORY_TYPES; iJ++)
-			{
-				if (AI_getMemoryCount(((PlayerTypes)iI), ((MemoryTypes)iJ)) > 0)
-				{
-				    ///Tks Med
-				    if ((MemoryTypes)iJ == MEMORY_MADE_VASSAL_DEMAND)
-				    {
-				        AI_changeMemoryCount(((PlayerTypes)iI), ((MemoryTypes)iJ), -1);
-				        continue;
-				    }
-                    ///Tke
-					if (GC.getLeaderHeadInfo(getPersonalityType()).getMemoryDecayRand(iJ) > 0)
-					{
-						if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getMemoryDecayRand(iJ), "Memory Decay") == 0)
-						{
-							AI_changeMemoryCount(((PlayerTypes)iI), ((MemoryTypes)iJ), -1);
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-
-void CvPlayerAI::AI_doMilitary()
-{
-
-
-	AI_setAttackOddsChange(GC.getLeaderHeadInfo(getPersonalityType()).getBaseAttackOddsChange() +
-		GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getAttackOddsChangeRand(), "AI Attack Odds Change #1") +
-		GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getAttackOddsChangeRand(), "AI Attack Odds Change #2"));
-}
-
-void CvPlayerAI::AI_doDiplo()
-{
-	PROFILE_FUNC();
-
-	FAssert(!isHuman());
-
-	// allow python to handle it
-	CyArgsList argsList;
-	argsList.add(getID());
-	long lResult=0;
-	gDLL->getPythonIFace()->callFunction(PYGameModule, "AI_doDiplo", argsList.makeFunctionArgs(), &lResult);
-	if (lResult == 1)
-	{
-		return;
-	}
-
-	std::vector<bool> abContacted(MAX_TEAMS, false);
-
-	for (int iPass = 0; iPass < 2; iPass++)
-	{
-		for (int iI = 0; iI < MAX_PLAYERS; iI++)
-		{
-			PlayerTypes ePlayer = (PlayerTypes) iI;
-			CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-			if (kPlayer.isAlive() && ePlayer != getID())
-			{
-				if (kPlayer.isHuman() == (iPass == 1))
-				{
-					if (AI_doDiploCancelDeals((PlayerTypes) iI))
-					{
-						if (kPlayer.isHuman())
-						{
-							abContacted[kPlayer.getTeam()] = true;
-						}
-					}
-
-					if (canContact(ePlayer) && AI_isWillingToTalk(ePlayer))
-					{
-						if (kPlayer.getTeam() != getTeam() && !(GET_TEAM(getTeam()).isHuman()) && (kPlayer.isHuman() || !(GET_TEAM(kPlayer.getTeam()).isHuman())))
-						{
-							FAssertMsg(iI != getID(), "iI is not expected to be equal with getID()");
-
-							if (!(GET_TEAM(getTeam()).isAtWar(kPlayer.getTeam())))
-							{
-							    ///TKs Med
-							    bool bOfferedVassal = false;
-							    if (AI_doDiploOfferVassalCity(ePlayer))
-								{
-								    bOfferedVassal = true;
-									if (kPlayer.isHuman())
-									{
-										abContacted[kPlayer.getTeam()] = true;
-									}
-								}
-                                if (!bOfferedVassal)
-                                {
-                                    if (AI_doDiploOfferCity(ePlayer))
-                                    {
-                                        if (kPlayer.isHuman())
-                                        {
-                                            abContacted[kPlayer.getTeam()] = true;
-                                        }
-                                    }
-                                }
-                                ///TKe
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploOfferAlliance(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-										else
-										{
-											// move on to the next player since we are on the same team now
-											break;
-										}
-									}
-								}
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploAskJoinWar(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploAskStopTrading(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploGiveHelp(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploAskForHelp(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploDemandTribute(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-                                ///TKs Med Dip
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploKissPinky(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-                                ///Tke
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploOpenBorders(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-
-                                ///TKs Invention Core Mod v 1.0
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploTradeResearch(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-								///Tke
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploDefensivePact(ePlayer))
-									{
-										if (kPlayer.isHuman())
-                                        {
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploTradeMap(ePlayer))
-									{
-										if (kPlayer.isHuman())
-										{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-
-								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
-								{
-									if (AI_doDiploDeclareWar(ePlayer))
-									{
-										if (kPlayer.isHuman())
-									{
-											abContacted[kPlayer.getTeam()] = true;
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-
-bool CvPlayerAI::AI_doDiploCancelDeals(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (kPlayer.getTeam() == getTeam())
-	{
-		return false;
-	}
-
-	bool bKilled = false;
-
-	int iLoop;
-	for (CvDeal* pLoopDeal = GC.getGameINLINE().firstDeal(&iLoop); pLoopDeal != NULL; pLoopDeal = GC.getGameINLINE().nextDeal(&iLoop))
-	{
-		if (pLoopDeal->isCancelable(getID()))
-		{
-			if ((GC.getGameINLINE().getGameTurn() - pLoopDeal->getInitialGameTurn()) >= (GC.getCache_PEACE_TREATY_LENGTH() * 2))
-			{
-				bool bCancelDeal = false;
-
-				if ((pLoopDeal->getFirstPlayer() == getID()) && (pLoopDeal->getSecondPlayer() == ePlayer))
-				{
-					if (kPlayer.isHuman())
-					{
-						if (!AI_considerOffer(ePlayer, pLoopDeal->getSecondTrades(), pLoopDeal->getFirstTrades(), -1))
-						{
-							bCancelDeal = true;
-						}
-					}
-					else
-					{
-						for (CLLNode<TradeData>* pNode = pLoopDeal->getFirstTrades()->head(); pNode; pNode = pLoopDeal->getFirstTrades()->next(pNode))
-						{
-							if (getTradeDenial(ePlayer, pNode->m_data) != NO_DENIAL)
-							{
-								bCancelDeal = true;
-								break;
-							}
-						}
-					}
-				}
-				else if ((pLoopDeal->getFirstPlayer() == ePlayer) && (pLoopDeal->getSecondPlayer() == getID()))
-				{
-					if (kPlayer.isHuman())
-					{
-						if (!AI_considerOffer(ePlayer, pLoopDeal->getFirstTrades(), pLoopDeal->getSecondTrades(), -1))
-						{
-							bCancelDeal = true;
-						}
-					}
-					else
-					{
-						for (CLLNode<TradeData>* pNode = pLoopDeal->getSecondTrades()->head(); pNode; pNode = pLoopDeal->getSecondTrades()->next(pNode))
-						{
-							if (getTradeDenial(ePlayer, pNode->m_data) != NO_DENIAL)
-							{
-								bCancelDeal = true;
-								break;
-							}
-						}
-					}
-				}
-
-				if (bCancelDeal)
-				{
-					if (canContact(ePlayer) && AI_isWillingToTalk(ePlayer))
-					{
-						if (kPlayer.isHuman())
-						{
-							CLinkList<TradeData> ourList;
-							CLinkList<TradeData> theirList;
-
-							for (CLLNode<TradeData>* pNode = pLoopDeal->headFirstTradesNode(); (pNode != NULL); pNode = pLoopDeal->nextFirstTradesNode(pNode))
-							{
-								if (pLoopDeal->getFirstPlayer() == getID())
-								{
-									ourList.insertAtEnd(pNode->m_data);
-								}
-								else
-								{
-									theirList.insertAtEnd(pNode->m_data);
-								}
-							}
-
-							for (pNode = pLoopDeal->headSecondTradesNode(); (pNode != NULL); pNode = pLoopDeal->nextSecondTradesNode(pNode))
-							{
-								if (pLoopDeal->getSecondPlayer() == getID())
-								{
-									ourList.insertAtEnd(pNode->m_data);
-								}
-								else
-								{
-									theirList.insertAtEnd(pNode->m_data);
-								}
-							}
-
-							CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-							pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_CANCEL_DEAL"));
-							pDiplo->setAIContact(true);
-							pDiplo->setOurOfferList(theirList);
-							pDiplo->setTheirOfferList(ourList);
-							gDLL->beginDiplomacy(pDiplo, ePlayer);
-						}
-					}
-
-					pLoopDeal->kill(true, getTeam()); // XXX test this for AI...
-					bKilled = true;
-				}
-			}
-		}
-	}
-
-	return bKilled;
-}
-
-
-
-bool CvPlayerAI::AI_doDiploOfferCity(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (AI_getAttitude(ePlayer) < ATTITUDE_CAUTIOUS)
-	{
-		return false;
-	}
-	///Tks Med
-	if (GET_PLAYER(getID()).getVassalOwner() != NO_PLAYER)
-	{
-	    return false;
-	}
-	///Tke
-	bool bOffered = false;
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity->getPreviousOwner() != ePlayer)
-		{
-			if (((pLoopCity->getGameTurnAcquired() + 4) % 20) == (GC.getGameINLINE().getGameTurn() % 20))
-			{
-				int iCount = 0;
-				int iPossibleCount = 0;
-
-				for (int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)
-				{
-					CvPlot* pLoopPlot = plotCity(pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE(), iJ);
-
-					if (pLoopPlot != NULL)
-					{
-						if (pLoopPlot->getOwnerINLINE() == ePlayer)
-						{
-							++iCount;
-						}
-
-						++iPossibleCount;
-					}
-				}
-
-				if (iCount >= (iPossibleCount / 2))
-				{
-					TradeData item;
-					setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
-
-					if (canTradeItem((ePlayer), item, true))
-					{
-						CLinkList<TradeData> ourList;
-						ourList.insertAtEnd(item);
-
-						if (kPlayer.isHuman())
-						{
-							CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-							pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_CITY"));
-							pDiplo->setAIContact(true);
-							pDiplo->setTheirOfferList(ourList);
-							gDLL->beginDiplomacy(pDiplo, ePlayer);
-						}
-						else
-						{
-							GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, NULL);
-						}
-						bOffered = true;
-					}
-				}
-			}
-		}
-	}
-
-	return bOffered;
-}
-
-
-bool CvPlayerAI::AI_doDiploOfferAlliance(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (kPlayer.getParent() == getID())
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer((ePlayer), CONTACT_PERMANENT_ALLIANCE) > 0)
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_PERMANENT_ALLIANCE), "AI Diplo Alliance") != 0)
-	{
-		return false;
-	}
-
-	bool bOffered = false;
-	TradeData item;
-	setTradeItem(&item, TRADE_PERMANENT_ALLIANCE, 0, NULL);
-
-	if (canTradeItem((ePlayer), item, true) && kPlayer.canTradeItem(getID(), item, true))
-	{
-		CLinkList<TradeData> ourList;
-		CLinkList<TradeData> theirList;
-		ourList.insertAtEnd(item);
-		theirList.insertAtEnd(item);
-
-		bOffered = true;
-
-		if (kPlayer.isHuman())
-		{
-			AI_changeContactTimer(ePlayer, CONTACT_PERMANENT_ALLIANCE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_PERMANENT_ALLIANCE));
-			CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-			FAssertMsg(pDiplo != NULL, "pDiplo must be valid");
-			pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
-			pDiplo->setAIContact(true);
-			pDiplo->setOurOfferList(theirList);
-			pDiplo->setTheirOfferList(ourList);
-			gDLL->beginDiplomacy(pDiplo, ePlayer);
-		}
-		else
-		{
-			GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
-		}
-	}
-
-	return bOffered;
-}
-
-
-bool CvPlayerAI::AI_doDiploAskJoinWar(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (!kPlayer.isHuman())
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if ((AI_getMemoryCount(ePlayer, MEMORY_DECLARED_WAR) > 0) || (AI_getMemoryCount(ePlayer, MEMORY_HIRED_WAR_ALLY) > 0))
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer(ePlayer, CONTACT_JOIN_WAR) > 0)
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_JOIN_WAR), "AI Diplo Join War") != 0)
-	{
-		return false;
-	}
-
-	int iBestValue = 0;
-	TeamTypes eBestTeam = NO_TEAM;
-	for (int iJ = 0; iJ < MAX_TEAMS; ++iJ)
-	{
-		TeamTypes eLoopTeam = (TeamTypes) iJ;
-		CvTeam& kLoopTeam = GET_TEAM(eLoopTeam);
-		if (kLoopTeam.isAlive())
-		{
-			if (atWar(eLoopTeam, getTeam()) && !atWar(eLoopTeam, kPlayer.getTeam()))
-			{
-				if (GET_TEAM(kPlayer.getTeam()).isHasMet(eLoopTeam))
-				{
-					if (GET_TEAM(kPlayer.getTeam()).canDeclareWar(eLoopTeam))
-					{
-						int iValue = (1 + GC.getGameINLINE().getSorenRandNum(10000, "AI Joining War"));
-
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							eBestTeam = eLoopTeam;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (eBestTeam == NO_TEAM)
-	{
-		return false;
-	}
-
-	AI_changeContactTimer(ePlayer, CONTACT_JOIN_WAR, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_JOIN_WAR));
-	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_JOIN_WAR"));
-	pDiplo->addDiploCommentVariable(GET_PLAYER(GET_TEAM(eBestTeam).getLeaderID()).getCivilizationAdjectiveKey());
-	pDiplo->setAIContact(true);
-	pDiplo->setData(eBestTeam);
-	gDLL->beginDiplomacy(pDiplo, ePlayer);
-
-	return true;
-}
-
-bool CvPlayerAI::AI_doDiploAskStopTrading(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (!kPlayer.isHuman())
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer((ePlayer), CONTACT_STOP_TRADING) > 0)
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_STOP_TRADING), "AI Diplo Stop Trading") != 0)
-	{
-		return false;
-	}
-
-	TeamTypes eBestTeam = GET_TEAM(getTeam()).AI_getWorstEnemy();
-	if (eBestTeam == NO_TEAM)
-	{
-		return false;
-	}
-
-	if (!GET_TEAM(kPlayer.getTeam()).isHasMet(eBestTeam))
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).isParentOf(eBestTeam) && !::atWar(getTeam(), eBestTeam))
-	{
-		return false;
-	}
-
-	if (!kPlayer.canStopTradingWithTeam(eBestTeam))
-	{
-		return false;
-	}
-
-	FAssert(!atWar(kPlayer.getTeam(), eBestTeam));
-	FAssert(kPlayer.getTeam() != eBestTeam);
-
-	AI_changeContactTimer(ePlayer, CONTACT_STOP_TRADING, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_STOP_TRADING));
-	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_STOP_TRADING"));
-	pDiplo->addDiploCommentVariable(GET_PLAYER(GET_TEAM(eBestTeam).getLeaderID()).getCivilizationAdjectiveKey());
-	pDiplo->setAIContact(true);
-	pDiplo->setData(eBestTeam);
-	gDLL->beginDiplomacy(pDiplo, ePlayer);
-
-	return true;
-}
-
-bool CvPlayerAI::AI_doDiploGiveHelp(PlayerTypes ePlayer)
-									{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (!kPlayer.isHuman())
-	{
-		return false;
-	}
-
-	if (isNative())
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (AI_getAttitude(ePlayer) <= GC.getLeaderHeadInfo(kPlayer.getPersonalityType()).getNoGiveHelpAttitudeThreshold())
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer((ePlayer), CONTACT_GIVE_HELP) > 0)
-	{
-		return false;
-	}
-
-	if (GET_TEAM(kPlayer.getTeam()).getAssets() > GET_TEAM(getTeam()).getAssets() / 2)
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_GIVE_HELP), "AI Diplo Give Help") != 0)
-	{
-		return false;
-	}
-
-	int iGold = AI_maxGoldTrade(ePlayer);
-	if (iGold <= 0)
-	{
-		return false;
-	}
-
-	TradeData item;
-	setTradeItem(&item, TRADE_GOLD, iGold, NULL);
-	if (!canTradeItem(ePlayer, item, true))
-	{
-		return false;
-	}
-
-	CLinkList<TradeData> ourList;
-	ourList.insertAtEnd(item);
-
-	AI_changeContactTimer((ePlayer), CONTACT_GIVE_HELP, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_GIVE_HELP));
-	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_GIVE_HELP"));
-	pDiplo->setTheirOfferList(ourList);
-	pDiplo->setAIContact(true);
-	gDLL->beginDiplomacy(pDiplo, ePlayer);
-
-	return true;
-}
-
-
-bool CvPlayerAI::AI_doDiploAskForHelp(PlayerTypes ePlayer)
-									{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (!kPlayer.isHuman())
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer((ePlayer), CONTACT_ASK_FOR_HELP) > 0)
-	{
-		return false;
-	}
-
-	if (GET_TEAM(kPlayer.getTeam()).getAssets() <= GET_TEAM(getTeam()).getAssets() / 2)
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_ASK_FOR_HELP), "AI Diplo Ask for Help") != 0)
-	{
-		return false;
-	}
-
-	int iGold = kPlayer.AI_maxGoldTrade(getID()) * GC.getGameINLINE().getSorenRandNum(100, "Ask for gold percent") / 100;
-	if (iGold <= 0)
-	{
-		return false;
-	}
-
-	TradeData item;
-	setTradeItem(&item, TRADE_GOLD, iGold, NULL);
-	if (!canTradeItem(ePlayer, item, true))
-	{
-		return false;
-	}
-
-	CLinkList<TradeData> theirList;
-	theirList.insertAtEnd(item);
-
-	AI_changeContactTimer((ePlayer), CONTACT_GIVE_HELP, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_GIVE_HELP));
-	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_ASK_FOR_HELP"));
-	pDiplo->setOurOfferList(theirList);
-	pDiplo->setAIContact(true);
-	gDLL->beginDiplomacy(pDiplo, ePlayer);
-
-	return true;
-}
-
-
-bool CvPlayerAI::AI_doDiploDemandTribute(PlayerTypes ePlayer)
-{
-	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
-
-	if (!kPlayer.isHuman())
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (!GET_TEAM(getTeam()).canDeclareWar(kPlayer.getTeam()))
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).AI_isSneakAttackPreparing(kPlayer.getTeam()))
-	{
-		return false;
-	}
-
-	if (GET_TEAM(kPlayer.getTeam()).getDefensivePower() >= GET_TEAM(getTeam()).getPower())
-	{
-		return false;
-	}
-
-	if (AI_getAttitude(ePlayer) > GC.getLeaderHeadInfo(kPlayer.getPersonalityType()).getDemandTributeAttitudeThreshold())
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE) > 0)
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEMAND_TRIBUTE), "AI Diplo Demand Tribute") != 0)
-	{
-		return false;
-	}
-
-	TradeData item;
-	int iReceiveGold = std::min(std::max(0, (kPlayer.getGold() - 50)), kPlayer.AI_goldTarget());
-	iReceiveGold -= (iReceiveGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-	if (iReceiveGold > 50)
-	{
-		setTradeItem(&item, TRADE_GOLD, iReceiveGold, NULL);
-	}
-	else if (GET_TEAM(getTeam()).AI_mapTradeVal(kPlayer.getTeam()) > 100)
-	{
-		setTradeItem(&item, TRADE_MAPS, 0, NULL);
-	}
-
-	if (!canTradeItem(ePlayer, item, true))
-	{
-		return false;
-	}
-
-	CLinkList<TradeData> theirList;
-	theirList.insertAtEnd(item);
-
-	AI_changeContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEMAND_TRIBUTE));
-	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_DEMAND_TRIBUTE"));
-	pDiplo->setAIContact(true);
-	pDiplo->setOurOfferList(theirList);
-	gDLL->beginDiplomacy(pDiplo, ePlayer);
-
-	return true;
-}
-
-bool CvPlayerAI::AI_doDiploKissPinky(PlayerTypes ePlayer)
-{
-	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
-
-	if (!kPlayer.isHuman())
-	{
-		return false;
-	}
-
-	if (GC.getEraInfo(kPlayer.getCurrentEra()).isRevolution())
-	{
-		return false;
-	}
-
-	if (kPlayer.getNumCities() == 0)
-	{
-		return false;
-	}
-
-	if (kPlayer.getParent() != getID())
-	{
-		return false;
-	}
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-///Tks Med
-	bool bTesting = gDLL->ctrlKey() && gDLL->getChtLvl() > 0;
-	//bool bTesting = false;
-	if (AI_getContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE) > 0)
-	{
-		return false;
-	}
-	if (!kPlayer.isFeatAccomplished(FEAT_CITY_NO_FOOD))
-	{
-	    return false;
-	}
-
-
-	//if (AI_getMemoryCount(ePlayer, MEMORY_REFUSED_TAX)) ATTITUDE_ANNOYED
-	if (kPlayer.isHuman() && GC.getLeaderHeadInfo(kPlayer.getLeaderType()).getVictoryType() == 1)
-    {
-
-        if (AI_getAttitude(ePlayer, false) <= ATTITUDE_ANNOYED)
-        {
-            if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEMAND_TRIBUTE), "AI Diplo Upset At You") <= 2 || bTesting)
-            {
-                int iMaxGoldPercent = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIDeclareWarProb() * kPlayer.AI_maxGoldTrade(getID()) / 100;
-                int iReceiveGold = iMaxGoldPercent * GC.getGameINLINE().getSorenRandNum(100, "Ask for tithe gold percent") / 100;
-
-                iReceiveGold -= (iReceiveGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-                //iReceiveGold += iMaxGoldPercent * 50 / 100;
-                if (iReceiveGold <= 0)
-                {
-                    return false;
-                }
-                AI_changeContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEMAND_TRIBUTE));
-                CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-                pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_KING_ASK_FOR_GOLD_OR_ELSE"));
-                pDiplo->addDiploCommentVariable(iReceiveGold);
-                pDiplo->setData(iReceiveGold);
-                pDiplo->setAIContact(true);
-                gDLL->beginDiplomacy(pDiplo, ePlayer);
-
-                return true;
-            }
-        }
-        else if (bTesting)
-        {
-            AI_changeMemoryCount(ePlayer, MEMORY_REFUSED_TAX, 1);
-        }
-    }
-    ///tke
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEMAND_TRIBUTE), "AI Diplo Kiss Pinky") != 0)
-	{
-		return false;
-	}
-
-	int iMaxGoldPercent = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIDeclareWarProb() * kPlayer.AI_maxGoldTrade(getID()) / 100;
-	int iReceiveGold = iMaxGoldPercent * GC.getGameINLINE().getSorenRandNum(100, "Ask for pinky gold percent") / 100;
-	iReceiveGold -= (iReceiveGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
-	if (iReceiveGold <= 0)
-	{
-		return false;
-	}
-
-	AI_changeContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEMAND_TRIBUTE));
-
-	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_KING_ASK_FOR_GOLD"));
-	pDiplo->addDiploCommentVariable(iReceiveGold);
-	pDiplo->setData(iReceiveGold);
-	pDiplo->setAIContact(true);
-	gDLL->beginDiplomacy(pDiplo, ePlayer);
-
-	return true;
-}
-
-bool CvPlayerAI::AI_doDiploOpenBorders(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (getNumCities() == 0)
-	{
-		return false;
-	}
-
-	if (kPlayer.getNumCities() == 0)
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer(ePlayer, CONTACT_OPEN_BORDERS) > 0)
-											{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_OPEN_BORDERS), "AI Diplo Open Borders") != 0)
-	{
-		return false;
-	}
-
-	TradeData item;
-	setTradeItem(&item, TRADE_OPEN_BORDERS, 0, NULL);
-
-	if (!canTradeItem(ePlayer, item, true) || !kPlayer.canTradeItem(getID(), item, true))
-	{
-		return false;
-	}
-
-	CLinkList<TradeData> theirList;
-	theirList.insertAtEnd(item);
-	CLinkList<TradeData> ourList;
-	ourList.insertAtEnd(item);
-
-	if (kPlayer.isHuman())
-	{
-		AI_changeContactTimer(ePlayer, CONTACT_OPEN_BORDERS, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_OPEN_BORDERS));
-		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
-		pDiplo->setAIContact(true);
-		pDiplo->setOurOfferList(theirList);
-		pDiplo->setTheirOfferList(ourList);
-		gDLL->beginDiplomacy(pDiplo, ePlayer);
-	}
-	else
-	{
-		GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
-	}
-
-	return true;
-}
-
-///TKs Med
-//int CvPlayerAI::AI_getInsultedAttitude(PlayerTypes ePlayer)
-//{
-//	return m_aiInsultedAttitudeCache[ePlayer];
-//}
-//void CvPlayerAI::AI_changeInsultedAttitude(PlayerTypes ePlayer, int Change)
-//{
-//    m_aiInsultedAttitudeCache[ePlayer] += Change;
-//}
-///TKs Invention Core Mod v 1.0
-bool CvPlayerAI::AI_doDiploCollaborateResearch(PlayerTypes ePlayer)
-{
-    return false;
-}
-bool CvPlayerAI::AI_doDiploTradeResearch(PlayerTypes ePlayer)
-{
-    CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-    if (kPlayer.getParent() == getID())
-	{
-		return false;
-	}
-
-	if (isEurope())
-	{
-		return false;
-	}
-
-//	if (isNative())
-//	{
-//	    return false;
-//	}
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (getNumCities() == 0)
-	{
-		return false;
-	}
-
-	if (kPlayer.getNumCities() == 0)
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer(ePlayer, CONTACT_TRADE_IDEAS) > 0)
-    {
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_TRADE_IDEAS), "AI Diplo Tech Trade") != 0)
-	{
-		return false;
-	}
-
-
-
-    if (isNative())
-    {
-        if (kPlayer.isNative())
-        {
-            return false;
-        }
-    }
-    //char szOut[1024];
-//    if (kPlayer.isHuman())
-//    {
-//
-//        sprintf(szOut, "######################## Player %d %S check 1 for trade\n", getID(), getNameKey());
-//        gDLL->messageControlLog(szOut);
-//    }
-
-    int iCivic = getIdea(false, ePlayer);
-	if (iCivic == -1)
-	{
-//	    sprintf(szOut, "######################## No Idea FOund\n");
-//        gDLL->messageControlLog(szOut);
-	    return false;
-	}
-
-	TradeData myitem;
-	setTradeItem(&myitem, TRADE_IDEAS, iCivic, NULL);
-	if (!canTradeItem(ePlayer, myitem, true))
-	{
-	    if (kPlayer.isHuman())
-        {
-//            sprintf(szOut, "######################## Player %d Can not Trade\n", ePlayer);
-//            gDLL->messageControlLog(szOut);
-            return false;
-        }
-	}
-
-	TradeData thereitem;
-
-    if (isNative())
-    {
-        int iGold = GC.getCache_TK_RESEARCH_TRADE_VALUE() + GC.getCivicInfo((CivicTypes)iCivic).getAIWeight();
-        setTradeItem(&thereitem, TRADE_GOLD, iGold, NULL);
-        if (!kPlayer.canTradeItem(getID(), thereitem, true))
-        {
-            return false;
-        }
-    }
-    else
-    {
-        /// THEIR TRADE
-        iCivic = kPlayer.getIdea(false, getID());
-        if (iCivic == -1)
-        {
-//            sprintf(szOut, "######################## No There Idea FOund\n");
-//            gDLL->messageControlLog(szOut);
-            return false;
-        }
-        setTradeItem(&thereitem, TRADE_IDEAS, iCivic, NULL);
-        if (!kPlayer.canTradeItem(getID(), thereitem, true))
-        {
-//            sprintf(szOut, "######################## Can There not Trade\n");
-//            gDLL->messageControlLog(szOut);
-            return false;
-        }
-    }
-
-	CLinkList<TradeData> theirList;
-	theirList.insertAtEnd(thereitem);
-	CLinkList<TradeData> ourList;
-	ourList.insertAtEnd(myitem);
-
-	if (kPlayer.isHuman())
-	{
-		AI_changeContactTimer(ePlayer, CONTACT_TRADE_IDEAS, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_TRADE_IDEAS));
-		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
-		pDiplo->setAIContact(true);
-		pDiplo->setOurOfferList(theirList);
-		pDiplo->setTheirOfferList(ourList);
-		gDLL->beginDiplomacy(pDiplo, ePlayer);
-	}
-	else
-	{
-		GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
-	}
-
-	return true;
-}
-///TKe
-
-bool CvPlayerAI::AI_doDiploDefensivePact(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (GET_TEAM(getTeam()).getLeaderID() != getID())
-	{
-		return false;
-	}
-
-	if (kPlayer.getParent() == getID())
-	{
-		return false;
-	}
-
-	if (isEurope())
-	{
-		return false;
-	}
-
-	if (AI_getContactTimer(ePlayer, CONTACT_DEFENSIVE_PACT) > 0)
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEFENSIVE_PACT), "AI Diplo Defensive Pact") != 0)
-	{
-		return false;
-	}
-
-	TradeData item;
-	setTradeItem(&item, TRADE_DEFENSIVE_PACT, 0, NULL);
-
-	if (!canTradeItem(ePlayer, item, true) || !kPlayer.canTradeItem(getID(), item, true))
-	{
-		return false;
-	}
-
-	CLinkList<TradeData> theirList;
-	theirList.insertAtEnd(item);
-	CLinkList<TradeData> ourList;
-	ourList.insertAtEnd(item);
-
-	if (kPlayer.isHuman())
-	{
-		AI_changeContactTimer(ePlayer, CONTACT_DEFENSIVE_PACT, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEFENSIVE_PACT));
-		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
-		pDiplo->setAIContact(true);
-		pDiplo->setOurOfferList(theirList);
-		pDiplo->setTheirOfferList(ourList);
-		gDLL->beginDiplomacy(pDiplo, ePlayer);
-	}
-	else
-	{
-		GC.getGameINLINE().implementDeal(getID(), ePlayer, &ourList, &theirList);
-	}
-
-	return true;
-}
-
-bool CvPlayerAI::AI_doDiploTradeMap(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (AI_getContactTimer(ePlayer, CONTACT_TRADE_MAP) > 0)
-	{
-		return false;
-	}
-
-	if (isEurope())
-	{
-		return false;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_TRADE_MAP), "AI Diplo Trade Map") != 0)
-	{
-		return false;
-	}
-
-	TradeData item;
-	setTradeItem(&item, TRADE_MAPS, 0, NULL);
-
-	if (!kPlayer.canTradeItem(getID(), item, true) || !canTradeItem(ePlayer, item, true))
-	{
-		return false;
-	}
-
-	if (kPlayer.isHuman() && GET_TEAM(getTeam()).AI_mapTradeVal(kPlayer.getTeam()) < GET_TEAM(kPlayer.getTeam()).AI_mapTradeVal(getTeam()))
-	{
-		return false;
-	}
-
-	CLinkList<TradeData> theirList;
-	theirList.insertAtEnd(item);
-	CLinkList<TradeData> ourList;
-	ourList.insertAtEnd(item);
-
-	if (kPlayer.isHuman())
-	{
-		AI_changeContactTimer((ePlayer), CONTACT_TRADE_MAP, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_TRADE_MAP));
-		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
-		pDiplo->setAIContact(true);
-		pDiplo->setOurOfferList(theirList);
-		pDiplo->setTheirOfferList(ourList);
-		gDLL->beginDiplomacy(pDiplo, ePlayer);
-	}
-	else
-	{
-		GC.getGameINLINE().implementDeal(getID(), ePlayer, &ourList, &theirList);
-	}
-
-	return true;
-}
-
-bool CvPlayerAI::AI_doDiploDeclareWar(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	int iDeclareWarTradeRand = GC.getLeaderHeadInfo(getPersonalityType()).getDeclareWarTradeRand();
-	int iMinAtWarCounter = MAX_INT;
-	for (int iJ = 0; iJ < MAX_TEAMS; iJ++)
-	{
-		if (GET_TEAM((TeamTypes)iJ).isAlive())
-		{
-			if (atWar(((TeamTypes)iJ), getTeam()))
-			{
-				int iAtWarCounter = GET_TEAM(getTeam()).AI_getAtWarCounter((TeamTypes)iJ);
-				if (GET_TEAM(getTeam()).AI_getWarPlan((TeamTypes)iJ) == WARPLAN_DOGPILE)
-				{
-					iAtWarCounter *= 2;
-					iAtWarCounter += 5;
-				}
-				iMinAtWarCounter = std::min(iAtWarCounter, iMinAtWarCounter);
-			}
-		}
-	}
-
-	if (iMinAtWarCounter < 10)
-	{
-		iDeclareWarTradeRand *= iMinAtWarCounter;
-		iDeclareWarTradeRand /= 10;
-		iDeclareWarTradeRand ++;
-	}
-
-	if (iMinAtWarCounter < 4)
-	{
-		iDeclareWarTradeRand /= 4;
-		iDeclareWarTradeRand ++;
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(iDeclareWarTradeRand, "AI Diplo Declare War Trade") != 0)
-	{
-		return false;
-	}
-
-	int iGoldValuePercent = AI_goldTradeValuePercent();
-
-	int iBestValue = 0;
-	TeamTypes eBestTeam = NO_TEAM;
-	for (int iJ = 0; iJ < MAX_TEAMS; iJ++)
-	{
-		if (GET_TEAM((TeamTypes)iJ).isAlive())
-		{
-			if (atWar(((TeamTypes) iJ), getTeam()) && !atWar(((TeamTypes) iJ), kPlayer.getTeam()))
-			{
-				if (GET_TEAM((TeamTypes)iJ).getAtWarCount() < std::max(2, (GC.getGameINLINE().countCivTeamsAlive() / 2)))
-				{
-					TradeData item;
-					setTradeItem(&item, TRADE_WAR, iJ, NULL);
-
-					if (kPlayer.canTradeItem(getID(), item, true))
-					{
-						int iValue = (1 + GC.getGameINLINE().getSorenRandNum(1000, "AI Declare War Trading"));
-
-						iValue *= (101 + GET_TEAM((TeamTypes)iJ).AI_getAttitudeWeight(getTeam()));
-						iValue /= 100;
-
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							eBestTeam = ((TeamTypes)iJ);
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (eBestTeam == NO_TEAM)
-	{
-		return false;
-	}
-
-	iBestValue = 0;
-	int iOurValue = GET_TEAM(getTeam()).AI_declareWarTradeVal(eBestTeam, kPlayer.getTeam());
-	int iTheirValue = 0;
-	int iReceiveGold = 0;
-	int iGiveGold = 0;
-
-	if (iTheirValue > iOurValue)
-	{
-		int iGold = std::min(((iTheirValue - iOurValue) * 100) / iGoldValuePercent, kPlayer.AI_maxGoldTrade(getID()));
-
-		if (iGold > 0)
-		{
-			TradeData item;
-			setTradeItem(&item, TRADE_GOLD, iGold, NULL);
-
-			if (kPlayer.canTradeItem(getID(), item, true))
-			{
-				iReceiveGold = iGold;
-				iOurValue += (iGold * iGoldValuePercent) / 100;
-			}
-		}
-	}
-	else if (iOurValue > iTheirValue)
-	{
-		int iGold = std::min(((iOurValue - iTheirValue) * 100) / iGoldValuePercent, AI_maxGoldTrade(ePlayer));
-
-		if (iGold > 0)
-		{
-			TradeData item;
-			setTradeItem(&item, TRADE_GOLD, iGold, NULL);
-
-			if (canTradeItem((ePlayer), item, true))
-			{
-				iGiveGold = iGold;
-				iTheirValue += (iGold * iGoldValuePercent) / 100;
-			}
-		}
-	}
-
-	if (iTheirValue <= (iOurValue * 3 / 4))
-	{
-		return false;
-	}
-
-	CLinkList<TradeData> theirList;
-	CLinkList<TradeData> ourList;
-
-	TradeData item;
-	setTradeItem(&item, TRADE_WAR, eBestTeam, NULL);
-	theirList.insertAtEnd(item);
-
-	if (iGiveGold != 0)
-	{
-		setTradeItem(&item, TRADE_GOLD, iGiveGold, NULL);
-		ourList.insertAtEnd(item);
-	}
-
-	if (iReceiveGold != 0)
-	{
-		setTradeItem(&item, TRADE_GOLD, iReceiveGold, NULL);
-		theirList.insertAtEnd(item);
-	}
-
-	GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
-
-	return true;
-}
-
-
-//Convert units from city population to map units (such as pioneers)
-void CvPlayerAI::AI_doProfessions()
-{
-
-	std::map<int, bool> cityDanger;
-
-	{
-		int iLoop;
-		CvCity* pLoopCity;
-		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-		{
-			cityDanger[pLoopCity->getID()] = AI_getPlotDanger(pLoopCity->plot(), 5, true);
-		}
-	}
-
-	for (int iI = 0; iI < NUM_UNITAI_TYPES; ++iI)
-	{
-		UnitAITypes eUnitAI = (UnitAITypes)iI;
-
-		int iPriority = 0;
-
-		if ((AI_unitAIValueMultipler(eUnitAI) > 0) && eUnitAI != UNITAI_DEFENSIVE)
-		{
-			ProfessionTypes eProfession = AI_idealProfessionForUnitAIType(eUnitAI);
-
-			if ((eProfession != NO_PROFESSION) && (eUnitAI == UNITAI_SETTLER || (eProfession != (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession())))
-			{
-				CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-
-				bool bDone = false;
-
-				int iLoop;
-				CvCity* pLoopCity;
-
-				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-				{
-					if (pLoopCity->getPopulation() > ((pLoopCity->getHighestPopulation() * 2) / 3))
-					{
-						if (!cityDanger[pLoopCity->getID()] || AI_unitAIIsCombat(eUnitAI))
-						{
-							for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-							{
-								CvUnit* pUnit = pLoopCity->getPopulationUnitByIndex(i);
-								if (pUnit != NULL)
-								{
-									ProfessionTypes eIdealProfession = AI_idealProfessionForUnit(pUnit->getUnitType());
-									if (eIdealProfession == NO_PROFESSION || pUnit->getProfession() != eIdealProfession)
-									{
-										if (pUnit->canHaveProfession(eProfession, false) && (AI_professionSuitability(pUnit, eProfession, pLoopCity->plot()) > 100))
-										{
-											pLoopCity->removePopulationUnit(pUnit, false, eProfession);
-											pUnit->AI_setUnitAIType(eUnitAI);
-											bDone = true;
-											break;
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-
-				if (!bDone)
-				{
-					for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-					{
-						int iBestValue = 0;
-						CvUnit* pBestUnit = NULL;
-
-						if (!cityDanger[pLoopCity->getID()] || AI_unitAIIsCombat(eUnitAI))
-						{
-							if (pLoopCity->getPopulation() > ((pLoopCity->getHighestPopulation() * 2) / 3))
-							{
-								for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-								{
-									CvUnit* pUnit = pLoopCity->getPopulationUnitByIndex(i);
-									if (pUnit != NULL)
-									{
-										if (pUnit->canHaveProfession(eProfession, false))
-										{
-											int iValue = AI_professionSuitability(pUnit, eProfession, pLoopCity->plot());
-
-											if (pUnit->getProfession() == NO_PROFESSION)
-											{
-
-											}
-											else if (pUnit->getProfession() == pUnit->AI_getIdealProfession())
-											{
-												iValue /= 4;
-											}
-
-											if (eUnitAI == UNITAI_SETTLER)
-											{
-												if (pUnit->AI_getIdealProfession() != NO_PROFESSION)
-												{
-													if ((pUnit->getProfession() != pUnit->AI_getIdealProfession()) && (GC.getProfessionInfo(pUnit->AI_getIdealProfession()).isWorkPlot()))
-													{
-														iValue *= 150;
-														iValue /= 100;
-													}
-												}
-												else
-												{
-													iValue *= 120;
-													iValue /= 100;
-												}
-											}
-
-											iValue *= 100;
-											iValue += GC.getGameINLINE().getSorenRandNum(100, "AI pick unit");
-
-											if (iValue > iBestValue)
-											{
-												iBestValue = iValue;
-												pBestUnit = pUnit;
-											}
-										}
-									}
-								}
-							}
-						}
-						if (pBestUnit != NULL)
-						{
-							pLoopCity->removePopulationUnit(pBestUnit, false, eProfession);
-							pBestUnit->AI_setUnitAIType(eUnitAI);
-						}
-					}
-				}
-			}
-		}
-	}
-
-	//Military
-	int iLoop;
-	CvCity* pLoopCity;
-
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity->AI_isDanger())
-		{
-			ProfessionTypes eProfession = AI_idealProfessionForUnitAIType(UNITAI_DEFENSIVE, pLoopCity);
-
-			if ((eProfession != NO_PROFESSION) && (eProfession != (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()))
-			{
-				CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-				bool bDone = false;
-
-				int iNeededDefenders = pLoopCity->AI_neededDefenders();
-				int iHaveDefenders = pLoopCity->AI_numDefenders(true, false);
-
-				if (iHaveDefenders < iNeededDefenders)
-				{
-					while (!bDone)
-					{
-						int iBestValue = 0;
-						CvUnit* pBestUnit = NULL;
-
-						for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-						{
-							CvUnit* pUnit = pLoopCity->getPopulationUnitByIndex(i);
-							if (pUnit != NULL)
-							{
-								if (pUnit->canHaveProfession(eProfession, false))
-								{
-									int iValue = AI_professionSuitability(pUnit, eProfession, pLoopCity->plot());
-
-									if (pUnit->getProfession() == NO_PROFESSION)
-									{
-
-									}
-									else if (pUnit->getProfession() == pUnit->AI_getIdealProfession())
-									{
-										iValue /= 4;
-									}
-
-									iValue *= 100;
-									iValue += GC.getGameINLINE().getSorenRandNum(100, "AI pick unit");
-
-									if (iValue > iBestValue)
-									{
-										iBestValue = iValue;
-										pBestUnit = pUnit;
-									}
-								}
-							}
-						}
-
-						if (pBestUnit != NULL)
-						{
-							pLoopCity->removePopulationUnit(pBestUnit, false, eProfession);
-							pBestUnit->AI_setUnitAIType(UNITAI_DEFENSIVE);
-						}
-						else
-						{
-							bDone = true;
-						}
-					}
-				}
-			}
-		}
-	}
-
-}
-
-void CvPlayerAI::AI_doEurope()
-{
-	//Buy Units.
-	UnitTypes eBuyUnit;
-	UnitAITypes eBuyUnitAI;
-	int iBuyUnitValue;
-
-	if (!canTradeWithEurope())
-	{
-		return;
-	}
-
-	if (!isHuman() && !isNative() && !isEurope())
-	{
-		//Always refresh at start of new turn (maybe do this smarter but it's okay for now)
-		AI_updateNextBuyUnit();
-		AI_updateNextBuyProfession();
-	}
-
-
-	eBuyUnit = AI_nextBuyUnit(&eBuyUnitAI, &iBuyUnitValue);
-
-	UnitTypes eBuyProfessionUnit;
-	ProfessionTypes eBuyProfession;
-	UnitAITypes eBuyProfessionAI;
-	int iBuyProfessionValue;
-
-	eBuyProfessionUnit = AI_nextBuyProfessionUnit(&eBuyProfession, &eBuyProfessionAI, &iBuyProfessionValue);
-
-	int iUnitPrice = 0;
-
-	if (eBuyUnit != NO_UNIT)
-	{
-		iUnitPrice = getEuropeUnitBuyPrice(eBuyUnit);
-	}
-
-	if ((eBuyUnit != NO_UNIT) && ((iBuyUnitValue > iBuyProfessionValue) || (iUnitPrice < getGold())))
-	{
-		if (getGold() > iUnitPrice)
-		{
-			CvUnit* pUnit = buyEuropeUnit(eBuyUnit, 100);
-
-			FAssert(pUnit != NULL);
-			pUnit->AI_setUnitAIType(eBuyUnitAI);
-
-			AI_updateNextBuyUnit();
-		}
-	}
-
-	if ((eBuyProfession != NO_PROFESSION) && (iBuyProfessionValue > iBuyUnitValue))
-	{
-		ProfessionTypes eDefaultProfession = (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession();
-
-		int iBestValue = 0;
-		CvUnit* pBestUnit = NULL;
-
-		int iBuyPrice = -1;
-		if (eBuyProfessionUnit != NO_UNIT)
-		{
-			iBuyPrice = getEuropeUnitBuyPrice(eBuyProfessionUnit);
-		}
-
-		CvProfessionInfo& kProfession = GC.getProfessionInfo(eBuyProfession);
-
-		if (!kProfession.isCitizen() && (eBuyProfessionAI != UNITAI_COLONIST))
-		{
-			//Consider upgrading an existing unit.
-			for (int i = 0; i < getNumEuropeUnits(); ++i)
-			{
-				CvUnit* pLoopUnit = getEuropeUnit(i);
-				if (!pLoopUnit->AI_hasAIChanged(4))
-				{
-					if (pLoopUnit->getProfession() == eBuyProfession)
-					{
-						int iValue = 200;
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							pBestUnit = pLoopUnit;
-						}
-					}
-					else
-					{
-						if (pLoopUnit->getProfession() == eDefaultProfession)
-						{
-							if (pLoopUnit->canHaveProfession(eBuyProfession, false))
-							{
-								int iValue = AI_professionSuitability(pLoopUnit, eBuyProfession, NULL);
-
-								bool bValid = true;
-
-								if (eBuyProfessionAI == UNITAI_SCOUT)
-								{
-									if (iValue < 100)
-									{
-										bValid = false;
-									}
-								}
-								if (bValid)
-								{
-									iValue *= 100 + ((iBuyProfessionValue - 100) / 5);
-									iValue /= 100;
-
-									int iMinThreshold = 1;
-
-									if (iValue >= iMinThreshold)
-									{
-										iValue *= 2;
-
-										//XXX Perform Gold Cost of Upgrade Modification.
-										if (iValue > iBestValue)
-										{
-											iBestValue = iValue;
-											pBestUnit = pLoopUnit;
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-
-		if (pBestUnit != NULL)
-		{
-			changeProfessionEurope(pBestUnit->getID(), eBuyProfession);
-			FAssert(pBestUnit->getProfession() == eBuyProfession);
-			pBestUnit->AI_setUnitAIType(eBuyProfessionAI);
-		}
-		else if (eBuyProfessionUnit != NO_UNIT)
-		{
-			FAssert(iBuyPrice >= 0);
-			if (getGold() > iBuyPrice)
-			{
-				CvUnit* pUnit = buyEuropeUnit(eBuyProfessionUnit, 100);
-				pUnit->AI_setUnitAIType(eBuyProfessionAI);
-			}
-		}
-	}
-
-	//arm any europe units that need it
-	for (int i = 0; i < getNumEuropeUnits(); i++)
-	{
-		CvUnit *pUnit = getEuropeUnit(i);
-
-		int iUndefended = 0;
-		int iNeeded = AI_totalDefendersNeeded(&iUndefended);
-		if (iNeeded > 0 || AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-		{
-			ProfessionTypes eBestProfession = NO_PROFESSION;
-			if (GC.getGameINLINE().getSorenRandNum(100, "") < 50)
-			{
-				eBestProfession = GET_PLAYER(pUnit->getOwnerINLINE()).AI_idealProfessionForUnitAIType(UNITAI_DEFENSIVE);
-			}
-			else
-			{
-				eBestProfession = GET_PLAYER(pUnit->getOwnerINLINE()).AI_idealProfessionForUnitAIType(UNITAI_COUNTER);
-			}
-
-			if (eBestProfession != NO_PROFESSION && pUnit->canHaveProfession(eBestProfession, false))
-			{
-				changeProfessionEurope(pUnit->getID(), eBestProfession);
-			}
-		}
-	}
-}
-
-void CvPlayerAI::AI_nativeYieldGift(CvUnit* pUnit)
-{
-	FAssert(pUnit != NULL);
-	FAssert(pUnit->isOnMap());
-	FAssert(pUnit->plot()->isCity());
-	FAssert(isNative());
-
-	CvCity* pHomeCity = pUnit->getHomeCity();
-	if (pHomeCity == NULL)
-	{
-		pHomeCity = GC.getMapINLINE().findCity(pUnit->getX_INLINE(), pUnit->getY_INLINE(), pUnit->getOwnerINLINE());
-		pUnit->setHomeCity(pHomeCity);
-	}
-
-	if (pHomeCity == NULL)
-	{
-		return;
-	}
-
-	YieldTypes eBestYield = NO_YIELD;
-	int iBestValue = 0;
-
-	for(int i=0;i<NUM_YIELD_TYPES;i++)
-	{
-		if (pHomeCity->canProduceYield((YieldTypes)i))
-		{
-		    ///Tks Med
-		    CvPlayer& kPlayer = GET_PLAYER(pUnit->plot()->getPlotCity()->getOwner());
-		    if (!kPlayer.canUnitBeTraded((YieldTypes)i))
-		    {
-		        continue;
-		    }
-			//if ((YIELD_FOOD != i) && (YIELD_HORSES != i))
-			if ((YIELD_FOOD != i) && !GC.isEquipmentType((YieldTypes)i, EQUIPMENT_ARMOR_HORSES))
-			{
-            ///TKe
-				YieldTypes eYield = (YieldTypes) i;
-				if (GC.getYieldInfo(eYield).getNativeSellPrice() > 0)
-				{
-					int iRandValue = 100 + GC.getGameINLINE().getSorenRandNum(900, "Native Yield Gift: pick yield");
-					iRandValue *= pHomeCity->getYieldStored(eYield);
-					if (iRandValue > iBestValue)
-					{
-						eBestYield = eYield;
-						iBestValue = iRandValue;
-					}
-				}
-			}
-		}
-	}
-
-	if (eBestYield == NO_YIELD)
-	{
-		return;
-	}
-
-	CvCity* pOtherCity = pUnit->plot()->getPlotCity();
-	FAssert(pOtherCity != NULL);
-	FAssert(!pOtherCity->isNative());
-
-	if(pOtherCity != NULL)
-	{
-		//give some yields from pBestCity to pOtherCity
-		int iYieldPercent = 5 * (AI_getAttitudeVal(pOtherCity->getOwnerINLINE(), false) + GC.getGameINLINE().getSorenRandNum(10, "Native Yield Gift: pick amount"));
-		int iYieldAmount = iYieldPercent * pHomeCity->getYieldStored(eBestYield) / 100;
-		iYieldAmount = std::min(iYieldAmount, pHomeCity->getYieldStored(eBestYield));
-		iYieldAmount = std::max(iYieldAmount, 0);
-		if(iYieldAmount > 0)
-		{
-			pHomeCity->changeYieldStored(eBestYield, -iYieldAmount);
-			pOtherCity->changeYieldStored(eBestYield, iYieldAmount);
-
-			//AI_changeContactTimer(pOtherCity->getOwnerINLINE(), CONTACT_YIELD_GIFT, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_YIELD_GIFT));
-
-			//popup dialog
-			CvPlayer& kOtherPlayer = GET_PLAYER(pOtherCity->getOwnerINLINE());
-			if(kOtherPlayer.isHuman())
-			{
-				CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-				pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_NATIVES_YIELD_GIFT"));
-				pDiplo->addDiploCommentVariable(iYieldAmount);
-				pDiplo->addDiploCommentVariable(GC.getYieldInfo(eBestYield).getChar());
-				pDiplo->addDiploCommentVariable(pOtherCity->getNameKey());
-				pDiplo->setAIContact(true);
-				gDLL->beginDiplomacy(pDiplo, kOtherPlayer.getID());
-			}
-		}
-	}
-}
-
-bool CvPlayerAI::AI_isYieldForSale(YieldTypes eYield) const
-{
-	if (!GC.getYieldInfo(eYield).isCargo())
-	{
-		return false;
-	}
-
-	switch (eYield)
-	{
-		case YIELD_FOOD:
-		case YIELD_LUMBER:
-		///TK ME start
-		case YIELD_STONE:///NEW*
-		///TKs Invention Core Mod v 1.0
-//        case YIELD_COAL:
-            //break;
-        ///TKe
-        case YIELD_GRAIN:///NEW*
-			return false;
-			break;
-        ///Discoverys Bonus
-//        case YIELD_SILK:///NEW*
-//        case YIELD_PORCELAIN:///NEW*
-        ///Discoverys^
-        ///Food Goods
-	    case YIELD_CATTLE:///NEW*
-	    case YIELD_SHEEP:///NEW*
-        case YIELD_WOOL:///NEW*
-        case YIELD_SALT:///NEW*
-        ///Food Goods^
-//        case YIELD_LEATHER:///NEW*
-//        case YIELD_IVORY:///NEW*
-        case YIELD_SPICES:///NEW*
-		case YIELD_SILVER:
-		case YIELD_COTTON:
-		case YIELD_FUR:
-		case YIELD_BARLEY:
-		case YIELD_GRAPES:
-		case YIELD_ORE:
-		case YIELD_CLOTH:
-		case YIELD_COATS:
-		case YIELD_ALE:
-		case YIELD_WINE:
-			return true;
-			break;
-
-		case YIELD_TOOLS:
-		{
-		    if (isNative())
-		    {
-		        return true;
-		    }
-		    break;
-		}
-		case YIELD_HORSES:
-		{
-		    if (isNative())
-		    {
-		        return true;
-		    }
-		    break;
-		}
-
-		case YIELD_WEAPONS:
-		 ///Armor
-        case YIELD_LEATHER_ARMOR:///NEW*
-        case YIELD_SCALE_ARMOR:///NEW*
-        case YIELD_MAIL_ARMOR:///NEW*
-        case YIELD_PLATE_ARMOR:///NEW*
-        ///Armor^
-		case YIELD_TRADE_GOODS:
-			return false;
-			break;
-        ///TK ME end
-        ///TKs Invention Core Mod v 1.0
-        case YIELD_IDEAS:
-        ///TKe
-		case YIELD_HAMMERS:
-		case YIELD_BELLS:
-		case YIELD_CROSSES:
-        case YIELD_GOLD:///NEW*
-			FAssertMsg(false, "Selling intangibles?");
-			break;
-		default:
-			FAssert(false);
-	}
-
-	return false;
-
-
-}
-
-bool CvPlayerAI::AI_isYieldFinalProduct(YieldTypes eYield) const
-{
-	if (!GC.getYieldInfo(eYield).isCargo())
-	{
-		return false;
-	}
-
-	bool bFinal = true;
-
-	switch (eYield)
-	{
-	    ///TK ME start
-		case YIELD_FOOD:
-		case YIELD_LUMBER:
-        case YIELD_GRAIN:///NEW*
-			bFinal = false;
-			break;
-        ///Food Goods
-		case YIELD_SILVER:
-			bFinal = true;
-			break;
-        ///Trade Goods
-//        case YIELD_LEATHER:///NEW*
-        ///Trade Goods^
-		case YIELD_COTTON:
-		case YIELD_BARLEY:
-		case YIELD_GRAPES:
-		case YIELD_ORE:
-        case YIELD_CATTLE:///NEW*
-        case YIELD_SPICES:///NEW*
-        case YIELD_SHEEP:///NEW*
-        case YIELD_WOOL:///NEW*
-        case YIELD_SALT:///NEW*
-        case YIELD_STONE:///NEW*
-        case YIELD_FUR:
-		///TKs Invention Core Mod v 1.0
-//        case YIELD_COAL:
-        ///TKe
-			{
-				int iLoop;
-				CvCity* pLoopCity = NULL;
-				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-				{
-					if (pLoopCity->AI_getNeededYield(eYield) > 0)
-					{
-						bFinal = false;
-						break;
-					}
-				}
-			}
-			break;
-
-		case YIELD_CLOTH:
-		case YIELD_COATS:
-		case YIELD_ALE:
-		case YIELD_WINE:
-			bFinal = true;
-			break;
-
-		case YIELD_TOOLS:
-		case YIELD_WEAPONS:
-		case YIELD_HORSES:
-		///Armor
-		case YIELD_LEATHER_ARMOR:///NEW*
-		case YIELD_SCALE_ARMOR:///NEW*
-		case YIELD_MAIL_ARMOR:///NEW*
-		case YIELD_PLATE_ARMOR:///NEW*
-        ///Armor^
-			bFinal = false;
-			break;
-
-		case YIELD_TRADE_GOODS:
-			bFinal = true;
-			break;
-		///TKs Invention Core Mod v 1.0
-        case YIELD_IDEAS:
-        ///TKe
-		case YIELD_HAMMERS:
-		case YIELD_BELLS:
-		case YIELD_CROSSES:
-        case YIELD_GOLD:///NEW*
-			bFinal = false;
-			FAssertMsg(false, "Selling intangibles?");
-			break;
-		default:
-			FAssert(false);
-	}
-
-	return bFinal;
-}
-///TKs Med
-bool CvPlayerAI::AI_shouldBuyFromNative(YieldTypes eYield, CvUnit* pTransport) const
-{
-    CvCity* pNativeCity;
-    if (pTransport->plot()->getPlotCity() == NULL)
-    {
-        return false;
-    }
-    pNativeCity = pTransport->plot()->getPlotCity();
-	if (!GC.getYieldInfo(eYield).isCargo())
-	{
-		return false;
-	}
-
-	if (GC.getYieldInfo(eYield).getNativeSellPrice() < 1)
-	{
-		return false;
-	}
-
-	if (GET_PLAYER(pNativeCity->getOwnerINLINE()).getTradeYieldAmount(eYield, pTransport) <= 0)
-    {
-        return false;
-    }
-
-	bool bBuy = false;
-
-	switch (eYield)
-	{
-	    case YIELD_SPICES:
-	    case YIELD_TOOLS:
-        case YIELD_GRAIN:///NEW*
-        case YIELD_CATTLE:///NEW*
-			bBuy = true;
-			break;
-        case YIELD_SALT:
-		case YIELD_FOOD:
-	    case YIELD_SHEEP:///NEW*
-        case YIELD_WOOL:///NEW*
-        case YIELD_STONE:///NEW*
-		case YIELD_LUMBER:
-		case YIELD_SILVER:
-		case YIELD_COTTON:
-		case YIELD_FUR:
-		case YIELD_BARLEY:
-		case YIELD_GRAPES:
-		case YIELD_ORE:
-		case YIELD_CLOTH:
-		case YIELD_COATS:
-		case YIELD_ALE:
-		case YIELD_WINE:
-        case YIELD_LEATHER_ARMOR:///NEW*
-        case YIELD_SCALE_ARMOR:///NEW*
-        case YIELD_MAIL_ARMOR:///NEW*
-        case YIELD_PLATE_ARMOR:///NEW*
-        ///Armor^
-		case YIELD_WEAPONS:
-		case YIELD_HORSES:
-		case YIELD_TRADE_GOODS:
-			bBuy = false;
-			break;
-		///TKs Invention Core Mod v 1.0
-        case YIELD_IDEAS:
-        ///TKe
-		case YIELD_HAMMERS:
-		case YIELD_BELLS:
-		case YIELD_CROSSES:
-        case YIELD_GOLD:///NEW*
-			bBuy = false;
-			FAssertMsg(false, "Selling intangibles?");
-			break;
-		default:
-			FAssert(false);
-	}
-
-	return bBuy;
-}
-///tke
-bool CvPlayerAI::AI_shouldBuyFromEurope(YieldTypes eYield) const
-{
-	if (!GC.getYieldInfo(eYield).isCargo())
-	{
-		return false;
-	}
-
-	bool bBuy = false;
-
-	switch (eYield)
-	{
-		case YIELD_FOOD:
-	    case YIELD_CATTLE:///NEW*
-	    case YIELD_SHEEP:///NEW*
-        case YIELD_GRAIN:///NEW*
-        case YIELD_WOOL:///NEW*
-        case YIELD_SALT:///NEW*
-        case YIELD_STONE:///NEW*
-		case YIELD_LUMBER:
-		case YIELD_SILVER:
-		case YIELD_COTTON:
-		case YIELD_FUR:
-		case YIELD_BARLEY:
-		case YIELD_GRAPES:
-		case YIELD_ORE:
-		case YIELD_CLOTH:
-		case YIELD_COATS:
-		case YIELD_ALE:
-		case YIELD_WINE:
-			bBuy = false;
-			break;
-         ///Armor
-        case YIELD_LEATHER_ARMOR:///NEW*
-        case YIELD_SCALE_ARMOR:///NEW*
-        case YIELD_MAIL_ARMOR:///NEW*
-        case YIELD_PLATE_ARMOR:///NEW*
-        ///Armor^
-		case YIELD_TOOLS:
-		case YIELD_WEAPONS:
-		case YIELD_HORSES:
-		case YIELD_TRADE_GOODS:
-        case YIELD_SPICES:///NEW*
-			bBuy = true;
-			break;
-		///TKs Invention Core Mod v 1.0
-        case YIELD_IDEAS:
-        ///TKe
-		case YIELD_HAMMERS:
-		case YIELD_BELLS:
-		case YIELD_CROSSES:
-        case YIELD_GOLD:///NEW*
-			bBuy = false;
-			FAssertMsg(false, "Selling intangibles?");
-			break;
-		default:
-			FAssert(false);
-	}
-
-	return bBuy;
-}
-///TKs Invention Core Mod v 1.0
-int CvPlayerAI::AI_yieldValue(YieldTypes eYield, bool bProduce, int iAmount)
-{
-	int iValue = 0;
-	if (bProduce)
-	{
-		iValue += 100 * (isNative() ? GC.getYieldInfo(eYield).getNativeBaseValue() : GC.getYieldInfo(eYield).getAIBaseValue());
-	}
-	if (eYield == YIELD_FOOD)
-	{
-
-	}
-	else if (isNative())
-	{
-		CvYieldInfo& kYieldInfo = GC.getYieldInfo(eYield);
-		int iPrice = 0;
-		int iValidPrices = 0;
-		if (kYieldInfo.getNativeBuyPrice() > 0)
-		{
-			iPrice += kYieldInfo.getNativeBuyPrice();
-			iValidPrices++;
-		}
-		if (kYieldInfo.getNativeSellPrice() > 0)
-		{
-			iPrice += kYieldInfo.getNativeSellPrice();
-			iValidPrices++;
-		}
-
-		if (iPrice > 0)
-		{
-			//If both buy and sell, use average. Otherwise, use 2/3rd the value.
-			iPrice *= 2;
-			iPrice /= 2 + iValidPrices;
-
-			iValue += iPrice * 100;
-		}
-	}
-	else
-	{
-		iValue += m_aiYieldValuesTimes100[eYield];
-	}
-
-	iValue *= AI_yieldWeight(eYield);
-	iValue /= 100;
-
-	if (bProduce)
-	{
-		int iWeaponsMultiplier = 100;
-		int iNoblesMultiplier = 100;
-		if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-		{
-		    iNoblesMultiplier += 50;
-			iWeaponsMultiplier += 50;
-		}
-
-		int iGoodsMultiplier = 100;
-		if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-		{
-			iGoodsMultiplier -= 15;
-			iNoblesMultiplier += 25;
-			iWeaponsMultiplier += 25;
-		}
-		else if (AI_isStrategy(STRATEGY_CASH_FOCUS))
-		{
-			iGoodsMultiplier += 50;
-			iNoblesMultiplier -= 25;
-		}
-
-		if (AI_isStrategy(STRATEGY_REVOLUTION))
-		{
-			iGoodsMultiplier -= 15;
-			iWeaponsMultiplier += 50;
-			iNoblesMultiplier += 25;
-		}
-
-		switch (eYield)
-		{
-			case YIELD_FOOD:
-				break;
-			case YIELD_LUMBER:
-            case YIELD_STONE:///NEW*
-				iValue *= 100;
-				iValue /= iGoodsMultiplier;
-				break;
-            ///Bonus Resources
-            case YIELD_SALT:///NEW*
-			case YIELD_SILVER:
-			case YIELD_COTTON:
-			case YIELD_FUR:
-			case YIELD_BARLEY:
-			case YIELD_GRAPES:
-			case YIELD_ORE:
-			case YIELD_CLOTH:
-			case YIELD_COATS:
-			case YIELD_ALE:
-			case YIELD_WINE:
-				iValue *= iGoodsMultiplier;
-				iValue /= 100;
-				break;
-
-			case YIELD_TOOLS:
-				break;
-             ///Armor
-            case YIELD_LEATHER_ARMOR:///NEW*
-            case YIELD_SCALE_ARMOR:///NEW*
-            case YIELD_MAIL_ARMOR:///NEW*
-            case YIELD_PLATE_ARMOR:///NEW*
-            ///Armor^
-			case YIELD_WEAPONS:
-			case YIELD_HORSES:
-				iValue *= iWeaponsMultiplier;
-				iValue /= 100;
-				break;
-
-			case YIELD_TRADE_GOODS:
-				break;
-            ///TKs Invention Core Mod v 1.0
-            case YIELD_IDEAS:
-                if (getCurrentResearch() != NO_CIVIC)
-                {
-                    iValue *= iGoodsMultiplier;
-                    iValue /= GC.getCache_TK_IDEAS_CITY_VALUE();
-                }
-                else
-                {
-                   iValue = 0;
-                }
-				break;
-            case YIELD_CATTLE:///NEW*
-            case YIELD_GRAIN:///NEW*
-            case YIELD_SPICES:///NEW*
-				//if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING) || AI_isStrategy(STRATEGY_BUILDUP))
-				{
-					iValue *= iNoblesMultiplier;
-					iValue /= 100;
-					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-					{
-						iValue *= iNoblesMultiplier;
-						iValue /= 100;
-					}
-				}
-				break;
-            ///TKe
-			case YIELD_HAMMERS:
-				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					iValue *= 125;
-					iValue /= 100;
-					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-					{
-						iValue *= 125;
-						iValue /= 100;
-					}
-				}
-				break;
-
-			case YIELD_BELLS:
-				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					iValue *= 150;
-					iValue /= 100;
-					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-					{
-						iValue *= 150;
-						iValue /= 100;
-					}
-				}
-				break;
-			case YIELD_CROSSES:
-			case YIELD_EDUCATION:
-            case YIELD_GOLD:///NEW*
-				iValue *= 100;
-				iValue /= iWeaponsMultiplier;
-				break;
-			default:
-			break;
-		}
-	}
-
-	iValue *= iAmount;
-	iValue /= 100;
-
-	return iValue;
-}
-///TKe
-void CvPlayerAI::AI_updateYieldValues()
-{
-	if (isNative())
-	{
-		return;
-	}
-
-	PlayerTypes eParent = getParent();
-
-	if (getParent() == NO_PLAYER)
-	{
-		eParent = getID();
-	}
-
-	CvPlayer& kParent = GET_PLAYER(eParent);
-	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
-	{
-		YieldTypes eYield = (YieldTypes)i;
-		int iValue = 0;
-		switch (eYield)
-		{
-			case YIELD_FOOD:
-            case YIELD_GRAIN:///NEW*
-				iValue += (kParent.getYieldSellPrice(eYield) + kParent.getYieldBuyPrice(eYield)) / 2;
-				break;
-			case YIELD_LUMBER:
-            case YIELD_STONE:///NEW*
-				iValue += (kParent.getYieldSellPrice(eYield) + kParent.getYieldBuyPrice(eYield)) / 2;
-				break;
-            ///Bonus Resources
-            case YIELD_SHEEP:///NEW*
-            case YIELD_WOOL:///NEW*
-            case YIELD_SALT:///NEW*
-            ///Food Goods^
-			case YIELD_SILVER:
-			case YIELD_COTTON:
-			case YIELD_FUR:
-			case YIELD_BARLEY:
-			case YIELD_GRAPES:
-			case YIELD_ORE:
-			case YIELD_CLOTH:
-				iValue += kParent.getYieldBuyPrice(eYield);
-				break;
-
-			case YIELD_COATS:
-			case YIELD_ALE:
-			case YIELD_WINE:
-				iValue += kParent.getYieldBuyPrice(eYield);
-				break;
-
-			case YIELD_TOOLS:
-			case YIELD_WEAPONS:
-			case YIELD_HORSES:
-			///Armor
-            case YIELD_LEATHER_ARMOR:///NEW*
-            case YIELD_SCALE_ARMOR:///NEW*
-            case YIELD_MAIL_ARMOR:///NEW*
-            case YIELD_PLATE_ARMOR:///NEW*
-            ///Armor^
-            case YIELD_SPICES:///NEW*
-            case YIELD_CATTLE:///NEW*
-				iValue += kParent.getYieldSellPrice(eYield);
-				break;
-
-			case YIELD_TRADE_GOODS:
-				iValue += kParent.getYieldSellPrice(eYield);
-				break;
-			///TKs Invention Core Mod v 1.0
-            case YIELD_IDEAS:
-            case YIELD_CULTURE:
-            ///TKe
-			case YIELD_HAMMERS:
-			case YIELD_BELLS:
-			case YIELD_CROSSES:
-			case YIELD_EDUCATION:
-            case YIELD_GOLD:///NEW*
-				break;
-			default:
-				FAssert(false);
-		}
-
-		m_aiYieldValuesTimes100[i] = 100 * iValue;
-	}
-	int iCrossValue = m_aiYieldValuesTimes100[YIELD_FOOD] * getGrowthThreshold(1) / (50 + immigrationThreshold() * GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent() / 100);
-	iCrossValue /= 2;
-
-	//Crosses
-	m_aiYieldValuesTimes100[YIELD_CROSSES] = std::max(m_aiYieldValuesTimes100[YIELD_CROSSES], iCrossValue);
-
-	//The function is quite simple. Iterate over every citizen which has input yield.
-	//Calculate the value of their output yield, and assign half of that to the input.
-	if (!isHuman())
-	{
-		int iLoop;
-		CvCity* pLoopCity;
-		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-		{
-			for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-			{
-				CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
-
-				ProfessionTypes eProfession = pLoopUnit->getProfession();
-				if (eProfession != NO_PROFESSION)
-				{
-					CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-					if (kProfession.getYieldsConsumed(0, getID()) != NO_YIELD)
-					{
-						int iValue = 0;
-						// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-						FAssert(kProfession.getYieldsProduced(0) != NO_YIELD);//damn welfware cheats.
-
-						int iInput = pLoopCity->getProfessionInput(eProfession, pLoopUnit);
-						int iOutput = pLoopCity->getProfessionOutput(eProfession, pLoopUnit);
-						///Tks Debug
-						if (iInput <= 0)
-						{
-							iInput = 1;
-						}
-						///TKe
-						int iProfit = (m_aiYieldValuesTimes100[kProfession.getYieldsProduced(0)] * iOutput);
-						// MultipleYieldsProduced End
-						int iInputValue = iProfit / (2 * iInput); //Assign 50% of the yield value to the input.
-						m_aiYieldValuesTimes100[kProfession.getYieldsConsumed(0, getID())] = std::max(iInputValue, m_aiYieldValuesTimes100[kProfession.getYieldsConsumed(0, getID())]);
-					}
-				}
-				ProfessionTypes eIdealProfesion = AI_idealProfessionForUnit(pLoopUnit->getUnitType());
-				if (eIdealProfesion != NO_PROFESSION && eIdealProfesion != eProfession)
-				{
-					CvProfessionInfo& kIdealPro = GC.getProfessionInfo(eIdealProfesion);
-					YieldTypes eYieldConsumed = (YieldTypes)kIdealPro.getYieldsConsumed(0, getID());
-					if (eYieldConsumed != NO_YIELD)
-					{
-						// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-						YieldTypes eYieldProduced = (YieldTypes)kIdealPro.getYieldsProduced(0);
-						FAssert(kIdealPro.getYieldsProduced(0) != NO_YIELD);
-						// MultipleYieldsProduced End
-						int iInputValue = m_aiYieldValuesTimes100[eYieldProduced] / 2;
-						m_aiYieldValuesTimes100[eYieldConsumed] = std::max(iInputValue, m_aiYieldValuesTimes100[eYieldConsumed]);
-					}
-				}
-			}
-		}
-	}
-}
-
-int CvPlayerAI::AI_transferYieldValue(const IDInfo target, YieldTypes eYield, int iAmount)
-{
-	FAssertMsg(eYield > NO_YIELD, "Index out of bounds");
-	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
-
-	const IDInfo kEurope(getID(), CvTradeRoute::EUROPE_CITY_ID);
-	CvCity* pCity = ::getCity(target);
-
-	int iValue = 0;
-	if (pCity != NULL)
-	{
-		int iStored = pCity->getYieldStored(eYield);
-		///TKs Med
-		int iMaxCapacity = (eYield == YIELD_FOOD || eYield == YIELD_GRAIN) ? pCity->growthThreshold() : pCity->getMaxYieldCapacity(eYield);
-		///Tke
-		int iMaintainLevel = pCity->getMaintainLevel(eYield);
-		FAssert(iMaxCapacity > 0);
-		if (iAmount < 0) // Loading
-		{
-			int iSurplus = iStored - iMaintainLevel;
-			if (iSurplus > 0)
-			{
-				iValue = std::min(iSurplus, -iAmount);
-                ///TKs Med
-				int iMaxCapacity = (eYield == YIELD_FOOD || eYield == YIELD_GRAIN) ? pCity->growthThreshold() : iMaxCapacity = pCity->getMaxYieldCapacity(eYield);
-				///TKe
-				FAssert(iMaxCapacity > 0);
-				iValue *= 50 + ((100 * iStored) / std::max(1, iMaxCapacity));
-				if (iStored >= iMaxCapacity)
-				{
-					iValue *= 125 + ((100 * (iStored - iMaxCapacity)) / iMaxCapacity);
-					iValue /= 100;
-				}
-			}
-		}
-		else //Unloading
-		{
-			if (iAmount > 0)
-			{
-				iStored += (pCity->AI_getTransitYield(eYield) * 75) / 100;
-			}
-
-			iValue = iAmount * 100;
-			if (iStored > iMaxCapacity)
-			{
-				iValue *= 10;
-				iValue /= 100 + ((100 * (iStored - iMaxCapacity)) / iMaxCapacity);
-			}
-			else
-			{
-				iValue *=  std::max(10, 10 + (100 * (iMaxCapacity - pCity->getYieldStored(eYield))) / std::max(1, 10 + iMaxCapacity));
-				iValue /= 100;
-			}
-
-			if (iStored < iMaintainLevel)
-			{
-				FAssert(iMaintainLevel > 0);
-				iValue *= 125 + 75 * (iMaintainLevel - iStored) / iMaintainLevel;
-				iValue /= 100;
-			}
-
-			int iProductionNeeded = 0;
-			UnitTypes eUnit = pCity->getProductionUnit();
-			if (eUnit != NO_UNIT)
-			{
-				iProductionNeeded = std::max(iProductionNeeded, pCity->getYieldProductionNeeded(eUnit, eYield));
-			}
-			BuildingTypes eBuilding = pCity->getProductionBuilding();
-			if (eBuilding != NO_BUILDING)
-			{
-				iProductionNeeded = std::max(iProductionNeeded, pCity->getYieldProductionNeeded(eBuilding, eYield));
-			}
-
-			if (iStored > 0 && iStored < iProductionNeeded)
-			{
-				iValue *= 150 + 100 * (iProductionNeeded - iStored) / iProductionNeeded;
-				iValue /= 100;
-			}
-		}
-	}
-	else if (target == kEurope)
-	{
-		if (iAmount < 0) //Loading
-		{
-			iValue = -iAmount;
-		}
-		else
-		{
-			iValue = iAmount;
-		}
-	}
-	else
-	{
-		FAssertMsg(false, "Invalid Route Destination");
-	}
-
-	return iValue;
-}
-
-int CvPlayerAI::AI_countYieldWaiting()
-{
-	int iCount = 0;
-	int iLoop;
-	CvCity* pLoopCity;
-
-	int iUnitSize = GC.getGameINLINE().getCargoYieldCapacity();
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity->AI_isPort())
-		{
-			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-			{
-				YieldTypes eLoopYield = (YieldTypes)iYield;
-				int iTotal = pLoopCity->getYieldStored(eLoopYield);
-				if (iTotal > 0)
-				{
-					if (pLoopCity->AI_shouldExportYield(eLoopYield))
-					{
-						iCount += (iTotal + iUnitSize / 2) / iUnitSize;
-					}
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_highestYieldAdvantage(YieldTypes eYield)
-{
-	int iBestValue = 0;
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		iBestValue = std::max(iBestValue, pLoopCity->AI_getYieldAdvantage(eYield));
-	}
-	return iBestValue;
-}
-
-//Big function to do everything.
-void CvPlayerAI::AI_manageEconomy()
-{
-	if (getNumCities() == 0)
-	{
-		return;
-	}
-
-	bool bAtWar = (GET_TEAM(getTeam()).getAnyWarPlanCount() > 0);
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
-		{
-			int iWeight = 100;
-			YieldTypes eLoopYield = (YieldTypes)iI;
-
-			if (isNative())
-			{
-				iWeight = 60 + GC.getGame().getSorenRandNum(40, "AI Native Yield Value Randomization 1");
-
-				if (pLoopCity->getTeachUnitClass() != NO_UNITCLASS)
-				{
-					UnitTypes eUnit = (UnitTypes)GC.getUnitClassInfo(pLoopCity->getTeachUnitClass()).getDefaultUnitIndex();
-					if (eUnit != NO_UNIT)
-					{
-						iWeight += GC.getUnitInfo(eUnit).getYieldModifier(eLoopYield);
-					}
-				}
-///Tks Med
-				if (eLoopYield == YIELD_FOOD || eLoopYield == YIELD_GRAIN)
-				{
-					iWeight += bAtWar ? 20 : 0;
-				}
-				else if (eLoopYield == YIELD_ORE)
-				{
-					iWeight *= 20 + GC.getGame().getSorenRandNum(80, "AI Native Yield Value Randomization 3");
-					iWeight /= 100;
-				}
-				else if (GC.isEquipmentType(eLoopYield, EQUIPMENT_ARMOR_HORSES))
-				{
-					iWeight += bAtWar ? 20 : 0;
-				}
-				///tke
-
-				int iTotalStored = countTotalYieldStored(eLoopYield);
-				int iMaxStored = getNumCities() * GC.getGameINLINE().getCargoYieldCapacity();
-				iMaxStored *= GC.getYieldInfo(eLoopYield).getNativeConsumptionPercent();
-
-				int iModifier = 1 + std::max(10, 100 - (100 * iTotalStored) / iMaxStored);
-				iWeight *= iModifier;
-				iWeight /= 100;
-			}
-
-			int iEmphasize = 0;
-			for (int i = 0; i < GC.getNumEmphasizeInfos(); ++i)
-			{
-				if (pLoopCity->AI_isEmphasize((EmphasizeTypes)i))
-				{
-					CvEmphasizeInfo& kEmphasize = GC.getEmphasizeInfo((EmphasizeTypes)i);
-					int iValue = kEmphasize.getYieldChange(eLoopYield);
-					if (iValue != 0)
-					{
-						iEmphasize = iValue;
-						break;
-					}
-				}
-			}
-
-			iWeight *= 100 + 133 * std::max(0, iEmphasize);
-			iWeight /= 100 + 166 * std::max(0, -iEmphasize);
-
-			pLoopCity->AI_setYieldOutputWeight(eLoopYield, iWeight);
-		}
-	}
-
-	//Calculate Comparative Advantage in producing various yields.
-
-	//For averages.
-	int aiBestYield[NUM_YIELD_TYPES];
-	int aiWorstYield[NUM_YIELD_TYPES];
-
-	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
-	{
-		aiBestYield[iYield] = 0;
-		aiWorstYield[iYield] = MAX_INT;
-	}
-
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		for (int i = 0; i < GC.getNumProfessionInfos(); ++i)
-		{
-			CvProfessionInfo& kProfession = GC.getProfessionInfo((ProfessionTypes)i);
-
-			if (kProfession.isCitizen())
-			{
-				// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-				YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
-				// MultipleYieldsProduced End
-				if (eYield != NO_YIELD)
-				{
-					int iOutput = pLoopCity->getProfessionOutput((ProfessionTypes)i, NULL);
-					pLoopCity->AI_setYieldAdvantage(eYield, iOutput);
-
-					aiBestYield[eYield] = std::max(aiBestYield[eYield], iOutput);
-					aiWorstYield[eYield] = std::min(aiWorstYield[eYield], iOutput);
-				}
-			}
-		}
-	}
-
-	if (!isNative())
-	{
-		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-		{
-			int iAdvantageCount = 0;
-			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-			{
-				YieldTypes eYield = (YieldTypes)iYield;
-				if (aiBestYield[eYield] > 0)
-				{
-					int iAdvantage = (100 * pLoopCity->AI_getYieldAdvantage(eYield)) / aiBestYield[eYield];
-					if (aiBestYield[eYield] == aiWorstYield[eYield])
-					{
-						iAdvantage *= 99;
-						iAdvantage /= 100;
-					}
-					if (iAdvantage == 100)
-					{
-						iAdvantageCount++;
-					}
-					pLoopCity->AI_setYieldAdvantage(eYield, iAdvantage);
-				}
-			}
-			pLoopCity->AI_setTargetSize(std::max(pLoopCity->getHighestPopulation(), 2 + iAdvantageCount * 3));
-		}
-	}
-
-}
-
-CvPlot* CvPlayerAI::AI_getTerritoryCenter() const
-{
-	if (getNumCities() == 0)
-	{
-		return NULL;
-	}
-
-	CvCity* pLoopCity;
-	int iLoop;
-
-	int iTotalX = 0;
-	int iTotalY = 0;
-	int iTotalWeight = 0;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		int iWeight = 1 + 10 * pLoopCity->AI_getTargetSize();
-		if (pLoopCity->area()->getCitiesPerPlayer(getID()) == 1)
-		{
-			iWeight /= 2;
-		}
-		iWeight = std::max(1, iWeight);
-
-		iTotalX += pLoopCity->getX_INLINE() * iWeight;
-		iTotalY += pLoopCity->getY_INLINE() * iWeight;
-		iTotalWeight += iWeight;
-	}
-
-	if (iTotalWeight == 0)
-	{
-		return NULL;
-	}
-
-	iTotalX += iTotalWeight / 2;
-	iTotalY += iTotalWeight / 2;
-
-	return GC.getMapINLINE().plotINLINE(iTotalX / iTotalWeight, iTotalY / iTotalWeight);
-}
-
-int CvPlayerAI::AI_getTerritoryRadius() const
-{
-	return 10;
-}
-
-void CvPlayerAI::AI_createNatives()
-{
-	AI_createNativeCities();
-	if (getNumCities() == 0)
-	{
-		return;
-	}
-
-	int iLoop;
-	CvCity* pLoopCity;
-	int iCount = 0;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-
-		int iExtraPop = std::max(1, ((getNumCities() - iCount) * 3) / getNumCities());
-
-		if (iCount == 0)
-		{
-			iExtraPop++;
-		}
-
-		//Require a certain minimum food surplus.
-		while ((pLoopCity->AI_getFoodGatherable(1 + iExtraPop, GC.getFOOD_CONSUMPTION_PER_POPULATION()) / 2) < GC.getFOOD_CONSUMPTION_PER_POPULATION() * (1 + iExtraPop))
-		{
-			iExtraPop--;
-			if (iExtraPop == 0)
-			{
-				iExtraPop = 1;
-				break;
-			}
-		}
-
-		pLoopCity->changePopulation(iExtraPop);
-		pLoopCity->AI_setTargetSize(pLoopCity->getPopulation());
-
-		iCount++;
-
-		int iBraveCount = pLoopCity->getPopulation() + 2;
-		for (int iI = 0; iI < iBraveCount; iI++)
-		{
-			UnitTypes eBrave = AI_bestUnit(UNITAI_DEFENSIVE);
-			if (eBrave != NO_UNIT)
-			{
-				initUnit(eBrave, (ProfessionTypes) GC.getUnitInfo(eBrave).getDefaultProfession(), pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE());
-			}
-		}
-	}
-
-	for (int iPass = 0; iPass < 2; ++iPass)
-	{
-		//Now provide some starting yield stockpiles.
-		AI_manageEconomy();
-		int aiYields[NUM_YIELD_TYPES];
-		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-		{
-			pLoopCity->AI_assignWorkingPlots();
-			pLoopCity->calculateNetYields(aiYields);
-
-			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-			{
-				YieldTypes eYield = (YieldTypes) iYield;
-				if (GC.getYieldInfo(eYield).isCargo())
-				{
-					pLoopCity->changeYieldStored(eYield, (aiYields[eYield] * (50 + GC.getGameINLINE().getSorenRandNum(50, "AI starting yields"))) / 10);
-				}
-			}
-		}
-	}
-}
-
-void CvPlayerAI::AI_createNativeCities()
-{
-	while (true)
-	{
-		int iBestValue = 0;
-		CvPlot* pBestPlot = NULL;
-		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-		{
-			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-			int iValue = AI_foundValueNative(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
-			if (iValue > iBestValue)
-			{
-				iBestValue = iValue;
-				pBestPlot = pLoopPlot;
-			}
-		}
-		if (pBestPlot == NULL)
-		{
-			break;
-		}
-
-		CvCity* pCity = pBestPlot->getPlotCity();
-		if (pCity != NULL)
-		{
-			FAssertMsg(false, "City already exists!");
-			break;
-		}
-
-		found(pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE());
-		pCity = pBestPlot->getPlotCity();
-		if (pCity == NULL)
-		{
-			FAssertMsg(false, "Cannot found city!");
-			break;
-		}
-		pCity->setCulture(getID(), 1, true);
-	}
-
-	for(int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-	{
-		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-		int iCulture = 0;
-		int iOursCount = 0;
-		if (pLoopPlot->isCityRadius())
-		{
-			if (pLoopPlot->getOwnerINLINE() == getID())
-			{
-				iCulture += 90;//XMLize and adjust for game speed...
-				if (pLoopPlot->getWorkingCity() != NULL)
-				{
-					iCulture += 10 * pLoopPlot->getWorkingCity()->getPopulation();
-				}
-			}
-		}
-		else
-		{
-			for (int iJ = 0; iJ < NUM_DIRECTION_TYPES; iJ++)
-			{
-				CvPlot* pDirectionPlot = plotDirection(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), (DirectionTypes)iJ);
-				if (pDirectionPlot != NULL)
-				{
-					if (pDirectionPlot->isCityRadius() && pDirectionPlot->getOwnerINLINE() == getID())
-					{
-						iOursCount++;
-					}
-				}
-			}
-
-			int iRand = GC.getGame().getSorenRandNum(2, "AI plot");
-			if ((iOursCount >= 3 + iRand) && (pLoopPlot->getOwnerINLINE() == getID() || !pLoopPlot->isOwned()))
-			{
-				iCulture += 40 + 10 * iOursCount;
-			}
-			else if (pLoopPlot->getOwnerINLINE() == getID())
-			{
-				pLoopPlot->setOwner(NO_PLAYER, false);
-			}
-		}
-
-		int iBestYield = 0;
-		int iTotalYield = 0;
-		if (iCulture > 0)
-		{
-			for (int i = 0; i < NUM_YIELD_TYPES; i++)
-			{
-				YieldTypes eYield = (YieldTypes)i;
-				iBestYield = std::max(iBestYield, pLoopPlot->getYield(eYield));
-				iTotalYield += pLoopPlot->getYield(eYield);
-			}
-
-			iCulture += 10 * iBestYield + (5 * (iTotalYield - iBestYield));
-
-			if (pLoopPlot->getFeatureType() != NO_FEATURE)
-			{
-				iCulture += pLoopPlot->getYield(YIELD_LUMBER) * 5;
-			}
-
-			iCulture *= 100 + GC.getGameINLINE().getSorenRandNum(40, "Native Plot Culture");
-			iCulture /= 100;
-			pLoopPlot->setCulture(getID(), iCulture, true);
-		}
-	}
-
-
-	for(int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-	{
-		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-
-
-		if (pLoopPlot->getOwnerINLINE() == getID())
-		{
-			int iOursCount = 0;
-			for (int iJ = 0; iJ < NUM_DIRECTION_TYPES; iJ++)
-			{
-				CvPlot* pDirectionPlot = plotDirection(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), (DirectionTypes)iJ);
-				if (pDirectionPlot != NULL)
-				{
-					if (pDirectionPlot->getOwnerINLINE() == getID())
-					{
-
-						if (pLoopPlot->getX_INLINE() == pDirectionPlot->getX_INLINE() || pLoopPlot->getY_INLINE() == pDirectionPlot->getY_INLINE())
-						{
-							iOursCount++;
-						}
-					}
-				}
-			}
-			if (iOursCount <= 1)
-			{
-				pLoopPlot->setCulture(getID(), 0, true);
-			}
-		}
-	}
-}
-
-bool CvPlayerAI::AI_isKing()
-{
-	return isEurope();
-}
-
-CvPlot* CvPlayerAI::AI_getImperialShipSpawnPlot()
-{
-	CvPlot* pBestPlot = NULL;
-	int iBestValue = 0;
-
-	std::deque<bool> zoneAllowable(GC.getNumEuropeInfos(), false);
-	bool bNoneAllowable = true;
-	for (int iI = 0; iI < MAX_PLAYERS; ++iI)
-	{
-		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);
-		if (kPlayer.isAlive() && (kPlayer.getParent() == getID()))
-		{
-			if (kPlayer.getStartingPlot() != NULL)
-			{
-				if (kPlayer.getStartingPlot()->getEurope() != NO_EUROPE)
-				{
-					zoneAllowable[kPlayer.getStartingPlot()->getEurope()] = true;
-					bNoneAllowable = false;
-				}
-			}
-		}
-	}
-
-	CvTeamAI& kTeam = GET_TEAM(getTeam());
-
-	CvPlot* pTargetPlot = NULL;
-
-	if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK))
-	{
-		pTargetPlot = GC.getMapINLINE().plotByIndexINLINE(AI_getStrategyData(STRATEGY_CONCENTRATED_ATTACK));
-	}
-
-	for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-	{
-		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-
-		EuropeTypes eEurope = pLoopPlot->getEurope();
-		if (eEurope != NO_EUROPE)
-		{
-			if (bNoneAllowable || zoneAllowable[eEurope])
-			{
-				int iEnemyDistance = kTeam.AI_enemyCityDistance(pLoopPlot);
-				int iValue = (bNoneAllowable || (!bNoneAllowable && iEnemyDistance == -1)) ? 100 : (10000 / (std::max(1, iEnemyDistance - 2)));
-
-				int iLocation = 50;
-				switch ((CardinalDirectionTypes)GC.getEuropeInfo(eEurope).getCardinalDirection())
-				{
-				case CARDINALDIRECTION_EAST:
-				case CARDINALDIRECTION_WEST:
-					iLocation = (100 * pLoopPlot->getY_INLINE() + 50) / GC.getMapINLINE().getGridHeightINLINE();
-					break;
-				case CARDINALDIRECTION_NORTH:
-				case CARDINALDIRECTION_SOUTH:
-					iLocation = (100 * pLoopPlot->getX_INLINE() + 50) / GC.getMapINLINE().getGridWidthINLINE();
-					break;
-				default:
-					break;
-				}
-
-				if (AI_isStrategy(STRATEGY_DISTRIBUTED_ATTACK))
-				{
-					iValue /= 1 + AI_plotTargetMissionAIs(pLoopPlot, MISSIONAI_ASSAULT, NULL, 1);
-
-					int iModifier = 2 * std::abs(iLocation - 50);
-
-					if (iModifier > 95)
-					{
-						iModifier = 1;
-					}
-					else if (iModifier > 80)
-					{
-						iModifier *= (100 - iModifier);
-						iModifier /= 100;
-					}
-					else
-					{
-						iModifier += 10;
-					}
-
-					iValue *= iModifier;
-					iValue /= 100;
-				}
-				if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK))
-				{
-					iValue /= 1 + AI_plotTargetMissionAIs(pLoopPlot, MISSIONAI_ASSAULT, NULL, 1);
-
-					if (pTargetPlot == NULL)
-					{
-						int iModifier = 100 - 2 * std::abs(iLocation - 50);
-
-						if (iModifier < 10)
-						{
-							iModifier = 1;
-						}
-						iValue *= iModifier;
-						iValue /= 100;
-					}
-					else
-					{
-						iValue *= 10;
-						iValue /= std::max(1, stepDistance(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE()) - 3);
-					}
-				}
-
-				iValue *= 25 + GC.getGameINLINE().getSorenRandNum(75, "AI best imperial ship spawn plot");
-
-				if (iValue > iBestValue)
-				{
-					iBestValue = iValue;
-					pBestPlot = pLoopPlot;
-				}
-			}
-		}
-	}
-
-	FAssert(pBestPlot != NULL);
-
-	return pBestPlot;
-}
-
-void CvPlayerAI::AI_addUnitToMoveQueue(CvUnit* pUnit)
-{
-	if (std::find(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), pUnit->getID()) == m_unitPriorityHeap.end())
-	{
-		m_unitPriorityHeap.push_back(pUnit->getID());
-		std::push_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
-	}
-	else
-	{
-		std::make_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
-	}
-}
-
-void CvPlayerAI::AI_removeUnitFromMoveQueue(CvUnit* pUnit)
-{
-	std::vector<int>::iterator it;
-	it = std::find(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), pUnit->getID());
-	if (it != m_unitPriorityHeap.end())
-	{
-		m_unitPriorityHeap.erase(it);
-		std::make_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
-	}
-}
-
-void CvPlayerAI::AI_verifyMoveQueue()
-{
-	std::vector<int>::iterator it = std::partition(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldUnitMove(getID()));
-	m_unitPriorityHeap.erase(it, m_unitPriorityHeap.end());
-	std::make_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
-}
-
-CvUnit* CvPlayerAI::AI_getNextMoveUnit()
-{
-	CvUnit* pUnit = getUnit(m_unitPriorityHeap.front());
-	std::pop_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
-	m_unitPriorityHeap.pop_back();
-	return pUnit;
-}
-
-int CvPlayerAI::AI_highestProfessionOutput(ProfessionTypes eProfession, const CvCity* pIgnoreCity)
-{
-	int iLoop;
-	CvCity* pLoopCity;
-
-	int iBestYield = 0;
-
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity != pIgnoreCity)
-		{
-			iBestYield = std::max(iBestYield, pLoopCity->getProfessionOutput(eProfession, NULL));
-
-			//Also consider buildings under construction.
-			CLLNode<OrderData>* pOrderNode = pLoopCity->headOrderQueueNode();
-
-			while (pOrderNode != NULL)
-			{
-				switch (pOrderNode->m_data.eOrderType)
-				{
-				case ORDER_TRAIN:
-				case ORDER_CONVINCE:
-					break;
-
-				case ORDER_CONSTRUCT:
-					{
-						BuildingTypes eBuilding = ((BuildingTypes)(pOrderNode->m_data.iData1));
-						if (eBuilding != NO_BUILDING)
-						{
-							if (GC.getProfessionInfo(eProfession).getSpecialBuilding() == GC.getBuildingInfo(eBuilding).getSpecialBuildingType())
-							{
-								iBestYield = std::max(iBestYield, GC.getBuildingInfo(eBuilding).getProfessionOutput());
-							}
-						}
-						break;
-					}
-
-				default:
-					FAssertMsg(false, "pOrderNode->m_data.eOrderType failed to match a valid option");
-					break;
-				}
-				pOrderNode = pLoopCity->nextOrderQueueNode(pOrderNode);
-			}
-		}
-	}
-
-	return iBestYield;
-}
-
-CvCity* CvPlayerAI::AI_bestCityForBuilding(BuildingTypes eBuilding)
-{
-	int iBestValue = 0;
-	CvCity* pBestCity = NULL;
-
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (!pLoopCity->isHasConceptualBuilding(eBuilding))
-		{
-			int iValue = pLoopCity->AI_buildingValue(eBuilding);
-			if (iValue > iBestValue)
-			{
-				pBestCity = pLoopCity;
-				iBestValue = iValue;
-			}
-		}
-	}
-
-	return pBestCity;
-}
-
-UnitTypes CvPlayerAI::AI_bestUnit(UnitAITypes eUnitAI, CvArea* pArea)
-{
-	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
-
-	int iBestValue = 0;
-	UnitTypes eBestUnit = NO_UNIT;
-
-	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
-
-		if (eLoopUnit != NO_UNIT)
-		{
-			if (eUnitAI == NO_UNITAI || GC.getUnitInfo(eLoopUnit).getDefaultUnitAIType() == eUnitAI)
-			{
-
-				int iValue = AI_unitValue(eLoopUnit, eUnitAI, pArea);
-
-				if (iValue > 0)
-				{
-					iValue *= (GC.getGameINLINE().getSorenRandNum(40, "AI Best Unit") + 100);
-					iValue /= 100;
-
-					iValue *= (getNumCities() + 2);
-					iValue /= (getUnitClassCountPlusMaking((UnitClassTypes)iI) + getNumCities() + 2);
-
-					FAssert((MAX_INT / 1000) > iValue);
-					iValue *= 1000;
-
-					iValue = std::max(1, iValue);
-
-					if (iValue > iBestValue)
-					{
-						iBestValue = iValue;
-						eBestUnit = eLoopUnit;
-					}
-				}
-			}
-		}
-	}
-
-	return eBestUnit;
-}
-
-int CvPlayerAI::AI_desiredCityCount()
-{
-	bool bDense = AI_isStrategy(STRATEGY_DENSE_CITY_SPACING);
-	int iCount = 0;
-
-	int iStep = 4;
-
-	int iTotal = getTotalPopulation();
-	if (AI_isStrategy(STRATEGY_DENSE_CITY_SPACING))
-	{
-		iTotal *= 133;
-		iTotal /= 100;
-	}
-
-	while (iTotal > 0)
-	{
-		iTotal -= iStep;
-		iStep += 3 + std::max(0, iCount - 4);
-
-		iCount++;
-	}
-
-	return std::max(1, iCount);
-}
-
-int CvPlayerAI::AI_professionBasicValue(ProfessionTypes eProfession, UnitTypes eUnit, CvCity* pCity)
-{
-	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-	// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-	YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
-	// MultipleYieldsProduced End
-	if (eYield == NO_YIELD)
-	{
-		return 0;
-	}
-
-	CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
-	int iBestValue = 0;
-
-	if (kProfession.isCitizen())
-	{
-		if (!kProfession.isWorkPlot())
-		{
-			int iNewOutput = pCity->AI_professionBasicOutput(eProfession, eUnit, NULL);
-			int iProfessionCount = 0;
-			bool bDone = false;
-			for (int i = 0; i < pCity->getPopulation(); ++i)
-			{
-				CvUnit* pLoopUnit = pCity->getPopulationUnitByIndex(i);
-				if (pLoopUnit->getProfession() == eProfession)
-				{
-					int iOldOutput = pCity->AI_professionBasicOutput(eProfession, pLoopUnit->getUnitType(), NULL);
-
-					if (iNewOutput > iOldOutput)
-					{
-						int iValue = AI_yieldValue(eYield, true, iNewOutput);
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							break;
-						}
-					}
-					else
-					{
-						iProfessionCount ++;
-					}
-				}
-			}
-			if (iBestValue == 0)
-			{
-				if (iProfessionCount < pCity->getNumProfessionBuildingSlots(eProfession))
-				{
-					iBestValue = AI_yieldValue(eYield, true, iNewOutput);
-				}
-			}
-		}
-		else
-		{
-			for (int i = 0; i < NUM_CITY_PLOTS; ++i)
-			{
-				CvPlot* pLoopPlot = plotCity(pCity->getX_INLINE(), pCity->getY_INLINE(), i);
-				if ((pLoopPlot != NULL) && (pLoopPlot->getWorkingCity()==pCity))
-				{
-					int iNewOutput = pCity->AI_professionBasicOutput(eProfession, eUnit, pLoopPlot);
-					int iOldOutput = 0;
-					if (pLoopPlot->isBeingWorked())
-					{
-						CvUnit* pWorkingUnit = pCity->getUnitWorkingPlot(pLoopPlot);
-						if (pWorkingUnit != NULL)
-						{
-							if ((pWorkingUnit->getProfession() == eProfession))
-							{
-								iOldOutput = pCity->AI_professionBasicOutput(eProfession, pWorkingUnit->getUnitType(), pLoopPlot);
-								if (iNewOutput <= iOldOutput)
-								{
-									iNewOutput = 0;
-								}
-							}
-							else
-							{
-								bool bOverride = false;
-								if ((pLoopPlot->getBonusType() != NO_BONUS) && (GC.getBonusInfo(pLoopPlot->getBonusType()).getYieldChange(eYield) > 0))
-								{
-									bOverride = true;
-								}
-								if (!bOverride)
-								{
-									int iBestYield = AI_getBestPlotYield(eYield);
-									if (pLoopPlot->getBonusType() == NO_BONUS)
-									{
-										if (pLoopPlot->calculateBestNatureYield(eYield, getTeam()) >= iBestYield)
-										{
-											bOverride = true;
-										}
-									}
-								}
-								if (!bOverride)
-								{
-									iNewOutput = 0;
-								}
-							}
-						}
-					}
-
-					if (iNewOutput > iOldOutput)
-					{
-						int iValue = AI_yieldValue(eYield, true, iNewOutput);
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return iBestValue;
-}
-
-int CvPlayerAI::AI_professionUpgradeValue(ProfessionTypes eProfession, UnitTypes eUnit)
-{
-	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-	// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-	YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
-	// MultipleYieldsProduced End
-	if (eYield == NO_YIELD)
-	{
-		return 0;
-	}
-
-	CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
-
-	int iBestValue = 0;
-	CvCity* pBestCity = NULL;
-
-	int iLoop;
-	CvCity* pLoopCity;
-
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-		{
-			CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
-
-			if (pLoopUnit->getProfession() == eProfession)
-			{
-				int iExistingYield = 0;
-				int iNewYield = 0;
-				int iExtraMultiplier = 0;
-				if (kProfession.isWorkPlot())
-				{
-					CvPlot* pWorkedPlot = pLoopCity->getPlotWorkedByUnit(pLoopUnit);
-					if (pWorkedPlot != NULL)
-					{
-						iExistingYield = pWorkedPlot->calculatePotentialYield(eYield, getID(), pWorkedPlot->getImprovementType(), false, pWorkedPlot->getRouteType(), pLoopUnit->getUnitType(), false);
-						iNewYield = pWorkedPlot->calculatePotentialYield(eYield, getID(), pWorkedPlot->getImprovementType(), false, pWorkedPlot->getRouteType(), eUnit, false);
-						if (pWorkedPlot->getBonusType() != NO_BONUS && GC.getBonusInfo(pWorkedPlot->getBonusType()).getYieldChange(eYield) > 0)
-						{
-							iExtraMultiplier += 100;
-						}
-					}
-				}
-				else
-				{
-					CvUnitInfo& kLoopUnit = GC.getUnitInfo(pLoopUnit->getUnitType());
-					iExistingYield = pLoopCity->getProfessionOutput(eProfession, pLoopUnit);
-					iNewYield = (iExistingYield * 100) / (100 + kLoopUnit.getYieldModifier(eYield));
-					iNewYield -= kLoopUnit.getYieldChange(eYield);
-					iNewYield += kUnit.getYieldChange(eYield);
-					iNewYield = iNewYield * (100 + kUnit.getYieldModifier(eYield)) / 100;
-				}
-
-				if (iNewYield > iExistingYield)
-				{
-					int iValue = AI_yieldValue(eYield, true, iNewYield - iExistingYield);
-					iValue *= 100 + iExtraMultiplier;
-					iValue /= 100;
-					if (iValue > iBestValue)
-					{
-						iBestValue = iValue;
-						pBestCity = pLoopCity;
-					}
-				}
-			}
-		}
-	}
-
-	return iBestValue;
-}
-
-int CvPlayerAI::AI_professionValue(ProfessionTypes eProfession, UnitAITypes eUnitAI)
-{
-	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-	if (kProfession.isCitizen())
-	{
-		return 0;
-	}
-
-	int iValue = 0;
-	switch (eUnitAI)
-	{
-		case UNITAI_UNKNOWN:
-			break;
-
-		case UNITAI_COLONIST:
-			{
-				if (GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession() == eProfession)
-				{
-					iValue += 100;
-				}
-			}
-			break;
-
-		case UNITAI_SETTLER:
-			{
-				if (kProfession.canFound())
-				{
-					iValue += 100;
-				}
-			}
-			break;
-
-		case UNITAI_WORKER:
-			{
-				if (kProfession.getWorkRate() > 0)
-				{
-					iValue += kProfession.getWorkRate();
-				}
-			}
-			break;
-
-		case UNITAI_MISSIONARY:
-			{
-				if (kProfession.getMissionaryRate() > 0)
-				{
-					iValue += kProfession.getMissionaryRate();
-				}
-			}
-			break;
-		case UNITAI_SCOUT:
-			{
-				if (kProfession.isScout())
-				{
-					iValue += 50;
-				}
-				iValue += 50 * kProfession.getMovesChange();
-			}
-			break;
-        ///Tks Med
-		case UNITAI_TRADER:
-			{
-			    if (kProfession.getDefaultUnitAIType() != eUnitAI || AI_isKing())
-                {
-                    return 0;
-                }
-				iValue += 100 * kProfession.getMovesChange();
-			}
-			break;
-        ///Tke
-		case UNITAI_WAGON:
-		case UNITAI_TREASURE:
-		case UNITAI_YIELD:
-		case UNITAI_GENERAL:
-			break;
-
-		case UNITAI_DEFENSIVE:
-			{
-				int iExtraCombatStrength = kProfession.getCombatChange() - GC.getProfessionInfo((ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()).getCombatChange();
-				if (isNative())
-				{
-					iValue += 10;
-				}
-
-				if (!kProfession.isUnarmed() && iExtraCombatStrength > 0)
-				{
-					if (kProfession.isCityDefender())
-					{
-						iValue += iExtraCombatStrength * 25;
-					}
-				}
-			}
-			break;
-
-		case UNITAI_OFFENSIVE:
-			if (isNative())
-			{
-				iValue += 10;
-				int iExtraCombatStrength = kProfession.getCombatChange() - GC.getProfessionInfo((ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()).getCombatChange();
-				if (!kProfession.isUnarmed() && iExtraCombatStrength > 0)
-				{
-					iValue += iExtraCombatStrength * 15;
-					iValue += kProfession.getMovesChange() * 15;
-				}
-			}
-			break;
-		case UNITAI_COUNTER:
-			{
-				int iExtraCombatStrength = kProfession.getCombatChange() - GC.getProfessionInfo((ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()).getCombatChange();
-				if (isNative())
-				{
-					iValue += 10;
-				}
-
-				if (isNative() || (!kProfession.isUnarmed() && iExtraCombatStrength > 0))
-				{
-					iValue += iExtraCombatStrength * 15;
-					iValue *= 1 + kProfession.getMovesChange();
-				}
-			}
-			break;
-
-		case UNITAI_TRANSPORT_SEA:
-		case UNITAI_ASSAULT_SEA:
-		case UNITAI_COMBAT_SEA:
-		case UNITAI_PIRATE_SEA:
-			break;
-		default:
-			FAssert(false);
-			break;
-	}
-	return iValue;
-}
-
-ProfessionTypes CvPlayerAI::AI_idealProfessionForUnit(UnitTypes eUnitType)
-{
-	int iBestValue = 0;
-	int iSecondBestValue = 0;
-	ProfessionTypes eBestProfession = NO_PROFESSION;
-	CvUnitInfo& kUnit = GC.getUnitInfo(eUnitType);
-
-	for (int iI = 0; iI < GC.getNumProfessionInfos(); ++iI)
-	{
-		ProfessionTypes eLoopProfession = (ProfessionTypes)iI;
-		CvProfessionInfo& kProfession = GC.getProfessionInfo(eLoopProfession);
-
-		if (kProfession.isCitizen())
-		{
-			// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-			YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
-			// MultipleYieldsProduced End
-			if (eYield != NO_YIELD)
-			{
-				int iValue = 0;
-
-				if (kProfession.isWater())
-				{
-					if (kUnit.isWaterYieldChanges())
-					{
-						iValue += kUnit.getYieldModifier(eYield);
-						iValue += 22 * kUnit.getYieldChange(eYield);
-						iValue += 17 * kUnit.getBonusYieldChange(eYield);
-					}
-				}
-				else
-				{
-					if (kUnit.isLandYieldChanges())
-					{
-						iValue += kUnit.getYieldModifier(eYield);
-						iValue += 22 * kUnit.getYieldChange(eYield);
-						iValue += 17 * kUnit.getBonusYieldChange(eYield);
-					}
-				}
-
-				if (iValue > iBestValue)
-				{
-					iBestValue = iValue;
-					eBestProfession = eLoopProfession;
-				}
-				else
-				{
-					iSecondBestValue = std::max(iSecondBestValue, iValue);
-				}
-			}
-		}
-	}
-	if (iBestValue == iSecondBestValue)
-	{
-		return NO_PROFESSION;
-	}
-	return eBestProfession;
-}
-
-
-ProfessionTypes CvPlayerAI::AI_idealProfessionForUnitAIType(UnitAITypes eUnitAI, CvCity* pCity)
-{
-	int iBestValue = 0;
-	ProfessionTypes eBestProfession = NO_PROFESSION;
-
-	for (int iI = 0; iI < GC.getNumProfessionInfos(); ++iI)
-	{
-		ProfessionTypes eLoopProfession = (ProfessionTypes)iI;
-		CvProfessionInfo& kProfession = GC.getProfessionInfo(eLoopProfession);
-
-		if (!(kProfession.isCitizen() || kProfession.isWorkPlot()))
-		{
-			if (GC.getCivilizationInfo(getCivilizationType()).isValidProfession(eLoopProfession))
-			{
-				CvUnit* pUnit = NULL;
-				if (pCity != NULL)
-				{
-					pUnit = pCity->getPopulationUnitByIndex(0);
-				}
-				if (pUnit == NULL || pUnit->canHaveProfession(eLoopProfession, true))
-				{
-					int iValue = AI_professionValue(eLoopProfession, eUnitAI);
-
-					if (iValue > iBestValue)
-					{
-						iBestValue = iValue;
-						eBestProfession = eLoopProfession;
-					}
-				}
-			}
-		}
-	}
-
-	return eBestProfession;
-}
-
-//100 means "An average use for Gold", so a higher multiplier here, means a higher priority on buying that unit type.
-//Most notably a "0" means "Don't bother".
-int CvPlayerAI::AI_unitAIValueMultipler(UnitAITypes eUnitAI)
-{
-	int iCount = AI_totalUnitAIs(eUnitAI) + AI_getNumRetiredAIUnits(eUnitAI);
-	int iPopulation = AI_getPopulation() + AI_getNumRetiredAIUnits(UNITAI_MISSIONARY);
-	int iValue = 0;
-	switch (eUnitAI)
-	{
-		case UNITAI_UNKNOWN:
-		case UNITAI_MARAUDER:
-			break;
-
-		case UNITAI_COLONIST:
-			{
-				iValue = std::min(75, 20 + iPopulation);
-				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					iValue *= 75;
-					iValue /= 100;
-					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-					{
-						iValue *= 75;
-						iValue /= 100;
-					}
-				}
-			}
-			break;
-
-		case UNITAI_SETTLER:
-			{
-				if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					int iDesiredCities = AI_desiredCityCount();
-					if (iDesiredCities > (getNumCities() + iCount))
-					{
-						iValue = 100 + 150 * (iDesiredCities - (getNumCities() + iCount));
-					}
-				}
-			}
-			break;
-
-		case UNITAI_WORKER:
-			if (!AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-			{
-				int iNeeded = AI_neededWorkers(NULL);
-
-				if (iNeeded > iCount)
-				{
-					iValue = 100 + 20 * iNeeded + (50 * iNeeded) / (iCount + 1);
-				}
-			}
-			break;
-
-		case UNITAI_MISSIONARY:
-			if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-			{
-				int iLowerPop = 12;
-				int iPop = 15 + iCount * 5;
-				int iModifier = 0;
-				iModifier -= getNativeCombatModifier() * 4;
-				iModifier += getMissionaryRateModifier();
-				iModifier += 10 * GC.getLeaderHeadInfo(getLeaderType()).getNativeAttitude();
-				iModifier += getMissionarySuccessPercent() - 50;
-				if (iModifier != 0)
-				{
-					iLowerPop *= 100 + std::max(0, -iModifier);
-					iLowerPop /= 100 + std::max(0, iModifier);
-					iPop *= 100 + std::max(0, -iModifier);
-					iPop /= 100 + std::max(0, iModifier);
-				}
-
-				iValue = (100 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
-				if (iValue > 0)
-				{
-					iValue += 100;
-				}
-			}
-			break;
-
-		case UNITAI_SCOUT:
-			if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-			{
-				if (iCount <= 1)
-				{
-					int iTotalUnexploredPlots = 0;
-
-					CvArea* pLoopArea;
-					int iLoop;
-					for(pLoopArea = GC.getMapINLINE().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMapINLINE().nextArea(&iLoop))
-					{
-						if (!(pLoopArea->isWater()))
-						{
-							iTotalUnexploredPlots += pLoopArea->getNumRevealedTiles(getTeam());
-						}
-					}
-
-					if (iTotalUnexploredPlots > 10)
-					{
-						if (iCount == 0)
-						{
-							iValue = 500;//scout is important.
-						}
-						else if (iCount == 1)
-						{
-							if ((iTotalUnexploredPlots > 500) && (iPopulation > 5))
-							{
-								iValue = 150;
-							}
-						}
-					}
-				}
-			}
-			break;
-
-		case UNITAI_WAGON:
-			{
-				int iNeeded = 1 + getNumCities() + (getNumCities() - countNumCoastalCities());
-				iNeeded /= 3;
-				if (getNumCities() > 1)
-				{
-					iNeeded = std::max(1, iNeeded);
-				}
-
-				if (iCount < iNeeded)
-				{
-					iValue = 100 + (100 * (iNeeded - iCount)) / iNeeded;
-				}
-			}
-			break;
-
-		case UNITAI_TREASURE:
-		///TKs Med Animal
-		case UNITAI_ANIMAL:
-		case UNITAI_HUNTSMAN:
-		case UNITAI_TRADER:
-		///TKe
-		case UNITAI_YIELD:
-		case UNITAI_GENERAL:
-			break;
-
-		case UNITAI_DEFENSIVE:
-			{
-				if (isNative())
-				{
-					return 100;
-				}
-				bool bAtWar = GET_TEAM(getTeam()).getAnyWarPlanCount();
-				int iLowerPop = bAtWar ? 8 : 15;
-				int iPop = bAtWar ? (10 + 5 * iCount) : 17 + 6 * iCount;
-				iValue = 110 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
-
-				int iUndefended = 0;
-				int iNeeded = AI_totalDefendersNeeded(&iUndefended);
-				if (iUndefended > 0)
-				{
-					iValue += 100 + ((200 * iUndefended) / (1 + getNumCities()));
-				}
-				iValue += (200 * iNeeded) / (1 + getNumCities());
-
-				if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-				{
-					iValue += 3000 / (25 + iCount);
-				}
-
-				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					iValue += 3000 / (25 + iCount);
-				}
-
-				if (getGold() > 5000)
-				{
-					iValue += 1;
-					iValue *= 2;
-				}
-			}
-			break;
-
-		case UNITAI_OFFENSIVE:
-			{
-				bool bAtWar = GET_TEAM(getTeam()).getAnyWarPlanCount();
-				int iLowerPop = bAtWar ? 9 : 15 ;
-				int iPop = bAtWar ? 10 : 20;
-				iValue = 100 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
-
-				if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-				{
-					iValue += 3000 / (40 + iCount);
-				}
-				else
-				{
-					if (iValue > 0)
-					{
-						iValue += 50 + getNativeCombatModifier() * 2;
-					}
-				}
-
-				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					iValue += 1500 / (40 + iCount);
-				}
-			}
-			break;
-
-		case UNITAI_COUNTER:
-			{
-				bool bAtWar = GET_TEAM(getTeam()).getAnyWarPlanCount();
-				int iPop = bAtWar ? 12 : 20;
-				int iLowerPop = bAtWar ? 8 : 14;
-				iValue = 100 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
-				if (iValue > 0)
-				{
-					iValue += 25;
-				}
-
-				if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-				{
-					iValue += 3000 / (25 + iCount);
-				}
-
-				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					iValue += 3000 / (25 + iCount);
-				}
-
-				if (getGold() > 5000)
-				{
-					iValue += 1;
-					iValue *= 2;
-				}
-			}
-			break;
-
-		case UNITAI_TRANSPORT_SEA:
-			if (!AI_isStrategy(STRATEGY_REVOLUTION))
-			{
-				if (iCount < 6)
-				{
-					int iLowerPop = 5 - countNumCoastalCities();
-					int iPop = 13 + 26 * iCount;
-					iValue = 150 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
-
-					iValue += 25 * std::max(0, AI_countYieldWaiting() - 4 * iCount);
-				}
-			}
-			break;
-
-		case UNITAI_ASSAULT_SEA:
-			{
-				int iLowerPop = 5;
-				int iPop = 15 + 50 * iCount;
-				iValue = (160 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
-			}
-		case UNITAI_COMBAT_SEA:
-			{
-				int iLowerPop = 5;
-				int iPop = 40 + 30 * iCount;
-				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-				{
-					iPop /= 2;
-				}
-				iValue = (140 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
-			}
-			break;
-
-		case UNITAI_PIRATE_SEA:
-			{
-				if (iCount < 2)
-				{
-					int iLowerPop = 5;
-					int iPop = 16 + 6 * iCount;
-					iValue = (140 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
-				}
-			}
-			break;
-		default:
-			FAssert(false);
-			break;
-	}
-
-	iValue *= 100 + m_aiUnitAIStrategyWeights[eUnitAI];
-	iValue /= 100;
-
-	return iValue;
-}
-
-bool CvPlayerAI::AI_isCityAcceptingYield(CvCity* pCity, YieldTypes eYield)
-{
-	for (CvIdVector<CvTradeRoute>::iterator it = m_tradeRoutes.begin(); it != m_tradeRoutes.end(); ++it)
-	{
-		CvTradeRoute* pTradeRoute = it->second;
-
-		if (pTradeRoute->getYield() == eYield)
-		{
-			if (pTradeRoute->getDestinationCity() == pCity->getIDInfo())
-			{
-				return true;
-			}
-		}
-	}
-
-	return false;
-}
-
-int CvPlayerAI::AI_professionSuitability(UnitTypes eUnit, ProfessionTypes eProfession)
-{
-	if (eProfession == NO_PROFESSION)
-	{
-		return 0;
-	}
-
-	if (!GC.getCivilizationInfo(getCivilizationType()).isValidProfession(eProfession))
-	{
-		return 0;
-	}
-
-
-	CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
-
-	if (kUnit.getDefaultProfession() == NO_PROFESSION)
-	{
-		return 0;
-	}
-
-	if (eProfession == (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession())
-	{
-		return 100;
-	}
-
-	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-	int iValue = 100;
-
-	int iPositiveYields = 0;
-	int iNegativeYields = 0;
-
-	int iProModifiers = 0;
-	int iConModifiers = 0;
-
-	if (kProfession.isWater() && kUnit.isWaterYieldChanges() || !kProfession.isWater() && kUnit.isLandYieldChanges())
-	{
-
-		for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-		{
-			YieldTypes eLoopYield = (YieldTypes)iYield;
-
-
-			int iModifier = kUnit.getYieldModifier(eLoopYield);
-			// XXX account for kUnit.getYieldChange, kUnit.getBonusYieldChange
-			int iYieldChange = kUnit.getYieldChange(eLoopYield) * 2 + kUnit.getBonusYieldChange(eLoopYield);
-			iModifier += 10 * iYieldChange;
-
-			if (iModifier != 0)
-			{
-				// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-				if (kProfession.getYieldsProduced(0) == eLoopYield)
-				// MultipleYieldsProduced End
-				{
-					//We produce enhanced yield for this profession.
-					if (iModifier > 0)
-					{
-						iProModifiers += iModifier;
-					}
-					else //We produce reduced yield for this profession.
-					{
-						iConModifiers += iModifier;
-					}
-				}
-				else
-				{
-					//We produce enhanced yield for ANOTHER profession.
-					if (iModifier > 0)
-					{
-						iNegativeYields = std::max(iModifier, iNegativeYields);
-					}
-				}
-			}
-		}
-
-		iProModifiers += iPositiveYields / 8;
-		iConModifiers += iNegativeYields / 20;
-
-	}
-
-	if (!kProfession.isCitizen())
-	{
-		int iChange = kUnit.getYieldModifier(YIELD_FOOD) / 10 + kUnit.getYieldChange(YIELD_FOOD) * 3 + kUnit.getYieldChange(YIELD_FOOD) * 2;
-		if (iChange > 0)
-		{
-			iConModifiers += iChange;
-		}
-	}
-
-	if (kProfession.getMissionaryRate() > 0)
-	{
-		int iModifier = kUnit.getMissionaryRateModifier();
-		if (iModifier > 0)
-		{
-			iProModifiers += iModifier;
-		}
-		else
-		{
-			iConModifiers += iModifier / 8;
-		}
-	}
-
-	if (kProfession.getWorkRate() > 0)
-	{
-		int iModifier = kUnit.getWorkRate();
-		if (iModifier > 0)
-		{
-			iProModifiers += iModifier;
-		}
-		else
-		{
-			iConModifiers += iModifier / 8;
-		}
-	}
-
-	if (kProfession.isScout())
-	{
-		if (kUnit.isNoBadGoodies())
-		{
-			iProModifiers += 100;
-		}
-		else
-		{
-			iConModifiers += 5;
-		}
-	}
-
-	for (int i = 0; i < GC.getNumPromotionInfos(); ++i)
-	{
-		if (kUnit.getFreePromotions(i))
-		{
-			if (kProfession.isUnarmed())
-			{
-				iConModifiers += 25;
-			}
-			else
-			{
-				iProModifiers += 25;
-			}
-		}
-	}
-
-	if (eProfession != (ProfessionTypes)GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession())
-	{
-		if (kUnit.getDefaultProfession() == eProfession)
-		{
-			iProModifiers = std::max(100, iProModifiers);//Just in case.
-		}
-		else
-		{
-			if (hasContentsYieldEquipmentAmount((ProfessionTypes)kUnit.getDefaultProfession())) // cache CvPlayer::getYieldEquipmentAmount - Nightinggale
-			{
-				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-				{
-					if (getYieldEquipmentAmount((ProfessionTypes)kUnit.getDefaultProfession(), (YieldTypes) iYield) > 0)
-					{
-						if (getYieldEquipmentAmount(eProfession, (YieldTypes) iYield) == 0)
-						{
-							iConModifiers += 50;
-						}
-						break;
-					}
-				}
-			}
-		}
-	}
-
-	iValue *= 100 + iProModifiers;
-	iValue /= 100 + iConModifiers;
-
-	return iValue;
-}
-
-int CvPlayerAI::AI_professionSuitability(const CvUnit* pUnit, ProfessionTypes eProfession, const CvPlot* pPlot, UnitAITypes eUnitAI)
-{
-	CvPlot* pCityPlot = NULL;
- 	if (pPlot != NULL)
-	{
-		CvCity* pCity = pPlot->getPlotCity();
-		if (pCity == NULL)
-		{
-			pCity = pPlot->getWorkingCity();
-		}
-
-		if (pCity != NULL)
-		{
-			pCityPlot = pCity->plot();
-		}
-	}
-
-	if (!pUnit->canHaveProfession(eProfession, true, pCityPlot))
-	{
-		return 0;
-	}
-
-	int iValue = AI_professionSuitability(pUnit->getUnitType(), eProfession);
-
-	if (eUnitAI != NO_UNITAI && pUnit != NULL)
-	{
-		int iPromotionCount = 0;
-		for (int i = 0; i < GC.getNumPromotionInfos(); ++i)
-		{
-			PromotionTypes eLoopPromotion = (PromotionTypes)i;
-
-			if (pUnit->isHasPromotion(eLoopPromotion))
-			{
-				iPromotionCount ++;
-			}
-		}
-		iValue *= 100 + 5 * iPromotionCount;
-		iValue /= 100;
-
-		if (eUnitAI == UNITAI_OFFENSIVE)
-		{
-			iValue *= 100 + pUnit->cityAttackModifier();
-			iValue /= 100;
-		}
-		else if (eUnitAI == UNITAI_DEFENSIVE)
-		{
-			iValue *= 100 + pUnit->cityDefenseModifier();
-			iValue /= 100;
-		}
-	}
-
-	if (pPlot == NULL)
-	{
-		return iValue;
-	}
-
-	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
-	CvUnitInfo& kUnit = GC.getUnitInfo(pUnit->getUnitType());
-
-	CvCity* pCity = pPlot->getPlotCity();
-	if (pCity == NULL)
-	{
-		pCity = pPlot->getWorkingCity();
-	}
-
-	if (pCity == NULL || pCity->getOwnerINLINE() != getID())
-	{
-		return iValue;
-	}
-
-	bool bMismatchedBonus = false;
-	int iExtraValue = 0;
-	if (kProfession.isCitizen())
-	{
-		// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-		YieldTypes eYieldProducedType = (YieldTypes)kProfession.getYieldsProduced(0);
-		// MultipleYieldsProduced End
-		FAssert(eYieldProducedType != NO_YIELD);
-
-		if (kProfession.isWorkPlot())
-		{
-			if (pPlot->getWorkingCity() == pCity)
-			{
-				if (kProfession.isWater() == pPlot->isWater())
-				{
-					if (pPlot->getBonusType() != NO_BONUS)
-					{
-						int iBonusYield = GC.getBonusInfo(pPlot->getBonusType()).getYieldChange(eYieldProducedType);
-						if (iBonusYield > 0)
-						{
-							int iPlotYield = pPlot->calculateNatureYield(eYieldProducedType, getTeam());
-							if (iPlotYield > 0)
-							{
-								int iExtraYield = kUnit.getYieldChange(eYieldProducedType);
-								iExtraYield += kUnit.getBonusYieldChange(eYieldProducedType);
-
-								iExtraValue += (100 * iExtraYield) / iPlotYield;
-							}
-						}
-						else
-						{
-							bMismatchedBonus = true;
-						}
-					}
-				}
-			}
-		}
-		else
-		{
-			if (pCity != NULL)
-			{
-				int iModifier = kUnit.getYieldModifier(eYieldProducedType);
-				iModifier += kUnit.getYieldChange(eYieldProducedType) * 10;
-
-				iModifier *= pCity->AI_getYieldAdvantage(eYieldProducedType);
-				iModifier /= 100;
-
-				iExtraValue += iModifier;
-			}
-		}
-	}
-
-	iValue += iExtraValue;
-	if (bMismatchedBonus)
-	{
-		iValue *= 95;
-		iValue /= 100;
-	}
-	return iValue;
-}
-
-void CvPlayerAI::AI_swapUnitJobs(CvUnit* pUnitA, CvUnit* pUnitB)
-{
-	FAssert(pUnitA->plot() == pUnitB->plot());
-
-	UnitAITypes eUnitAI_A = pUnitA->AI_getUnitAIType();
-	ProfessionTypes eProfession_A = pUnitA->getProfession();
-	int iMovePriorityA = pUnitA->AI_getMovePriority();
-
-	UnitAITypes eUnitAI_B = pUnitB->AI_getUnitAIType();
-	ProfessionTypes eProfession_B = pUnitB->getProfession();
-	int iMovePriorityB = pUnitB->AI_getMovePriority();
-
-	CvProfessionInfo& kProfessionA = GC.getProfessionInfo(eProfession_A);
-	CvProfessionInfo& kProfessionB = GC.getProfessionInfo(eProfession_B);
-
-	CvCity* pCity = getPopulationUnitCity(pUnitA->getID());
-	if (pCity == NULL)
-	{
-		FAssert(pUnitA->isOnMap());
-		pCity = pUnitA->plot()->getPlotCity();
-	}
-	FAssert(pCity != NULL);
-
-	ProfessionTypes eDefaultProfession = (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession();
-
-	//Ensure all units are added to city.
-	if (pUnitA->isOnMap())
-	{
-		pCity->addPopulationUnit(pUnitA, NO_PROFESSION);
-	}
-	else
-	{
-		pUnitA->setProfession(NO_PROFESSION);
-	}
-
-	if (pUnitB->isOnMap())
-	{
-		pCity->addPopulationUnit(pUnitB, NO_PROFESSION);
-	}
-	else
-	{
-		pUnitB->setProfession(NO_PROFESSION);
-	}
-
-	if (kProfessionA.isCitizen())
-	{
-		pUnitB->setProfession(eProfession_A);
-	}
-	else
-	{
-		pCity->removePopulationUnit(pUnitB, false, eProfession_A);
-		pUnitB->AI_setUnitAIType(eUnitAI_A);
-		pUnitB->AI_setMovePriority(iMovePriorityA);
-	}
-
-	if (kProfessionB.isCitizen())
-	{
-		pUnitA->setProfession(eProfession_B);
-	}
-	else
-	{
-		pCity->removePopulationUnit(pUnitA, false, eProfession_B);
-		pUnitA->AI_setMovePriority(iMovePriorityB);
-		pUnitA->AI_setUnitAIType(eUnitAI_B);
-	}
-}
-
-int CvPlayerAI::AI_sumAttackerStrength(CvPlot* pPlot, CvPlot* pAttackedPlot, int iRange, DomainTypes eDomainType, bool bCheckCanAttack, bool bCheckCanMove)
-{
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	int	strSum = 0;
-
-	for (int iX = -iRange; iX <= iRange; ++iX)
-	{
-		for (int iY = -iRange; iY <= iRange; ++iY)
-		{
-			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
-			if (pLoopPlot != NULL)
-			{
-				pUnitNode = pLoopPlot->headUnitNode();
-
-				while (pUnitNode != NULL)
-				{
-					pLoopUnit = ::getUnit(pUnitNode->m_data);
-					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-					if (pLoopUnit->getOwnerINLINE() == getID())
-					{
-						if (!pLoopUnit->isDead())
-						{
-							bool bCanAttack = pLoopUnit->canAttack();
-
-							if (!bCheckCanAttack || bCanAttack)
-							{
-								if (!bCheckCanMove || pLoopUnit->canMove())
-									if (!bCheckCanMove || pAttackedPlot == NULL || pLoopUnit->canMoveInto(pAttackedPlot, /*bAttack*/ true, /*bDeclareWar*/ true))
-										if (eDomainType == NO_DOMAIN || pLoopUnit->getDomainType() == eDomainType)
-											strSum += pLoopUnit->currEffectiveStr(pAttackedPlot, pLoopUnit);
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return strSum;
-}
-
-int CvPlayerAI::AI_sumEnemyStrength(CvPlot* pPlot, int iRange, bool bAttack, DomainTypes eDomainType)
-{
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	int	strSum = 0;
-
-	for (int iX = -iRange; iX <= iRange; ++iX)
-	{
-		for (int iY = -iRange; iY <= iRange; ++iY)
-		{
-			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
-			if (pLoopPlot != NULL)
-			{
-				pUnitNode = pLoopPlot->headUnitNode();
-
-				while (pUnitNode != NULL)
-				{
-					pLoopUnit = ::getUnit(pUnitNode->m_data);
-					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-					if (pLoopUnit->isEnemy(getTeam(), pLoopPlot))
-					{
-						if (!pLoopUnit->isDead())
-						{
-							if (eDomainType == NO_DOMAIN || pLoopUnit->getDomainType() == eDomainType)
-							{
-								strSum += pLoopUnit->currEffectiveStr(pLoopPlot, bAttack ? pLoopUnit : NULL);
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return strSum;
-}
-
-int CvPlayerAI::AI_setUnitAIStatesRange(CvPlot* pPlot, int iRange, UnitAIStates eNewUnitAIState, UnitAIStates eValidUnitAIState, const std::vector<UnitAITypes>& validUnitAITypes)
-{
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	int iCount = 0;
-
-	for (int iX = -iRange; iX <= iRange; ++iX)
-	{
-		for (int iY = -iRange; iY <= iRange; ++iY)
-		{
-			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
-			if (pLoopPlot != NULL)
-			{
-				pUnitNode = pLoopPlot->headUnitNode();
-
-				while (pUnitNode != NULL)
-				{
-					pLoopUnit = ::getUnit(pUnitNode->m_data);
-					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-					if ((eValidUnitAIState == NO_UNITAI_STATE) || (pLoopUnit->AI_getUnitAIState() == eValidUnitAIState))
-					{
-						if (std::find(validUnitAITypes.begin(), validUnitAITypes.end(), pLoopUnit->AI_getUnitAIType()) != validUnitAITypes.end())
-						{
-							pLoopUnit->AI_setUnitAIState(eNewUnitAIState);
-							iCount++;
-						}
-					}
-				}
-			}
-		}
-	}
-	return iCount;
-}
-
-//
-// read object from a stream
-// used during load
-//
-void CvPlayerAI::read(FDataStreamBase* pStream)
-{
-	CvPlayer::read(pStream);	// read base class data first
-
-	uint uiFlag=0;
-	pStream->Read(&uiFlag);	// flags for expansion
-
-	if (uiFlag > 0)
-	{
-		uint iSize;
-		pStream->Read(&iSize);
-		if (iSize > 0)
-		{
-			m_distanceMap.resize(iSize);
-			pStream->Read(iSize, &m_distanceMap[0]);
-		}
-
-		pStream->Read(&m_iDistanceMapDistance);
-	}
-
-	pStream->Read(&m_iAttackOddsChange);
-	pStream->Read(&m_iExtraGoldTarget);
-
-	pStream->Read(&m_iAveragesCacheTurn);
-
-	pStream->Read((int*)&m_eNextBuyUnit);
-	pStream->Read((int*)&m_eNextBuyUnitAI);
-	pStream->Read(&m_iNextBuyUnitValue);
-	pStream->Read((int*)&m_eNextBuyProfession);
-	pStream->Read((int*)&m_eNextBuyProfessionUnit);
-	pStream->Read((int*)&m_eNextBuyProfessionAI);
-	pStream->Read(&m_iNextBuyProfessionValue);
-
-	pStream->Read(&m_iTotalIncome);
-	pStream->Read(&m_iHurrySpending);
-
-	pStream->Read(NUM_YIELD_TYPES, m_aiAverageYieldMultiplier);
-	pStream->Read(NUM_YIELD_TYPES, m_aiBestWorkedYieldPlots);
-	pStream->Read(NUM_YIELD_TYPES, m_aiBestUnworkedYieldPlots);
-	pStream->Read(NUM_YIELD_TYPES, m_aiYieldValuesTimes100);
-
-	pStream->Read(&m_iUpgradeUnitsCacheTurn);
-	pStream->Read(&m_iUpgradeUnitsCachedExpThreshold);
-	pStream->Read(&m_iUpgradeUnitsCachedGold);
-
-	pStream->Read(NUM_UNITAI_TYPES, m_aiNumTrainAIUnits);
-	pStream->Read(NUM_UNITAI_TYPES, m_aiNumAIUnits);
-	pStream->Read(NUM_UNITAI_TYPES, m_aiNumRetiredAIUnits);
-	pStream->Read(NUM_UNITAI_TYPES, m_aiUnitAIStrategyWeights);
-	pStream->Read(MAX_PLAYERS, m_aiPeacetimeTradeValue);
-	pStream->Read(MAX_PLAYERS, m_aiPeacetimeGrantValue);
-	pStream->Read(MAX_PLAYERS, m_aiGoldTradedTo);
-	pStream->Read(MAX_PLAYERS, m_aiAttitudeExtra);
-
-	pStream->Read(MAX_PLAYERS, m_abFirstContact);
-
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		pStream->Read(NUM_CONTACT_TYPES, m_aaiContactTimer[i]);
-	}
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		pStream->Read(uiFlag > 1 ? NUM_MEMORY_TYPES : NUM_MEMORY_TYPES - 1, m_aaiMemoryCount[i]);
-	}
-
-	pStream->Read(&m_iTurnLastProductionDirty);
-	pStream->Read(&m_iTurnLastManagedPop);
-	pStream->Read(&m_iMoveQueuePasses);
-
-	{
-		m_aiAICitySites.clear();
-		uint iSize;
-		pStream->Read(&iSize);
-		for (uint i = 0; i < iSize; i++)
-		{
-			int iCitySite;
-			pStream->Read(&iCitySite);
-			m_aiAICitySites.push_back(iCitySite);
-		}
-	}
-
-	if (uiFlag > 0)
-	{
-		uint iSize;
-		pStream->Read(&iSize);
-		if (iSize > 0)
-		{
-			m_unitPriorityHeap.resize(iSize);
-			pStream->Read(iSize, &m_unitPriorityHeap[0]);
-		}
-	}
-
-	pStream->Read(GC.getNumUnitClassInfos(), m_aiUnitClassWeights);
-	pStream->Read(GC.getNumUnitCombatInfos(), m_aiUnitCombatWeights);
-	pStream->Read(MAX_PLAYERS, m_aiCloseBordersAttitudeCache);
-	pStream->Read(MAX_PLAYERS, m_aiStolenPlotsAttitudeCache);
-	///TKs Med
-	//pStream->Read(MAX_PLAYERS, m_aiInsultedAttitudeCache);
-	//tkend
-	pStream->Read(NUM_EMOTION_TYPES, m_aiEmotions);
-	pStream->Read(NUM_STRATEGY_TYPES, m_aiStrategyStartedTurn);
-	pStream->Read(NUM_STRATEGY_TYPES, m_aiStrategyData);
-
-}
-
-
-//
-// save object to a stream
-// used during save
-//
-void CvPlayerAI::write(FDataStreamBase* pStream)
-{
-	CvPlayer::write(pStream);	// write base class data first
-
-	uint uiFlag=2;
-	pStream->Write(uiFlag);		// flag for expansion
-
-	pStream->Write(m_distanceMap.size());
-	if (!m_distanceMap.empty())
-	{
-		pStream->Write(m_distanceMap.size(), &m_distanceMap[0]);
-	}
-	pStream->Write(m_iDistanceMapDistance);
-
-	pStream->Write(m_iAttackOddsChange);
-	pStream->Write(m_iExtraGoldTarget);
-
-	pStream->Write(m_iAveragesCacheTurn);
-
-	pStream->Write(m_eNextBuyUnit);
-	pStream->Write(m_eNextBuyUnitAI);
-	pStream->Write(m_iNextBuyUnitValue);
-	pStream->Write(m_eNextBuyProfession);
-	pStream->Write(m_eNextBuyProfessionUnit);
-	pStream->Write(m_eNextBuyProfessionAI);
-	pStream->Write(m_iNextBuyProfessionValue);
-
-	pStream->Write(m_iTotalIncome);
-	pStream->Write(m_iHurrySpending);
-
-	pStream->Write(NUM_YIELD_TYPES, m_aiAverageYieldMultiplier);
-	pStream->Write(NUM_YIELD_TYPES, m_aiBestWorkedYieldPlots);
-	pStream->Write(NUM_YIELD_TYPES, m_aiBestUnworkedYieldPlots);
-	pStream->Write(NUM_YIELD_TYPES, m_aiYieldValuesTimes100);
-
-	pStream->Write(m_iUpgradeUnitsCacheTurn);
-	pStream->Write(m_iUpgradeUnitsCachedExpThreshold);
-	pStream->Write(m_iUpgradeUnitsCachedGold);
-
-	pStream->Write(NUM_UNITAI_TYPES, m_aiNumTrainAIUnits);
-	pStream->Write(NUM_UNITAI_TYPES, m_aiNumAIUnits);
-	pStream->Write(NUM_UNITAI_TYPES, m_aiNumRetiredAIUnits);
-	pStream->Write(NUM_UNITAI_TYPES, m_aiUnitAIStrategyWeights);
-	pStream->Write(MAX_PLAYERS, m_aiPeacetimeTradeValue);
-	pStream->Write(MAX_PLAYERS, m_aiPeacetimeGrantValue);
-	pStream->Write(MAX_PLAYERS, m_aiGoldTradedTo);
-	pStream->Write(MAX_PLAYERS, m_aiAttitudeExtra);
-
-	pStream->Write(MAX_PLAYERS, m_abFirstContact);
-
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		pStream->Write(NUM_CONTACT_TYPES, m_aaiContactTimer[i]);
-	}
-	for (int i = 0; i < MAX_PLAYERS; i++)
-	{
-		pStream->Write(NUM_MEMORY_TYPES, m_aaiMemoryCount[i]);
-	}
-
-	pStream->Write(m_iTurnLastProductionDirty);
-	pStream->Write(m_iTurnLastManagedPop);
-	pStream->Write(m_iMoveQueuePasses);
-
-	{
-		uint iSize = m_aiAICitySites.size();
-		pStream->Write(iSize);
-		std::vector<int>::iterator it;
-		for (it = m_aiAICitySites.begin(); it != m_aiAICitySites.end(); ++it)
-		{
-			pStream->Write((*it));
-		}
-	}
-
-	pStream->Write(m_unitPriorityHeap.size());
-	if (!m_unitPriorityHeap.empty())
-	{
-		pStream->Write(m_unitPriorityHeap.size(), &m_unitPriorityHeap[0]);
-	}
-
-	pStream->Write(GC.getNumUnitClassInfos(), m_aiUnitClassWeights);
-	pStream->Write(GC.getNumUnitCombatInfos(), m_aiUnitCombatWeights);
-	pStream->Write(MAX_PLAYERS, m_aiCloseBordersAttitudeCache);
-	pStream->Write(MAX_PLAYERS, m_aiStolenPlotsAttitudeCache);
-	///TKs MEd
-	//pStream->Write(MAX_PLAYERS, m_aiInsultedAttitudeCache);
-	//tkend
-	pStream->Write(NUM_EMOTION_TYPES, m_aiEmotions);
-	pStream->Write(NUM_STRATEGY_TYPES, m_aiStrategyStartedTurn);
-	pStream->Write(NUM_STRATEGY_TYPES, m_aiStrategyData);
-}
-
-
-int CvPlayerAI::AI_eventValue(EventTypes eEvent, const EventTriggeredData& kTriggeredData)
-{
-	CvEventTriggerInfo& kTrigger = GC.getEventTriggerInfo(kTriggeredData.m_eTrigger);
-	CvEventInfo& kEvent = GC.getEventInfo(eEvent);
-
-	int iNumCities = getNumCities();
-	CvCity* pCity = getCity(kTriggeredData.m_iCityId);
-	CvPlot* pPlot = GC.getMapINLINE().plot(kTriggeredData.m_iPlotX, kTriggeredData.m_iPlotY);
-	CvUnit* pUnit = getUnit(kTriggeredData.m_iUnitId);
-
-	int aiYields[NUM_YIELD_TYPES];
-
-	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
-	{
-		aiYields[iI] = 0;
-	}
-
-	if (NO_PLAYER != kTriggeredData.m_eOtherPlayer)
-	{
-		if (kEvent.isDeclareWar())
-		{
-			switch (AI_getAttitude(kTriggeredData.m_eOtherPlayer))
-			{
-			case ATTITUDE_FURIOUS:
-			case ATTITUDE_ANNOYED:
-			case ATTITUDE_CAUTIOUS:
-				if (GET_TEAM(getTeam()).getDefensivePower() < GET_TEAM(GET_PLAYER(kTriggeredData.m_eOtherPlayer).getTeam()).getPower())
-				{
-					return -MAX_INT + 1;
-				}
-				break;
-			case ATTITUDE_PLEASED:
-			case ATTITUDE_FRIENDLY:
-				return -MAX_INT + 1;
-				break;
-			}
-		}
-	}
-
-	//Proportional to #turns in the game...
-	//(AI evaluation will generally assume proper game speed scaling!)
-	int iGameSpeedPercent = 100;
-
-	int iValue = GC.getGameINLINE().getSorenRandNum(kEvent.getAIValue(), "AI Event choice");
-	iValue += (getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, false) + getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, true)) / 2;
-	if (kEvent.getUnitClass() != NO_UNITCLASS)
-	{
-		UnitTypes eUnit = (UnitTypes)GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(kEvent.getUnitClass());
-		if (eUnit != NO_UNIT)
-		{
-			//Although AI_unitValue compares well within units, the value is somewhat independent of cost
-			int iUnitValue = 0;
-			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-			{
-				iUnitValue += GC.getUnitInfo(eUnit).getYieldCost(iYield);
-			}
-			if (iUnitValue > 0)
-			{
-				iUnitValue *= 2;
-			}
-			else
-			{
-				iUnitValue = 200;
-			}
-
-			iUnitValue *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();
-			iValue += kEvent.getNumUnits() * iUnitValue;
-		}
-	}
-
-	if (kEvent.isDisbandUnit())
-	{
-		CvUnit* pUnit = getUnit(kTriggeredData.m_iUnitId);
-		if (NULL != pUnit)
-		{
-			int iUnitValue = 0;
-			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-			{
-				iUnitValue += pUnit->getUnitInfo().getYieldCost(iYield);
-			}
-			if (iUnitValue > 0)
-			{
-				iUnitValue *= 2;
-			}
-			else
-			{
-				iUnitValue = 200;
-			}
-
-			iUnitValue *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();
-			iValue -= iUnitValue;
-		}
-	}
-
-	if (kEvent.getBuildingClass() != NO_BUILDINGCLASS)
-	{
-		BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(getCivilizationType()).getCivilizationBuildings(kEvent.getBuildingClass());
-		if (eBuilding != NO_BUILDING)
-		{
-			if (pCity)
-			{
-				//iValue += kEvent.getBuildingChange() * pCity->AI_buildingValue(eBuilding);
-				int iBuildingValue = 0;
-				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-				{
-					iBuildingValue += GC.getBuildingInfo(eBuilding).getYieldCost(iYield);
-				}
-				if (iBuildingValue > 0)
-				{
-					iBuildingValue *= 2;
-				}
-				else if (iBuildingValue == -1)
-				{
-					iBuildingValue = 300;
-				}
-
-				iBuildingValue *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getConstructPercent();
-				iValue += kEvent.getBuildingChange() * iBuildingValue;
-			}
-		}
-	}
-
-	{	//Yield and other changes
-		if (kEvent.getNumBuildingYieldChanges() > 0)
-		{
-			for (int iBuildingClass = 0; iBuildingClass < GC.getNumBuildingClassInfos(); ++iBuildingClass)
-			{
-				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
-				{
-					aiYields[iYield] += kEvent.getBuildingYieldChange(iBuildingClass, iYield);
-				}
-			}
-		}
-	}
-
-	if (kEvent.isCityEffect())
-	{
-		int iCityPopulation = -1;
-		int iCityTurnValue = 0;
-		if (NULL != pCity)
-		{
-			iCityPopulation = pCity->getPopulation();
-		}
-
-		if (-1 == iCityPopulation)
-		{
-			//What is going on here?
-			iCityPopulation = 5;
-		}
-
-		iCityTurnValue += aiYields[YIELD_FOOD] * 5;
-
-		iCityTurnValue += aiYields[YIELD_BELLS] * 3;
-		iCityTurnValue += aiYields[YIELD_CROSSES] * 1;
-
-		iValue += (iCityTurnValue * 20 * iGameSpeedPercent) / 100;
-
-		iValue += kEvent.getFood();
-		iValue += kEvent.getFoodPercent() / 4;
-		iValue += kEvent.getPopulationChange() * 30;
-		iValue -= kEvent.getRevoltTurns() * (12 + iCityPopulation * 16);
-		iValue += kEvent.getCulture() / 2;
-	}
-	else if (!kEvent.isOtherPlayerCityEffect())
-	{
-		int iPerTurnValue = 0;
-
-		iValue += (iPerTurnValue * 20 * iGameSpeedPercent) / 100;
-
-		iValue += (kEvent.getFood() * iNumCities);
-		iValue += (kEvent.getFoodPercent() * iNumCities) / 4;
-		iValue += (kEvent.getPopulationChange() * iNumCities * 40);
-		iValue += iNumCities * kEvent.getCulture() / 2;
-	}
-
-	if (NULL != pPlot)
-	{
-		if (kEvent.getImprovementChange() > 0)
-		{
-			iValue += (30 * iGameSpeedPercent) / 100;
-		}
-		else if (kEvent.getImprovementChange() < 0)
-		{
-			iValue -= (30 * iGameSpeedPercent) / 100;
-		}
-
-		if (kEvent.getRouteChange() > 0)
-		{
-			iValue += (10 * iGameSpeedPercent) / 100;
-		}
-		else if (kEvent.getRouteChange() < 0)
-		{
-			iValue -= (10 * iGameSpeedPercent) / 100;
-		}
-
-		for (int i = 0; i < NUM_YIELD_TYPES; ++i)
-		{
-			if (0 != kEvent.getPlotExtraYield(i))
-			{
-				if (pPlot->getWorkingCity() != NULL)
-				{
-					FAssertMsg(pPlot->getWorkingCity()->getOwner() == getID(), "Event creates a boni for another player?");
-					aiYields[i] += kEvent.getPlotExtraYield(i);
-				}
-				else
-				{
-					iValue += (20 * 8 * kEvent.getPlotExtraYield(i) * iGameSpeedPercent) / 100;
-				}
-			}
-		}
-	}
-
-	if (NULL != pUnit)
-	{
-		iValue += (2 * pUnit->baseCombatStr() * kEvent.getUnitExperience() * GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent()) / 100;
-
-		iValue -= 10 * kEvent.getUnitImmobileTurns();
-	}
-
-	{
-		int iPromotionValue = 0;
-
-		for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
-		{
-			if (NO_PROMOTION != kEvent.getUnitCombatPromotion(i))
-			{
-				int iLoop;
-				for (CvUnit* pLoopUnit = firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = nextUnit(&iLoop))
-				{
-					if (pLoopUnit->getUnitCombatType() == i)
-					{
-						if (!pLoopUnit->isHasPromotion((PromotionTypes)kEvent.getUnitCombatPromotion(i)))
-						{
-							iPromotionValue += 5 * pLoopUnit->baseCombatStr();
-						}
-					}
-				}
-
-				iPromotionValue += iNumCities * 50;
-			}
-		}
-
-		iValue += (iPromotionValue * iGameSpeedPercent) / 100;
-	}
-
-	int iOtherPlayerAttitudeWeight = 0;
-	if (kTriggeredData.m_eOtherPlayer != NO_PLAYER)
-	{
-		iOtherPlayerAttitudeWeight = AI_getAttitudeWeight(kTriggeredData.m_eOtherPlayer);
-		iOtherPlayerAttitudeWeight += 10 - GC.getGame().getSorenRandNum(20, "AI event value attitude");
-	}
-
-	if (NO_PLAYER != kTriggeredData.m_eOtherPlayer)
-	{
-		CvPlayerAI& kOtherPlayer = GET_PLAYER(kTriggeredData.m_eOtherPlayer);
-
-		int iDiploValue = 0;
-		//if we like this player then value positive attitude, if however we really hate them then
-		//actually value negative attitude.
-		iDiploValue += ((iOtherPlayerAttitudeWeight + 50) * kEvent.getAttitudeModifier() * GET_PLAYER(kTriggeredData.m_eOtherPlayer).getPower()) / std::max(1, getPower());
-
-		if (kEvent.getTheirEnemyAttitudeModifier() != 0)
-		{
-			//Oh wow this sure is mildly complicated.
-			TeamTypes eWorstEnemy = GET_TEAM(GET_PLAYER(kTriggeredData.m_eOtherPlayer).getTeam()).AI_getWorstEnemy();
-
-			if (NO_TEAM != eWorstEnemy && eWorstEnemy != getTeam())
-			{
-			int iThirdPartyAttitudeWeight = GET_TEAM(getTeam()).AI_getAttitudeWeight(eWorstEnemy);
-
-			//If we like both teams, we want them to get along.
-			//If we like otherPlayer but not enemy (or vice-verca), we don't want them to get along.
-			//If we don't like either, we don't want them to get along.
-			//Also just value stirring up trouble in general.
-
-			int iThirdPartyDiploValue = 50 * kEvent.getTheirEnemyAttitudeModifier();
-			iThirdPartyDiploValue *= (iThirdPartyAttitudeWeight - 10);
-			iThirdPartyDiploValue *= (iOtherPlayerAttitudeWeight - 10);
-			iThirdPartyDiploValue /= 10000;
-
-			if ((iOtherPlayerAttitudeWeight) < 0 && (iThirdPartyAttitudeWeight < 0))
-			{
-				iThirdPartyDiploValue *= -1;
-			}
-
-			iThirdPartyDiploValue /= 2;
-
-			iDiploValue += iThirdPartyDiploValue;
-		}
-		}
-
-		iDiploValue *= iGameSpeedPercent;
-		iDiploValue /= 100;
-
-		if (GC.getGameINLINE().isOption(GAMEOPTION_AGGRESSIVE_AI))
-		{
-			//What is this "relationships" thing?
-			iDiploValue /= 2;
-		}
-
-		if (kEvent.isGoldToPlayer())
-		{
-			//If the gold goes to another player instead of the void, then this is a positive
-			//thing if we like the player, otherwise it's a negative thing.
-			int iGiftValue = (getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, false) + getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, true)) / 2;
-			iGiftValue *= -iOtherPlayerAttitudeWeight;
-			iGiftValue /= 110;
-
-			iValue += iGiftValue;
-		}
-
-		if (kEvent.isDeclareWar())
-		{
-			int iWarValue = (GET_TEAM(getTeam()).getDefensivePower() - GET_TEAM(GET_PLAYER(kTriggeredData.m_eOtherPlayer).getTeam()).getPower());// / std::max(1, GET_TEAM(getTeam()).getDefensivePower());
-			iWarValue -= 30 * AI_getAttitudeVal(kTriggeredData.m_eOtherPlayer);
-		}
-
-		if (kEvent.getMaxPillage() > 0)
-		{
-			int iPillageValue = (40 * (kEvent.getMinPillage() + kEvent.getMaxPillage())) / 2;
-			//If we hate them, this is good to do.
-			iPillageValue *= 25 - iOtherPlayerAttitudeWeight;
-			iPillageValue *= iGameSpeedPercent;
-			iPillageValue /= 12500;
-		}
-
-		iValue += (iDiploValue * iGameSpeedPercent) / 100;
-	}
-
-	int iThisEventValue = iValue;
-	//XXX THIS IS VULNERABLE TO NON-TRIVIAL RECURSIONS!
-	//Event A effects Event B, Event B effects Event A
-	for (int iEvent = 0; iEvent < GC.getNumEventInfos(); ++iEvent)
-	{
-		if (kEvent.getAdditionalEventChance(iEvent) > 0)
-		{
-			if (iEvent == eEvent)
-			{
-				//Infinite recursion is not our friend.
-				//Fortunately we have the event value for this event - sans values of other events
-				//disabled or cleared. Hopefully no events will be that complicated...
-				//Double the value since it's recursive.
-				iValue += (kEvent.getAdditionalEventChance(iEvent) * iThisEventValue) / 50;
-			}
-			else
-			{
-				iValue += (kEvent.getAdditionalEventChance(iEvent) * AI_eventValue((EventTypes)iEvent, kTriggeredData)) / 100;
-			}
-		}
-
-		if (kEvent.getClearEventChance(iEvent) > 0)
-		{
-			if (iEvent == eEvent)
-			{
-				iValue -= (kEvent.getClearEventChance(iEvent) * iThisEventValue) / 50;
-			}
-			else
-			{
-				iValue -= (kEvent.getClearEventChance(iEvent) * AI_eventValue((EventTypes)iEvent, kTriggeredData)) / 100;
-			}
-		}
-	}
-
-	iValue *= 100 + GC.getGameINLINE().getSorenRandNum(20, "AI Event choice");
-	iValue /= 100;
-
-	return iValue;
-}
-
-EventTypes CvPlayerAI::AI_chooseEvent(int iTriggeredId)
-{
-	EventTriggeredData* pTriggeredData = getEventTriggered(iTriggeredId);
-	if (NULL == pTriggeredData)
-	{
-		return NO_EVENT;
-	}
-
-	CvEventTriggerInfo& kTrigger = GC.getEventTriggerInfo(pTriggeredData->m_eTrigger);
-
-	int iBestValue = -MAX_INT;
-	EventTypes eBestEvent = NO_EVENT;
-
-	for (int i = 0; i < kTrigger.getNumEvents(); i++)
-	{
-		int iValue = -MAX_INT;
-		if (kTrigger.getEvent(i) != NO_EVENT)
-		{
-			CvEventInfo& kEvent = GC.getEventInfo((EventTypes)kTrigger.getEvent(i));
-			if (canDoEvent((EventTypes)kTrigger.getEvent(i), *pTriggeredData))
-			{
-				iValue = AI_eventValue((EventTypes)kTrigger.getEvent(i), *pTriggeredData);
-			}
-		}
-
-		if (iValue > iBestValue)
-		{
-			iBestValue = iValue;
-			eBestEvent = (EventTypes)kTrigger.getEvent(i);
-		}
-	}
-
-	return eBestEvent;
-}
-
-void CvPlayerAI::AI_doNativeArmy(TeamTypes eTeam)
-{
-	CvTeamAI& kTeam = GET_TEAM(getTeam());
-	FAssert(eTeam != NO_TEAM && eTeam != getTeam());
-
-	int iTotalUnitCount = getTotalPopulation();
-
-	int iGameTurn = GC.getGameINLINE().getGameTurn();
-	int iEndTurn = GC.getGameINLINE().getEstimateEndTurn();
-
-	iEndTurn *= GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getNativePacifismPercent();
-	iEndTurn /= 100;
-
-	int iOffensivePercent = std::max(40, 30 * iGameTurn * 2 / iEndTurn);
-	int iCounterPercent = std::max(25, 15 * iGameTurn * 3 / iEndTurn);
-
-	if (kTeam.AI_getWarPlan(eTeam) == WARPLAN_TOTAL || kTeam.AI_getWarPlan(eTeam) == WARPLAN_PREPARING_TOTAL)
-	{
-		iOffensivePercent *= 3;
-		iOffensivePercent /= 2;
-	}
-	else if (kTeam.AI_getWarPlan(eTeam) == WARPLAN_ATTACKED_RECENT)
-	{
-		iOffensivePercent += 3;
-		iOffensivePercent /= 4;
-	}
-	else
-	{
-		iCounterPercent += (iOffensivePercent * 1 + 2) / 3;
-		iOffensivePercent = (iOffensivePercent * 2 + 1) / 3;
-	}
-
-	//First convert units which are already on the map.
-	int iLoop;
-	CvUnit* pLoopUnit;
-	for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-	{
-		CvArea* pArea = pLoopUnit->area();
-		AreaAITypes eAreaAI = pArea->getAreaAIType(getTeam());
-		if (pLoopUnit->AI_getUnitAIType() == UNITAI_DEFENSIVE)
-		{
-			int iValue = 0;
-
-			int iAreaPopulation = pArea->getPopulationPerPlayer(getID()) + pArea->getUnitsPerPlayer(getID());
-
-			CvCity* pLoopCity = pLoopUnit->plot()->getPlotCity();
-			if (pLoopCity != NULL && pLoopCity->getOwnerINLINE() != getID())
-			{
-				pLoopCity = NULL;
-			}
-			if (pLoopCity == NULL || pLoopCity->AI_isDefended())
-			{
-				int iOffenseValue = iOffensivePercent * (iOffensivePercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_OFFENSIVE) / iAreaPopulation);
-				int iCounterValue = iCounterPercent * (iCounterPercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_COUNTER) / iAreaPopulation);
-
-				if (iOffenseValue >= 0 && iOffenseValue >= iCounterValue)
-				{
-					pLoopUnit->AI_setUnitAIType(UNITAI_OFFENSIVE);
-				}
-				else if (iCounterValue > 0)
-				{
-					pLoopUnit->AI_setUnitAIType(UNITAI_COUNTER);
-				}
-			}
-		}
-		else if (eAreaAI == AREAAI_NEUTRAL)
-		{		    ///TKs Med
-		    if (!pLoopUnit->isAlwaysHostile(pLoopUnit->plot()))
-            {
-                pLoopUnit->AI_setUnitAIType(UNITAI_DEFENSIVE);
-            }
-            ///TKe
-		}
-	}
-
-	int iBestValue = 0;
-	CvCity* pBestCity = NULL;
-
-	int iInfiniteLoop = 0;
-	while (true)
-	{
-		int iBestValue = 0;
-		UnitAITypes eBestUnitAI = NO_UNITAI;
-		CvCity* pBestCity = NULL;
-
-
-		CvCity* pLoopCity;
-		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-		{
-			if (pLoopCity->getPopulation() > 1)
-			{
-				CvArea* pArea = pLoopCity->area();
-				AreaAITypes eAreaAI = pArea->getAreaAIType(getTeam());
-
-				if (eAreaAI != AREAAI_NEUTRAL)
-				{
-					int iAreaPopulation = pArea->getPopulationPerPlayer(getID()) + pArea->getUnitsPerPlayer(getID());
-					int iOffenseValue = iOffensivePercent * (iOffensivePercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_OFFENSIVE) / iAreaPopulation);
-					int iCounterValue = iCounterPercent * (iCounterPercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_COUNTER) / iAreaPopulation);
-
-					if (iOffenseValue > 0 || iCounterValue > 0)
-					{
-						int iValue = (100 * pLoopCity->getPopulation()) / pLoopCity->getHighestPopulation();
-
-						iValue /= (3 + kTeam.AI_enemyCityDistance(pLoopCity->plot()));
-
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							pBestCity = pLoopCity;
-							eBestUnitAI = (iOffenseValue > iCounterValue) ? UNITAI_OFFENSIVE : UNITAI_COUNTER;
-						}
-					}
-				}
-			}
-		}
-
-		if (pBestCity == NULL)
-		{
-			break;
-		}
-		if (iInfiniteLoop > 100)
-		{
-			FAssertMsg(false, "Infinite Loop in Native War Preperations");
-			break;
-		}
-		CvUnit* pEjectUnit = pBestCity->AI_bestPopulationUnit(eBestUnitAI);
-		if (pEjectUnit == NULL)
-		{
-			FAssertMsg(false, "Could not eject unit");
-			break;
-		}
-	}
-}
-
-CvCity* CvPlayerAI::AI_getPrimaryCity()
-{
-	int iLoop;
-	CvCity* pCity = firstCity(&iLoop);
-	if (pCity != NULL)
-	{
-		return pCity;
-	}
-	return NULL;
-
-}
-
-int CvPlayerAI::AI_getOverpopulationPercent()
-{
-	int iCityPopulation = getTotalPopulation() - getNumUnits();
-
-	if (iCityPopulation <= 0)
-	{
-		return 0;
-	}
-
-	int iTargetPop = (iCityPopulation + getNumCities()) * (100 + 100 / GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAITrainPercent());
-	iTargetPop /= 100;
-
-	return (100 * getNumUnits() / std::max(1, iTargetPop) - 100);
-}
-
-int CvPlayerAI::AI_countNumHomedUnits(CvCity* pCity, UnitAITypes eUnitAI, UnitAIStates eUnitAIState)
-{
-	int iCount = 0;
-
-	int iLoop;
-	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-	{
-		if (pCity == NULL || pLoopUnit->getHomeCity() == pCity)
-		{
-			if (eUnitAI == NO_UNITAI || pLoopUnit->AI_getUnitAIType() == eUnitAI)
-			{
-				if (eUnitAIState == NO_UNITAI_STATE || pLoopUnit->AI_getUnitAIState() == eUnitAIState)
-				{
-					iCount++;
-				}
-			}
-		}
-	}
-
-	return iCount;
-}
-
-void CvPlayerAI::AI_doMilitaryStrategy()
-{
-
-	//Iterate over every enemy city.
-	//If we are sieging that city then evaluate the strength of our units vs the strength of the local defense (blah blah blah)
-
-	//If we are in a strong position : CHARGE
-	//If we are waiting for reinforcements: CAMP
-	//If we are weak and no reinforcements are coming: RETREAT
-
-	std::vector<UnitAITypes> militaryUnitAIs;
-
-	militaryUnitAIs.push_back(UNITAI_COUNTER);
-	militaryUnitAIs.push_back(UNITAI_OFFENSIVE);
-
-	CvTeamAI& kTeam = GET_TEAM(getTeam());
-	for (int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
-	{
-		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
-		WarPlanTypes eWarPlan = kTeam.AI_getWarPlan(kLoopPlayer.getTeam());
-		if (kLoopPlayer.isAlive() && (kLoopPlayer.getTeam() != getTeam()) && (eWarPlan != NO_WARPLAN))
-		{
-			bool bKnockKnock_WhoseThere_Monty_MontyWho_MontyAndHisHordeDieDieDie = false;
-			int iLoop;
-			CvCity* pLoopCity;
-			for (pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))
-			{
-				if (pLoopCity->plot()->isVisible(getTeam(), false) || isNative())
-				{
-					int iOurStrength = AI_sumAttackerStrength(pLoopCity->plot(), pLoopCity->plot(), 3, DOMAIN_LAND);
-					if ((iOurStrength > 0) && (GC.getGameINLINE().getSorenRandNum(100, "AI new wave") < 25))
-					{
-						//Only consider enemy strength for total war, otherwise dribble on in.
-						int iEnemyStrength = (eWarPlan == WARPLAN_TOTAL) ? AI_sumEnemyStrength(pLoopCity->plot(), 1, false, DOMAIN_LAND) : 0;
-						if ((iOurStrength * 100) > iEnemyStrength * 150)
-						{
-							AI_setUnitAIStatesRange(pLoopCity->plot(), 3, UNITAI_STATE_CHARGING, UNITAI_STATE_GROUPING, militaryUnitAIs);
-							bKnockKnock_WhoseThere_Monty_MontyWho_MontyAndHisHordeDieDieDie = true;
-						}
-					}
-				}
-			}
-
-			if (bKnockKnock_WhoseThere_Monty_MontyWho_MontyAndHisHordeDieDieDie)
-			{
-				if (!atWar(getTeam(), kLoopPlayer.getTeam()))
-				{
-					WarPlanTypes eNewWarplan = WARPLAN_TOTAL;
-
-					//Do the whole extortion thing
-					kTeam.declareWar(kLoopPlayer.getTeam(), true, eNewWarplan);
-				}
-			}
-		}
-	}
-	return;
-}
-
-void CvPlayerAI::AI_doSuppressRevolution()
-{
-	bool bContinue = false;
-	PlayerTypes eColony = NO_PLAYER;
-	for (int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
-	{
-		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
-		if (kLoopPlayer.isAlive())
-		{
-			if (GET_TEAM(getTeam()).isParentOf(kLoopPlayer.getTeam()))
-			{
-				if (atWar(getTeam(), kLoopPlayer.getTeam()))
-				{
-					eColony = (PlayerTypes)iPlayer;
-					bContinue = true;
-					break;
-				}
-			}
-		}
-	}
-
-	if (!bContinue)
-	{
-		return;
-	}
-
-	CvPlayerAI& kColony = GET_PLAYER(eColony);
-
-	if (!AI_isAnyStrategy())
-	{
-		AI_setStrategy(STRATEGY_SMALL_WAVES);
-
-		int iTactics = GC.getGameINLINE().getSorenRandNum(5, "AI Choose Strategy");
-		switch (iTactics)
-		{
-			case 0:
-			case 1:
-			case 2:
-				AI_setStrategy(STRATEGY_CONCENTRATED_ATTACK);
-				break;
-			case 3:
-			case 4:
-				AI_setStrategy(STRATEGY_DISTRIBUTED_ATTACK);
-				break;
-			default:
-				break;
-		}
-	}
-
-	if (GC.getGameINLINE().getSorenRandNum(100, "AI change King Strategy") < 33)
-	{
-		if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK) && (AI_getStrategyDuration(STRATEGY_CONCENTRATED_ATTACK) > 7))
-		{
-			AI_clearStrategy(STRATEGY_CONCENTRATED_ATTACK);
-
-			AI_setStrategy(STRATEGY_DISTRIBUTED_ATTACK);
-		}
-		else if (AI_isStrategy(STRATEGY_DISTRIBUTED_ATTACK) && (AI_getStrategyDuration(STRATEGY_DISTRIBUTED_ATTACK) > 4))
-		{
-			AI_clearStrategy(STRATEGY_DISTRIBUTED_ATTACK);
-
-			AI_setStrategy(STRATEGY_CONCENTRATED_ATTACK);
-		}
-	}
-
-	if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK) && AI_getStrategyData(STRATEGY_CONCENTRATED_ATTACK) == -1)
-	{
-		int iBestValue = 0;
-		CvPlot* pBestPlot = NULL;
-		//Select a target city.
-		int iLoop;
-		CvCity* pLoopCity;
-		for (pLoopCity = kColony.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kColony.nextCity(&iLoop))
-		{
-			if (pLoopCity->plot()->getNearestEurope() != NO_EUROPE)
-			{
-				int iValue = pLoopCity->getHighestPopulation() * 50 + pLoopCity->plot()->getCrumbs();
-
-				iValue *= 25 + GC.getGameINLINE().getSorenRandNum(75, "AI choose target for concentrated attack");
-				if (iValue > iBestValue)
-				{
-					iBestValue = iValue;
-					pBestPlot = pLoopCity->plot();
-				}
-			}
-		}
-		if (pBestPlot != NULL)
-		{
-			AI_setStrategy(STRATEGY_CONCENTRATED_ATTACK, GC.getMap().plotNum(pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE()));
-		}
-	}
-
-	int iShipCount = 0;
-	int iSoldierCount = 0;
-	int iCargoSpace = 0;
-
-	std::vector<CvUnit*> ships;
-	std::vector<CvUnit*> soldiers;
-
-	int iLoop;
-	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-	{
-		if (pLoopUnit->getDomainType() == DOMAIN_SEA)
-		{
-			if (pLoopUnit->getUnitTravelState() == UNIT_TRAVEL_STATE_IN_EUROPE)
-			{
-				ships.push_back(pLoopUnit);
-				iShipCount++;
-				iCargoSpace += pLoopUnit->cargoSpace();
-			}
-	    }
-	}
-
-	std::vector<int> shuffle(getNumEuropeUnits());
-	for (int i = 0; i < getNumEuropeUnits(); ++i)
-	{
-		shuffle[i] = i;
-	}
-	GC.getGameINLINE().getSorenRand().shuffleArray(shuffle, NULL);
-
-	for (int i = 0; i < getNumEuropeUnits(); ++i)
-	{
-		CvUnit* pLoopUnit = getEuropeUnit(shuffle[i]);
-		FAssert(pLoopUnit != NULL);
-        if (pLoopUnit->getDomainType() == DOMAIN_LAND)
-		{
-			soldiers.push_back(pLoopUnit);
-			iSoldierCount++;
-		}
-	}
-
-	if (iShipCount == 0)
-	{
-		//FAssertMsg(iSoldierCount == 0, "Uh oh, soldiers stuck in europe");
-		return;
-	}
-
-	int iTotalShipCount = AI_getNumAIUnits(UNITAI_COMBAT_SEA);
-
-	int iShipsToLaunch = 0;
-
-	if (AI_isStrategy(STRATEGY_SMALL_WAVES))//Set at start of revolution.
-	{
-		iShipsToLaunch = (iTotalShipCount + 9) / 10;
-	}
-	else if (AI_isStrategy(STRATEGY_BUILDUP))//Set when first ship gets back.
-	{
-		if (iShipCount > (iTotalShipCount / 2))
-		{
-			iShipsToLaunch = (iTotalShipCount + 2) / 3;
-
-			AI_clearStrategy(STRATEGY_BUILDUP);
-			AI_setStrategy(STRATEGY_SMALL_WAVES);
-		}
-	}
-
-	int iMinWaveSize = 3;
-
-	if (iShipCount < iMinWaveSize)
-	{
-		if (iTotalShipCount >= iMinWaveSize)
-		{
-			return;
-		}
-	}
-
-	iShipsToLaunch = std::max(iShipsToLaunch, iMinWaveSize);
-	iShipsToLaunch = std::min(iShipsToLaunch, iShipCount);
-
-
-	int iSoldiersToLoad = 0;
-
-	int iMaxCargo = iCargoSpace * iShipsToLaunch / iShipCount;
-	if (iSoldierCount < iMaxCargo)
-	{
-		iSoldiersToLoad = iSoldierCount;
-	}
-	else if (iSoldierCount < iMaxCargo * 2)
-	{
-		iSoldiersToLoad = iSoldierCount / 2;
-	}
-	else
-	{
-		iSoldiersToLoad = iMaxCargo;
-	}
-
-	if (iSoldiersToLoad > 0)
-	{
-		int iSoldiersLoaded = 0;
-		for (int i = 0; i < iShipCount; ++i)
-		{
-			CvUnit* pLoopUnit = ships[i];
-			FAssert(pLoopUnit != NULL);
-			if (i < iShipsToLaunch)
-			{
-				while (iSoldiersLoaded < iSoldiersToLoad)
-				{
-					CvUnit* pSoldier = soldiers[iSoldiersLoaded];
-					FAssert(pSoldier != NULL);
-
-					iSoldiersLoaded++;
-					loadUnitFromEurope(pSoldier, pLoopUnit);
-					if (pLoopUnit->isFull())
-					{
-						break;
-					}
-				}
-
-				CvPlot* pTargetPlot = AI_getImperialShipSpawnPlot();
-
-				if (!pLoopUnit->atPlot(pTargetPlot))
-				{
-					pLoopUnit->setXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), false, false, false);
-				}
-
-
-				pLoopUnit->crossOcean(UNIT_TRAVEL_STATE_FROM_EUROPE);
-			}
-		}
-	}
-	else if (iSoldierCount == 0)
-	{
-		//Lets wander around the New World!
-		for (int i = 0; i < iShipCount; ++i)
-		{
-			CvUnit* pLoopUnit = ships[i];
-			FAssert(pLoopUnit != NULL);
-
-			CvPlot* pTargetPlot = AI_getImperialShipSpawnPlot();
-
-			if (!pLoopUnit->atPlot(pTargetPlot))
-			{
-				pLoopUnit->setXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), false, false, false);
-			}
-
-			pLoopUnit->crossOcean(UNIT_TRAVEL_STATE_FROM_EUROPE);
-		}
-	}
-
-}
-
-void CvPlayerAI::AI_doUnitAIWeights()
-{
-	if ((GC.getGame().getGameTurn() == 2) || (GC.getGameINLINE().getSorenRandNum(50, "AI do Unit AI Weight Calculations") == 0))
-	for (int i = 0; i < NUM_UNITAI_TYPES; ++i)
-	{
-		int iWeight = 90 + GC.getGameINLINE().getSorenRandNum(20, "AI Unit AI Weights");
-
-		m_aiUnitAIStrategyWeights[i] = iWeight;
-	}
-}
-
-void CvPlayerAI::AI_doEmotions()
-{
-	CvMap& kMap = GC.getMap();
-
-	std::vector<short> const &distanceMap = *AI_getDistanceMap();
-
-	int iGreedValue = 0;
-	int iAnxietyValue = 0;
-	int iAngerValue = 0;
-	int iEnvyValue = 0;
-
-	for (int i = 0; i < kMap.numPlotsINLINE(); ++i)
-	{
-		CvPlot* pLoopPlot = kMap.plotByIndexINLINE(i);
-		if (distanceMap[i] != -1)
-		{
-			if (!pLoopPlot->isOwned())
-			{
-				if (pLoopPlot->getBonusType() != NO_BONUS)
-				{
-					if (pLoopPlot->isWater())
-					{
-						iGreedValue += 1;
-					}
-					else
-					{
-						iGreedValue += 2;
-					}
-				}
-			}
-			if (pLoopPlot->isVisible(getTeam(), false))
-			{
-				int iEnemyUnits = 0;
-				int iFriendlyUnits = 0;
-				int iNeutralColonialUnits = 0;
-				int iTreasureUnits = 0;
-
-
-				CLLNode<IDInfo>* pUnitNode;
-				CvUnit* pLoopUnit;
-				pUnitNode = pLoopPlot->headUnitNode();
-
-				while (pUnitNode != NULL)
-				{
-					pLoopUnit = ::getUnit(pUnitNode->m_data);
-					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-					if (pLoopUnit->getTeam() == getTeam())
-					{
-						iFriendlyUnits++;
-					}
-					else if (pLoopUnit->isEnemy(getTeam(), pLoopPlot))
-					{
-						iEnemyUnits++;
-					}
-					else
-					{
-						if (!pLoopUnit->isNative())
-						{
-							iNeutralColonialUnits++;
-						}
-					}
-
-					if (pLoopUnit->getTeam() != getTeam())
-					{
-						if ((pLoopUnit->getUnitInfo().isTreasure()) && pLoopUnit->getYieldStored() > 0)
-						{
-							iEnvyValue += pLoopUnit->getYieldStored() / 40;
-						}
-					}
-
-					if (pLoopPlot->getOwnerINLINE() == getID())
-					{
-						iAnxietyValue += 5 * iEnemyUnits;
-						if (isNative())
-						{
-							iAngerValue += 3 * iNeutralColonialUnits;
-						}
-					}
-					else
-					{
-						if (isNative())
-						{
-							iAngerValue += iNeutralColonialUnits;
-						}
-						iAngerValue += 1 * iEnemyUnits;
-						iAnxietyValue += 1 * iEnemyUnits;
-					}
-				}
-			}
-		}
-	}
-	iGreedValue /= 2;
-	AI_changeEmotion(EMOTION_GREED, iGreedValue);
-	AI_changeEmotion(EMOTION_ANXIETY, iAnxietyValue);
-	AI_changeEmotion(EMOTION_ANGER, iAngerValue);
-
-	//Anxiety
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (!pLoopCity->AI_isDefended())
-		{
-			AI_changeEmotion(EMOTION_ANXIETY, pLoopCity->getPopulation());
-		}
-	}
-}
-
-void CvPlayerAI::AI_doStrategy()
-{
-	int iGameTurn = GC.getGameINLINE().getGameTurn();
-	CvTeamAI& kTeam = GET_TEAM(getTeam());
-
-	int iPercent = 10000 / GC.getGame().AI_adjustedTurn(100);;
-
-	if (getParent() != NO_PLAYER)
-	{
-		if (iGameTurn == 1)
-		{
-			AI_setStrategy(STRATEGY_CASH_FOCUS);
-			AI_setStrategy(STRATEGY_SELL_TO_NATIVES);
-		}
-
-		if (iGameTurn == GC.getGameINLINE().AI_adjustedTurn(10))
-		{
-			//Set initial strategies.
-			if (GC.getGame().getSorenRandNum(100, "AI Fast Bells") < 30)
-			{
-				AI_setStrategy(STRATEGY_FAST_BELLS);
-			}
-
-			if (GC.getGameINLINE().getSorenRandNum(100, "AI Dense Spacing") < 50)
-			{
-				AI_setStrategy(STRATEGY_DENSE_CITY_SPACING);
-			}
-		}
-
-		if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-		{
-			if (!AI_isStrategy(STRATEGY_FAST_BELLS) && GC.getGameINLINE().getSorenRandNum(10000, "AI Fast Bells") < (2 * iPercent))
-			{
-				AI_setStrategy(STRATEGY_FAST_BELLS);
-			}
-
-			if (iGameTurn > GC.getGameINLINE().AI_adjustedTurn(35))
-			{
-				if (AI_isStrategy(STRATEGY_CASH_FOCUS) && GC.getGameINLINE().getSorenRandNum(10000, "AI Cash Focus") < (3 * iPercent))
-				{
-					AI_clearStrategy(STRATEGY_CASH_FOCUS);
-				}
-			}
-
-			if (!AI_isStrategy(STRATEGY_SELL_TO_NATIVES) && GC.getGameINLINE().getSorenRandNum(10000, "AI Sell to Natives") < (6 * iPercent))
-			{
-				AI_setStrategy(STRATEGY_SELL_TO_NATIVES);
-			}
-
-			if (GC.getGameINLINE().getSorenRandNum(10000, "AI toggle spacing strategy") < (4 * iPercent))
-			{
-				if (AI_isStrategy(STRATEGY_DENSE_CITY_SPACING))
-				{
-					AI_clearStrategy(STRATEGY_DENSE_CITY_SPACING);
-				}
-				else
-				{
-					AI_setStrategy(STRATEGY_DENSE_CITY_SPACING);
-				}
-			}
-		}
-
-		if (iGameTurn > GC.getGameINLINE().AI_adjustedTurn(100))
-		{
-			int iProb = 3 * iPercent;
-			int iRebelPercent = GET_TEAM(getTeam()).getRebelPercent();
-			iProb *= (100 + iRebelPercent + ((200 * iGameTurn) / GC.getGameINLINE().getEstimateEndTurn()));
-			iProb /= 100;
-
-			if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-			{
-				if (GC.getGameINLINE().getSorenRandNum(10000, "AI Start Revolution") < iProb)
-				{
-					AI_setStrategy(STRATEGY_REVOLUTION_PREPARING);
-					AI_clearStrategy(STRATEGY_FAST_BELLS);
-				}
-			}
-			else if (!AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
-			{
-				if ((iRebelPercent > 70) &&  (AI_getStrategyDuration(STRATEGY_REVOLUTION_PREPARING) > GC.getGameINLINE().AI_adjustedTurn(20)))
-				{
-					if (GC.getGameINLINE().getSorenRandNum(10000, "AI Start Revolution") < iProb * 6)
-					{
-						AI_setStrategy(STRATEGY_REVOLUTION_DECLARING);
-					}
-				}
-			}
-			else
-			{
-				FAssert(AI_isStrategy(STRATEGY_REVOLUTION_DECLARING));
-				if (AI_getStrategyDuration(STRATEGY_REVOLUTION_DECLARING) > GC.getGameINLINE().AI_adjustedTurn(20))
-				{
-				    ///TKs Med
-					int iValue = iRebelPercent + 100 * AI_getStrategyDuration(STRATEGY_REVOLUTION_DECLARING) / GC.getGameINLINE().AI_adjustedTurn(50);
-
-					if (iValue > 125)
-					{
-					    int iID = getID();
-					    int iDefendersNeeded = AI_totalDefendersNeeded(NULL);
-					    int iTechValues = 0;
-					    for (int iI = 0; iI < GC.getNumCivicInfos(); iI++)
-                        {
-                            if (getIdeasResearched((CivicTypes)iI) > 0)
-                            {
-                                iTechValues += GC.getCivicInfo((CivicTypes)iI).getAIWeight();
-                            }
-                        }
-                        iTechValues += iValue;
-
-					    int iValueB =  iDefendersNeeded - AI_totalUnitAIs(UNITAI_OFFENSIVE) - AI_totalUnitAIs(UNITAI_COUNTER) - getNumCities();
-						if (iValueB <= 0 && iTechValues >= 1700)
-						{
-							if (kTeam.canDoRevolution())
-							{
-							    char szTKdebug[1024];
-                                sprintf( szTKdebug, "Player %d is Revolting in the turn %d with %d defenders needed\n", getID(), GC.getGameINLINE().getGameTurn(), AI_totalDefendersNeeded(NULL));
-                                gDLL->messageControlLog(szTKdebug);
-								kTeam.doRevolution();
-								AI_setStrategy(STRATEGY_REVOLUTION);
-							}
-						}
-					}
-					///Tks
-				}
-			}
-		}
-	}
-
-	if (isNative())
-	{
-		if (AI_isStrategy(STRATEGY_DIE_FIGHTING))
-		{
-			if (AI_getNumAIUnits(UNITAI_OFFENSIVE) == 0)
-			{
-				AI_clearStrategy(STRATEGY_DIE_FIGHTING);
-			}
-		}
-		else if (kTeam.getAnyWarPlanCount() > 0)
-		{
-			for (int i = 0; i < MAX_PLAYERS; ++i)
-			{
-				PlayerTypes eLoopPlayer = (PlayerTypes)i;
-				if (GET_PLAYER(eLoopPlayer).isAlive())
-				{
-					TeamTypes eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();
-					if (kTeam.isAtWar((TeamTypes)i))
-					{
-						WarPlanTypes eWarPlan = kTeam.AI_getWarPlan(eLoopTeam);
-						int iDuration = kTeam.AI_getWarPlanStateCounter(eLoopTeam);
-
-						bool bRazedCity = AI_getMemoryAttitude(eLoopPlayer, MEMORY_RAZED_CITY) > 0;
-
-						if (eWarPlan == WARPLAN_ATTACKED || eWarPlan == WARPLAN_TOTAL)
-						{
-							AI_setStrategy(STRATEGY_DIE_FIGHTING);
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-int CvPlayerAI::AI_countDeadlockedBonuses(CvPlot* pPlot)
-{
-    CvPlot* pLoopPlot;
-    CvPlot* pLoopPlot2;
-    int iDX, iDY;
-    int iI;
-
-    int iMinRange = GC.getMIN_CITY_RANGE();
-    int iRange = iMinRange * 2;
-    int iCount = 0;
-
-    for (iDX = -(iRange); iDX <= iRange; iDX++)
-    {
-        for (iDY = -(iRange); iDY <= iRange; iDY++)
-        {
-            if (plotDistance(iDX, iDY, 0, 0) > CITY_PLOTS_RADIUS)
-            {
-                pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-
-                if (pLoopPlot != NULL)
-                {
-                    if (pLoopPlot->getBonusType() != NO_BONUS)
-                    {
-                        if (!pLoopPlot->isCityRadius() && ((pLoopPlot->area() == pPlot->area()) || pLoopPlot->isWater()))
-                        {
-                            bool bCanFound = false;
-                            bool bNeverFound = true;
-                            //potentially blockable resource
-                            //look for a city site within a city radius
-                            for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
-                            {
-                                pLoopPlot2 = plotCity(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), iI);
-                                if (pLoopPlot2 != NULL)
-                                {
-                                    //canFound usually returns very quickly
-                                    if (canFound(pLoopPlot2->getX_INLINE(), pLoopPlot2->getY_INLINE(), false))
-                                    {
-                                        bNeverFound = false;
-                                        if (stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot2->getX_INLINE(), pLoopPlot2->getY_INLINE()) > iMinRange)
-                                        {
-                                            bCanFound = true;
-                                            break;
-                                        }
-                                    }
-                                }
-                            }
-                            if (!bNeverFound && !bCanFound)
-                            {
-                                iCount++;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    return iCount;
-}
-
-int CvPlayerAI::AI_getOurPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves)
-{
-	PROFILE_FUNC();
-
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	CvPlot* pLoopPlot;
-	int iValue;
-	int iDistance;
-	int iDX, iDY;
-
-	iValue = 0;
-
-	for (iDX = -(iRange); iDX <= iRange; iDX++)
-	{
-		for (iDY = -(iRange); iDY <= iRange; iDY++)
-		{
-			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-
-			if (pLoopPlot != NULL)
-			{
-				if (pLoopPlot->area() == pPlot->area())
-				{
-				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
-					pUnitNode = pLoopPlot->headUnitNode();
-
-					while (pUnitNode != NULL)
-					{
-						pLoopUnit = ::getUnit(pUnitNode->m_data);
-						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-						if (pLoopUnit->getOwnerINLINE() == getID())
-						{
-							if ((bDefensiveBonuses && pLoopUnit->canDefend()) || pLoopUnit->canAttack())
-							{
-								if (!(pLoopUnit->isInvisible(getTeam(), false)))
-								{
-								    if (pLoopUnit->atPlot(pPlot) || pLoopUnit->canMoveInto(pPlot) || pLoopUnit->canMoveInto(pPlot, /*bAttack*/ true))
-								    {
-                                        if (!bTestMoves)
-                                        {
-                                        	iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
-                                        }
-                                        else
-                                        {
-											if (pLoopUnit->baseMoves() >= iDistance)
-                                            {
-                                                iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
-                                            }
-                                        }
-								    }
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-
-	return iValue;
-}
-
-int CvPlayerAI::AI_getEnemyPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves)
-{
-	PROFILE_FUNC();
-
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	CvPlot* pLoopPlot;
-	int iValue;
-	int iDistance;
-	int iDX, iDY;
-
-	iValue = 0;
-
-	for (iDX = -(iRange); iDX <= iRange; iDX++)
-	{
-		for (iDY = -(iRange); iDY <= iRange; iDY++)
-		{
-			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
-
-			if (pLoopPlot != NULL)
-			{
-				if (pLoopPlot->area() == pPlot->area())
-				{
-				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
-					pUnitNode = pLoopPlot->headUnitNode();
-
-					while (pUnitNode != NULL)
-					{
-						pLoopUnit = ::getUnit(pUnitNode->m_data);
-						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-						if (atWar(pLoopUnit->getTeam(), getTeam()))
-						{
-							if ((bDefensiveBonuses && pLoopUnit->canDefend()) || pLoopUnit->canAttack())
-							{
-								if (!(pLoopUnit->isInvisible(getTeam(), false)))
-								{
-								    if (pPlot->isValidDomainForAction(*pLoopUnit))
-								    {
-                                        if (!bTestMoves)
-                                        {
-                                            iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
-                                        }
-                                        else
-                                        {
-                                            int iDangerRange = pLoopUnit->baseMoves();
-                                            iDangerRange += ((pLoopPlot->isValidRoute(pLoopUnit)) ? 1 : 0);
-                                            if (iDangerRange >= iDistance)
-                                            {
-                                                iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
-                                            }
-                                        }
-								    }
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-
-	return iValue;
-
-}
-
-int CvPlayerAI::AI_goldToUpgradeAllUnits(int iExpThreshold)
-{
-	if (m_iUpgradeUnitsCacheTurn == GC.getGameINLINE().getGameTurn() && m_iUpgradeUnitsCachedExpThreshold == iExpThreshold)
-	{
-		return m_iUpgradeUnitsCachedGold;
-	}
-
-	int iTotalGold = 0;
-
-	CvCivilizationInfo& kCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
-
-	// cache the value for each unit type
-	std::vector<int> aiUnitUpgradePrice(GC.getNumUnitInfos(), 0);	// initializes to zeros
-
-	int iLoop;
-	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-	{
-		// if experience is below threshold, skip this unit
-		if (pLoopUnit->getExperience() < iExpThreshold)
-		{
-			continue;
-		}
-
-		UnitTypes eUnitType = pLoopUnit->getUnitType();
-
-		// check cached value for this unit type
-		int iCachedUnitGold = aiUnitUpgradePrice[eUnitType];
-		if (iCachedUnitGold != 0)
-		{
-			// if positive, add it to the sum
-			if (iCachedUnitGold > 0)
-			{
-				iTotalGold += iCachedUnitGold;
-			}
-
-			// either way, done with this unit
-			continue;
-		}
-
-		int iUnitGold = 0;
-		int iUnitUpgradePossibilities = 0;
-
-		UnitAITypes eUnitAIType = pLoopUnit->AI_getUnitAIType();
-		CvArea* pUnitArea = pLoopUnit->area();
-		int iUnitValue = AI_unitValue(eUnitType, eUnitAIType, pUnitArea);
-
-		for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-		{
-			UnitClassTypes eUpgradeUnitClassType = (UnitClassTypes) iI;
-			UnitTypes eUpgradeUnitType = (UnitTypes)(kCivilizationInfo.getCivilizationUnits(iI));
-
-			if (NO_UNIT != eUpgradeUnitType)
-			{
-				// is it better?
-				int iUpgradeValue = AI_unitValue(eUpgradeUnitType, eUnitAIType, pUnitArea);
-				if (iUpgradeValue > iUnitValue)
-				{
-					// is this a valid upgrade?
-					if (pLoopUnit->upgradeAvailable(eUnitType, eUpgradeUnitClassType))
-					{
-						// can we actually make this upgrade?
-						bool bCanUpgrade = false;
-						CvCity* pCapitalCity = getPrimaryCity();
-						if (pCapitalCity != NULL && pCapitalCity->canTrain(eUpgradeUnitType))
-						{
-							bCanUpgrade = true;
-						}
-						else
-						{
-							CvCity* pCloseCity = GC.getMapINLINE().findCity(pLoopUnit->getX_INLINE(), pLoopUnit->getY_INLINE(), getID(), NO_TEAM, true, (pLoopUnit->getDomainType() == DOMAIN_SEA));
-							if (pCloseCity != NULL && pCloseCity->canTrain(eUpgradeUnitType))
-							{
-								bCanUpgrade = true;
-							}
-						}
-
-						if (bCanUpgrade)
-						{
-							iUnitGold += pLoopUnit->upgradePrice(eUpgradeUnitType);
-							iUnitUpgradePossibilities++;
-						}
-					}
-				}
-			}
-		}
-
-		// if we found any, find average and add to total
-		if (iUnitUpgradePossibilities > 0)
-		{
-			iUnitGold /= iUnitUpgradePossibilities;
-
-			// add to cache
-			aiUnitUpgradePrice[eUnitType] = iUnitGold;
-
-			// add to sum
-			iTotalGold += iUnitGold;
-		}
-		else
-		{
-			// add to cache, dont upgrade to this type
-			aiUnitUpgradePrice[eUnitType] = -1;
-		}
-	}
-
-	m_iUpgradeUnitsCacheTurn = GC.getGameINLINE().getGameTurn();
-	m_iUpgradeUnitsCachedExpThreshold = iExpThreshold;
-	m_iUpgradeUnitsCachedGold = iTotalGold;
-
-	return iTotalGold;
-}
-
-int CvPlayerAI::AI_goldTradeValuePercent()
-{
-	return 100;
-}
-
-int CvPlayerAI::AI_playerCloseness(PlayerTypes eIndex, int iMaxDistance)
-{
-	PROFILE_FUNC();
-	CvCity* pLoopCity;
-	int iLoop;
-	int iValue;
-
-	FAssert(GET_PLAYER(eIndex).isAlive());
-	FAssert(eIndex != getID());
-
-	iValue = 0;
-	for (pLoopCity = GET_PLAYER(eIndex).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eIndex).nextCity(&iLoop))
-	{
-		iValue += pLoopCity->AI_playerCloseness(eIndex, iMaxDistance);
-	}
-
-	return iValue;
-}
-
-int CvPlayerAI::AI_targetValidity(PlayerTypes ePlayer)
-{
-	FAssert(ePlayer != NO_PLAYER);
-
-	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
-
-	if (!kPlayer.isAlive())
-	{
-		return 0;
-	}
-	if (kPlayer.getTeam() == getTeam())
-	{
-		return 0;
-	}
-
-	int iAggressionRange = 10;
-	if (isNative())
-	{
-		iAggressionRange = 5;
-	}
-
-	int iValidTargetCount = 0;
-	int iTotalValue = 0;
-
-	if (!kPlayer.isAlive())
-	{
-		return 0;
-	}
-
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
-	{
-		bool bLandTarget = (pLoopCity->area()->getCitiesPerPlayer(getID()) > 0);
-
-		if (bLandTarget || !isNative())
-		{
-			int iDistance = AI_cityDistance(pLoopCity->plot());
-			int iAdjustedRange = iAggressionRange;
-			if (!bLandTarget)
-			{
-				iAdjustedRange *= 2;
-			}
-
-			if (iDistance <= iAdjustedRange)
-			{
-				iTotalValue += 100 - (100 * (iDistance - 1)) / iAdjustedRange;
-				iValidTargetCount++;
-			}
-		}
-	}
-
-	int iValue = (2 * iTotalValue) / (1 + kPlayer.getNumCities() + iValidTargetCount);
-	return iValue;
-}
-
-int CvPlayerAI::AI_totalDefendersNeeded(int* piUndefendedCityCount)
-{
-	PROFILE_FUNC();
-	CvCity* pLoopCity;
-	int iLoop;
-	int iValue;
-
-	int iTotalNeeded = 0;
-	int iUndefendedCount = 0;
-
-	iValue = 0;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		int iHave = pLoopCity->AI_numDefenders(true, true);
-		int iNeeded = pLoopCity->AI_neededDefenders();
-
-		if (iNeeded > 0)
-		{
-			if (iHave == 0)
-			{
-				iUndefendedCount++;
-			}
-			iTotalNeeded += iNeeded - iHave;
-		}
-	}
-
-	if (piUndefendedCityCount != NULL)
-	{
-		*piUndefendedCityCount = iUndefendedCount;
-	}
-
-	return iTotalNeeded;
-}
-
-
-int CvPlayerAI::AI_getTotalAreaCityThreat(CvArea* pArea)
-{
-	PROFILE_FUNC();
-	CvCity* pLoopCity;
-	int iLoop;
-	int iValue;
-
-	iValue = 0;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity->getArea() == pArea->getID())
-		{
-			iValue += pLoopCity->AI_cityThreat();
-		}
-	}
-	return iValue;
-}
-
-int CvPlayerAI::AI_countNumAreaHostileUnits(CvArea* pArea, bool bPlayer, bool bTeam, bool bNeutral, bool bHostile)
-{
-	PROFILE_FUNC();
-	CvPlot* pLoopPlot;
-	int iCount;
-	int iI;
-
-	iCount = 0;
-
-	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-	{
-		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-		if ((pLoopPlot->area() == pArea) && pLoopPlot->isVisible(getTeam(), false) &&
-			((bPlayer && pLoopPlot->getOwnerINLINE() == getID()) || (bTeam && pLoopPlot->getTeam() == getTeam())
-				|| (bNeutral && !pLoopPlot->isOwned()) || (bHostile && pLoopPlot->isOwned() && GET_TEAM(getTeam()).isAtWar(pLoopPlot->getTeam()))))
-			{
-			iCount += pLoopPlot->plotCount(PUF_isEnemy, getID(), false, NO_PLAYER, NO_TEAM, PUF_isVisible, getID());
-		}
-	}
-	return iCount;
-}
-
-//this doesn't include the minimal one or two garrison units in each city.
-int CvPlayerAI::AI_getTotalFloatingDefendersNeeded(CvArea* pArea)
-{
-	PROFILE_FUNC();
-	int iDefenders;
-	int iCurrentEra = getCurrentEra();
-	int iAreaCities = pArea->getCitiesPerPlayer(getID());
-
-	iCurrentEra = std::max(0, iCurrentEra - GC.getGame().getStartEra() / 2);
-
-	iDefenders = 1 + ((iCurrentEra + ((GC.getGameINLINE().getMaxCityElimination() > 0) ? 3 : 2)) * iAreaCities);
-	iDefenders /= 3;
-	iDefenders += pArea->getPopulationPerPlayer(getID()) / 7;
-
-	if (pArea->getAreaAIType(getTeam()) == AREAAI_DEFENSIVE)
-	{
-		iDefenders *= 2;
-	}
-	else if ((pArea->getAreaAIType(getTeam()) == AREAAI_OFFENSIVE) || (pArea->getAreaAIType(getTeam()) == AREAAI_MASSING))
-	{
-		iDefenders *= 2;
-		iDefenders /= 3;
-	}
-
-	if (AI_getTotalAreaCityThreat(pArea) == 0)
-	{
-		iDefenders /= 2;
-	}
-
-	if (!GC.getGameINLINE().isOption(GAMEOPTION_AGGRESSIVE_AI))
-	{
-		iDefenders *= 2;
-		iDefenders /= 3;
-	}
-
-	iDefenders *= 60;
-	iDefenders /= std::max(30, (GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAITrainPercent() - 20));
-
-	if (getPrimaryCity() != NULL)
-	{
-		if (getPrimaryCity()->area() != pArea)
-		{
-			//Defend offshore islands only lightly.
-			iDefenders = std::min(iDefenders, iAreaCities * iAreaCities - 1);
-		}
-	}
-
-	return iDefenders;
-}
-
-int CvPlayerAI::AI_getTotalFloatingDefenders(CvArea* pArea)
-{
-	PROFILE_FUNC();
-	int iCount = 0;
-
-	iCount += AI_totalAreaUnitAIs(pArea, UNITAI_DEFENSIVE);
-	iCount += AI_totalAreaUnitAIs(pArea, UNITAI_OFFENSIVE);
-	iCount += AI_totalAreaUnitAIs(pArea, UNITAI_COUNTER);
-	return iCount / 2;
-}
-
-RouteTypes CvPlayerAI::AI_bestAdvancedStartRoute(CvPlot* pPlot, int* piYieldValue)
-{
-	RouteTypes eBestRoute = NO_ROUTE;
-	int iBestValue = -1;
-    for (int iI = 0; iI < GC.getNumRouteInfos(); iI++)
-    {
-        RouteTypes eRoute = (RouteTypes)iI;
-
-		int iValue = 0;
-		int iCost = getAdvancedStartRouteCost(eRoute, true, pPlot);
-
-		if (iCost >= 0)
-		{
-			iValue += GC.getRouteInfo(eRoute).getValue();
-
-			if (iValue > 0)
-			{
-				int iYieldValue = 0;
-				if (pPlot->getImprovementType() != NO_IMPROVEMENT)
-				{
-					iYieldValue += ((GC.getImprovementInfo(pPlot->getImprovementType()).getRouteYieldChanges(eRoute, YIELD_FOOD)) * 100);
-				}
-				iValue *= 1000;
-				iValue /= (1 + iCost);
-
-				if (iValue > iBestValue)
-				{
-					iBestValue = iValue;
-					eBestRoute = eRoute;
-					if (piYieldValue != NULL)
-					{
-						*piYieldValue = iYieldValue;
-					}
-				}
-			}
-		}
-	}
-	return eBestRoute;
-}
-
-UnitTypes CvPlayerAI::AI_bestAdvancedStartUnitAI(CvPlot* pPlot, UnitAITypes eUnitAI)
-{
-	UnitTypes eLoopUnit;
-	UnitTypes eBestUnit;
-	int iValue;
-	int iBestValue;
-	int iI, iJ, iK;
-
-	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
-
-	iBestValue = 0;
-	eBestUnit = NO_UNIT;
-
-	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
-
-		if (eLoopUnit != NO_UNIT)
-		{
-			if (GC.getUnitInfo(eLoopUnit).getDefaultUnitAIType() == eUnitAI)
-			{
-				int iUnitCost = getAdvancedStartUnitCost(eLoopUnit, true, pPlot);
-				if (iUnitCost >= 0)
-				{
-					iValue = AI_unitValue(eLoopUnit, eUnitAI, pPlot->area());
-
-					if (iValue > 0)
-					{
-						//free promotions. slow?
-						//only 1 promotion per source is counted (ie protective isn't counted twice)
-						int iPromotionValue = 0;
-
-						//special to the unit
-						for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
-						{
-							if (GC.getUnitInfo(eLoopUnit).getFreePromotions(iJ))
-							{
-								iPromotionValue += 15;
-								break;
-							}
-						}
-
-						for (iK = 0; iK < GC.getNumPromotionInfos(); iK++)
-						{
-							if (isFreePromotion((UnitCombatTypes)GC.getUnitInfo(eLoopUnit).getUnitCombatType(), (PromotionTypes)iK))
-							{
-								iPromotionValue += 15;
-								break;
-							}
-
-							if (isFreePromotion((UnitClassTypes)GC.getUnitInfo(eLoopUnit).getUnitClassType(), (PromotionTypes)iK))
-							{
-								iPromotionValue += 15;
-								break;
-							}
-						}
-
-						//traits
-						for (iJ = 0; iJ < GC.getNumTraitInfos(); iJ++)
-						{
-							if (hasTrait((TraitTypes)iJ))
-							{
-								for (iK = 0; iK < GC.getNumPromotionInfos(); iK++)
-								{
-									if (GC.getTraitInfo((TraitTypes) iJ).isFreePromotion(iK))
-									{
-										if ((GC.getUnitInfo(eLoopUnit).getUnitCombatType() != NO_UNITCOMBAT) && GC.getTraitInfo((TraitTypes) iJ).isFreePromotionUnitCombat(GC.getUnitInfo(eLoopUnit).getUnitCombatType()))
-										{
-											iPromotionValue += 15;
-											break;
-										}
-									}
-								}
-							}
-						}
-
-						iValue *= (iPromotionValue + 100);
-						iValue /= 100;
-
-						iValue *= (GC.getGameINLINE().getSorenRandNum(40, "AI Best Advanced Start Unit") + 100);
-						iValue /= 100;
-
-						iValue *= (getNumCities() + 2);
-						iValue /= (getUnitClassCountPlusMaking((UnitClassTypes)iI) + getNumCities() + 2);
-
-						FAssert((MAX_INT / 1000) > iValue);
-						iValue *= 1000;
-
-						iValue /= 1 + iUnitCost;
-
-						iValue = std::max(1, iValue);
-
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							eBestUnit = eLoopUnit;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return eBestUnit;
-}
-
-CvPlot* CvPlayerAI::AI_advancedStartFindCapitalPlot()
-{
-	CvPlot* pBestPlot = NULL;
-	int iBestValue = -1;
-
-	for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
-	{
-		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
-		if (kPlayer.isAlive())
-		{
-			if (kPlayer.getTeam() == getTeam())
-			{
-				CvPlot* pLoopPlot = kPlayer.getStartingPlot();
-				if (pLoopPlot != NULL)
-				{
-					if (getAdvancedStartCityCost(true, pLoopPlot) > 0)
-					{
-					int iX = pLoopPlot->getX_INLINE();
-					int iY = pLoopPlot->getY_INLINE();
-
-						int iValue = 1000;
-						if (iPlayer == getID())
-						{
-							iValue += 1000;
-						}
-						else
-						{
-							iValue += GC.getGame().getSorenRandNum(100, "AI Advanced Start Choose Team Start");
-						}
-						CvCity * pNearestCity = GC.getMapINLINE().findCity(iX, iY, NO_PLAYER, getTeam());
-						if (NULL != pNearestCity)
-						{
-							FAssert(pNearestCity->getTeam() == getTeam());
-							int iDistance = stepDistance(iX, iY, pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE());
-							if (iDistance < 10)
-							{
-								iValue /= (10 - iDistance);
-							}
-						}
-
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							pBestPlot = pLoopPlot;
-						}
-					}
-				}
-				else
-				{
-					FAssertMsg(false, "StartingPlot for a live player is NULL!");
-				}
-			}
-		}
-	}
-
-	if (pBestPlot != NULL)
-	{
-		return pBestPlot;
-	}
-
-	FAssertMsg(false, "AS: Failed to find a starting plot for a player");
-
-	//Execution should almost never reach here.
-
-	//Update found values just in case - particulary important for simultaneous turns.
-	AI_updateFoundValues();
-
-	pBestPlot = NULL;
-	iBestValue = -1;
-
-	if (NULL != getStartingPlot())
-	{
-		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-		{
-			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-			if (pLoopPlot->getArea() == getStartingPlot()->getArea())
-			{
-				int iValue = pLoopPlot->getFoundValue(getID());
-				if (iValue > 0)
-				{
-					if (getAdvancedStartCityCost(true, pLoopPlot) > 0)
-					{
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							pBestPlot = pLoopPlot;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (pBestPlot != NULL)
-	{
-		return pBestPlot;
-	}
-
-	//Commence panic.
-	FAssertMsg(false, "Failed to find an advanced start starting plot");
-	return NULL;
-}
-
-
-bool CvPlayerAI::AI_advancedStartPlaceExploreUnits(bool bLand)
-{
-	CvPlot* pBestExplorePlot = NULL;
-	int iBestExploreValue = 0;
-	UnitTypes eBestUnitType = NO_UNIT;
-
-	UnitAITypes eUnitAI = NO_UNITAI;
-	if (bLand)
-	{
-		eUnitAI = UNITAI_SCOUT;
-	}
-	else if (!bLand)
-	{
-		return false;
-	}
-
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		CvPlot* pLoopPlot = pLoopCity->plot();
-		CvArea* pLoopArea = bLand ? pLoopCity->area() : pLoopPlot->waterArea();
-
-		if (pLoopArea != NULL)
-			{
-			int iValue = std::max(0, pLoopArea->getNumUnrevealedTiles(getTeam()) - 10) * 10;
-			iValue += std::max(0, pLoopArea->getNumTiles() - 50);
-
-				if (iValue > 0)
-				{
-					int iOtherPlotCount = 0;
-					int iGoodyCount = 0;
-					int iExplorerCount = 0;
-				int iAreaId = pLoopArea->getID();
-
-				int iRange = 4;
-					for (int iX = -iRange; iX <= iRange; iX++)
-					{
-						for (int iY = -iRange; iY <= iRange; iY++)
-						{
-							CvPlot* pLoopPlot2 = plotXY(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), iX, iY);
-						if (NULL != pLoopPlot2)
-							{
-								iExplorerCount += pLoopPlot2->plotCount(PUF_isUnitAIType, eUnitAI, -1, NO_PLAYER, getTeam());
-							if (pLoopPlot2->getArea() == iAreaId)
-							{
-								if (pLoopPlot2->isGoody())
-								{
-									iGoodyCount++;
-								}
-								if (pLoopPlot2->getTeam() != getTeam())
-								{
-									iOtherPlotCount++;
-								}
-							}
-						}
-					}
-				}
-
-					iValue -= 300 * iExplorerCount;
-					iValue += 200 * iGoodyCount;
-					iValue += 10 * iOtherPlotCount;
-					if (iValue > iBestExploreValue)
-					{
-						UnitTypes eUnit = AI_bestAdvancedStartUnitAI(pLoopPlot, eUnitAI);
-						if (eUnit != NO_UNIT)
-						{
-							eBestUnitType = eUnit;
-							iBestExploreValue = iValue;
-							pBestExplorePlot = pLoopPlot;
-						}
-					}
-				}
-			}
-		}
-
-	if (pBestExplorePlot != NULL)
-	{
-		doAdvancedStartAction(ADVANCEDSTARTACTION_UNIT, pBestExplorePlot->getX_INLINE(), pBestExplorePlot->getY_INLINE(), eBestUnitType, true);
-		return true;
-	}
-	return false;
-}
-
-void CvPlayerAI::AI_advancedStartRevealRadius(CvPlot* pPlot, int iRadius)
-{
-	for (int iRange = 1; iRange <=iRadius; iRange++)
-	{
-		for (int iX = -iRange; iX <= iRange; iX++)
-		{
-			for (int iY = -iRange; iY <= iRange; iY++)
-			{
-				if (plotDistance(0, 0, iX, iY) <= iRadius)
-				{
-					CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
-
-					if (NULL != pLoopPlot)
-					{
-						if (getAdvancedStartVisibilityCost(true, pLoopPlot) > 0)
-						{
-							doAdvancedStartAction(ADVANCEDSTARTACTION_VISIBILITY, pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), -1, true);
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-bool CvPlayerAI::AI_advancedStartPlaceCity(CvPlot* pPlot)
-{
-	if (isNative())
-	{
-		doAdvancedStartAction(ADVANCEDSTARTACTION_CITY, pPlot->getX(), pPlot->getY(), -1, true);
-		return true;
-	}
-	//If there is already a city, then improve it.
-	CvCity* pCity = pPlot->getPlotCity();
-	if (pCity == NULL)
-	{
-		doAdvancedStartAction(ADVANCEDSTARTACTION_CITY, pPlot->getX(), pPlot->getY(), -1, true);
-
-		pCity = pPlot->getPlotCity();
-		if ((pCity == NULL) || (pCity->getOwnerINLINE() != getID()))
-		{
-			//this should never happen since the cost for a city should be 0 if
-			//the city can't be placed.
-			//(It can happen if another player has placed a city in the fog)
-			FAssertMsg(false, "ADVANCEDSTARTACTION_CITY failed in unexpected way");
-			return false;
-		}
-	}
-
-	/*
-	if (pCity->getCultureLevel() <= 1)
-	{
-		doAdvancedStartAction(ADVANCEDSTARTACTION_CULTURE, pPlot->getX(), pPlot->getY(), -1, true);
-	}
-	*/
-
-	//to account for culture expansion.
-	pCity->AI_updateBestBuild();
-
-	int iPlotsImproved = 0;
-	for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
-	{
-		if (iI != CITY_HOME_PLOT)
-		{
-			CvPlot* pLoopPlot = plotCity(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iI);
-			if ((pLoopPlot != NULL) && (pLoopPlot->getWorkingCity() == pCity))
-			{
-				if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
-				{
-					iPlotsImproved++;
-				}
-			}
-		}
-	}
-
-	int iTargetPopulation = (getCurrentEra() / 2 + 3);
-
-	while (iPlotsImproved < iTargetPopulation)
-	{
-		CvPlot* pBestPlot;
-		ImprovementTypes eBestImprovement = NO_IMPROVEMENT;
-		int iBestValue = 0;
-		for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
-		{
-			int iValue = pCity->AI_getBestBuildValue(iI);
-			if (iValue > iBestValue)
-			{
-				BuildTypes eBuild = pCity->AI_getBestBuild(iI);
-				if (eBuild != NO_BUILD)
-				{
-					ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild).getImprovement();
-					if (eImprovement != NO_IMPROVEMENT)
-					{
-						CvPlot* pLoopPlot = plotCity(pCity->getX_INLINE(), pCity->getY_INLINE(), iI);
-						if ((pLoopPlot != NULL) && (pLoopPlot->getImprovementType() != eImprovement))
-						{
-							eBestImprovement = eImprovement;
-							pBestPlot = pLoopPlot;
-							iBestValue = iValue;
-						}
-					}
-				}
-			}
-		}
-
-		if (iBestValue > 0)
-		{
-
-			FAssert(pBestPlot != NULL);
-			doAdvancedStartAction(ADVANCEDSTARTACTION_IMPROVEMENT, pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE(), eBestImprovement, true);
-			iPlotsImproved++;
-			if (pCity->getPopulation() < iPlotsImproved)
-			{
-				doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE(), -1, true);
-			}
-		}
-		else
-		{
-			break;
-		}
-	}
-
-
-	while (iPlotsImproved > pCity->getPopulation())
-	{
-		int iPopCost = getAdvancedStartPopCost(true, pCity);
-		if (iPopCost <= 0 || iPopCost > getAdvancedStartPoints())
-		{
-			break;
-		}
-		doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pPlot->getX_INLINE(), pPlot->getY_INLINE(), -1, true);
-	}
-
-	while (iTargetPopulation > pCity->getPopulation())
-	{
-		int iPopCost = getAdvancedStartPopCost(true, pCity);
-		if (iPopCost <= 0 || iPopCost > getAdvancedStartPoints())
-		{
-			break;
-		}
-		doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pPlot->getX_INLINE(), pPlot->getY_INLINE(), -1, true);
-	}
-
-	pCity->AI_updateAssignWork();
-
-	return true;
-}
-
-
-
-
-//Returns false if we have no more points.
-bool CvPlayerAI::AI_advancedStartDoRoute(CvPlot* pFromPlot, CvPlot* pToPlot)
-{
-	FAssert(pFromPlot != NULL);
-	FAssert(pToPlot != NULL);
-
-	FAStarNode* pNode;
-	gDLL->getFAStarIFace()->ForceReset(&GC.getStepFinder());
-	if (gDLL->getFAStarIFace()->GeneratePath(&GC.getStepFinder(), pFromPlot->getX_INLINE(), pFromPlot->getY_INLINE(), pToPlot->getX_INLINE(), pToPlot->getY_INLINE(), false, 0, true))
-	{
-		pNode = gDLL->getFAStarIFace()->GetLastNode(&GC.getStepFinder());
-		if (pNode != NULL)
-		{
-			if (pNode->m_iData1 > (1 + stepDistance(pFromPlot->getX(), pFromPlot->getY(), pToPlot->getX(), pToPlot->getY())))
-			{
-				//Don't build convulted paths.
-				return true;
-			}
-		}
-
-		while (pNode != NULL)
-		{
-			CvPlot* pPlot = GC.getMapINLINE().plotSorenINLINE(pNode->m_iX, pNode->m_iY);
-			RouteTypes eRoute = AI_bestAdvancedStartRoute(pPlot);
-			if (eRoute != NO_ROUTE)
-			{
-				if (getAdvancedStartRouteCost(eRoute, true, pPlot) > getAdvancedStartPoints())
-				{
-					return false;
-				}
-				doAdvancedStartAction(ADVANCEDSTARTACTION_ROUTE, pNode->m_iX, pNode->m_iY, eRoute, true);
-			}
-			pNode = pNode->m_pParent;
-		}
-	}
-	return true;
-}
-void CvPlayerAI::AI_advancedStartRouteTerritory()
-{
-	CvPlot* pLoopPlot;
-	int iI;
-
-	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-	{
-		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-		if ((pLoopPlot != NULL) && (pLoopPlot->getOwner() == getID()) && (pLoopPlot->getRouteType() == NO_ROUTE))
-		{
-			if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
-			{
-				if (pLoopPlot->getRouteType() == NO_ROUTE)
-				{
-					int iRouteYieldValue = 0;
-					RouteTypes eRoute = (AI_bestAdvancedStartRoute(pLoopPlot, &iRouteYieldValue));
-					if (eRoute != NO_ROUTE && iRouteYieldValue > 0)
-					{
-						doAdvancedStartAction(ADVANCEDSTARTACTION_ROUTE, pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), eRoute, true);
-					}
-				}
-			}
-		}
-	}
-}
-
-
-void CvPlayerAI::AI_doAdvancedStart(bool bNoExit)
-{
-	if (NULL == getStartingPlot())
-	{
-		FAssert(false);
-		return;
-	}
-
-	int iTargetCityCount = GC.getWorldInfo(GC.getMapINLINE().getWorldSize()).getTargetNumCities();
-
-	iTargetCityCount = 1 + iTargetCityCount + GC.getGameINLINE().getSorenRandNum(2 * iTargetCityCount, "AI Native Civilization Size");
-	iTargetCityCount /= 2;
-
-	int iLoop;
-	CvCity* pLoopCity;
-	int iStartingPoints = getAdvancedStartPoints();
-	int iRevealPoints;
-	int iMilitaryPoints;
-	int iCityPoints;
-
-	bool bIsNative = isNative();
-
-	if (bIsNative)
-	{
-		AI_createNatives();
-		if (bNoExit)
-		{
-			return;
-		}
-		else
-		{
-			doAdvancedStartAction(ADVANCEDSTARTACTION_EXIT, -1, -1, -1, true);
-		}
-	}
-
-	if (isNative())
-	{
-		iRevealPoints = (iStartingPoints * 20) / 100;
-		iMilitaryPoints = (iStartingPoints * 40) / 100;
-		iCityPoints = iStartingPoints - (iMilitaryPoints + iRevealPoints);
-	}
-	else
-	{
-		iRevealPoints = (iStartingPoints * 10) / 100;
-		iMilitaryPoints = (iStartingPoints * (isHuman() ? 17 : 20)) / 100;
-		iCityPoints = iStartingPoints - (iMilitaryPoints + iRevealPoints);
-	}
-
-	if (!bIsNative)
-	{
-
-		if (getPrimaryCity() != NULL)
-		{
-			AI_advancedStartPlaceCity(getPrimaryCity()->plot());
-		}
-		else
-		{
-			for (int iPass = 0; iPass < 2 && NULL == getPrimaryCity(); ++iPass)
-			{
-				CvPlot* pBestCapitalPlot = AI_advancedStartFindCapitalPlot();
-
-				if (pBestCapitalPlot != NULL)
-				{
-					if (!AI_advancedStartPlaceCity(pBestCapitalPlot))
-					{
-						FAssertMsg(false, "AS AI: Unexpected failure placing capital");
-					}
-					break;
-				}
-				else
-				{
-					//If this point is reached, the advanced start system is broken.
-					//Find a new starting plot for this player
-					setStartingPlot(findStartingPlot(false), true);
-					//Redo Starting visibility
-					CvPlot* pStartingPlot = getStartingPlot();
-					if (NULL != pStartingPlot)
-					{
-						for (int iPlotLoop = 0; iPlotLoop < GC.getMapINLINE().numPlots(); ++iPlotLoop)
-						{
-							CvPlot* pPlot = GC.getMapINLINE().plotByIndex(iPlotLoop);
-
-							if (plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pStartingPlot->getX_INLINE(), pStartingPlot->getY_INLINE()) <= GC.getCache_ADVANCED_START_SIGHT_RANGE())
-							{
-								pPlot->setRevealed(getTeam(), true, false, NO_TEAM);
-							}
-						}
-					}
-				}
-			}
-
-			if (getPrimaryCity() == NULL)
-			{
-				if (!bNoExit)
-				{
-					doAdvancedStartAction(ADVANCEDSTARTACTION_EXIT, -1, -1, -1, true);
-				}
-				return;
-			}
-		}
-
-		iCityPoints -= (iStartingPoints - getAdvancedStartPoints());
-
-		int iLastPointsTotal = getAdvancedStartPoints();
-
-		for (int iPass = 0; iPass < 6; iPass++)
-		{
-			for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-			{
-				CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-				if (pLoopPlot->isRevealed(getTeam(), false))
-				{
-					if (pLoopPlot->getBonusType() != NO_BONUS)
-					{
-						AI_advancedStartRevealRadius(pLoopPlot, CITY_PLOTS_RADIUS);
-					}
-					else
-					{
-						for (int iJ = 0; iJ < NUM_CARDINALDIRECTION_TYPES; iJ++)
-						{
-							CvPlot* pLoopPlot2 = plotCardinalDirection(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), (CardinalDirectionTypes)iJ);
-							if ((pLoopPlot2 != NULL) && (getAdvancedStartVisibilityCost(true, pLoopPlot2) > 0))
-							{
-								//Mildly maphackery but any smart human can see the terrain type of a tile.
-								pLoopPlot2->getTerrainType();
-								int iFoodYield = GC.getTerrainInfo(pLoopPlot2->getTerrainType()).getYield(YIELD_FOOD);
-								if (pLoopPlot2->getFeatureType() != NO_FEATURE)
-								{
-									iFoodYield += GC.getFeatureInfo(pLoopPlot2->getFeatureType()).getYieldChange(YIELD_FOOD);
-								}
-								if (iFoodYield >= 2 || pLoopPlot2->isHills() || pLoopPlot2->isPeak() || pLoopPlot2->isRiver())
-								{
-									doAdvancedStartAction(ADVANCEDSTARTACTION_VISIBILITY, pLoopPlot2->getX_INLINE(), pLoopPlot2->getY_INLINE(), -1, true);
-								}
-							}
-						}
-					}
-				}
-				if ((iLastPointsTotal - getAdvancedStartPoints()) > iRevealPoints)
-				{
-					break;
-				}
-			}
-		}
-
-		iLastPointsTotal = getAdvancedStartPoints();
-		iCityPoints = std::min(iCityPoints, iLastPointsTotal);
-		int iArea = -1; //getStartingPlot()->getArea();
-		bool bDonePlacingCities = false;
-		for (int iPass = 0; iPass < 100; ++iPass)
-		{
-			int iBestFoundValue = 0;
-			CvPlot* pBestFoundPlot = NULL;
-			AI_updateFoundValues(false);
-			for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-			{
-				CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-				if (plotDistance(getStartingPlot()->getX_INLINE(), getStartingPlot()->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE()) < 19)
-				{
-					int iFoundValue = pLoopPlot->getFoundValue(getID());
-					if (isNative())
-					{
-						iFoundValue = iFoundValue + GC.getGameINLINE().getSorenRandNum(iFoundValue * 2, "AI place native city");
-					}
-					if (pLoopPlot->getFoundValue(getID()) > iBestFoundValue)
-					{
-						if (getAdvancedStartCityCost(true, pLoopPlot) > 0)
-						{
-							pBestFoundPlot = pLoopPlot;
-							iBestFoundValue = pLoopPlot->getFoundValue(getID());
-						}
-					}
-				}
-			}
-
-			if (isNative())
-			{
-				if (getNumCities() >= iTargetCityCount)
-				{
-					bDonePlacingCities = true;
-				}
-			}
-			else if (iBestFoundValue < ((getNumCities() == 0) ? 1 : (500 + 250 * getNumCities())))
-			{
-				bDonePlacingCities = true;
-			}
-
-			if (pBestFoundPlot == NULL)
-			{
-				bDonePlacingCities = true;
-			}
-
-			if (!bDonePlacingCities)
-			{
-				int iCost = getAdvancedStartCityCost(true, pBestFoundPlot);
-				if (iCost > getAdvancedStartPoints())
-				{
-					bDonePlacingCities = true;
-				}// at 500pts, we have 200, we spend 100.
-				else if (((iLastPointsTotal - getAdvancedStartPoints()) + iCost) > iCityPoints)
-				{
-					bDonePlacingCities = true;
-				}
-			}
-
-			if (!bDonePlacingCities)
-			{
-				if (!AI_advancedStartPlaceCity(pBestFoundPlot))
-				{
-					FAssertMsg(false, "AS AI: Failed to place city (non-capital)");
-					bDonePlacingCities = true;
-				}
-			}
-
-			if (bDonePlacingCities)
-			{
-				break;
-			}
-		}
-
-
-		//Land
-		AI_advancedStartPlaceExploreUnits(true);
-		if (getCurrentEra() > 2)
-		{
-			//Sea
-			AI_advancedStartPlaceExploreUnits(false);
-		}
-
-		if (!isNative())
-		{
-			AI_advancedStartRouteTerritory();
-		}
-
-		bool bDoneBuildings = (iLastPointsTotal - getAdvancedStartPoints()) > iCityPoints;
-		for (int iPass = 0; iPass < 10 && !bDoneBuildings; ++iPass)
-		{
-			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-			{
-				BuildingTypes eBuilding = pLoopCity->AI_bestAdvancedStartBuilding(iPass);
-				if (eBuilding != NO_BUILDING)
-				{
-					bDoneBuildings = (iLastPointsTotal - (getAdvancedStartPoints() - getAdvancedStartBuildingCost(eBuilding, true, pLoopCity))) > iCityPoints;
-					if (!bDoneBuildings)
-					{
-						doAdvancedStartAction(ADVANCEDSTARTACTION_BUILDING, pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE(), eBuilding, true);
-					}
-					else
-					{
-						//continue there might be cheaper buildings in other cities we can afford
-					}
-				}
-			}
-		}
-	}
-
-	//Units
-	std::vector<UnitAITypes> aeUnitAITypes;
-	if (!isNative())
-	{
-		aeUnitAITypes.push_back(UNITAI_COLONIST);
-	}
-	else
-	{
-		aeUnitAITypes.push_back(UNITAI_DEFENSIVE);
-	}
-
-
-	bool bDone = false;
-	for (int iPass = 0; iPass < 6; ++iPass)
-	{
-		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-		{
-
-			{
-				if (iPass > 0)
-			{
-					if (getAdvancedStartPopCost(true, pLoopCity) > getAdvancedStartPoints())
-					{
-						bDone = true;
-						break;
-					}
-					doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pLoopCity->getX(), pLoopCity->getY(), -1, true);
-				}
-				CvPlot* pUnitPlot = pLoopCity->plot();
-				//Token defender
-				UnitTypes eBestUnit = AI_bestAdvancedStartUnitAI(pUnitPlot, aeUnitAITypes[iPass % aeUnitAITypes.size()]);
-				if (eBestUnit != NO_UNIT)
-				{
-
-					if (getAdvancedStartUnitCost(eBestUnit, true, pUnitPlot) > getAdvancedStartPoints())
-					{
-						bDone = true;
-						break;
-					}
-					doAdvancedStartAction(ADVANCEDSTARTACTION_UNIT, pUnitPlot->getX(), pUnitPlot->getY(), eBestUnit, true);
-				}
-			}
-		}
-	}
-
-	if (!bNoExit)
-	{
-		doAdvancedStartAction(ADVANCEDSTARTACTION_EXIT, -1, -1, -1, true);
-	}
-
-}
-
-int CvPlayerAI::AI_getMinFoundValue()
-{
-	return 600;
-}
-
-int CvPlayerAI::AI_bestAreaUnitAIValue(UnitAITypes eUnitAI, CvArea* pArea, UnitTypes* peBestUnitType)
-{
-
-	CvCity* pCity = NULL;
-
-	if (pArea != NULL)
-	{
-	if (getPrimaryCity() != NULL)
-	{
-		if (pArea->isWater())
-		{
-			if (getPrimaryCity()->plot()->isAdjacentToArea(pArea))
-			{
-				pCity = getPrimaryCity();
-			}
-		}
-		else
-		{
-			if (getPrimaryCity()->getArea() == pArea->getID())
-			{
-				pCity = getPrimaryCity();
-			}
-		}
-	}
-
-	if (NULL == pCity)
-	{
-		CvCity* pLoopCity;
-		int iLoop;
-		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-		{
-			if (pArea->isWater())
-			{
-				if (pLoopCity->plot()->isAdjacentToArea(pArea))
-				{
-					pCity = pLoopCity;
-					break;
-				}
-			}
-			else
-			{
-				if (pLoopCity->getArea() == pArea->getID())
-				{
-					pCity = pLoopCity;
-					break;
-				}
-			}
-		}
-	}
-	}
-
-	return AI_bestCityUnitAIValue(eUnitAI, pCity, peBestUnitType);
-
-}
-
-int CvPlayerAI::AI_bestCityUnitAIValue(UnitAITypes eUnitAI, CvCity* pCity, UnitTypes* peBestUnitType)
-{
-	UnitTypes eLoopUnit;
-	int iValue;
-	int iBestValue;
-	int iI;
-
-	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
-
-	iBestValue = 0;
-
-	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
-
-		if (eLoopUnit != NO_UNIT)
-		{
-			if (!isHuman() || (GC.getUnitInfo(eLoopUnit).getDefaultUnitAIType() == eUnitAI))
-			{
-				if (NULL == pCity ? canTrain(eLoopUnit) : pCity->canTrain(eLoopUnit))
-				{
-					iValue = AI_unitValue(eLoopUnit, eUnitAI, (pCity == NULL) ? NULL : pCity->area());
-					if (iValue > iBestValue)
-					{
-						iBestValue = iValue;
-						if (peBestUnitType != NULL)
-						{
-							*peBestUnitType = eLoopUnit;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return iBestValue;
-}
-
-int CvPlayerAI::AI_calculateTotalBombard(DomainTypes eDomain)
-{
-	int iI;
-	int iTotalBombard = 0;
-
-	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
-		if (eLoopUnit != NO_UNIT)
-		{
-			if (GC.getUnitInfo(eLoopUnit).getDomainType() == eDomain)
-			{
-				int iBombardRate = GC.getUnitInfo(eLoopUnit).getBombardRate();
-
-				if (iBombardRate > 0)
-				{
-					iTotalBombard += iBombardRate * getUnitClassCount((UnitClassTypes)iI);
-				}
-			}
-		}
-	}
-
-	return iTotalBombard;
-}
-
-int CvPlayerAI::AI_getUnitClassWeight(UnitClassTypes eUnitClass)
-{
-	return m_aiUnitClassWeights[eUnitClass] / 100;
-}
-
-int CvPlayerAI::AI_getUnitCombatWeight(UnitCombatTypes eUnitCombat)
-{
-	return m_aiUnitCombatWeights[eUnitCombat] / 100;
-}
-
-void CvPlayerAI::AI_doEnemyUnitData()
-{
-	std::vector<int> aiUnitCounts(GC.getNumUnitInfos(), 0);
-
-	std::vector<int> aiDomainSums(NUM_DOMAIN_TYPES, 0);
-
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	int iI;
-
-	int iOldTotal = 0;
-	int iNewTotal = 0;
-
-
-	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
-	{
-
-		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
-		int iAdjacentAttackers = -1;
-		if (pLoopPlot->isVisible(getTeam(), false))
-		{
-			pUnitNode = pLoopPlot->headUnitNode();
-
-			while (pUnitNode != NULL)
-			{
-				pLoopUnit = ::getUnit(pUnitNode->m_data);
-				pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-				if (pLoopUnit->canFight())
-				{
-					int iUnitValue = 1;
-					if (atWar(getTeam(), pLoopUnit->getTeam()))
-					{
-						iUnitValue += 10;
-
-						if ((pLoopPlot->getOwnerINLINE() == getID()))
-						{
-							iUnitValue += 15;
-						}
-						else if (atWar(getTeam(), pLoopPlot->getTeam()))
-						{
-							if (iAdjacentAttackers == -1)
-							{
-								iAdjacentAttackers = GET_PLAYER(pLoopPlot->getOwnerINLINE()).AI_adjacentPotentialAttackers(pLoopPlot);
-							}
-							if (iAdjacentAttackers > 0)
-							{
-								iUnitValue += 15;
-							}
-						}
-					}
-					else if (pLoopUnit->getOwnerINLINE() != getID())
-					{
-						iUnitValue += pLoopUnit->canAttack() ? 4 : 1;
-						if (pLoopPlot->getCulture(getID()) > 0)
-						{
-							iUnitValue += pLoopUnit->canAttack() ? 4 : 1;
-						}
-					}
-
-					if (m_aiUnitClassWeights[pLoopUnit->getUnitClassType()] == 0)
-					{
-						iUnitValue *= 4;
-					}
-
-					iUnitValue *= pLoopUnit->baseCombatStr();
-					aiUnitCounts[pLoopUnit->getUnitType()] += iUnitValue;
-					aiDomainSums[pLoopUnit->getDomainType()] += iUnitValue;
-					iNewTotal += iUnitValue;
-				}
-			}
-		}
-	}
-
-	if (iNewTotal == 0)
-	{
-		//This should rarely happen.
-		return;
-	}
-
-	//Decay
-	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		m_aiUnitClassWeights[iI] -= 100;
-		m_aiUnitClassWeights[iI] *= 3;
-		m_aiUnitClassWeights[iI] /= 4;
-		m_aiUnitClassWeights[iI] = std::max(0, m_aiUnitClassWeights[iI]);
-	}
-
-	for (iI = 0; iI < GC.getNumUnitInfos(); iI++)
-	{
-		if (aiUnitCounts[iI] > 0)
-		{
-			UnitTypes eLoopUnit = (UnitTypes)iI;
-			aiUnitCounts[iI] = 0;
-			FAssert(aiDomainSums[GC.getUnitInfo(eLoopUnit).getDomainType()] > 0);
-			m_aiUnitClassWeights[GC.getUnitInfo(eLoopUnit).getUnitClassType()] += (5000 * aiUnitCounts[iI]) / std::max(1, aiDomainSums[GC.getUnitInfo(eLoopUnit).getDomainType()]);
-		}
-	}
-
-	for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
-	{
-		m_aiUnitCombatWeights[iI] = 0;
-	}
-
-	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		if (m_aiUnitClassWeights[iI] > 0)
-		{
-			UnitTypes eUnit = (UnitTypes)GC.getUnitClassInfo((UnitClassTypes)iI).getDefaultUnitIndex();
-			m_aiUnitCombatWeights[GC.getUnitInfo(eUnit).getUnitCombatType()] += m_aiUnitClassWeights[iI];
-
-		}
-	}
-
-	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
-	{
-		if (m_aiUnitCombatWeights[iI] > 25)
-		{
-			m_aiUnitCombatWeights[iI] += 2500;
-		}
-		else if (m_aiUnitCombatWeights[iI] > 0)
-		{
-			m_aiUnitCombatWeights[iI] += 1000;
-		}
-	}
-}
-
-int CvPlayerAI::AI_calculateUnitAIViability(UnitAITypes eUnitAI, DomainTypes eDomain)
-{
-	int iBestUnitAIStrength = 0;
-	int iBestOtherStrength = 0;
-
-	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		UnitTypes eLoopUnit = (UnitTypes)GC.getUnitClassInfo((UnitClassTypes)iI).getDefaultUnitIndex();
-		CvUnitInfo& kUnitInfo = GC.getUnitInfo((UnitTypes)iI);
-		if (kUnitInfo.getDomainType() == eDomain)
-		{
-			if (m_aiUnitClassWeights[iI] > 0)
-			{
-				if (kUnitInfo.getUnitAIType(eUnitAI))
-				{
-					iBestUnitAIStrength = std::max(iBestUnitAIStrength, kUnitInfo.getCombat());
-				}
-
-				iBestOtherStrength = std::max(iBestOtherStrength, kUnitInfo.getCombat());
-			}
-		}
-	}
-
-	return (100 * iBestUnitAIStrength) / std::max(1, iBestOtherStrength);
-}
-
-int CvPlayerAI::AI_getAttitudeWeight(PlayerTypes ePlayer)
-{
-	int iAttitudeWeight = 0;
-	switch (AI_getAttitude(ePlayer))
-	{
-	case ATTITUDE_FURIOUS:
-		iAttitudeWeight = -100;
-		break;
-	case ATTITUDE_ANNOYED:
-		iAttitudeWeight = -50;
-		break;
-	case ATTITUDE_CAUTIOUS:
-		iAttitudeWeight = 0;
-		break;
-	case ATTITUDE_PLEASED:
-		iAttitudeWeight = 50;
-		break;
-	case ATTITUDE_FRIENDLY:
-		iAttitudeWeight = 100;
-		break;
-	}
-
-	return iAttitudeWeight;
-}
-
-int CvPlayerAI::AI_getPlotCanalValue(CvPlot* pPlot)
-{
-	PROFILE_FUNC();
-
-	FAssert(pPlot != NULL);
-
-	if (pPlot->isOwned())
-	{
-		if (pPlot->getTeam() != getTeam())
-		{
-			return 0;
-		}
-		if (pPlot->isCityRadius())
-		{
-			CvCity* pWorkingCity = pPlot->getWorkingCity();
-			if (pWorkingCity != NULL)
-			{
-				if (pWorkingCity->AI_getBestBuild(pWorkingCity->getCityPlotIndex(pPlot)) != NO_BUILD)
-				{
-					return 0;
-				}
-				if (pPlot->getImprovementType() != NO_IMPROVEMENT)
-				{
-					CvImprovementInfo &kImprovementInfo = GC.getImprovementInfo(pPlot->getImprovementType());
-					if (!kImprovementInfo.isActsAsCity())
-					{
-						return 0;
-					}
-				}
-			}
-		}
-	}
-
-	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
-	{
-		CvPlot* pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), (DirectionTypes)iI);
-		if (pLoopPlot != NULL)
-		{
-			if (pLoopPlot->isCity(true))
-			{
-				return 0;
-			}
-		}
-	}
-
-	CvArea* pSecondWaterArea = pPlot->secondWaterArea();
-	if (pSecondWaterArea == NULL)
-	{
-		return 0;
-	}
-
-	return 10 * std::min(0, pSecondWaterArea->getNumTiles() - 2);
-}
-
-void CvPlayerAI::AI_diplomaticHissyFit(PlayerTypes ePlayer, int iAttitudeChange)
-{
-	if (ePlayer == NO_PLAYER)
-	{
-		FAssert(false);
-		return;
-	}
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (iAttitudeChange >= 0)
-	{
-		return;
-	}
-
-	if (atWar(getTeam(), kPlayer.getTeam()))
-	{
-		return;
-	}
-
-	if (!kPlayer.isHuman())
-	{
-		return;
-	}
-
-	if (GET_TEAM(getTeam()).AI_performNoWarRolls(kPlayer.getTeam()))
-	{
-		return;
-	}
-
-	//Out of 1000, so 100 is a 10% chance.
-	//Note this could be modified by all sorts of things. Difficulty level might be a good one.
-	int iProbability = -iAttitudeChange * 100;
-
-	iProbability /= (GET_TEAM(getTeam()).getNumMembers() * GET_TEAM(kPlayer.getTeam()).getNumMembers());
-
-	if (iProbability < GC.getGameINLINE().getSorenRandNum(1000, "AI Diplomatic Hissy Fit"))
-	{
-		return;
-	}
-
-	GET_TEAM(getTeam()).declareWar(kPlayer.getTeam(), true, WARPLAN_EXTORTION);
-
-}
-
-UnitTypes CvPlayerAI::AI_nextBuyUnit(UnitAITypes* peUnitAI, int* piValue)
-{
-	if (peUnitAI != NULL)
-	{
-		*peUnitAI = m_eNextBuyUnitAI;
-	}
-	if (piValue != NULL)
-	{
-		*piValue = m_iNextBuyUnitValue;
-	}
-	return m_eNextBuyUnit;
-}
-
-UnitTypes CvPlayerAI::AI_nextBuyProfessionUnit(ProfessionTypes* peProfession, UnitAITypes* peUnitAI, int* piValue)
-{
-	if (peProfession != NULL)
-	{
-		*peProfession = m_eNextBuyProfession;
-	}
-	if (peUnitAI != NULL)
-	{
-		*peUnitAI = m_eNextBuyProfessionAI;
-	}
-	if (peUnitAI != NULL)
-	{
-		*piValue = m_iNextBuyProfessionValue;
-	}
-	return m_eNextBuyProfessionUnit;
-}
-
-void CvPlayerAI::AI_updateNextBuyUnit()
-{
-	PROFILE_FUNC();
-	int iBestValue = 0;
-	UnitTypes eBestUnit = NO_UNIT;
-	UnitAITypes eBestUnitAI = NO_UNITAI;
-
-	for (int iUnitAI = 0; iUnitAI < NUM_UNITAI_TYPES; ++iUnitAI)
-	{
-		UnitAITypes eLoopUnitAI = (UnitAITypes) iUnitAI;
-		bool bValid = false;
-
-		int iMultipler = AI_unitAIValueMultipler(eLoopUnitAI);
-		if (iMultipler > 0)
-		{
-			bValid = true;
-		}
-		int iTreasureSum = -1;
-		int iTreasureSize = -1;
-
-		if ((eLoopUnitAI == UNITAI_TRANSPORT_SEA) && (AI_totalUnitAIs(UNITAI_TREASURE) > 0))
-		{
-			int iLoop;
-			CvUnit* pLoopUnit;
-			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-			{
-				if (pLoopUnit->canMove())
-				{
-					if (pLoopUnit->AI_getUnitAIType() == UNITAI_TREASURE)
-					{
-						int iSize = pLoopUnit->getUnitInfo().getRequiredTransportSize();
-						if (iSize > 1)
-						{
-							iTreasureSize = std::max(iTreasureSize, iSize);
-							iTreasureSum += pLoopUnit->getYieldStored();
-						}
-					}
-				}
-			}
-
-			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
-			{
-				if (pLoopUnit->AI_getUnitAIType() == UNITAI_TRANSPORT_SEA)
-				{
-					if (pLoopUnit->cargoSpace() >= iTreasureSize)
-					{
-						//Can already transport all treasure, cancel.
-						iTreasureSize = -1;
-						iTreasureSum = -1;
-						break;
-					}
-				}
-			}
-		}
-
-		if (iTreasureSum < 1)
-		{
-			iTreasureSum = 1;
-		}
-
-		if (iTreasureSize < 1)
-		{
-			iTreasureSize = 1;
-		}
-
-		if (iTreasureSum > 0)
-		{
-			bValid = true;
-		}
-
-		if (bValid)
-		{
-			for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-			{
-				UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
-
-				if (eLoopUnit != NO_UNIT)
-				{
-					CvUnitInfo& kUnitInfo = GC.getUnitInfo(eLoopUnit);
-					if (kUnitInfo.getDefaultProfession() == NO_PROFESSION || kUnitInfo.getDefaultUnitAIType() == UNITAI_DEFENSIVE || kUnitInfo.getDefaultUnitAIType() == UNITAI_COUNTER)
-					{
-						int iPrice = getEuropeUnitBuyPrice(eLoopUnit);
-						if (iPrice > 0)// && !kUnitInfo.getUnitAIType(eLoopUnitAI))
-						{
-							if (iTreasureSum > 0) //Perform treasure calculations
-							{
-								if (kUnitInfo.getCargoSpace() >= iTreasureSize)
-								{
-									iMultipler += 100 + (100 * iTreasureSum) / iPrice;
-									iPrice = std::max(iPrice / 3, iPrice - iTreasureSum);
-								}
-							}
-
-							if (kUnitInfo.getDefaultUnitAIType() == UNITAI_COMBAT_SEA)
-							{
-								iMultipler += 100 + (100 * (kUnitInfo.getCombat() * 1000)) / iPrice;
-								if (getGold() > iPrice)
-								{
-									iPrice /= 4;
-								}
-							}
-
-							int iGoldValue = AI_unitGoldValue(eLoopUnit, eLoopUnitAI, NULL);
-
-							int iValue = (iMultipler * iGoldValue) / iPrice;
-
-							if (iValue > iBestValue)
-							{
-								iBestValue = iValue;
-								eBestUnit = eLoopUnit;
-								eBestUnitAI = eLoopUnitAI;
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	m_eNextBuyUnit = eBestUnit;
-	m_eNextBuyUnitAI = eBestUnitAI;
-	m_iNextBuyUnitValue = iBestValue;
-}
-
-int CvPlayerAI::AI_highestNextBuyValue()
-{
-	return std::max(m_iNextBuyUnitValue, m_iNextBuyProfessionValue);
-}
-
-void CvPlayerAI::AI_updateNextBuyProfession()
-{
-	PROFILE_FUNC();
-	int iBestValue = 0;
-	UnitTypes eBestProfessionUnit = NO_UNIT;
-	ProfessionTypes eBestProfession = NO_PROFESSION;
-	UnitAITypes eBestUnitAI = NO_UNITAI;
-
-	ProfessionTypes eDefaultProfession = (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession();
-
-	int iColMultiplier = AI_unitAIValueMultipler(UNITAI_COLONIST);
-	//Professions which work in cities.
-	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-	{
-		UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
-
-		if (eLoopUnit != NO_UNIT)
-		{
-			CvUnitInfo& kUnitInfo = GC.getUnitInfo(eLoopUnit);
-
-			int iPrice = getEuropeUnitBuyPrice(eLoopUnit);
-			if (iPrice > 0)
-			{
-				if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
-				{
-					int iValue = 0;
-					UnitAITypes eUnitAI = NO_UNITAI;
-					//if (kUnitInfo.getDefaultProfession() == eDefaultProfession)
-					{
-						ProfessionTypes eProfession = AI_idealProfessionForUnit(eLoopUnit);
-						if (eProfession != NO_PROFESSION)
-						{
-
-							int iValue = 50 + 3 * AI_professionUpgradeValue(eProfession, eLoopUnit);
-
-							iValue *= iColMultiplier;
-							iValue /= 100;
-
-							int iExisting = getUnitClassCountPlusMaking((UnitClassTypes)iI);
-
-							if (iExisting < 3)
-							{
-								iValue *= 100 + (5 + getTotalPopulation()) * kUnitInfo.getYieldModifier(YIELD_LUMBER) / (5 * (1 + iExisting));
-								iValue /= 100;
-
-								iValue *= 100 + (5 + getTotalPopulation()) * (44 * kUnitInfo.getYieldChange(YIELD_FOOD) + 34 * kUnitInfo.getBonusYieldChange(YIELD_FOOD)) / (5 * (1 + iExisting)) ;
-								iValue /= 100;
-
-								if (AI_isStrategy(STRATEGY_FAST_BELLS))
-								{
-									iValue *= 100 + kUnitInfo.getYieldModifier(YIELD_BELLS) / (2 + iExisting);
-									iValue /= 100;
-								}
-								///TKs Med
-								//else if (AI_isStrategy(STRATEGY_BUILDUP) || AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
-                                else
-								{
-									iValue *= 100 + kUnitInfo.getYieldModifier(YIELD_GRAIN) / (2 + iExisting);
-									iValue /= 100;
-								}
-								///TKe
-							}
-
-							for (int i = 0; i < NUM_YIELD_TYPES; ++i)
-							{
-								YieldTypes eLoopYield = (YieldTypes)i;
-
-								int iModifier = kUnitInfo.getYieldModifier(eLoopYield);
-								if (iModifier > 0)
-								{
-									if (AI_highestYieldAdvantage(eLoopYield) == 100)
-									{
-										if (!AI_isYieldFinalProduct(eLoopYield))
-										{
-											iModifier /= 4;
-										}
-										iValue *= 100 + iModifier;
-										iValue /= 100;
-									}
-								}
-							}
-
-							if (iExisting < 4)
-							{
-								iValue *= 2;
-								iValue /= 2 + iExisting;
-								if (iValue > iBestValue)
-								{
-									iBestValue = iValue;
-									eBestProfession = eDefaultProfession;
-									eBestProfessionUnit = eLoopUnit;
-									eBestUnitAI = UNITAI_COLONIST;
-								}
-							}
-						}
-					}
-				}
-			}
-		}
-	}
-
-	for (int iUnitAI = 0; iUnitAI < NUM_UNITAI_TYPES; ++iUnitAI)
-	{
-		UnitAITypes eLoopUnitAI = (UnitAITypes) iUnitAI;
-
-		if (eLoopUnitAI != UNITAI_COLONIST)
-		{
-			int iMultiplier = AI_unitAIValueMultipler(eLoopUnitAI);
-
-			if (iMultiplier > 0)
-			{
-				ProfessionTypes eProfession = AI_idealProfessionForUnitAIType(eLoopUnitAI);
-
-				if (eProfession != NO_PROFESSION)
-				{
-					UnitTypes eBestUnit = NO_UNIT;
-
-					for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
-					{
-						UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
-
-						if (eLoopUnit != NO_UNIT)
-						{
-							CvUnitInfo& kUnitInfo = GC.getUnitInfo(eLoopUnit);
-
-							int iPrice = getEuropeUnitBuyPrice(eLoopUnit);
-							if (iPrice > 0)
-							{
-
-								int iValue = AI_professionSuitability(eLoopUnit, eProfession);
-								if (iValue >= 100)
-								{
-									iValue *= 2 * iMultiplier;
-									iValue /= 3 * 100;
-
-									if (iValue > iBestValue)
-									{
-										iBestValue = iValue;
-										eBestProfession = eProfession;
-										eBestProfessionUnit = eLoopUnit;
-										eBestUnitAI = eLoopUnitAI;
-									}
-								}
-							}
-						}
-					}
-
-					if (eBestUnit == NO_UNIT)
-					{
-						//Special Case.
-						int iValue = iMultiplier;
-
-
-						if (iValue > iBestValue)
-						{
-							iBestValue = iValue;
-							eBestProfession = eProfession;
-							eBestProfessionUnit = NO_UNIT;
-							eBestUnitAI = eLoopUnitAI;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	m_eNextBuyProfession = eBestProfession;
-	m_eNextBuyProfessionUnit = eBestProfessionUnit;
-	m_eNextBuyProfessionAI = eBestUnitAI;
-	m_iNextBuyProfessionValue = iBestValue;
-}
-
-void CvPlayerAI::AI_invalidateCloseBordersAttitudeCache()
-{
-	for (int i = 0; i < MAX_PLAYERS; ++i)
-	{
-		m_aiCloseBordersAttitudeCache[i] = MAX_INT;
-		m_aiStolenPlotsAttitudeCache[i] = MAX_INT;
-	}
-}
-
-
-EmotionTypes CvPlayerAI::AI_strongestEmotion()
-{
-	int iBestValue = 0;
-	EmotionTypes eBestEmotion = NO_EMOTION;
-
-	for (int i = 0; i < NUM_EMOTION_TYPES; ++i)
-	{
-		if (m_aiEmotions[i] > iBestValue)
-		{
-			iBestValue = m_aiEmotions[i];
-			eBestEmotion = (EmotionTypes)i;
-		}
-	}
-
-	return eBestEmotion;
-}
-
-int CvPlayerAI::AI_emotionWeight(EmotionTypes eEmotion)
-{
-	EmotionTypes eBestEmotion = AI_strongestEmotion();
-	if (eBestEmotion == NO_EMOTION)
-	{
-		return 0;
-	}
-	return (100 * m_aiEmotions[eEmotion]) / (m_aiEmotions[eBestEmotion]);
-}
-
-int CvPlayerAI::AI_getEmotion(EmotionTypes eEmotion)
-{
-	FAssert(eEmotion > NO_EMOTION);
-	FAssert(eEmotion < NUM_EMOTION_TYPES);
-	return m_aiEmotions[eEmotion];
-}
-
-void CvPlayerAI::AI_setEmotion(EmotionTypes eEmotion, int iNewValue)
-{
-	FAssert(eEmotion > NO_EMOTION);
-	FAssert(eEmotion < NUM_EMOTION_TYPES);
-	m_aiEmotions[eEmotion] = iNewValue;
-}
-
-void CvPlayerAI::AI_changeEmotion(EmotionTypes eEmotion, int iChange)
-{
-	FAssert(eEmotion > NO_EMOTION);
-	FAssert(eEmotion < NUM_EMOTION_TYPES);
-	m_aiEmotions[eEmotion] += iChange;
-}
-
-bool CvPlayerAI::AI_isAnyStrategy() const
-{
-	for (int i = 0; i < NUM_STRATEGY_TYPES; ++i)
-	{
-		if (AI_isStrategy((StrategyTypes)i))
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool CvPlayerAI::AI_isStrategy(StrategyTypes eStrategy) const
-{
-	FAssert(eStrategy > NO_STRATEGY);
-	FAssert(eStrategy < NUM_STRATEGY_TYPES);
-	return (m_aiStrategyStartedTurn[eStrategy] != -1);
-}
-
-int CvPlayerAI::AI_getStrategyDuration(StrategyTypes eStrategy) const
-{
-	FAssert(eStrategy > NO_STRATEGY);
-	FAssert(eStrategy < NUM_STRATEGY_TYPES);
-	if (!AI_isStrategy(eStrategy))
-	{
-		return -1;
-	}
-
-	return (GC.getGameINLINE().getGameTurn() - m_aiStrategyStartedTurn[eStrategy]);
-}
-
-int CvPlayerAI::AI_getStrategyData(StrategyTypes eStrategy)
-{
-	FAssert(eStrategy > NO_STRATEGY);
-	FAssert(eStrategy < NUM_STRATEGY_TYPES);
-	return m_aiStrategyData[eStrategy];
-}
-
-void CvPlayerAI::AI_setStrategy(StrategyTypes eStrategy, int iData)
-{
-	FAssert(eStrategy > NO_STRATEGY);
-	FAssert(eStrategy < NUM_STRATEGY_TYPES);
-	m_aiStrategyStartedTurn[eStrategy] = GC.getGameINLINE().getGameTurn();
-	m_aiStrategyData[eStrategy] = iData;
-}
-
-void CvPlayerAI::AI_clearStrategy(StrategyTypes eStrategy)
-{
-	FAssert(eStrategy > NO_STRATEGY);
-	FAssert(eStrategy < NUM_STRATEGY_TYPES);
-	m_aiStrategyStartedTurn[eStrategy] = -1;
-	m_aiStrategyData[eStrategy] = -1;
-}
-
-int CvPlayerAI::AI_cityDistance(CvPlot* pPlot)
-{
-	FAssert(pPlot != NULL);
-
-	if (m_iDistanceMapDistance == -1)
-	{
-		AI_getDistanceMap();
-	}
-
-	return m_distanceMap[GC.getMapINLINE().plotNumINLINE(pPlot->getX_INLINE(), pPlot->getY_INLINE())];
-}
-
-//There's no need to save this (it is very fast to generate anyway)
-std::vector<short>* CvPlayerAI::AI_getDistanceMap()
-{
-	if (m_iDistanceMapDistance != -1)
-	{
-		return &m_distanceMap;
-	}
-
-	int iMaxRange = MAX_SHORT;
-	CvMap& kMap = GC.getMap();
-
-	std::deque<int>plotQueue;
-	m_distanceMap.resize(kMap.numPlotsINLINE());
-
-	for (int i = 0; i < kMap.numPlotsINLINE(); ++i)
-	{
-		CvPlot* pLoopPlot = kMap.plotByIndexINLINE(i);
-
-		if (pLoopPlot->isCity() && (pLoopPlot->getOwnerINLINE() == getID()))
-		{
-			plotQueue.push_back(i);
-			m_distanceMap[i] = 0;
-		}
-		else
-		{
-			m_distanceMap[i] = iMaxRange;
-		}
-	}
-
-	int iVisits = 0;
-	while (!plotQueue.empty())
-	{
-		iVisits++;
-		int iPlot = plotQueue.front();
-		CvPlot* pPlot = kMap.plotByIndexINLINE(iPlot);
-		plotQueue.pop_front();
-
-		int iDistance = m_distanceMap[iPlot];
-		iDistance += 1;
-
-		if (iDistance < iMaxRange)
-		{
-			for (int iDirection = 0; iDirection < NUM_DIRECTION_TYPES; iDirection++)
-			{
-				CvPlot* pDirectionPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), (DirectionTypes)iDirection);
-				if (pDirectionPlot != NULL)
-				{
-					if ((pDirectionPlot->isWater() && pPlot->isWater())
-						|| (!pDirectionPlot->isWater() && !pPlot->isWater())
-							|| (pDirectionPlot->isWater() && (pPlot->isCity() && (pPlot->getOwnerINLINE() == getID()))))
-					{
-
-						int iPlotNum = kMap.plotNumINLINE(pDirectionPlot->getX_INLINE(), pDirectionPlot->getY_INLINE());
-						if (iDistance < m_distanceMap[iPlotNum])
-						{
-							m_distanceMap[iPlotNum] = iDistance;
-							plotQueue.push_back(iPlotNum);
-						}
-					}
-				}
-			}
-		}
-	}
-	m_iDistanceMapDistance = iMaxRange;
-	return &m_distanceMap;
-}
-
-void CvPlayerAI::AI_invalidateDistanceMap()
-{
-	m_iDistanceMapDistance = -1;
-}
-
-void CvPlayerAI::AI_updateBestYieldPlots()
-{
-	int aiBestWorkedYield[NUM_YIELD_TYPES];
-	int aiBestUnworkedYield[NUM_YIELD_TYPES];
-
-	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
-	{
-		m_aiBestWorkedYieldPlots[i] = -1;
-		m_aiBestUnworkedYieldPlots[i] = -1;
-
-		aiBestWorkedYield[i] = 0;
-		aiBestUnworkedYield[i] = 0;
-	}
-	CvMap& kMap = GC.getMapINLINE();
-	for (int i = 0; i < kMap.numPlotsINLINE(); ++i)
-	{
-		CvPlot* pLoopPlot = kMap.plotByIndex(i);
-
-		if (pLoopPlot->isCityRadius() && (pLoopPlot->getOwnerINLINE() == getID()))
-		{
-			for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
-			{
-				int iPlotYield = std::max(pLoopPlot->calculateNatureYield((YieldTypes)iYield, getTeam(), false), pLoopPlot->calculateNatureYield((YieldTypes)iYield, getTeam(), true));
-				if (iPlotYield > 0)
-				{
-					if (pLoopPlot->isBeingWorked() && pLoopPlot->getYield((YieldTypes)iYield) > 0)
-					{
-						if (iPlotYield > aiBestWorkedYield[iYield])
-						{
-							aiBestWorkedYield[iYield] = iPlotYield;
-							m_aiBestWorkedYieldPlots[iYield] = i;
-						}
-					}
-					else
-					{
-						if (iPlotYield > aiBestUnworkedYield[iYield])
-						{
-							aiBestUnworkedYield[iYield] = iPlotYield;
-							m_aiBestUnworkedYieldPlots[iYield] = i;
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-CvPlot* CvPlayerAI::AI_getBestWorkedYieldPlot(YieldTypes eYield)
-{
-	FAssertMsg(eYield > NO_YIELD, "Index out of bounds");
-	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
-
-	//Automatically returns NULL, if -1.
-	return GC.getMapINLINE().plotByIndexINLINE(m_aiBestWorkedYieldPlots[eYield]);
-}
-
-CvPlot* CvPlayerAI::AI_getBestUnworkedYieldPlot(YieldTypes eYield)
-{
-	FAssertMsg(eYield > NO_YIELD, "Index out of bounds");
-	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
-
-	//Automatically returns NULL, if -1.
-	return GC.getMapINLINE().plotByIndexINLINE(m_aiBestUnworkedYieldPlots[eYield]);
-}
-
-int CvPlayerAI::AI_getBestPlotYield(YieldTypes eYield)
-{
-	CvPlot* pPlot = AI_getBestWorkedYieldPlot(eYield);
-	if (pPlot == NULL)
-	{
-		pPlot = AI_getBestUnworkedYieldPlot(eYield);
-	}
-	if (pPlot == NULL)
-	{
-		return 0;
-	}
-	return pPlot->calculateBestNatureYield(eYield, getTeam());
-}
-
-void CvPlayerAI::AI_changeTotalIncome(int iChange)
-{
-	m_iTotalIncome += iChange;
-}
-
-int CvPlayerAI::AI_getTotalIncome()
-{
-	return m_iTotalIncome;
-}
-
-void CvPlayerAI::AI_changeHurrySpending(int iChange)
-{
-	m_iHurrySpending += iChange;
-}
-
-int CvPlayerAI::AI_getHurrySpending()
-{
-	return m_iHurrySpending;
-}
-
-int CvPlayerAI::AI_getPopulation()
-{
-	int iTotal = 0;
-
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		iTotal += pLoopCity->getPopulation();
-	}
-
-	return iTotal;
-}
-
-bool CvPlayerAI::AI_shouldAttackAdjacentCity(CvPlot* pPlot)
-{
-	FAssert(pPlot != NULL);
-
-	for (int i = 0; i < NUM_DIRECTION_TYPES; ++i)
-	{
-		CvPlot* pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), (DirectionTypes)i);
-		if (pLoopPlot != NULL)
-		{
-			if (atWar(getTeam(), pLoopPlot->getTeam()))
-			{
-				CvCity* pPlotCity = pLoopPlot->getPlotCity();
-				if (pPlotCity != NULL)
-				{
-					if (!pPlotCity->isBombarded())
-					{
-						return true;
-					}
-
-					if (((100 * pPlotCity->getDefenseDamage()) / std::max(1, GC.getMAX_CITY_DEFENSE_DAMAGE())) > 90)
-					{
-						return true;
-					}
-				}
-			}
-		}
-	}
-	return false;
-}
-
-int CvPlayerAI::AI_getNumProfessionUnits(ProfessionTypes eProfession)
-{
-	int iCount = 0;
-
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-		{
-			CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
-
-			if (pLoopUnit->getProfession() == eProfession)
-			{
-				iCount ++;
-			}
-		}
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_countNumCityUnits(UnitTypes eUnit)
-{
-	int iCount = 0;
-
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		for (int i = 0; i < pLoopCity->getPopulation(); ++i)
-		{
-			CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
-
-			if (pLoopUnit->getUnitType() == eUnit)
-			{
-				iCount ++;
-			}
-		}
-	}
-
-	return iCount;
-}
-
-int CvPlayerAI::AI_getNumCityUnitsNeeded(UnitTypes eUnit)
-{
-	int iCount = 0;
-	ProfessionTypes eIdealProfession = AI_idealProfessionForUnit(eUnit);
-
-	if (eIdealProfession == NO_PROFESSION)
-	{
-		return 0;
-	}
-	// MultipleYieldsProduced Start by Aymerick 22/01/2010**
-	YieldTypes eYieldProducedType = (YieldTypes)GC.getProfessionInfo(eIdealProfession).getYieldsProduced(0);
-	// MultipleYieldsProduced End
-	if (eYieldProducedType == NO_YIELD)
-	{
-		return 0;
-	}
-
-	if (GC.getProfessionInfo(eIdealProfession).isWorkPlot())
-	{
-		return 0;//XXX
-	}
-
-	int iLoop;
-	CvCity* pLoopCity;
-	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity->AI_getYieldAdvantage(eYieldProducedType) == 100)
-		{
-			iCount += pLoopCity->getNumProfessionBuildingSlots(eIdealProfession);
-		}
-	}
-	return iCount;
-}
-
-int CvPlayerAI::AI_countPromotions(PromotionTypes ePromotion, CvPlot* pPlot, int iRange, int* piUnitCount)
-{
-	CLLNode<IDInfo>* pUnitNode;
-	CvUnit* pLoopUnit;
-	int iCount = 0;
-	int iUnitCount = 0;
-
-	for (int iX = -iRange; iX <= iRange; ++iX)
-	{
-		for (int iY = -iRange; iY <= iRange; ++iY)
-		{
-			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
-			if (pLoopPlot != NULL)
-			{
-				pUnitNode = pLoopPlot->headUnitNode();
-
-				while (pUnitNode != NULL)
-				{
-					pLoopUnit = ::getUnit(pUnitNode->m_data);
-					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
-
-					if (pLoopUnit->getOwnerINLINE() == getID())
-					{
-						if (pLoopUnit->isHasPromotion(ePromotion))
-						{
-							iCount++;
-						}
-
-						iUnitCount++;
-					}
-				}
-			}
-		}
-	}
-
-	if (piUnitCount != NULL)
-	{
-		*piUnitCount = iUnitCount;
-	}
-	return iCount;
-}
-///TKs Med
-bool CvPlayerAI::AI_doDiploOfferVassalCity(PlayerTypes ePlayer)
-{
-	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
-
-	if (AI_getAttitude(ePlayer) < ATTITUDE_CAUTIOUS)
-	{
-		return false;
-	}
-
-	if (GET_PLAYER(getID()).getVassalOwner() == ePlayer)
-	{
-	    return false;
-	}
-
-	if (!isNative())
-	{
-	    return false;
-	}
-
-//	for (int iI = 0; iI < MAX_PLAYERS; iI++)
-//	{
-//	    if (GET_PLAYER((PlayerTypes)iI).getVassalOwner() == ePlayer)
-//        {
-//            return false;
-//        }
-//	}
-    ///TKs Testing (false means no longer testing)
-    bool bTesting = false;
-	bool bOffered = false;
-	int iLoop;
-	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
-	{
-		if (pLoopCity->getPreviousOwner() != ePlayer)
-		{
-			if ((((pLoopCity->getGameTurnAcquired() + 4) % 20) == (GC.getGameINLINE().getGameTurn() % 20)) || bTesting)
-			{
-				int iCount = 0;
-				int iPossibleCount = 0;
-
-				for (int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)
-				{
-					CvPlot* pLoopPlot = plotCity(pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE(), iJ);
-
-					if (pLoopPlot != NULL)
-					{
-						if (pLoopPlot->getOwnerINLINE() == ePlayer)
-						{
-							++iCount;
-						}
-
-						++iPossibleCount;
-					}
-				}
-
-				if (iCount >= (iPossibleCount / 2))
-				{
-
-                    if (GET_PLAYER(getID()).getNumCities() > 1)
-                    {
-                        CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_NOBLES_JOIN, getID(), pLoopCity->getID());
-                        if (pInfo)
-                        {
-                            gDLL->getInterfaceIFace()->addPopup(pInfo, ePlayer, true);
-                            bOffered = true;
-                        }
-                    }
-                    else
-                    {
-                        TradeData item;
-                        setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
-                        //if (canTradeItem((ePlayer), item, true))
-                       // {
-                            CLinkList<TradeData> ourList;
-                            ourList.insertAtEnd(item);
-
-                            if (kPlayer.isHuman())
-                            {
-                                CvDiploParameters* pDiplo = new CvDiploParameters(getID());
-                                pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_VASSAL"));
-                                pDiplo->setAIContact(true);
-                                pDiplo->setData(pLoopCity->getID());
-                                pDiplo->setTheirOfferList(ourList);
-                                gDLL->beginDiplomacy(pDiplo, ePlayer);
-                            }
-    //						else
-    //						{
-    //							GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, NULL);
-    //						}
-                            bOffered = true;
-                        //}
-                    }
-				}
-			}
-		}
-	}
-
-	return bOffered;
-}
-///TKe
+// playerAI.cpp
+
+#include "CvGameCoreDLL.h"
+#include "CvPlayerAI.h"
+#include "CvRandom.h"
+#include "CvGlobals.h"
+#include "CvGameCoreUtils.h"
+#include "CvMap.h"
+#include "CvArea.h"
+#include "CvPlot.h"
+#include "CvGameAI.h"
+#include "CvTeamAI.h"
+#include "CvGameCoreUtils.h"
+#include "CvDiploParameters.h"
+#include "CvInitCore.h"
+#include "CyArgsList.h"
+#include "CvDLLInterfaceIFaceBase.h"
+#include "CvDLLEntityIFaceBase.h"
+#include "CvDLLPythonIFaceBase.h"
+#include "CvDLLEngineIFaceBase.h"
+#include "CvDLLEventReporterIFaceBase.h"
+#include "CvInfos.h"
+#include "CvPopupInfo.h"
+#include "FProfiler.h"
+#include "CvDLLFAStarIFaceBase.h"
+#include "FAStarNode.h"
+#include "CvTradeRoute.h"
+
+#define DANGER_RANGE				(4)
+#define GREATER_FOUND_RANGE			(5)
+#define CIVIC_CHANGE_DELAY			(25)
+
+// statics
+
+CvPlayerAI* CvPlayerAI::m_aPlayers = NULL;
+
+void CvPlayerAI::initStatics()
+{
+	m_aPlayers = new CvPlayerAI[MAX_PLAYERS];
+	for (int iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		m_aPlayers[iI].m_eID = ((PlayerTypes)iI);
+	}
+}
+
+void CvPlayerAI::freeStatics()
+{
+	SAFE_DELETE_ARRAY(m_aPlayers);
+}
+
+bool CvPlayerAI::areStaticsInitialized()
+{
+	if(m_aPlayers == NULL)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+DllExport CvPlayerAI& CvPlayerAI::getPlayerNonInl(PlayerTypes ePlayer)
+{
+	return getPlayer(ePlayer);
+}
+
+// Public Functions...
+
+CvPlayerAI::CvPlayerAI()
+{
+	m_aiNumTrainAIUnits = new int[NUM_UNITAI_TYPES];
+	m_aiNumAIUnits = new int[NUM_UNITAI_TYPES];
+	m_aiNumRetiredAIUnits = new int[NUM_UNITAI_TYPES];
+	m_aiUnitAIStrategyWeights = new int[NUM_UNITAI_TYPES];
+	m_aiPeacetimeTradeValue = new int[MAX_PLAYERS];
+	m_aiPeacetimeGrantValue = new int[MAX_PLAYERS];
+	m_aiGoldTradedTo = new int[MAX_PLAYERS];
+	m_aiAttitudeExtra = new int[MAX_PLAYERS];
+
+	m_abFirstContact = new bool[MAX_PLAYERS];
+
+	m_aaiContactTimer = new int*[MAX_PLAYERS];
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		m_aaiContactTimer[i] = new int[NUM_CONTACT_TYPES];
+	}
+
+	m_aaiMemoryCount = new int*[MAX_PLAYERS];
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		m_aaiMemoryCount[i] = new int[NUM_MEMORY_TYPES];
+	}
+
+	m_aiAverageYieldMultiplier = new int[NUM_YIELD_TYPES];
+
+	m_aiUnitClassWeights = NULL;
+	m_aiUnitCombatWeights = NULL;
+	m_aiEmotions = new int[NUM_EMOTION_TYPES];
+	m_aiStrategyStartedTurn = new int[NUM_STRATEGY_TYPES];
+	m_aiStrategyData = new int[NUM_STRATEGY_TYPES];
+
+	m_aiBestWorkedYieldPlots = new int[NUM_YIELD_TYPES];
+	m_aiBestUnworkedYieldPlots = new int[NUM_YIELD_TYPES];
+	m_aiYieldValuesTimes100 = new int[NUM_YIELD_TYPES];
+
+	m_aiCloseBordersAttitudeCache = new int[MAX_PLAYERS];
+	m_aiStolenPlotsAttitudeCache = new int[MAX_PLAYERS];
+	///Tks Med
+	//m_aiInsultedAttitudeCache = new int[MAX_PLAYERS];
+	//tkend
+
+	AI_reset();
+}
+
+
+CvPlayerAI::~CvPlayerAI()
+{
+	AI_uninit();
+
+	SAFE_DELETE_ARRAY(m_aiNumTrainAIUnits);
+	SAFE_DELETE_ARRAY(m_aiNumAIUnits);
+	SAFE_DELETE_ARRAY(m_aiNumRetiredAIUnits);
+	SAFE_DELETE_ARRAY(m_aiUnitAIStrategyWeights);
+	SAFE_DELETE_ARRAY(m_aiPeacetimeTradeValue);
+	SAFE_DELETE_ARRAY(m_aiPeacetimeGrantValue);
+	SAFE_DELETE_ARRAY(m_aiGoldTradedTo);
+	SAFE_DELETE_ARRAY(m_aiAttitudeExtra);
+	SAFE_DELETE_ARRAY(m_abFirstContact);
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		SAFE_DELETE_ARRAY(m_aaiContactTimer[i]);
+	}
+	SAFE_DELETE_ARRAY(m_aaiContactTimer);
+
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		SAFE_DELETE_ARRAY(m_aaiMemoryCount[i]);
+	}
+	SAFE_DELETE_ARRAY(m_aaiMemoryCount);
+
+	SAFE_DELETE_ARRAY(m_aiAverageYieldMultiplier);
+	SAFE_DELETE_ARRAY(m_aiCloseBordersAttitudeCache);
+	SAFE_DELETE_ARRAY(m_aiStolenPlotsAttitudeCache);
+	///TKs Med
+	//SAFE_DELETE_ARRAY(m_aiInsultedAttitudeCache);
+	//tkend
+	SAFE_DELETE_ARRAY(m_aiEmotions);
+	SAFE_DELETE_ARRAY(m_aiStrategyStartedTurn);
+	SAFE_DELETE_ARRAY(m_aiStrategyData);
+
+	SAFE_DELETE_ARRAY(m_aiBestWorkedYieldPlots);
+	SAFE_DELETE_ARRAY(m_aiBestUnworkedYieldPlots);
+	SAFE_DELETE_ARRAY(m_aiYieldValuesTimes100);
+}
+
+
+void CvPlayerAI::AI_init()
+{
+	AI_reset();
+
+	//--------------------------------
+	// Init other game data
+	if ((GC.getInitCore().getSlotStatus(getID()) == SS_TAKEN) || (GC.getInitCore().getSlotStatus(getID()) == SS_COMPUTER))
+	{
+		FAssert(getPersonalityType() != NO_LEADER);
+	}
+}
+
+
+void CvPlayerAI::AI_uninit()
+{
+	SAFE_DELETE_ARRAY(m_aiUnitClassWeights);
+	SAFE_DELETE_ARRAY(m_aiUnitCombatWeights);
+}
+
+
+void CvPlayerAI::AI_reset()
+{
+	int iI;
+
+	AI_uninit();
+
+	m_iAttackOddsChange = 0;
+	m_iExtraGoldTarget = 0;
+
+	m_eNextBuyUnit = NO_UNIT;
+	m_eNextBuyUnitAI = NO_UNITAI;
+	m_iNextBuyUnitValue = 0;
+
+	m_eNextBuyProfession = NO_PROFESSION;
+	m_eNextBuyProfessionUnit = NO_UNIT;
+	m_eNextBuyProfessionAI = NO_UNITAI;
+	m_iNextBuyProfessionValue = 0;
+
+	m_iTotalIncome = 0;
+	m_iHurrySpending = 0;
+
+	for (iI = 0; iI < NUM_UNITAI_TYPES; iI++)
+	{
+		m_aiNumTrainAIUnits[iI] = 0;
+		m_aiNumAIUnits[iI] = 0;
+		m_aiNumRetiredAIUnits[iI] = 0;
+		m_aiUnitAIStrategyWeights[iI] = 0;
+	}
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		m_aiPeacetimeTradeValue[iI] = 0;
+		m_aiPeacetimeGrantValue[iI] = 0;
+		m_aiGoldTradedTo[iI] = 0;
+		m_aiAttitudeExtra[iI] = 0;
+	}
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		m_abFirstContact[iI] = false;
+	}
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		for (int iJ = 0; iJ < NUM_CONTACT_TYPES; iJ++)
+		{
+			m_aaiContactTimer[iI][iJ] = 0;
+		}
+	}
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		for (int iJ = 0; iJ < NUM_MEMORY_TYPES; iJ++)
+		{
+			m_aaiMemoryCount[iI][iJ] = 0;
+		}
+	}
+
+	for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
+	{
+		m_aiAverageYieldMultiplier[iI] = 0;
+		m_aiBestWorkedYieldPlots[iI] = -1;
+		m_aiBestUnworkedYieldPlots[iI] = -1;
+		m_aiYieldValuesTimes100[iI] = 0;
+	}
+	m_iAveragesCacheTurn = -1;
+
+	m_iTurnLastProductionDirty = -1;
+	m_iTurnLastManagedPop = -1;
+	m_iMoveQueuePasses = 0;
+
+	m_iUpgradeUnitsCacheTurn = -1;
+	m_iUpgradeUnitsCachedExpThreshold = 0;
+	m_iUpgradeUnitsCachedGold = 0;
+
+	m_aiAICitySites.clear();
+
+	FAssert(m_aiUnitClassWeights == NULL);
+	m_aiUnitClassWeights = new int[GC.getNumUnitClassInfos()];
+	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		m_aiUnitClassWeights[iI] = 0;
+	}
+
+	FAssert(m_aiUnitCombatWeights == NULL);
+	m_aiUnitCombatWeights = new int[GC.getNumUnitCombatInfos()];
+	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
+	{
+		m_aiUnitCombatWeights[iI] = 0;
+	}
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		m_aiCloseBordersAttitudeCache[iI] = 0;
+		m_aiStolenPlotsAttitudeCache[iI] = 0;
+		///Tks Med
+		//m_aiInsultedAttitudeCache[iI] = 0;
+		//tkend
+	}
+
+
+	for (iI = 0; iI < NUM_EMOTION_TYPES; iI++)
+	{
+		m_aiEmotions[iI] = 0;
+	}
+
+	for (iI = 0; iI < NUM_STRATEGY_TYPES; iI++)
+	{
+		m_aiStrategyStartedTurn[iI] = -1;
+		m_aiStrategyData[iI] = -1;
+	}
+
+	m_iDistanceMapDistance = -1;
+	m_distanceMap.clear();
+	m_unitPriorityHeap.clear();
+}
+
+void CvPlayerAI::AI_doTurnPre()
+{
+	PROFILE_FUNC();
+
+	FAssertMsg(getPersonalityType() != NO_LEADER, "getPersonalityType() is not expected to be equal with NO_LEADER");
+	FAssertMsg(getLeaderType() != NO_LEADER, "getLeaderType() is not expected to be equal with NO_LEADER");
+	FAssertMsg(getCivilizationType() != NO_CIVILIZATION, "getCivilizationType() is not expected to be equal with NO_CIVILIZATION");
+
+	AI_invalidateCloseBordersAttitudeCache();
+
+	AI_doCounter();
+
+	AI_doEnemyUnitData();
+
+	if (isHuman())
+	{
+		return;
+	}
+
+	m_unitPriorityHeap.clear();
+	int iLoop;
+	for (CvUnit* pUnit = firstUnit(&iLoop); pUnit != NULL; pUnit = nextUnit(&iLoop))
+	{
+		pUnit->AI_setMovePriority(0);
+	}
+
+	AI_doEmotions();
+
+	AI_doUnitAIWeights();
+
+	AI_doMilitary();
+
+	AI_doStrategy();
+
+	AI_updateYieldValues();
+}
+
+
+void CvPlayerAI::AI_doTurnPost()
+{
+	PROFILE_FUNC();
+
+	if (isHuman())
+	{
+		return;
+	}
+
+	AI_doTradeRoutes();
+
+	AI_doDiplo();
+}
+
+
+void CvPlayerAI::AI_doTurnUnitsPre()
+{
+	PROFILE_FUNC();
+	AI_updateBestYieldPlots();
+	AI_updateFoundValues();
+	AI_doEmotions();
+
+	if (!isHuman())
+	{
+		if (getParent() != NO_PLAYER)
+		{
+			AI_doProfessions();
+			AI_doEurope();
+		}
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(8, "AI Update Area Targets") == 0) // XXX personality???
+	{
+		AI_updateAreaTargets();
+	}
+
+	if (!isHuman())
+	{
+		AI_doMilitaryStrategy();
+		AI_doSuppressRevolution();
+	}
+
+	if (isHuman())
+	{
+		return;
+	}
+}
+
+
+void CvPlayerAI::AI_doTurnUnitsPost()
+{
+	PROFILE_FUNC();
+
+	CvUnit* pLoopUnit;
+	int iLoop;
+	if (!isHuman() || isOption(PLAYEROPTION_AUTO_PROMOTION))
+	{
+		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+		{
+			pLoopUnit->AI_promote();
+		}
+	}
+
+	if (isHuman())
+	{
+		return;
+	}
+}
+
+
+void CvPlayerAI::AI_doPeace()
+{
+	PROFILE_FUNC();
+
+	CvDiploParameters* pDiplo;
+	CvCity* pBestReceiveCity;
+	CvCity* pBestGiveCity;
+	CvCity* pLoopCity;
+	CLinkList<TradeData> ourList;
+	CLinkList<TradeData> theirList;
+	bool abContacted[MAX_TEAMS];
+	TradeData item;
+	int iReceiveGold;
+	int iGiveGold;
+	int iGold;
+	int iValue;
+	int iBestValue;
+	int iOurValue;
+	int iTheirValue;
+	int iLoop;
+	int iI;
+	FAssert(!isHuman());
+
+	for (iI = 0; iI < MAX_TEAMS; iI++)
+	{
+		abContacted[iI] = false;
+	}
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			if (iI != getID())
+			{
+				if (canContact((PlayerTypes)iI) && AI_isWillingToTalk((PlayerTypes)iI))
+				{
+					if (!(GET_TEAM(getTeam()).isHuman()) && (GET_PLAYER((PlayerTypes)iI).isHuman() || !(GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).isHuman())))
+					{
+						if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER((PlayerTypes)iI).getTeam()))
+						{
+							if (!(GET_PLAYER((PlayerTypes)iI).isHuman()) || (GET_TEAM(getTeam()).getLeaderID() == getID()))
+							{
+								FAssertMsg(iI != getID(), "iI is not expected to be equal with getID()");
+								FAssert(GET_PLAYER((PlayerTypes)iI).getTeam() != getTeam());
+
+								if (GET_TEAM(getTeam()).AI_getAtWarCounter(GET_PLAYER((PlayerTypes)iI).getTeam()) > 10)
+								{
+									if (AI_getContactTimer(((PlayerTypes)iI), CONTACT_PEACE_TREATY) == 0)
+									{
+										bool bOffered = false;
+										if (!bOffered)
+										{
+											if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_PEACE_TREATY), "AI Diplo Peace Treaty") == 0)
+											{
+												setTradeItem(&item, TRADE_PEACE_TREATY, 0, NULL);
+
+												if (canTradeItem(((PlayerTypes)iI), item, true) && GET_PLAYER((PlayerTypes)iI).canTradeItem(getID(), item, true))
+												{
+													iOurValue = GET_TEAM(getTeam()).AI_endWarVal(GET_PLAYER((PlayerTypes)iI).getTeam());
+													iTheirValue = GET_TEAM(GET_PLAYER((PlayerTypes)iI).getTeam()).AI_endWarVal(getTeam());
+													iReceiveGold = 0;
+													iGiveGold = 0;
+
+													pBestReceiveCity = NULL;
+													pBestGiveCity = NULL;
+
+													if (iTheirValue > iOurValue)
+													{
+														if (iTheirValue > iOurValue)
+														{
+															iBestValue = 0;
+														}
+
+														iGold = std::min((iTheirValue - iOurValue), GET_PLAYER((PlayerTypes)iI).AI_maxGoldTrade(getID()));
+
+														if (iGold > 0)
+														{
+															setTradeItem(&item, TRADE_GOLD, iGold, NULL);
+
+															if (GET_PLAYER((PlayerTypes)iI).canTradeItem(getID(), item, true))
+															{
+																iReceiveGold = iGold;
+																iOurValue += iGold;
+															}
+														}
+
+														if (iTheirValue > iOurValue)
+														{
+															iBestValue = 0;
+
+															for (pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
+															{
+																setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
+
+																if (GET_PLAYER((PlayerTypes)iI).canTradeItem(getID(), item, true))
+																{
+																	iValue = pLoopCity->plot()->calculateCulturePercent(getID());
+
+																	if (iValue > iBestValue)
+																	{
+																		iBestValue = iValue;
+																		pBestReceiveCity = pLoopCity;
+																	}
+																}
+															}
+
+															if (pBestReceiveCity != NULL)
+															{
+																iOurValue += AI_cityTradeVal(pBestReceiveCity);
+															}
+														}
+													}
+													else if (iOurValue > iTheirValue)
+													{
+														iBestValue = 0;
+														iGold = std::min((iOurValue - iTheirValue), AI_maxGoldTrade((PlayerTypes)iI));
+
+														if (iGold > 0)
+														{
+															setTradeItem(&item, TRADE_GOLD, iGold, NULL);
+
+															if (canTradeItem(((PlayerTypes)iI), item, true))
+															{
+																iGiveGold = iGold;
+																iTheirValue += iGold;
+															}
+														}
+
+														iBestValue = 0;
+
+														for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+														{
+															setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
+
+															if (canTradeItem(((PlayerTypes)iI), item, true))
+															{
+																if (GET_PLAYER((PlayerTypes)iI).AI_cityTradeVal(pLoopCity) <= (iOurValue - iTheirValue))
+																{
+																	iValue = pLoopCity->plot()->calculateCulturePercent((PlayerTypes)iI);
+
+																	if (iValue > iBestValue)
+																	{
+																		iBestValue = iValue;
+																		pBestGiveCity = pLoopCity;
+																	}
+																}
+															}
+														}
+
+														if (pBestGiveCity != NULL)
+														{
+															iTheirValue += GET_PLAYER((PlayerTypes)iI).AI_cityTradeVal(pBestGiveCity);
+														}
+													}
+
+													if ((GET_PLAYER((PlayerTypes)iI).isHuman()) ? (iOurValue >= iTheirValue) : ((iOurValue > ((iTheirValue * 3) / 5)) && (iTheirValue > ((iOurValue * 3) / 5))))
+													{
+														ourList.clear();
+														theirList.clear();
+
+														setTradeItem(&item, TRADE_PEACE_TREATY, 0, NULL);
+
+														ourList.insertAtEnd(item);
+														theirList.insertAtEnd(item);
+														if (iGiveGold != 0)
+														{
+															setTradeItem(&item, TRADE_GOLD, iGiveGold, NULL);
+															ourList.insertAtEnd(item);
+														}
+
+														if (iReceiveGold != 0)
+														{
+															setTradeItem(&item, TRADE_GOLD, iReceiveGold, NULL);
+															theirList.insertAtEnd(item);
+														}
+
+														if (pBestGiveCity != NULL)
+														{
+															setTradeItem(&item, TRADE_CITIES, pBestGiveCity->getID(), NULL);
+															ourList.insertAtEnd(item);
+														}
+
+														if (pBestReceiveCity != NULL)
+														{
+															setTradeItem(&item, TRADE_CITIES, pBestReceiveCity->getID(), NULL);
+															theirList.insertAtEnd(item);
+														}
+
+														if (GET_PLAYER((PlayerTypes)iI).isHuman())
+														{
+															if (!(abContacted[GET_PLAYER((PlayerTypes)iI).getTeam()]))
+															{
+																AI_changeContactTimer(((PlayerTypes)iI), CONTACT_PEACE_TREATY, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_PEACE_TREATY));
+																pDiplo = new CvDiploParameters(getID());
+																FAssertMsg(pDiplo != NULL, "pDiplo must be valid");
+																pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_PEACE"));
+																pDiplo->setAIContact(true);
+																pDiplo->setOurOfferList(theirList);
+																pDiplo->setTheirOfferList(ourList);
+																gDLL->beginDiplomacy(pDiplo, (PlayerTypes)iI);
+																abContacted[GET_PLAYER((PlayerTypes)iI).getTeam()] = true;
+															}
+														}
+														else
+														{
+															GC.getGameINLINE().implementDeal(getID(), ((PlayerTypes)iI), &ourList, &theirList);
+														}
+													}
+												}
+											}
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+
+void CvPlayerAI::AI_updateFoundValues(bool bStartingLoc)
+{
+	PROFILE_FUNC();
+
+	int iLoop;
+	for(CvArea* pLoopArea = GC.getMapINLINE().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMapINLINE().nextArea(&iLoop))
+	{
+		pLoopArea->setBestFoundValue(getID(), 0);
+	}
+
+	if (bStartingLoc)
+	{
+		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+		{
+			GC.getMapINLINE().plotByIndexINLINE(iI)->setFoundValue(getID(), -1);
+		}
+	}
+	else
+	{
+		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+		{
+			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+
+			int iValue = 0;
+			if (pLoopPlot->isRevealed(getTeam(), false))
+			{
+				long lResult=-1;
+				if(GC.getUSE_GET_CITY_FOUND_VALUE_CALLBACK())
+				{
+					CyArgsList argsList;
+					argsList.add((int)getID());
+					argsList.add(pLoopPlot->getX());
+					argsList.add(pLoopPlot->getY());
+					gDLL->getPythonIFace()->callFunction(PYGameModule, "getCityFoundValue", argsList.makeFunctionArgs(), &lResult);
+				}
+
+				if (lResult == -1)
+				{
+					iValue = AI_foundValue(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
+				}
+				else
+				{
+					iValue = lResult;
+				}
+			}
+
+			pLoopPlot->setFoundValue(getID(), iValue);
+
+			CvArea* pArea = pLoopPlot->area();
+			if (iValue > pArea->getBestFoundValue(getID()))
+			{
+				pArea->setBestFoundValue(getID(), iValue);
+			}
+		}
+	}
+}
+
+
+void CvPlayerAI::AI_updateAreaTargets()
+{
+	CvArea* pLoopArea;
+	int iLoop;
+
+	for(pLoopArea = GC.getMapINLINE().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMapINLINE().nextArea(&iLoop))
+	{
+		if (!(pLoopArea->isWater()))
+		{
+			if (GC.getGameINLINE().getSorenRandNum(3, "AI Target City") == 0)
+			{
+				pLoopArea->setTargetCity(getID(), NULL);
+			}
+			else
+			{
+				pLoopArea->setTargetCity(getID(), AI_findTargetCity(pLoopArea));
+			}
+		}
+	}
+}
+
+
+// Returns priority for unit movement (lower values move first...)
+int CvPlayerAI::AI_movementPriority(CvSelectionGroup* pGroup)
+{
+	CvUnit* pHeadUnit;
+	int iCurrCombat;
+	int iBestCombat;
+
+	pHeadUnit = pGroup->getHeadUnit();
+
+	if (pHeadUnit != NULL)
+	{
+		if (pHeadUnit->hasCargo())
+		{
+			if (pHeadUnit->specialCargo() == NO_SPECIALUNIT)
+			{
+				return 0;
+			}
+			else
+			{
+				return 1;
+			}
+		}
+
+		if (pHeadUnit->AI_getUnitAIType() == UNITAI_SETTLER)
+		{
+			return 2;
+		}
+
+		if (pHeadUnit->AI_getUnitAIType() == UNITAI_WORKER)
+		{
+			return 3;
+		}
+
+		if (pHeadUnit->AI_getUnitAIType() == UNITAI_SCOUT)
+		{
+			return 4;
+		}
+
+		if (pHeadUnit->bombardRate() > 0)
+		{
+			return 5;
+		}
+
+		if (pHeadUnit->canFight())
+		{
+			if (pHeadUnit->withdrawalProbability() > 20)
+			{
+				return 7;
+			}
+
+			if (pHeadUnit->withdrawalProbability() > 0)
+			{
+				return 8;
+			}
+
+			iCurrCombat = pHeadUnit->currCombatStr(NULL, NULL);
+			iBestCombat = (GC.getGameINLINE().getBestLandUnitCombat() * 100);
+
+			if (pHeadUnit->noDefensiveBonus())
+			{
+				iCurrCombat *= 3;
+				iCurrCombat /= 2;
+			}
+
+			if (pHeadUnit->AI_isCityAIType())
+			{
+				iCurrCombat /= 2;
+			}
+
+			if (iCurrCombat > iBestCombat)
+			{
+				return 9;
+			}
+			else if (iCurrCombat > ((iBestCombat * 4) / 5))
+			{
+				return 10;
+			}
+			else if (iCurrCombat > ((iBestCombat * 3) / 5))
+			{
+				return 11;
+			}
+			else if (iCurrCombat > ((iBestCombat * 2) / 5))
+			{
+				return 12;
+			}
+			else if (iCurrCombat > ((iBestCombat * 1) / 5))
+			{
+				return 13;
+			}
+			else
+			{
+				return 14;
+			}
+		}
+
+		return 15;
+	}
+
+	return 16;
+}
+
+void CvPlayerAI::AI_unitUpdate()
+{
+	PROFILE_FUNC();
+
+	CLLNode<int>* pCurrUnitNode;
+	CvSelectionGroup* pLoopSelectionGroup;
+	CLinkList<int> tempGroupCycle;
+	CLinkList<int> finalGroupCycle;
+
+
+	if (GC.getGameINLINE().getGameTurn() != m_iTurnLastManagedPop)
+	{
+		//This should only be done once a turn, but must be done right before
+		//units are moved else it's unfair on the AI.
+		if (!isHuman())
+		{
+			int iLoop;
+			CvCity* pLoopCity;
+			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+			{
+				if (isNative())
+				{
+					pLoopCity->AI_doNative();
+				}
+				else if (pLoopCity->getPopulation() > 1)
+				{
+					int iValue = std::max(1, 11 / (1 + pLoopCity->getPopulation()));
+					if (((GC.getGameINLINE().getGameTurn() + iLoop) % iValue) == 0)
+					{
+						bool bRemove = true;
+						CvUnit* pRemoveUnit = pLoopCity->getPopulationUnitByIndex(0);
+
+						if (pRemoveUnit->getProfession() != NO_PROFESSION)
+						{
+							CvProfessionInfo& kProfession = GC.getProfessionInfo(pRemoveUnit->getProfession());
+							// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+							YieldTypes eYieldProducedType = (YieldTypes)kProfession.getYieldsProduced(0);
+							// MultipleYieldsProduced End
+							if (eYieldProducedType == YIELD_EDUCATION)
+							{
+								bRemove = false;
+							}
+
+							if (bRemove && (pRemoveUnit->AI_getIdealProfession() != NO_PROFESSION) && (pRemoveUnit->getProfession() == pRemoveUnit->AI_getIdealProfession()))
+							{
+								bRemove = false;
+								// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+								YieldTypes eYieldProducedType = (YieldTypes)kProfession.getYieldsProduced(0);
+								// MultipleYieldsProduced End
+								if (kProfession.isWorkPlot())
+								{
+									CvPlot* pWorkedPlot = pLoopCity->getPlotWorkedByUnit(pRemoveUnit);
+									if (pWorkedPlot == NULL)
+									{
+										bRemove = true;
+									}
+									else
+									{
+										if ((pWorkedPlot->getBonusType() == NO_BONUS) || (GC.getBonusInfo(pWorkedPlot->getBonusType()).getYieldChange(eYieldProducedType) <= 0))
+										{
+											bRemove = true;
+										}
+										else
+										{
+											CvPlot* pBestWorkedPlot = AI_getBestWorkedYieldPlot(eYieldProducedType);
+											if ((pBestWorkedPlot == NULL) || (pWorkedPlot->calculateBestNatureYield(eYieldProducedType, getTeam()) < pBestWorkedPlot->calculateBestNatureYield(eYieldProducedType, getTeam())))
+											{
+												bRemove = true;
+											}
+										}
+									}
+								}
+								else
+								{
+									if (pLoopCity->AI_getYieldAdvantage(eYieldProducedType) < 100)
+									{
+										bRemove = true;
+									}
+								}
+							}
+						}
+						if (bRemove)
+						{
+							pLoopCity->removePopulationUnit(pRemoveUnit, false, (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession());
+						}
+					}
+				}
+			}
+
+			for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+			{
+				if (pLoopUnit->AI_getMovePriority() == 0)
+				{
+					pLoopUnit->AI_doInitialMovePriority();
+				}
+				else
+				{
+					FAssert(std::find(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), pLoopUnit->getID()) != m_unitPriorityHeap.end());
+				}
+			}
+			m_iTurnLastManagedPop = GC.getGameINLINE().getGameTurn();
+			m_iMoveQueuePasses = 0;
+		}
+	}
+
+	if (!hasBusyUnit())
+	{
+		pCurrUnitNode = headGroupCycleNode();
+
+		while (pCurrUnitNode != NULL)
+		{
+			pLoopSelectionGroup = getSelectionGroup(pCurrUnitNode->m_data);
+			pCurrUnitNode = nextGroupCycleNode(pCurrUnitNode);
+
+			if (pLoopSelectionGroup->AI_isForceSeparate())
+			{
+				// do not split groups that are in the midst of attacking
+				if (pLoopSelectionGroup->isForceUpdate() || !pLoopSelectionGroup->AI_isGroupAttack())
+				{
+					pLoopSelectionGroup->AI_separate();	// pointers could become invalid...
+				}
+			}
+		}
+
+		if (isHuman())
+		{
+			pCurrUnitNode = headGroupCycleNode();
+
+			while (pCurrUnitNode != NULL)
+			{
+				pLoopSelectionGroup = getSelectionGroup(pCurrUnitNode->m_data);
+				pCurrUnitNode = nextGroupCycleNode(pCurrUnitNode);
+
+				if (pLoopSelectionGroup == NULL || pLoopSelectionGroup->AI_update())
+				{
+					break; // pointers could become invalid...
+				}
+			}
+		}
+        else
+		{
+			int iLoop;
+
+			//Continue existing missions.
+			for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+			{
+				pLoopSelectionGroup->autoMission();
+			}
+			///TKs Test
+			///if (getID() == 9)
+			///{
+				//int test = 0;
+			//}
+
+			while (!m_unitPriorityHeap.empty())
+			{
+				AI_verifyMoveQueue();
+				CvUnit* pUnit = AI_getNextMoveUnit();
+//				///TKs Test
+//				int iID = pUnit->getID();
+//				///Kailric DeBug
+//				char szTKdebug[1024];
+//				sprintf( szTKdebug, "Unit Id = %d\n", iID);
+//				gDLL->messageControlLog(szTKdebug);
+				///TKS Med Testing
+
+				//if (pUnit != NULL)
+				//{
+					//if (pUnit->getID() == 8 && getID() == 0 && pUnit->getUnitTravelState() == UNIT_TRAVEL_STATE_IN_EUROPE)
+					//{
+						//FAssert(false);
+					//}
+				//}
+				///TKe
+
+				if ((pUnit != NULL) && shouldUnitMove(pUnit))
+				{
+					int iOriginalPriority = pUnit->AI_getMovePriority();
+					if (iOriginalPriority > 0)
+					{
+						if (!pUnit->getGroup()->isBusy() && !pUnit->getGroup()->isCargoBusy())
+						{
+							pUnit->AI_update();
+						}
+						else
+						{
+							m_iMoveQueuePasses++;
+							if (m_iMoveQueuePasses > 100)
+							{
+								FAssertMsg(false, "Forcing AI to abort turn");
+								return;
+							}
+							AI_addUnitToMoveQueue(pUnit);
+							return;
+						}
+					}
+				}
+			}
+
+			for (CvSelectionGroup*pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+			{
+				if (pLoopSelectionGroup->readyToMove())
+				{
+					pLoopSelectionGroup->pushMission(MISSION_SKIP);
+				}
+			}
+		}
+	}
+}
+
+
+void CvPlayerAI::AI_makeAssignWorkDirty()
+{
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		pLoopCity->AI_setAssignWorkDirty(true);
+	}
+}
+
+
+void CvPlayerAI::AI_assignWorkingPlots()
+{
+	AI_manageEconomy();
+
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		pLoopCity->AI_assignWorkingPlots();
+	}
+}
+
+
+void CvPlayerAI::AI_updateAssignWork()
+{
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		pLoopCity->AI_updateAssignWork();
+	}
+}
+
+
+void CvPlayerAI::AI_makeProductionDirty()
+{
+	FAssertMsg(!isHuman(), "isHuman did not return false as expected");
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		pLoopCity->AI_setChooseProductionDirty(true);
+	}
+}
+
+
+void CvPlayerAI::AI_conquerCity(CvCity* pCity)
+{
+	bool bRaze = false;
+	if (canRaze(pCity))
+	{
+		bRaze = isNative();
+
+		if (!bRaze)
+		{
+			CvCity* pNearestCity;
+			int iRazeValue;
+
+			iRazeValue = 0;
+			if (GC.getGameINLINE().getElapsedGameTurns() > 20)
+			{
+				if (getNumCities() > 4)
+				{
+					pNearestCity = GC.getMapINLINE().findCity(pCity->getX_INLINE(), pCity->getY_INLINE(), NO_PLAYER, getTeam(), true, false, NO_TEAM, NO_DIRECTION, pCity);
+
+					if (pNearestCity == NULL)
+					{
+						if (pCity->getPreviousOwner() != NO_PLAYER)
+						{
+							if (GET_TEAM(GET_PLAYER(pCity->getPreviousOwner()).getTeam()).countNumCitiesByArea(pCity->area()) > 3)
+							{
+								iRazeValue += 30;
+							}
+						}
+					}
+					else
+					{
+						int iDistance = plotDistance(pCity->getX_INLINE(), pCity->getY_INLINE(), pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE());
+						if ( iDistance > 12)
+						{
+							iRazeValue += iDistance * 2;
+						}
+					}
+
+					int iCloseness = pCity->AI_playerCloseness(getID());
+					if (iCloseness > 0)
+					{
+						iRazeValue -= 25;
+						iRazeValue -= iCloseness * 2;
+					}
+					else
+					{
+						iRazeValue += 60;
+					}
+
+					if (pCity->area()->getCitiesPerPlayer(getID()) > 0)
+					{
+						iRazeValue += GC.getLeaderHeadInfo(getPersonalityType()).getRazeCityProb();
+					}
+
+					if (iRazeValue > 0)
+					{
+						if (GC.getGameINLINE().getSorenRandNum(100, "AI Raze City") < iRazeValue)
+						{
+							bRaze = true;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (bRaze)
+	{
+		pCity->doTask(TASK_RAZE);
+	}
+	else
+	{
+		gDLL->getEventReporterIFace()->cityAcquiredAndKept(GC.getGameINLINE().getActivePlayer(), pCity);
+	}
+}
+
+
+bool CvPlayerAI::AI_acceptUnit(CvUnit* pUnit)
+{
+	return true;
+}
+
+
+bool CvPlayerAI::AI_captureUnit(UnitTypes eUnit, CvPlot* pPlot)
+{
+	CvCity* pNearestCity;
+
+	FAssert(!isHuman());
+
+	if (pPlot->getTeam() == getTeam())
+	{
+		return true;
+	}
+
+	pNearestCity = GC.getMapINLINE().findCity(pPlot->getX_INLINE(), pPlot->getY_INLINE(), NO_PLAYER, getTeam());
+
+	if (pNearestCity != NULL)
+	{
+		if (plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE()) <= 4)
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+DomainTypes CvPlayerAI::AI_unitAIDomainType(UnitAITypes eUnitAI)
+{
+	switch (eUnitAI)
+	{
+	case UNITAI_UNKNOWN:
+		return NO_DOMAIN;
+		break;
+
+	case UNITAI_COLONIST:
+	case UNITAI_SETTLER:
+	case UNITAI_WORKER:
+	case UNITAI_MISSIONARY:
+	case UNITAI_SCOUT:
+	case UNITAI_WAGON:
+	case UNITAI_TREASURE:
+	case UNITAI_YIELD:
+	case UNITAI_GENERAL:
+	case UNITAI_DEFENSIVE:
+	case UNITAI_OFFENSIVE:
+	case UNITAI_COUNTER:
+	///TKs Med
+	case UNITAI_ANIMAL:
+	case UNITAI_HUNTSMAN:
+	case UNITAI_MARAUDER:
+	case UNITAI_TRADER:
+	///TKe
+		return DOMAIN_LAND;
+		break;
+
+	case UNITAI_TRANSPORT_SEA:
+	case UNITAI_ASSAULT_SEA:
+	case UNITAI_COMBAT_SEA:
+	case UNITAI_PIRATE_SEA:
+		return DOMAIN_SEA;
+		break;
+
+	default:
+		FAssert(false);
+		break;
+	}
+
+	return NO_DOMAIN;
+}
+
+bool CvPlayerAI::AI_unitAIIsCombat(UnitAITypes eUnitAI)
+{
+	switch (eUnitAI)
+	{
+	case UNITAI_UNKNOWN:
+		return false;
+		break;
+
+	case UNITAI_COLONIST:
+	case UNITAI_SETTLER:
+	case UNITAI_WORKER:
+	case UNITAI_MISSIONARY:
+	case UNITAI_SCOUT:
+	case UNITAI_WAGON:
+	case UNITAI_TREASURE:
+	case UNITAI_YIELD:
+	case UNITAI_GENERAL:
+	///TKs Med
+	case UNITAI_TRADER:
+	///TKe
+		return false;
+		break;
+
+	case UNITAI_DEFENSIVE:
+	case UNITAI_OFFENSIVE:
+	case UNITAI_COUNTER:
+	///TKs Med
+	case UNITAI_ANIMAL:
+	case UNITAI_HUNTSMAN:
+	case UNITAI_MARAUDER:
+	///TKe
+		return true;
+		break;
+
+	case UNITAI_TRANSPORT_SEA:
+	case UNITAI_ASSAULT_SEA:
+	case UNITAI_COMBAT_SEA:
+	case UNITAI_PIRATE_SEA:
+		return true;
+		break;
+
+	default:
+		FAssert(false);
+		break;
+	}
+	return false;
+}
+
+
+int CvPlayerAI::AI_yieldWeight(YieldTypes eYield)
+{
+	return GC.getYieldInfo(eYield).getAIWeightPercent();
+}
+
+int CvPlayerAI::AI_estimatedColonistIncome(CvPlot* pPlot, CvUnit* pColonist)
+{
+	FAssert(pPlot != NULL);
+
+	int iX = pPlot->getX_INLINE();
+	int iY = pPlot->getY_INLINE();
+
+	bool bFound = pColonist->canFound(pPlot);
+	bool bJoin = pColonist->canJoinCity(pPlot);
+
+	FAssert(!(bFound && bJoin));
+
+	if (!(bFound || bJoin))
+	{
+		return -1;
+	}
+
+	if (!pPlot->isRevealed(getTeam(), false))
+	{
+		return -1;
+	}
+
+	//Calculate the income from the city tile plus the most profitable plot.
+	int iTotal = 0;
+
+	CvPlayer& kPlayerEurope = GET_PLAYER(getParent());
+
+	if (bFound)
+	{
+		//cities get food and one other yield
+		YieldTypes bestYield = NO_YIELD;
+		int bestOutput = 0;
+		for (int i = 0; i < NUM_YIELD_TYPES; i++)
+		{
+			//ignore food and lumber
+			if ((i != YIELD_FOOD) && (i != YIELD_LUMBER))
+			{
+				int natureYield = pPlot->calculateNatureYield((YieldTypes) i, getTeam(), false);
+				if (natureYield > bestOutput)
+				{
+					bestYield = (YieldTypes) i;
+					bestOutput = natureYield;
+				}
+			}
+		}
+
+		if (bestYield != NO_YIELD)
+		{
+			if (isYieldEuropeTradable(bestYield))
+			{
+				iTotal += kPlayerEurope.getYieldSellPrice(bestYield) * bestOutput;
+			}
+		}
+	}
+
+	int iBestValue = 0;
+	for (int i = 0; i < NUM_CITY_PLOTS; i++)
+	{
+		CvPlot* pLoopPlot = plotCity(iX, iY, i);
+
+		if (pLoopPlot != NULL)
+		{
+			if (!pLoopPlot->isBeingWorked())
+			{
+				YieldTypes bestYield = NO_YIELD;
+				int bestOutput = 0;
+				for (int j = 0; j < GC.getNumProfessionInfos(); j++)
+				{
+					ProfessionTypes loopProfession = (ProfessionTypes)j;
+					if (GC.getCivilizationInfo(getCivilizationType()).isValidProfession(loopProfession))
+					{
+						CvProfessionInfo& kProfession = GC.getProfessionInfo(loopProfession);
+
+						if (GC.getProfessionInfo(loopProfession).isWorkPlot())
+						{
+							CvProfessionInfo& kProfession = GC.getProfessionInfo(loopProfession);
+							// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+							YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
+							// MultipleYieldsProduced End
+							if ((eYield != NO_YIELD) && isYieldEuropeTradable(eYield))
+							{
+								int iValue = 0;
+								int yield = pPlot->calculatePotentialProfessionYieldAmount(loopProfession, pColonist, false);
+								if (eYield == YIELD_LUMBER)
+								{
+									iValue += (yield * kPlayerEurope.getYieldSellPrice(eYield)) / 2;
+								}
+								else
+								{
+									iValue += yield * kPlayerEurope.getYieldBuyPrice(eYield);
+								}
+
+								iBestValue = std::max(iValue, iBestValue);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	iTotal += iBestValue;
+
+	if (bFound)
+	{
+		iTotal *= 7;
+		iTotal /= 6 + getNumCities();
+	}
+
+	return iTotal;
+}
+
+int CvPlayerAI::AI_foundValue(int iX, int iY, int iMinRivalRange, bool bStartingLoc)
+{
+	PROFILE_FUNC();
+	CvPlot* pPlot = GC.getMapINLINE().plotINLINE(iX, iY);
+
+	if (!canFound(iX, iY))
+	{
+		return 0;
+	}
+    ///TKs Med
+    bool bWaterStartNoCity = (!GC.getCivilizationInfo(getCivilizationType()).isWaterStart() && getNumCities() == 0);
+    int iTerrainMod = 1;
+    int iFinalMod = 1;
+	if (!bStartingLoc && !bWaterStartNoCity)
+	{
+		if (!pPlot->isRevealed(getTeam(), false))
+		{
+			return 0;
+		}
+//		if (!GC.getGameINLINE().isFinalInitialized() && isNative())
+//		{
+//            for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
+//            {
+//                CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes) iPlayer);
+//                if ((iPlayer != getID()) && otherPlayer.isAlive())
+//                {
+//                    CvPlot* pOtherPlot = otherPlayer.getStartingPlot();
+//                    if(pOtherPlot == pPlot)
+//                    {
+//                        return 0;
+//                    }
+//                    if(pOtherPlot != NULL)
+//                    {
+//                        int iRange = GC.getMIN_CITY_RANGE();
+//
+//                        for (int iDX = -(iRange); iDX <= iRange; iDX++)
+//                        {
+//                            for (int iDY = -(iRange); iDY <= iRange; iDY++)
+//                            {
+//                                CvPlot* pLoopPlot	= plotXY(pOtherPlot->getX_INLINE(), pOtherPlot->getY_INLINE(), iDX, iDY);
+//
+//                                if (pLoopPlot != NULL)
+//                                {
+//                                    if (pPlot == pLoopPlot)
+//                                    {
+//                                        return 0;
+//                                    }
+//                                }
+//                            }
+//                        }
+//                    }
+//                }
+//            }
+//		}
+
+	}
+	else
+	{
+	    if (pPlot->isCity())
+	    {
+	        return 0;
+	    }
+        if (pPlot->isCityRadius())
+	    {
+	        iFinalMod = 10;
+	    }
+	    if (!isNative() && GC.getCache_NO_STARTING_PLOTS_IN_JUNGLE() >= 1)
+	    {
+	        bool bReduceNoZones = false;
+	        for (int iWorld=0; iWorld<NUM_WORLDSIZE_TYPES; iWorld++)
+            {
+                if (GC.getMapINLINE().getWorldSize() == (WorldSizeTypes)iWorld)
+                {
+                    if (iWorld == 0 || iWorld == 1 || iWorld == 2)
+                    {
+                        bReduceNoZones = true;
+                        break;
+                    }
+                }
+            }
+	       // if (pPlot->getFeatureType() == (FeatureTypes)GC.getDefineINT("JUNGLE_FEATURE"))
+	       // {
+	         //   iFinalMod = 10;
+	       // }
+	        if (pPlot->getImprovementType() != NO_IMPROVEMENT)
+            {
+                if (GC.getImprovementInfo(pPlot->getImprovementType()).isGoody())
+                {
+                    iFinalMod = 5;
+                }
+            }
+            if (!bReduceNoZones)
+            {
+                int iSearchRange = GC.getCache_NO_STARTING_PLOTS_IN_JUNGLE();
+                int iDX, iDY;
+                for (iDX = -(iSearchRange); iDX <= iSearchRange; iDX++)
+                {
+                    for (iDY = -(iSearchRange); iDY <= iSearchRange; iDY++)
+                    {
+                        CvPlot* pLoopPlot = ::plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+
+                        if (pLoopPlot != NULL)
+                        {
+                            if (!pLoopPlot->isWater() && pLoopPlot->isEurope())
+                            {
+                                return 0;
+                            }
+                            if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
+                            {
+                                if (GC.getImprovementInfo(pLoopPlot->getImprovementType()).isGoody())
+                                {
+                                    iFinalMod = 2;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+	    }
+	    int iMinPlotDistance = startingPlotRange();
+        for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
+        {
+            CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes) iPlayer);
+            if ((iPlayer != getID()) && otherPlayer.isAlive())
+            {
+                CvPlot* pOtherPlot = otherPlayer.getStartingPlot();
+                if(pOtherPlot == pPlot)
+                {
+                    return 0;
+                }
+                if (!otherPlayer.isNative() && pOtherPlot != NULL)
+                {
+                    if(!GC.getCivilizationInfo(otherPlayer.getCivilizationType()).isWaterStart())
+                    {
+                        int iPlotDistance = plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pOtherPlot->getX_INLINE(), pOtherPlot->getY_INLINE());
+                        if (iPlotDistance < iMinPlotDistance)
+                        {
+                            return iPlotDistance;
+                        }
+                    }
+//                    int iSearchRange = GC.getDefineINT("NO_STARTING_PLOTS_IN_JUNGLE");
+//                    int iDX, iDY;
+//                    for (iDX = -(iSearchRange); iDX <= iSearchRange; iDX++)
+//                    {
+//                        for (iDY = -(iSearchRange); iDY <= iSearchRange; iDY++)
+//                        {
+//                            CvPlot* pLoopPlot = ::plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+//
+//                            if (pLoopPlot != NULL)
+//                            {
+//                                if(pOtherPlot == pLoopPlot)
+//                                {
+//                                    return 1;
+//                                }
+//
+//                            }
+//                        }
+//                    }
+                }
+            }
+        }
+//        TerrainTypes eFavoredTerrain = NO_TERRAIN;
+//        if (!isNative() && getNumCities() == 0)
+//        {
+//            eFavoredTerrain = (TerrainTypes)GC.getCivilizationInfo(getCivilizationType()).getFavoredTerrain();
+//            if (eFavoredTerrain != NO_TERRAIN)
+//            {
+//                if (pPlot->getTerrainType() == eFavoredTerrain)
+//                {
+//                    iTerrainMod = GC.getDefineINT("AI_FAVORED_TERRAIN_MOD");
+//                }
+//            }
+//        }
+	}
+    ///TKe
+
+	bool bNeedMoreExploring = false;
+	if (getNumCities() == 0 && (pPlot->area()->getNumRevealedTiles(getTeam()) < 10))
+	{
+		bNeedMoreExploring = true;
+	}
+
+	if (isNative() && getNumCities() > 0)
+	{
+		int iRange = CITY_PLOTS_RADIUS * 2 - 1;
+
+		int iCityDistance = AI_cityDistance(pPlot);
+		if (iCityDistance == -1)
+		{
+			return 0;
+		}
+		if (iCityDistance < iRange || iCityDistance > (iRange * 3))
+		{
+			return 0;
+		}
+
+		for (int iDX = -iRange; iDX <= iRange; ++iDX)
+		{
+			for (int iDY = -iRange; iDY <= iRange; ++iDY)
+			{
+				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
+
+				if (pLoopPlot != NULL)
+				{
+					if (pLoopPlot->isOwned())
+					{
+						return 0;
+					}
+				}
+			}
+		}
+	}
+
+	bool bIsCoastal = pPlot->isCoastalLand(GC.getMIN_WATER_SIZE_FOR_OCEAN());
+	CvArea* pArea = pPlot->area();
+	int iNumAreaCities = pArea->getCitiesPerPlayer(getID());
+
+	bool bAdvancedStart = (getAdvancedStartPoints() >= 0);
+
+	if (!bStartingLoc && !bAdvancedStart)
+	{
+		if (iNumAreaCities == 0)
+		{
+			if (getParent() != NO_PLAYER)
+			{
+				if (pPlot->getNearestEurope() == NO_EUROPE)
+				{
+					return 0;
+				}
+			}
+		}
+	}
+
+	if (!bStartingLoc)
+	{
+		if (getNumCities() == 0)
+		{
+			if (pArea->getNumTiles() < (NUM_CITY_PLOTS * 3))
+			{
+				return 0;
+			}
+		}
+	}
+
+	if (bAdvancedStart)
+	{
+		//FAssert(!bStartingLoc);
+		FAssert(GC.getGameINLINE().isOption(GAMEOPTION_ADVANCED_START) || GC.getCivilizationInfo(getCivilizationType()).getAdvancedStartPoints() > 0);
+		if (bStartingLoc)
+		{
+			bAdvancedStart = false;
+		}
+	}
+
+	if (iMinRivalRange != -1)
+	{
+		for (int iDX = -(iMinRivalRange); iDX <= iMinRivalRange; iDX++)
+		{
+			for (int iDY = -(iMinRivalRange); iDY <= iMinRivalRange; iDY++)
+			{
+				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
+
+				if (pLoopPlot != NULL)
+				{
+					if (pLoopPlot->plotCheck(PUF_isOtherTeam, getID()) != NULL)
+					{
+						return 0;
+					}
+				}
+			}
+		}
+	}
+
+	int iOwnedTiles = 0;
+
+	for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
+	{
+		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
+
+		if (pLoopPlot == NULL)
+		{
+			iOwnedTiles++;
+		}
+		else if (pLoopPlot->isOwned() && !GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative())
+        {
+            if (pLoopPlot->getTeam() != getTeam())
+            {
+                iOwnedTiles++;
+            }
+        }
+	}
+
+	if (iOwnedTiles > (NUM_CITY_PLOTS / 3))
+	{
+		return 0;
+	}
+
+	int iBadTile = 0;
+	int iNativeTile = 0;
+	int iFriendlyTile = 0;
+	int iColonialTile = 0;
+
+	std::vector<int> aiFood(NUM_CITY_PLOTS, 0);
+
+	for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
+	{
+		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
+
+		if (pLoopPlot != NULL)
+		{
+			if (iI != CITY_HOME_PLOT)
+			{
+				if (pLoopPlot->isImpassable())
+				{
+					iBadTile += 2;
+				}
+				else if (!pLoopPlot->isOwned() || GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative())
+				{
+					if (!pLoopPlot->isHills() && !pLoopPlot->isWater())
+					{
+						if ((pLoopPlot->calculateBestNatureYield(YIELD_FOOD, getTeam()) == 0) || (pLoopPlot->calculateTotalBestNatureYield(getTeam()) <= 2))
+						{
+							iBadTile++;
+						}
+						else if (pLoopPlot->isWater() && !bIsCoastal && (pLoopPlot->calculateBestNatureYield(YIELD_FOOD, getTeam()) <= 1))
+						{
+							iBadTile++;
+						}
+					}
+				}
+			}
+			if (pLoopPlot->isOwned())
+			{
+				if (GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative())
+				{
+					iNativeTile++;
+				}
+				else if (GET_PLAYER(pLoopPlot->getOwnerINLINE()).getParent() != NO_PLAYER)
+				{
+					iColonialTile += pLoopPlot->getCityRadiusCount();
+					if (pLoopPlot->getTeam() == getTeam())
+					{
+						iFriendlyTile++;
+					}
+				}
+			}
+		}
+		else
+		{
+			iBadTile++;
+		}
+
+	}
+
+	if(!bStartingLoc)
+	{
+		if (bNeedMoreExploring)
+		{
+			if (iBadTile >= (NUM_CITY_PLOTS / 2))
+			{
+				return 0;
+			}
+		}
+	}
+
+
+	int aiBestWorkedYield[NUM_YIELD_TYPES];
+	int aiBestUnworkedYield[NUM_YIELD_TYPES];
+
+	for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+	{
+		CvPlot* pWorkedPlot = AI_getBestWorkedYieldPlot((YieldTypes)iYield);
+		if (pWorkedPlot == NULL)
+		{
+			aiBestWorkedYield[iYield] = 0;
+		}
+		else
+		{
+			aiBestWorkedYield[iYield] = pWorkedPlot->calculateBestNatureYield((YieldTypes)iYield, getTeam());
+		}
+
+		CvPlot* pUnworkedPlot = AI_getBestUnworkedYieldPlot((YieldTypes)iYield);
+		if (pUnworkedPlot == NULL)
+		{
+			aiBestUnworkedYield[iYield] = 0;
+		}
+		else
+		{
+			aiBestUnworkedYield[iYield] = pUnworkedPlot->calculateBestNatureYield((YieldTypes)iYield, getTeam());
+		}
+	}
+
+	int iTakenTiles = 0;
+	int iTeammateTakenTiles = 0;
+	int iValue = 1000;
+
+	int iBestPlotValue = 0;
+	for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
+	{
+		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
+
+		if (pLoopPlot == NULL)
+		{
+			iTakenTiles++;
+		}
+		else
+		{
+			if (pLoopPlot->isCityRadius())
+			{
+				iTakenTiles++;
+
+				if (pLoopPlot->getTeam() == getTeam() && pLoopPlot->getOwner() != getID())
+				{
+					iTeammateTakenTiles++;
+				}
+			}
+
+			if (!pLoopPlot->isCityRadius() || (pLoopPlot->isOwned() && GET_PLAYER(pLoopPlot->getOwnerINLINE()).isNative()))
+			{
+				int iBestBonusAmount = 0;
+				YieldTypes eBestBonusYield = NO_YIELD;
+
+				int aiYield[NUM_YIELD_TYPES];
+
+				for (int iYieldType = 0; iYieldType < NUM_YIELD_TYPES; ++iYieldType)
+				{
+
+
+					YieldTypes eYield = (YieldTypes)iYieldType;
+					int iYield = pLoopPlot->calculateBestNatureYield(eYield, getTeam());
+
+
+
+					if (iI == CITY_HOME_PLOT)
+					{
+						iYield += GC.getYieldInfo(eYield).getCityChange();
+						//XXX make sure this reflects reality of Col
+						iYield = std::max(iYield, GC.getYieldInfo(eYield).getMinCity());
+					}
+
+					aiYield[eYield] = iYield;
+					if (eYield == YIELD_FOOD)
+					{
+						aiFood[iI] = iYield;
+					}
+				}
+
+				if (iI == CITY_HOME_PLOT)
+				{
+					iValue += 2 * aiYield[YIELD_FOOD] * AI_yieldValue(YIELD_FOOD);
+
+					YieldTypes bestYield = NO_YIELD;
+					int bestOutput = 0;
+					for (int i = 0; i < NUM_YIELD_TYPES; i++)
+					{
+						//ignore food and lumber
+						if ((i != YIELD_FOOD) && (i != YIELD_LUMBER))
+						{
+							int natureYield = pPlot->calculateNatureYield((YieldTypes) i, getTeam(), false);
+							if (natureYield > bestOutput)
+							{
+								bestYield = (YieldTypes) i;
+								bestOutput = natureYield;
+							}
+						}
+					}
+					if (bestYield != NO_YIELD)
+					{
+						iValue += 2 * bestOutput * AI_yieldValue(bestYield);
+					}
+				}
+				else
+				{
+					YieldTypes eBestYield = NO_YIELD;
+					int iBestValue = 0;
+					for (int iYieldType = 0; iYieldType < NUM_YIELD_TYPES; ++iYieldType)
+					{
+						YieldTypes eYield = (YieldTypes)iYieldType;
+
+						if (aiYield[eYield] > 0)
+						{
+							int iYieldValue = aiYield[eYield] * AI_yieldValue(eYield);
+
+							if (pLoopPlot->isWater())
+							{
+								iYieldValue /= 2;
+							}
+
+							if (getNumCities() > 0)
+							{
+								if (aiYield[eYield] > aiBestUnworkedYield[eYield])
+								{
+									iYieldValue *= (4 + aiYield[eYield]);
+									iYieldValue /= (2 + aiBestUnworkedYield[eYield]);
+
+									if (aiBestWorkedYield[eYield] == 0)
+									{
+										iYieldValue *= 2;
+										if (aiBestUnworkedYield[eYield] == 0)
+										{
+											if (eYield == YIELD_LUMBER)
+											{
+												iYieldValue *= 4;
+											}
+										}
+									}
+								}
+							}
+							else
+							{
+								if (eYield == YIELD_LUMBER)
+								{
+									iYieldValue *= 2;
+								}
+							}
+
+							iValue += iYieldValue / ((getNumCities() == 0) ? 3 : 8);
+							if (iYieldValue > iBestValue)
+							{
+								iBestValue = iYieldValue;
+								eBestYield = eYield;
+							}
+						}
+					}
+
+					if (getNumCities() == 0)
+					{
+						if (eBestYield == YIELD_FOOD)
+						{
+							iBestValue *= 150;
+							iBestValue /= 100;
+						}
+					}
+
+					iValue += iBestValue;
+
+					iBestPlotValue = std::max(iBestPlotValue, iBestValue);
+
+					if (pLoopPlot->getBonusType() != NO_BONUS && eBestYield != NO_YIELD)
+					{
+						iValue += iBestValue;
+						if (GC.getBonusInfo(pLoopPlot->getBonusType()).getYieldChange(eBestYield) > 0)
+						{
+							iValue += iBestValue;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	iValue += iBestPlotValue;
+
+	if (iTeammateTakenTiles > 1)
+	{
+		return 0;
+	}
+
+	if (pPlot->isCoastalLand(GC.getMIN_WATER_SIZE_FOR_OCEAN()))
+	{
+		iValue *= 125;
+		iValue /= 100;
+	}
+
+	if (bStartingLoc)
+	{
+		int iRange = GREATER_FOUND_RANGE;
+		int iGreaterBadTile = 0;
+
+		for (int iDX = -(iRange); iDX <= iRange; iDX++)
+		{
+			for (int iDY = -(iRange); iDY <= iRange; iDY++)
+			{
+				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
+
+				if (pLoopPlot != NULL)
+				{
+					if (pLoopPlot->isWater() || (pLoopPlot->area() == pArea))
+					{
+						if (plotDistance(iX, iY, pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE()) <= iRange)
+						{
+						    int iTempValue = 0;
+							iTempValue += (pLoopPlot->calculatePotentialYield(YIELD_FOOD, NULL, false) * 15);
+							///TKs Med
+							iValue += (iTempValue * iTerrainMod);
+							if (iTempValue < 21 && iTerrainMod == 1)
+							{
+                            ///TKe
+								iGreaterBadTile += 2;
+								if (pLoopPlot->getFeatureType() != NO_FEATURE)
+								{
+							    	if (pLoopPlot->calculateBestNatureYield(YIELD_FOOD, getTeam()) > 1)
+							    	{
+										iGreaterBadTile--;
+							    	}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+
+		if (!pPlot->isStartingPlot())
+		{
+			iGreaterBadTile /= 2;
+			if (iGreaterBadTile > 12)
+			{
+				iValue *= 11;
+				iValue /= iGreaterBadTile;
+			}
+		}
+
+		int iWaterCount = 0;
+
+		for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
+		{
+		    CvPlot* pLoopPlot = plotCity(iX, iY, iI);
+
+            if (pLoopPlot != NULL)
+		    {
+		        if (pLoopPlot->isWater())
+		        {
+		            iWaterCount ++;
+		            if (pLoopPlot->calculatePotentialYield(YIELD_FOOD, NULL, false) <= 1)
+		            {
+		                iWaterCount++;
+					}
+				}
+			}
+		}
+		iWaterCount /= 2;
+
+		int iLandCount = (NUM_CITY_PLOTS - iWaterCount);
+
+		if (iLandCount < (NUM_CITY_PLOTS / 2))
+		{
+		    //discourage very water-heavy starts.
+		    iValue *= 1 + iLandCount;
+		    iValue /= (1 + (NUM_CITY_PLOTS / 2));
+		}
+	}
+
+	if (bStartingLoc)
+	{
+		if (pPlot->getMinOriginalStartDist() == -1)
+		{
+			iValue += (GC.getMapINLINE().maxStepDistance() * 100);
+		}
+		else
+		{
+			iValue *= (1 + 4 * pPlot->getMinOriginalStartDist());
+			iValue /= (1 + 2 * GC.getMapINLINE().maxStepDistance());
+		}
+
+		//nice hacky way to avoid this messing with normalizer, use elsewhere?
+		if (!pPlot->isStartingPlot())
+		{
+			int iMinDistanceFactor = MAX_INT;
+			int iMinRange = startingPlotRange();
+
+			iValue *= 100;
+			for (int iJ = 0; iJ < MAX_PLAYERS; iJ++)
+			{
+				if (GET_PLAYER((PlayerTypes)iJ).isAlive())
+				{
+					if (iJ != getID())
+					{
+						int iClosenessFactor = GET_PLAYER((PlayerTypes)iJ).startingPlotDistanceFactor(pPlot, getID(), iMinRange);
+						iMinDistanceFactor = std::min(iClosenessFactor, iMinDistanceFactor);
+
+						if (iClosenessFactor < 1000)
+						{
+							iValue *= 2000 + iClosenessFactor;
+							iValue /= 3000;
+						}
+					}
+				}
+			}
+
+			if (iMinDistanceFactor > 1000)
+			{
+				if (isNative())
+				{
+					iValue *= 500 + iMinDistanceFactor;
+					iValue /= 1500;
+				}
+				else
+				{
+					//give a maximum boost of 25% for somewhat distant locations, don't go overboard.
+					iMinDistanceFactor = std::min(1500, iMinDistanceFactor);
+					iValue *= (1000 + iMinDistanceFactor);
+					iValue /= 2000;
+				}
+			}
+			else if (iMinDistanceFactor < 1000)
+			{
+				//this is too close so penalize again.
+				iValue *= iMinDistanceFactor;
+				iValue /= 1000;
+				iValue *= iMinDistanceFactor;
+				iValue /= 1000;
+			}
+
+			iValue /= 10;
+		}
+	}
+
+	if (getNumCities() > 0)
+	{
+		//Friendly City Distance Modifier
+		if (isNative())
+		{
+			int iCityDistance = AI_cityDistance(pPlot);
+
+			iCityDistance = std::min(iCityDistance, 15);
+
+			iValue *= 10;
+			iValue /= 6 + iCityDistance;
+
+			if (iCityDistance < 4)
+			{
+				iValue /= 4 - iCityDistance;
+			}
+		}
+		else
+		{
+			int iCityDistance = AI_cityDistance(pPlot);
+
+			iCityDistance = std::min(iCityDistance, 10);
+
+			int iMinDistance = GC.getMIN_CITY_RANGE() + 1;
+			int iMaxDistance = iMinDistance + 2;
+
+			if (iCityDistance < iMinDistance)
+			{
+				int iFactor = AI_isStrategy(STRATEGY_DENSE_CITY_SPACING) ? 4 : 1;
+				iValue *= iFactor + iCityDistance;
+				iValue /= iFactor + iMinDistance;
+			}
+
+			if (iCityDistance > iMaxDistance)
+			{
+				iValue *= iMaxDistance;
+				iValue /= iCityDistance;
+			}
+
+			CvCity* pPrimaryCity = AI_getPrimaryCity();
+			if (pPrimaryCity != NULL)
+			{
+				int iDistance = stepDistance(iX, iY, pPrimaryCity->getX_INLINE(), pPrimaryCity->getY_INLINE());
+
+				iValue *= 6;
+				iValue /= 3 + iDistance;
+				if (iDistance > 9)
+				{
+					iValue *= 3;
+					iValue /= iDistance - 6;
+				}
+			}
+		}
+	}
+	///TKs Med
+	else if (!isNative() && GC.getCivilizationInfo(getCivilizationType()).isWaterStart())
+	{// Ocean Distance Modifier
+		iValue *= 8;
+		iValue /= std::max(1, pPlot->getDistanceToOcean());
+	}
+    ///TKe
+	if (iValue <= 0)
+	{
+		return 1;
+	}
+
+	if (bNeedMoreExploring)
+	{
+		int iBonusCount = 0;
+		int iLandCount = 0;
+		for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
+		{
+			CvPlot* pLoopPlot = plotCity(iX, iY, iI);
+
+			if (iI != CITY_HOME_PLOT)
+			{
+				if ((pLoopPlot == NULL) || pLoopPlot->isImpassable())
+				{
+					return 1;
+				}
+				else
+				{
+					if (pLoopPlot->getBonusType() != NO_BONUS)
+					{
+						iBonusCount++;
+					}
+				}
+				if (!pLoopPlot->isWater())
+				{
+					iLandCount++;
+				}
+			}
+
+		}
+
+		if (iBonusCount == 0)
+		{
+			return 1;
+		}
+		else if (iBonusCount == 1)
+		{
+			if (pPlot->getYield(YIELD_FOOD) < GC.getFOOD_CONSUMPTION_PER_POPULATION())
+			{
+				return 1;
+			}
+			if (iLandCount < (NUM_CITY_PLOTS / 2))
+			{
+				return 1;
+			}
+			iValue /= 4;
+		}
+	}
+
+	//Modify value according to easily attainable food.
+	//Making this more important for early cities.
+	{
+		int iFood = aiFood[CITY_HOME_PLOT];
+
+		std::sort(aiFood.begin(), aiFood.end(), std::greater<int>());
+
+		iFood += aiFood[0];
+
+		int iConsumption = 4 * GC.getFOOD_CONSUMPTION_PER_POPULATION();
+
+		if (iFood < iConsumption)
+		{
+			if (getNumCities() == 0)
+			{
+				return 1;
+			}
+			iValue *= 100 - 4 * (100 - 100 * iFood / iConsumption) / (4 + getNumCities());
+			iValue /= 100;
+		}
+		else if (iFood > iConsumption)
+		{
+			iValue *= 100 + ((100 * iFood / iConsumption) - 100) / (1 + getNumCities());
+			iValue /= 100;
+		}
+
+		if (isNative())
+		{
+			iValue *= iFood;
+			iValue /= iConsumption;
+		}
+	}
+
+	if (pPlot->getBonusType() != NO_BONUS)
+	{
+		iValue *= 2;
+		iValue /= 3;
+	}
+
+	//Modify values according to other player culture
+	if (!isNative())
+	{
+		iValue *= (NUM_CITY_PLOTS - iNativeTile);
+		iValue /= NUM_CITY_PLOTS;
+
+		if (iColonialTile > 0)
+		{
+			iValue *= std::max(1, (NUM_CITY_PLOTS - iColonialTile));
+			iValue /= NUM_CITY_PLOTS;
+
+			if (iFriendlyTile == 0)
+			{
+				iValue /= 2;
+			}
+		}
+	}
+
+	///Tks Med
+	if (iValue > iFinalMod)
+	{
+        iValue /= iFinalMod;
+	}
+	///Tke
+
+	return std::max(1, iValue);
+}
+
+int CvPlayerAI::AI_foundValueNative(int iX, int iY)
+{
+	CvPlot* pPlot = plotXY(iX, iY, 0, 0);
+	FAssert(pPlot != NULL);
+
+	if (pPlot->isWater())
+	{
+		return 0;
+	}
+
+	if (pPlot->getOwnerINLINE() != getID())
+	{
+		return 0;
+	}
+
+	if (!canFound(iX, iY, false))
+	{
+		return 0;
+	}
+    ///TKs Med
+    //if (!GC.getGameINLINE().isFinalInitialized() && isNative())
+    //{
+        for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
+        {
+            CvPlayer& otherPlayer = GET_PLAYER((PlayerTypes) iPlayer);
+            if ((iPlayer != getID()) && otherPlayer.isAlive() && !otherPlayer.isNative())
+            {
+                CvPlot* pOtherPlot = otherPlayer.getStartingPlot();
+                if(pOtherPlot->isWater())
+                {
+                    continue;
+                }
+                if(pOtherPlot == pPlot)
+                {
+                    return 0;
+                }
+                if(pOtherPlot != NULL)
+                {
+                    int iRange = GC.getMIN_CITY_RANGE();
+
+                    for (int iDX = -(iRange); iDX <= iRange; iDX++)
+                    {
+                        for (int iDY = -(iRange); iDY <= iRange; iDY++)
+                        {
+                            CvPlot* pLoopPlot	= plotXY(pOtherPlot->getX_INLINE(), pOtherPlot->getY_INLINE(), iDX, iDY);
+
+                            if (pLoopPlot != NULL)
+                            {
+                                if (pPlot == pLoopPlot)
+                                {
+                                    return 0;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+   /// }
+    ///TKe
+	int iYields = 0;
+	for (int i = 0; i < NUM_YIELD_TYPES; i++)
+	{
+		if (i != YIELD_FOOD)
+		{
+			iYields += pPlot->getYield((YieldTypes)i);
+		}
+	}
+	if (iYields == 0)
+	{
+		return 0;
+	}
+
+	int iWaterCount = 0;
+	for (int iDirection = 0; iDirection < NUM_DIRECTION_TYPES; iDirection++)
+	{
+		CvPlot* pLoopPlot = plotDirection(iX, iY, (DirectionTypes)iDirection);
+		if (pLoopPlot != NULL)
+		{
+			if (pLoopPlot->isWater() && !pLoopPlot->isLake())
+			{
+				iWaterCount++;
+			}
+		}
+	}
+	if (iWaterCount > 4)
+	{
+		return 0;
+	}
+
+	int iBadTileCount = 0;
+	for (int iI = 0; iI < NUM_CITY_PLOTS; ++iI)
+	{
+		CvPlot* pLoopPlot = plotCity(iX, iY, iI);
+		if (pLoopPlot != NULL)
+		{
+			if (pLoopPlot->isImpassable())
+			{
+				iBadTileCount++;
+			}
+			else if (pLoopPlot->getYield(YIELD_FOOD) < 2)
+			{
+				iBadTileCount++;
+			}
+		}
+	}
+	if (iBadTileCount > (NUM_CITY_PLOTS * 2) / 3)
+	{
+		return 0;
+	}
+
+	int iValue = 0;
+	int iCityCount = 0;
+	int iRange = 3;
+
+	for (int iDX = -iRange; iDX <= iRange; iDX++)
+	{
+		for (int iDY = -iRange; iDY <= iRange; iDY++)
+		{
+			int iDistance = plotDistance(iDX, iDY, 0, 0);
+			if (iDistance <= iRange)
+			{
+				CvPlot* pLoopPlot = plotXY(iX, iY, iDX, iDY);
+				if (pLoopPlot != NULL)
+				{
+					if (pLoopPlot->isCity())
+					{
+						iCityCount++;
+						if (iDistance == 1)
+						{
+							iCityCount++;
+						}
+					}
+					else if (!pLoopPlot->isCityRadius())
+					{
+						if (pLoopPlot->isWater())
+						{
+							iValue ++;
+						}
+						else if (pLoopPlot->getOwnerINLINE() == getID())
+						{
+							iValue++;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (iCityCount > 1)
+	{
+		return 0;
+	}
+
+	if (iValue < (27 / (std::max(1, 3 - getNumCities()))))
+	{
+		return 0;
+	}
+	iValue *= 100;
+	iValue += GC.getGame().getSorenRandNum(300, "AI native city found value");
+	return iValue;
+}
+
+
+bool CvPlayerAI::AI_isAreaAlone(CvArea* pArea)
+{
+	return ((pArea->getNumCities()) == GET_TEAM(getTeam()).countNumCitiesByArea(pArea));
+}
+
+
+bool CvPlayerAI::AI_isCapitalAreaAlone()
+{
+	CvCity* pCapitalCity;
+
+	pCapitalCity = getPrimaryCity();
+
+	if (pCapitalCity != NULL)
+	{
+		return AI_isAreaAlone(pCapitalCity->area());
+	}
+
+	return false;
+}
+
+
+bool CvPlayerAI::AI_isPrimaryArea(CvArea* pArea)
+{
+	CvCity* pCapitalCity;
+
+	if (pArea->isWater())
+	{
+		return false;
+	}
+
+	if (pArea->getCitiesPerPlayer(getID()) > 2)
+	{
+		return true;
+	}
+
+	pCapitalCity = getPrimaryCity();
+
+	if (pCapitalCity != NULL)
+	{
+		if (pCapitalCity->area() == pArea)
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+int CvPlayerAI::AI_militaryWeight(CvArea* pArea)
+{
+	return (pArea->getPopulationPerPlayer(getID()) + pArea->getCitiesPerPlayer(getID()) + 1);
+}
+
+
+int CvPlayerAI::AI_targetCityValue(CvCity* pCity, bool bRandomize, bool bIgnoreAttackers)
+{
+	PROFILE_FUNC();
+
+	CvCity* pNearestCity;
+	CvPlot* pLoopPlot;
+	int iValue;
+	int iI;
+
+	FAssertMsg(pCity != NULL, "City is not assigned a valid value");
+
+	iValue = 1;
+
+	iValue += ((pCity->getPopulation() * (50 + pCity->calculateCulturePercent(getID()))) / 100);
+
+	if (pCity->getDefenseDamage() > 0)
+	{
+		iValue += ((pCity->getDefenseDamage() / 30) + 1);
+	}
+
+	if (pCity->isCoastal(GC.getMIN_WATER_SIZE_FOR_OCEAN()))
+	{
+		iValue++;
+	}
+
+	if (pCity->isEverOwned(getID()))
+	{
+		iValue += 3;
+	}
+	if (!bIgnoreAttackers)
+	{
+	iValue += AI_adjacentPotentialAttackers(pCity->plot());
+	}
+
+	for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
+	{
+		pLoopPlot = plotCity(pCity->getX_INLINE(), pCity->getY_INLINE(), iI);
+
+		if (pLoopPlot != NULL)
+		{
+			if (pLoopPlot->getBonusType() != NO_BONUS)
+			{
+				iValue++;
+			}
+
+			if (pLoopPlot->getOwnerINLINE() == getID())
+			{
+				iValue++;
+			}
+
+			if (pLoopPlot->isAdjacentPlayer(getID(), true))
+			{
+				iValue++;
+			}
+		}
+	}
+
+	pNearestCity = GC.getMapINLINE().findCity(pCity->getX_INLINE(), pCity->getY_INLINE(), getID());
+
+	if (pNearestCity != NULL)
+	{
+		iValue += std::max(1, ((GC.getMapINLINE().maxStepDistance() * 2) - GC.getMapINLINE().calculatePathDistance(pNearestCity->plot(), pCity->plot())));
+	}
+
+	if (bRandomize)
+	{
+		iValue += GC.getGameINLINE().getSorenRandNum(((pCity->getPopulation() / 2) + 1), "AI Target City Value");
+	}
+
+	return iValue;
+}
+
+
+CvCity* CvPlayerAI::AI_findTargetCity(CvArea* pArea)
+{
+	CvCity* pLoopCity;
+	CvCity* pBestCity;
+	int iValue;
+	int iBestValue;
+	int iLoop;
+	int iI;
+
+	iBestValue = 0;
+	pBestCity = NULL;
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			if (isPotentialEnemy(getTeam(), GET_PLAYER((PlayerTypes)iI).getTeam()))
+			{
+				for (pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
+				{
+					if (pLoopCity->area() == pArea)
+					{
+						iValue = AI_targetCityValue(pLoopCity, true);
+
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							pBestCity = pLoopCity;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return pBestCity;
+}
+
+
+int CvPlayerAI::AI_getPlotDanger(CvPlot* pPlot, int iRange, bool bTestMoves, bool bOffensive)
+{
+	PROFILE_FUNC();
+
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	CvPlot* pLoopPlot;
+	int iCount;
+	int iDistance;
+	int iBorderDanger;
+	int iDX, iDY;
+	CvArea *pPlotArea = pPlot->area();
+
+	iCount = 0;
+	iBorderDanger = 0;
+
+	if (iRange == -1)
+	{
+		iRange = DANGER_RANGE;
+	}
+
+	for (iDX = -(iRange); iDX <= iRange; iDX++)
+	{
+		for (iDY = -(iRange); iDY <= iRange; iDY++)
+		{
+			pLoopPlot	= plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+
+			if (pLoopPlot != NULL)
+			{
+				if (pLoopPlot->area() == pPlotArea)
+				{
+				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
+				    if (atWar(pLoopPlot->getTeam(), getTeam()))
+				    {
+				        if (iDistance == 1)
+				        {
+				            iBorderDanger++;
+				        }
+				        else if ((iDistance == 2) && (pLoopPlot->isRoute()))
+				        {
+				            iBorderDanger++;
+				        }
+				    }
+
+
+					pUnitNode = pLoopPlot->headUnitNode();
+
+					while (pUnitNode != NULL)
+					{
+						pLoopUnit = ::getUnit(pUnitNode->m_data);
+						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+						if (pLoopUnit->isEnemy(getTeam()))
+						{
+						    //TKs Med
+						    bool bDangerousBarb = true;
+						    //if (pLoopUnit->isBarbarian() && !pLoopUnit->isOnlyDefensive())
+						    if (isHuman() && pLoopUnit->isBarbarian())
+						    {
+						        bDangerousBarb = false;
+						    }
+
+							if (bDangerousBarb && (bOffensive || pLoopUnit->canAttack()))
+							{
+								if (!(pLoopUnit->isInvisible(getTeam(), false)))
+								{
+								    if (bOffensive || bDangerousBarb || pLoopUnit->canMoveOrAttackInto(pPlot))
+								    {
+								        ///Tke
+                                        if (!bTestMoves)
+                                        {
+                                            iCount++;
+                                        }
+                                        else
+                                        {
+                                            int iDangerRange = pLoopUnit->baseMoves();
+                                            iDangerRange += ((pLoopPlot->isValidRoute(pLoopUnit)) ? 1 : 0);
+                                            if (iDangerRange >= iDistance)
+											{
+												iCount++;
+											}
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (iBorderDanger > 0)
+	{
+	    if (!isHuman() && (!pPlot->isCity() || bOffensive))
+	    {
+            iCount += iBorderDanger;
+	    }
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_getUnitDanger(CvUnit* pUnit, int iRange, bool bTestMoves, bool bAnyDanger)
+{
+	PROFILE_FUNC();
+
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	CvPlot* pLoopPlot;
+	int iCount;
+	int iDistance;
+	int iBorderDanger;
+	int iDX, iDY;
+
+    CvPlot* pPlot = pUnit->plot();
+	iCount = 0;
+	iBorderDanger = 0;
+
+	if (iRange == -1)
+	{
+		iRange = DANGER_RANGE;
+	}
+
+	for (iDX = -(iRange); iDX <= iRange; iDX++)
+	{
+		for (iDY = -(iRange); iDY <= iRange; iDY++)
+		{
+			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+
+			if (pLoopPlot != NULL)
+			{
+				if (pLoopPlot->area() == pPlot->area())
+				{
+				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
+				    if (atWar(pLoopPlot->getTeam(), getTeam()))
+				    {
+				        if (iDistance == 1)
+				        {
+				            iBorderDanger++;
+				        }
+				        else if ((iDistance == 2) && (pLoopPlot->isRoute()))
+				        {
+				            iBorderDanger++;
+				        }
+				    }
+
+
+					pUnitNode = pLoopPlot->headUnitNode();
+
+					while (pUnitNode != NULL)
+					{
+						pLoopUnit = ::getUnit(pUnitNode->m_data);
+						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+						if (atWar(pLoopUnit->getTeam(), getTeam()))
+						{
+							if (pLoopUnit->canAttack())
+							{
+								if (!(pLoopUnit->isInvisible(getTeam(), false)))
+								{
+								    if (pLoopUnit->canMoveOrAttackInto(pPlot))
+								    {
+                                        if (!bTestMoves)
+                                        {
+                                            iCount++;
+                                        }
+                                        else
+                                        {
+                                            int iDangerRange = pLoopUnit->baseMoves();
+                                            iDangerRange += ((pLoopPlot->isValidRoute(pLoopUnit)) ? 1 : 0);
+                                            if (iDangerRange >= iDistance)
+                                            {
+                                                iCount++;
+                                            }
+                                        }
+								    }
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (iBorderDanger > 0)
+	{
+	    if (!isHuman() || pUnit->isAutomated())
+	    {
+            iCount += iBorderDanger;
+	    }
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_getWaterDanger(CvPlot* pPlot, int iRange, bool bTestMoves)
+{
+	PROFILE_FUNC();
+
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	CvPlot* pLoopPlot;
+	int iCount;
+	int iDX, iDY;
+
+	iCount = 0;
+
+	if (iRange == -1)
+	{
+		iRange = DANGER_RANGE;
+	}
+
+	CvArea* pWaterArea = pPlot->waterArea();
+
+	for (iDX = -(iRange); iDX <= iRange; iDX++)
+	{
+		for (iDY = -(iRange); iDY <= iRange; iDY++)
+		{
+			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+
+			if (pLoopPlot != NULL)
+			{
+				if (pLoopPlot->isWater())
+				{
+					if (pPlot->isAdjacentToArea(pLoopPlot->getArea()))
+					{
+						pUnitNode = pLoopPlot->headUnitNode();
+
+						while (pUnitNode != NULL)
+						{
+							pLoopUnit = ::getUnit(pUnitNode->m_data);
+							pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+							if (pLoopUnit->isEnemy(getTeam()))
+							{
+								if (pLoopUnit->canAttack())
+								{
+									if (!(pLoopUnit->isInvisible(getTeam(), false)))
+									{
+										iCount++;
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_goldTarget()
+{
+	int iGold = 0;
+
+	if (GC.getGameINLINE().getElapsedGameTurns() >= 40)
+	{
+		int iMultiplier = 0;
+		iMultiplier += GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getFatherPercent();
+		iMultiplier += GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();
+		iMultiplier += GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getConstructPercent();
+		iMultiplier /= 3;
+
+		iGold += ((getNumCities() * 3) + (getTotalPopulation() / 3));
+
+		iGold += (GC.getGameINLINE().getElapsedGameTurns() / 2);
+
+		iGold *= iMultiplier;
+		iGold /= 100;
+
+		bool bAnyWar = GET_TEAM(getTeam()).getAnyWarPlanCount() > 0;
+		if (bAnyWar)
+		{
+			iGold *= 3;
+			iGold /= 2;
+		}
+		iGold += (AI_goldToUpgradeAllUnits() / (bAnyWar ? 1 : 2));
+	}
+
+	return iGold + AI_getExtraGoldTarget();
+}
+
+DiploCommentTypes CvPlayerAI::AI_getGreeting(PlayerTypes ePlayer)
+{
+	TeamTypes eWorstEnemy;
+
+	if (GET_PLAYER(ePlayer).getTeam() != getTeam())
+	{
+		eWorstEnemy = GET_TEAM(getTeam()).AI_getWorstEnemy();
+
+		if ((eWorstEnemy != NO_TEAM) && (eWorstEnemy != GET_PLAYER(ePlayer).getTeam()) && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eWorstEnemy) && (GC.getASyncRand().get(4) == 0))
+		{
+			if (GET_PLAYER(ePlayer).AI_hasTradedWithTeam(eWorstEnemy) && !atWar(GET_PLAYER(ePlayer).getTeam(), eWorstEnemy))
+			{
+				return (DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_WORST_ENEMY_TRADING");
+			}
+			else
+			{
+				return (DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_WORST_ENEMY");
+			}
+		}
+	}
+
+	return (DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_GREETINGS");
+}
+
+
+bool CvPlayerAI::AI_isWillingToTalk(PlayerTypes ePlayer)
+{
+	FAssertMsg(getPersonalityType() != NO_LEADER, "getPersonalityType() is not expected to be equal with NO_LEADER");
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+
+	if (GET_PLAYER(ePlayer).getTeam() == getTeam())
+	{
+		return true;
+	}
+
+	if (GET_TEAM(getTeam()).isHuman())
+	{
+		return false;
+	}
+
+	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+	{
+		if (GET_TEAM(getTeam()).isParentOf(GET_PLAYER(ePlayer).getTeam()))
+		{
+			return false;
+		}
+
+		int iRefuseDuration = (GC.getLeaderHeadInfo(getPersonalityType()).getRefuseToTalkWarThreshold());
+
+		if  (GET_TEAM(getTeam()).AI_isChosenWar(GET_PLAYER(ePlayer).getTeam()))
+		{
+			if (!isNative())
+			{
+				iRefuseDuration *= 2;
+			}
+		}
+		else
+		{
+			if (isNative())
+			{
+				iRefuseDuration *= 2;
+			}
+		}
+
+		int iOurSuccess = 1 + GET_TEAM(getTeam()).AI_getWarSuccess(GET_PLAYER(ePlayer).getTeam());
+		int iTheirSuccess = 1 + GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_getWarSuccess(getTeam());
+		if (iTheirSuccess > iOurSuccess * 2)
+		{
+			iRefuseDuration *= 50 + ((50 * iOurSuccess * 2) / iTheirSuccess);
+			iRefuseDuration /= 100;
+		}
+
+		if (isNative())
+		{
+			iRefuseDuration *= 2;
+			int iGameTurns = GC.getGameINLINE().getEstimateEndTurn();
+			int iCurrentTurn = GC.getGameINLINE().getGameTurn();
+
+			if (!GET_TEAM(getTeam()).AI_isChosenWar((GET_PLAYER(ePlayer).getTeam())))
+			{
+				iCurrentTurn += iGameTurns / 2;
+			}
+
+			iRefuseDuration *= std::max(0, iCurrentTurn - iGameTurns / 12);
+			iRefuseDuration /= iGameTurns;
+		}
+
+		if (GET_TEAM(getTeam()).AI_getAtWarCounter(GET_PLAYER(ePlayer).getTeam()) < iRefuseDuration)
+		{
+			return false;
+		}
+	}
+	else
+	{
+		if (AI_getMemoryCount(ePlayer, MEMORY_STOPPED_TRADING_RECENT) > 0)
+		{
+			return false;
+		}
+	}
+
+	return true;
+}
+
+
+// XXX what if already at war???
+// Returns true if the AI wants to sneak attack...
+bool CvPlayerAI::AI_demandRebukedSneak(PlayerTypes ePlayer)
+{
+	FAssertMsg(!isHuman(), "isHuman did not return false as expected");
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+
+	FAssert(!(GET_TEAM(getTeam()).isHuman()));
+
+	if (GC.getGameINLINE().getSorenRandNum(100, "AI Demand Rebuked") < GC.getLeaderHeadInfo(getPersonalityType()).getDemandRebukedSneakProb())
+	{
+		if (GET_TEAM(getTeam()).getPower() > GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getDefensivePower())
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+// XXX what if already at war???
+// Returns true if the AI wants to declare war...
+bool CvPlayerAI::AI_demandRebukedWar(PlayerTypes ePlayer)
+{
+	FAssertMsg(!isHuman(), "isHuman did not return false as expected");
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+
+	FAssert(!(GET_TEAM(getTeam()).isHuman()));
+
+	// needs to be async because it only happens on the computer of the player who is in diplomacy...
+	if (GC.getASyncRand().get(100, "AI Demand Rebuked ASYNC") < GC.getLeaderHeadInfo(getPersonalityType()).getDemandRebukedWarProb())
+	{
+		if (GET_TEAM(getTeam()).getPower() > GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getDefensivePower())
+		{
+			if (GET_TEAM(getTeam()).AI_isAllyLandTarget(GET_PLAYER(ePlayer).getTeam()))
+			{
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+
+// XXX maybe make this a little looser (by time...)
+bool CvPlayerAI::AI_hasTradedWithTeam(TeamTypes eTeam)
+{
+	int iI;
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			if (GET_PLAYER((PlayerTypes)iI).getTeam() == eTeam)
+			{
+				if ((AI_getPeacetimeGrantValue((PlayerTypes)iI) + AI_getPeacetimeTradeValue((PlayerTypes)iI)) > 0)
+				{
+					return true;
+				}
+			}
+		}
+	}
+
+	return false;
+}
+
+// static
+AttitudeTypes CvPlayerAI::AI_getAttitude(int iAttitudeVal)
+{
+	if (iAttitudeVal >= 10)
+	{
+		return ATTITUDE_FRIENDLY;
+	}
+	else if (iAttitudeVal >= 3)
+	{
+		return ATTITUDE_PLEASED;
+	}
+	else if (iAttitudeVal <= -10)
+	{
+		return ATTITUDE_FURIOUS;
+	}
+	else if (iAttitudeVal <= -3)
+	{
+		return ATTITUDE_ANNOYED;
+	}
+	else
+	{
+		return ATTITUDE_CAUTIOUS;
+	}
+}
+
+AttitudeTypes CvPlayerAI::AI_getAttitude(PlayerTypes ePlayer, bool bForced)
+{
+	PROFILE_FUNC();
+
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+
+	return (AI_getAttitude(AI_getAttitudeVal(ePlayer, bForced)));
+}
+
+
+int CvPlayerAI::AI_getAttitudeVal(PlayerTypes ePlayer, bool bForced)
+{
+	PROFILE_FUNC();
+
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+
+	if (bForced)
+	{
+		if (getTeam() == GET_PLAYER(ePlayer).getTeam())
+		{
+			return 100;
+		}
+	}
+
+	int iAttitude = GC.getLeaderHeadInfo(getPersonalityType()).getBaseAttitude();
+
+	if (GET_PLAYER(ePlayer).isNative())
+	{
+		iAttitude += GC.getLeaderHeadInfo(getPersonalityType()).getNativeAttitude();
+	}
+
+	iAttitude += GC.getHandicapInfo(GET_PLAYER(ePlayer).getHandicapType()).getAttitudeChange();
+
+	iAttitude -= std::max(0, (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getNumMembers() - GET_TEAM(getTeam()).getNumMembers()));
+
+	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_getWarSuccess(getTeam()) > GET_TEAM(getTeam()).AI_getWarSuccess(GET_PLAYER(ePlayer).getTeam()))
+	{
+		iAttitude += GC.getLeaderHeadInfo(getPersonalityType()).getLostWarAttitudeChange();
+	}
+
+	iAttitude += AI_getCloseBordersAttitude(ePlayer);
+	iAttitude += AI_getStolenPlotsAttitude(ePlayer);
+	iAttitude += AI_getAlarmAttitude(ePlayer);
+	iAttitude += AI_getRebelAttitude(ePlayer);
+	iAttitude += AI_getWarAttitude(ePlayer);
+	iAttitude += AI_getPeaceAttitude(ePlayer);
+	iAttitude += AI_getOpenBordersAttitude(ePlayer);
+	iAttitude += AI_getDefensivePactAttitude(ePlayer);
+	iAttitude += AI_getRivalDefensivePactAttitude(ePlayer);
+	iAttitude += AI_getShareWarAttitude(ePlayer);
+	iAttitude += AI_getTradeAttitude(ePlayer);
+	iAttitude += AI_getRivalTradeAttitude(ePlayer);
+
+	for (int iI = 0; iI < NUM_MEMORY_TYPES; iI++)
+	{
+		iAttitude += AI_getMemoryAttitude(ePlayer, ((MemoryTypes)iI));
+	}
+
+	iAttitude += AI_getAttitudeExtra(ePlayer);
+
+	return range(iAttitude, -100, 100);
+}
+
+
+int CvPlayerAI::AI_calculateStolenCityRadiusPlots(PlayerTypes ePlayer)
+{
+	PROFILE_FUNC();
+
+	CvPlot* pLoopPlot;
+	int iCount;
+	int iI;
+
+	FAssert(ePlayer != getID());
+
+	iCount = 0;
+
+	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+	{
+		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+
+		if (pLoopPlot->getOwnerINLINE() == ePlayer)
+		{
+			if (pLoopPlot->isPlayerCityRadius(getID()))
+			{
+				iCount++;
+			}
+		}
+	}
+
+	return iCount;
+}
+
+
+int CvPlayerAI::AI_getCloseBordersAttitude(PlayerTypes ePlayer)
+{
+	if (m_aiCloseBordersAttitudeCache[ePlayer] == MAX_INT)
+	{
+		if (isNative())
+		{
+			return 0;
+		}
+
+		if (getTeam() == GET_PLAYER(ePlayer).getTeam())
+		{
+			return 0;
+		}
+
+		int iPercent = std::min(60, (AI_calculateStolenCityRadiusPlots(ePlayer) * 3));
+
+		if (GET_TEAM(getTeam()).AI_isLandTarget(GET_PLAYER(ePlayer).getTeam()))
+		{
+			iPercent += 40;
+		}
+
+		m_aiCloseBordersAttitudeCache[ePlayer] = ((GC.getLeaderHeadInfo(getPersonalityType()).getCloseBordersAttitudeChange() * iPercent) / 100);
+	}
+
+	return m_aiCloseBordersAttitudeCache[ePlayer];
+}
+
+
+int CvPlayerAI::AI_getStolenPlotsAttitude(PlayerTypes ePlayer)
+{
+	if (m_aiStolenPlotsAttitudeCache[ePlayer] == MAX_INT)
+	{
+		if (getTeam() == GET_PLAYER(ePlayer).getTeam())
+		{
+			return 0;
+		}
+
+		if (!isNative())
+		{
+			return 0;
+		}
+
+		int iStolenPlots = 0;
+		for(int i=0;i<GC.getMapINLINE().numPlotsINLINE();i++)
+		{
+			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(i);
+			if(pLoopPlot->getOwnerINLINE() == ePlayer && pLoopPlot->getCulture(getID()) > pLoopPlot->getCulture(ePlayer))
+			{
+				++iStolenPlots;
+			}
+		}
+
+		// change attitude by stolen plots per city
+		m_aiStolenPlotsAttitudeCache[ePlayer] = GC.getLeaderHeadInfo(getPersonalityType()).getCloseBordersAttitudeChange() * iStolenPlots / std::max(getNumCities(), 1);
+	}
+
+	return m_aiStolenPlotsAttitudeCache[ePlayer];
+}
+
+
+int CvPlayerAI::AI_getAlarmAttitude(PlayerTypes ePlayer)
+{
+	if (getTeam() == GET_PLAYER(ePlayer).getTeam())
+	{
+		return 0;
+	}
+
+	AlarmTypes eAlarm = (AlarmTypes) GC.getLeaderHeadInfo(getLeaderType()).getAlarmType();
+	if (eAlarm == NO_ALARM)
+	{
+		return 0;
+	}
+
+	int iAlarm = GET_PLAYER(ePlayer).getNumCities() * GC.getAlarmInfo(eAlarm).getNumColonies();
+	iAlarm *= std::max(0, 100 + GET_PLAYER(ePlayer).getNativeAngerModifier());
+	iAlarm /= 100;
+
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		iAlarm += pLoopCity->AI_calculateAlarm(ePlayer);
+	}
+
+	iAlarm *= GC.getLeaderHeadInfo(getPersonalityType()).getAlarmAttitudeChange();
+	iAlarm /= std::max(1, GC.getAlarmInfo(eAlarm).getAttitudeDivisor());
+
+	return std::min(iAlarm, 0);
+}
+
+int CvPlayerAI::AI_getRebelAttitude(PlayerTypes ePlayer)
+{
+	if (GET_PLAYER(ePlayer).getParent() != getID())
+	{
+		return 0;
+	}
+
+	if (GC.getLeaderHeadInfo(getPersonalityType()).getRebelAttitudeDivisor() == 0)
+	{
+		return 0;
+	}
+
+	int iBells = GET_PLAYER(ePlayer).getBellsStored();
+
+	iBells *= 100;
+	iBells /= std::max(1, GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent());
+	iBells /= GC.getLeaderHeadInfo(getPersonalityType()).getRebelAttitudeDivisor();
+
+	return iBells;
+
+}
+
+int CvPlayerAI::AI_getWarAttitude(PlayerTypes ePlayer)
+{
+	int iAttitude = 0;
+
+	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+	{
+		iAttitude -= 3;
+	}
+
+	if (GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeDivisor() != 0)
+	{
+		int iAttitudeChange = (GET_TEAM(getTeam()).AI_getAtWarCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeDivisor());
+		iAttitude += range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtWarAttitudeChangeLimit()));
+	}
+
+	return iAttitude;
+}
+
+
+int CvPlayerAI::AI_getPeaceAttitude(PlayerTypes ePlayer)
+{
+	if (GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeDivisor() != 0)
+	{
+		int iAttitudeChange = (GET_TEAM(getTeam()).AI_getAtPeaceCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeDivisor());
+		return range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getAtPeaceAttitudeChangeLimit()));
+	}
+
+	return 0;
+}
+
+
+int CvPlayerAI::AI_getOpenBordersAttitude(PlayerTypes ePlayer)
+{
+	if (!atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+	{
+		if (GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeDivisor() != 0)
+		{
+			int iAttitudeChange = (GET_TEAM(getTeam()).AI_getOpenBordersCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeDivisor());
+			return range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getOpenBordersAttitudeChangeLimit()));
+		}
+	}
+
+	return 0;
+}
+
+
+int CvPlayerAI::AI_getDefensivePactAttitude(PlayerTypes ePlayer)
+{
+	if (!atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+	{
+		if (GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeDivisor() != 0)
+		{
+			int iAttitudeChange = (GET_TEAM(getTeam()).AI_getDefensivePactCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeDivisor());
+			return range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getDefensivePactAttitudeChangeLimit()));
+		}
+	}
+
+	return 0;
+}
+
+
+int CvPlayerAI::AI_getRivalDefensivePactAttitude(PlayerTypes ePlayer)
+{
+	int iAttitude = 0;
+
+	if (getTeam() == GET_PLAYER(ePlayer).getTeam())
+	{
+		return iAttitude;
+	}
+
+	if (!(GET_TEAM(getTeam()).isDefensivePact(GET_PLAYER(ePlayer).getTeam())))
+	{
+		iAttitude -= ((4 * GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getDefensivePactCount(GET_PLAYER(ePlayer).getTeam())) / std::max(1, (GC.getGameINLINE().countCivTeamsAlive() - 2)));
+	}
+
+	return iAttitude;
+}
+
+
+int CvPlayerAI::AI_getShareWarAttitude(PlayerTypes ePlayer)
+{
+
+	int iAttitudeChange;
+	int iAttitude;
+
+	iAttitude = 0;
+	if (!atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+	{
+		if (GET_TEAM(getTeam()).AI_shareWar(GET_PLAYER(ePlayer).getTeam()))
+		{
+			iAttitude += GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeChange();
+		}
+
+		if (GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeDivisor() != 0)
+		{
+			iAttitudeChange = (GET_TEAM(getTeam()).AI_getShareWarCounter(GET_PLAYER(ePlayer).getTeam()) / GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeDivisor());
+			iAttitude += range(iAttitudeChange, -(abs(GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeChangeLimit())), abs(GC.getLeaderHeadInfo(getPersonalityType()).getShareWarAttitudeChangeLimit()));
+		}
+	}
+
+	return iAttitude;
+}
+
+int CvPlayerAI::AI_getTradeAttitude(PlayerTypes ePlayer)
+{
+	// XXX human only?
+	return range(((AI_getPeacetimeGrantValue(ePlayer) + std::max(0, (AI_getPeacetimeTradeValue(ePlayer) - GET_PLAYER(ePlayer).AI_getPeacetimeTradeValue(getID())))) / ((GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 1) * 5)), 0, 4);
+}
+
+int CvPlayerAI::AI_getRivalTradeAttitude(PlayerTypes ePlayer)
+{
+	// XXX human only?
+	return -(range(((GET_TEAM(getTeam()).AI_getEnemyPeacetimeGrantValue(GET_PLAYER(ePlayer).getTeam()) + (GET_TEAM(getTeam()).AI_getEnemyPeacetimeTradeValue(GET_PLAYER(ePlayer).getTeam()) / 3)) / ((GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 1) * 10)), 0, 4));
+}
+
+
+int CvPlayerAI::AI_getMemoryAttitude(PlayerTypes ePlayer, MemoryTypes eMemory)
+{
+	return ((AI_getMemoryCount(ePlayer, eMemory) * GC.getLeaderHeadInfo(getPersonalityType()).getMemoryAttitudePercent(eMemory)) / 100);
+}
+
+int CvPlayerAI::AI_dealVal(PlayerTypes ePlayer, const CLinkList<TradeData>* pList, bool bIgnoreAnnual, int iChange)
+{
+	int iValue = 0;
+
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+
+	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+	{
+		iValue += GET_TEAM(getTeam()).AI_endWarVal(GET_PLAYER(ePlayer).getTeam());
+	}
+
+	for (CLLNode<TradeData>* pNode = pList->head(); pNode; pNode = pList->next(pNode))
+	{
+		FAssertMsg(!(pNode->m_data.m_bHidden), "(pNode->m_data.m_bHidden) did not return false as expected");
+
+		switch (pNode->m_data.m_eItemType)
+		{
+        ///TKs Invention Core Mod v 1.0
+        case TRADE_RESEARCH:
+        {
+            iValue += GC.getCache_TK_RESEARCH_TRADE_VALUE() + GC.getCivicInfo((CivicTypes)pNode->m_data.m_iData1).getAIWeight();
+
+//            if (getCurrentResearch() != NO_CIVIC)
+//            {
+//                int iCurrentResearch = 1;
+//                if (getCurrentResearchProgress(true) > 0)
+//                {
+//                    iCurrentResearch = getCurrentResearchProgress(true);
+//                }
+//                iValue += (GC.getDefineINT("TK_RESEARCH_TRADE_VALUE") + GC.getCivicInfo(getCurrentResearch()).getAIWeight()) / iCurrentResearch;
+//            }
+//            else if (GET_PLAYER(ePlayer).getCurrentResearch() != NO_CIVIC)
+//            {
+//                int iCurrentResearch = 1;
+//                if (GET_PLAYER(ePlayer).getCurrentResearchProgress(true) > 0)
+//                {
+//                    iCurrentResearch = GET_PLAYER(ePlayer).getCurrentResearchProgress(true);
+//                }
+//                iValue += (GC.getDefineINT("TK_RESEARCH_TRADE_VALUE") + GC.getCivicInfo(GET_PLAYER(ePlayer).getCurrentResearch()).getAIWeight()) / iCurrentResearch;
+//            }
+//            else
+//            {
+//                iValue = 0;
+//            }
+        }
+			break;
+        case TRADE_IDEAS:
+            iValue += GC.getCache_TK_RESEARCH_TRADE_VALUE() + GC.getCivicInfo((CivicTypes)pNode->m_data.m_iData1).getCostToResearch() * 5;
+			break;
+        ///TKe
+		case TRADE_CITIES:
+			iValue += AI_cityTradeVal(GET_PLAYER(ePlayer).getCity(pNode->m_data.m_iData1));
+			break;
+		case TRADE_GOLD:
+			iValue += (pNode->m_data.m_iData1 * AI_goldTradeValuePercent()) / 100;
+			break;
+		case TRADE_YIELD:
+			iValue += AI_yieldTradeVal((YieldTypes) pNode->m_data.m_iData1, pNode->m_data.m_kTransport, ePlayer);
+			break;
+		case TRADE_MAPS:
+			iValue += GET_TEAM(getTeam()).AI_mapTradeVal(GET_PLAYER(ePlayer).getTeam());
+			break;
+		case TRADE_OPEN_BORDERS:
+			iValue += GET_TEAM(getTeam()).AI_openBordersTradeVal(GET_PLAYER(ePlayer).getTeam());
+			break;
+		case TRADE_DEFENSIVE_PACT:
+			iValue += GET_TEAM(getTeam()).AI_defensivePactTradeVal(GET_PLAYER(ePlayer).getTeam());
+			break;
+		case TRADE_PEACE:
+			iValue += GET_TEAM(getTeam()).AI_makePeaceTradeVal(((TeamTypes)(pNode->m_data.m_iData1)), GET_PLAYER(ePlayer).getTeam());
+			break;
+		case TRADE_WAR:
+			iValue += GET_TEAM(getTeam()).AI_declareWarTradeVal(((TeamTypes)(pNode->m_data.m_iData1)), GET_PLAYER(ePlayer).getTeam());
+			break;
+		case TRADE_EMBARGO:
+			iValue += AI_stopTradingTradeVal(((TeamTypes)(pNode->m_data.m_iData1)), ePlayer);
+			break;
+		}
+	}
+
+	return iValue;
+}
+
+
+bool CvPlayerAI::AI_goldDeal(const CLinkList<TradeData>* pList)
+{
+	CLLNode<TradeData>* pNode;
+
+	for (pNode = pList->head(); pNode; pNode = pList->next(pNode))
+	{
+		FAssert(!(pNode->m_data.m_bHidden));
+
+		switch (pNode->m_data.m_eItemType)
+		{
+		case TRADE_GOLD:
+			return true;
+			break;
+		}
+	}
+
+	return false;
+}
+
+
+bool CvPlayerAI::AI_considerOffer(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, int iChange)
+{
+	CLLNode<TradeData>* pNode;
+	int iThreshold;
+
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+
+	if (AI_goldDeal(pTheirList) && AI_goldDeal(pOurList))
+	{
+		return false;
+	}
+
+	if (iChange > -1)
+	{
+		for (pNode = pOurList->head(); pNode; pNode = pOurList->next(pNode))
+		{
+			if (getTradeDenial(ePlayer, pNode->m_data) != NO_DENIAL)
+			{
+				return false;
+			}
+		}
+	}
+///Tks Med
+//	if (GET_PLAYER(ePlayer).getTeam() == getTeam())
+//	{
+//		return true;
+//	}
+///Tke
+
+	if ((pOurList->getLength() == 0) && (pTheirList->getLength() > 0))
+	{
+		return true;
+	}
+
+	int iOurValue = GET_PLAYER(ePlayer).AI_dealVal(getID(), pOurList, false, iChange);
+	int iTheirValue = AI_dealVal(ePlayer, pTheirList, false, iChange);
+
+	if (iOurValue > 0 && 0 == pTheirList->getLength() && 0 == iTheirValue)
+	{
+		if (AI_getAttitude(ePlayer) < ATTITUDE_PLEASED)
+		{
+			if (GET_TEAM(getTeam()).getPower() > ((GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPower() * 4) / 3))
+			{
+				return false;
+			}
+		}
+
+		if (AI_getMemoryCount(ePlayer, MEMORY_MADE_DEMAND_RECENT) > 0)
+		{
+			return false;
+		}
+
+		iThreshold = (GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 50);
+
+		iThreshold *= 2;
+
+		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_isLandTarget(getTeam()))
+		{
+			iThreshold *= 3;
+		}
+
+		iThreshold *= (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPower() + 100);
+		iThreshold /= (GET_TEAM(getTeam()).getPower() + 100);
+
+		iThreshold -= GET_PLAYER(ePlayer).AI_getPeacetimeGrantValue(getID());
+
+		return (iOurValue < iThreshold);
+	}
+
+	if (iChange < 0)
+	{
+		return (iTheirValue * 110 >= iOurValue * 100);
+	}
+
+	return (iTheirValue >= iOurValue);
+}
+
+int CvPlayerAI::AI_militaryHelp(PlayerTypes ePlayer, int& iNumUnits, UnitTypes& eUnit, ProfessionTypes& eProfession)
+{
+	FAssert(GET_PLAYER(ePlayer).getParent() == getID());
+
+	iNumUnits = 0;
+	eUnit = NO_UNIT;
+	eProfession = NO_PROFESSION;
+
+	if (AI_getAttitude(ePlayer) < ATTITUDE_CAUTIOUS)
+	{
+		return -1;
+	}
+
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+	int iBestValue = MAX_INT;
+	for (int i = 0; i < GC.getNumUnitClassInfos(); ++i)
+	{
+		UnitTypes eLoopUnit = (UnitTypes) GC.getCivilizationInfo(kPlayer.getCivilizationType()).getCivilizationUnits(i);
+		if (eLoopUnit != NO_UNIT)
+		{
+			CvUnitInfo& kUnit = GC.getUnitInfo(eLoopUnit);
+			if (kUnit.getDomainType() == DOMAIN_LAND && kPlayer.getEuropeUnitBuyPrice(eLoopUnit) > 0)
+			{
+				bool bValid = (kUnit.getCombat() > 0);
+				for (int j = 0; j < GC.getNumPromotionInfos() && !bValid; ++j)
+				{
+					if (kUnit.getFreePromotions(j))
+					{
+						bValid = true;
+					}
+				}
+
+				if (bValid)
+				{
+					int iValue = kPlayer.getUnitClassCount((UnitClassTypes) i);
+					if (iValue < iBestValue)
+					{
+						iBestValue = iValue;
+						eUnit = eLoopUnit;
+					}
+				}
+			}
+		}
+	}
+
+	if (eUnit == NO_UNIT)
+	{
+		return -1;
+	}
+
+	iNumUnits = 1;
+	eProfession = (ProfessionTypes) GC.getUnitInfo(eUnit).getDefaultProfession();
+
+	return kPlayer.getEuropeUnitBuyPrice(eUnit) * GC.getCache_KING_BUY_UNIT_PRICE_MODIFIER() / 100;
+}
+
+bool CvPlayerAI::AI_counterPropose(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, CLinkList<TradeData>* pTheirInventory, CLinkList<TradeData>* pOurInventory, CLinkList<TradeData>* pTheirCounter, CLinkList<TradeData>* pOurCounter, const IDInfo& kTransport)
+{
+	CLLNode<TradeData>* pNode;
+	CLLNode<TradeData>* pBestNode;
+	CLLNode<TradeData>* pGoldNode;
+	CvCity* pCity;
+	bool bTheirGoldDeal;
+	bool bOurGoldDeal;
+	int iHumanDealWeight;
+	int iAIDealWeight;
+	int iGoldData;
+	int iGoldWeight;
+	int iWeight;
+	int iBestWeight;
+	int iValue;
+	int iBestValue;
+
+	bTheirGoldDeal = AI_goldDeal(pTheirList);
+	bOurGoldDeal = AI_goldDeal(pOurList);
+
+	if (bOurGoldDeal && bTheirGoldDeal)
+	{
+		return false;
+	}
+
+	pGoldNode = NULL;
+
+	iHumanDealWeight = AI_dealVal(ePlayer, pTheirList);
+	iAIDealWeight = GET_PLAYER(ePlayer).AI_dealVal(getID(), pOurList);
+
+	int iGoldValuePercent = AI_goldTradeValuePercent();
+
+	pTheirCounter->clear();
+	pOurCounter->clear();
+
+	if (iAIDealWeight > iHumanDealWeight)
+	{
+		if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+		{
+			iBestValue = 0;
+			iBestWeight = 0;
+			pBestNode = NULL;
+
+			for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
+			{
+				if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+				{
+					if (pNode->m_data.m_eItemType == TRADE_CITIES)
+					{
+						FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
+
+						if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
+						{
+							pCity = GET_PLAYER(ePlayer).getCity(pNode->m_data.m_iData1);
+
+							if (pCity != NULL)
+							{
+								iWeight = AI_cityTradeVal(pCity);
+
+								if (iWeight > 0)
+								{
+									iValue = AI_targetCityValue(pCity, false);
+
+									if (iValue > iBestValue)
+									{
+										iBestValue = iValue;
+										iBestWeight = iWeight;
+										pBestNode = pNode;
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+
+			if (pBestNode != NULL)
+			{
+				iHumanDealWeight += iBestWeight;
+				pTheirCounter->insertAtEnd(pBestNode->m_data);
+			}
+		}
+
+		for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
+		{
+			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+			{
+				FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
+
+				if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
+				{
+					switch (pNode->m_data.m_eItemType)
+					{
+					case TRADE_GOLD:
+						if (!bOurGoldDeal)
+						{
+							pGoldNode = pNode;
+						}
+						break;
+					}
+				}
+			}
+		}
+
+		///TKs Invention Core Mod v 1.0
+		for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
+		{
+			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+			{
+			    if (pNode->m_data.m_eItemType == TRADE_IDEAS)
+				{
+					FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
+
+					if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
+					{
+					    //int iOurValue = GET_PLAYER(ePlayer).AI_dealVal(getID(), pOurList, false, iChange);
+						iWeight = GC.getCivicInfo((CivicTypes)pNode->m_data.m_iData1).getAIWeight() + GC.getCache_TK_RESEARCH_TRADE_VALUE();
+
+						if (iWeight > 0)
+						{
+							iHumanDealWeight += iWeight;
+							pTheirCounter->insertAtEnd(pNode->m_data);
+						}
+					}
+				}
+
+			}
+		}
+		///Tke
+        int iGoldWeight = iAIDealWeight - iHumanDealWeight;
+		if (iGoldWeight > 0)
+		{
+			if (pGoldNode)
+			{
+				iGoldData = iGoldWeight * 100;
+				iGoldData /= iGoldValuePercent;
+				if ((iGoldData * iGoldValuePercent) < iGoldWeight)
+				{
+					iGoldData++;
+				}
+				if (GET_PLAYER(ePlayer).getMaxGoldTrade(getID(), kTransport) >= iGoldData)
+				{
+					pGoldNode->m_data.m_iData1 = iGoldData;
+					iHumanDealWeight += (iGoldData * iGoldValuePercent) / 100;
+					pTheirCounter->insertAtEnd(pGoldNode->m_data);
+					pGoldNode = NULL;
+				}
+			}
+		}
+
+		for (pNode = pTheirInventory->head(); pNode && iAIDealWeight > iHumanDealWeight; pNode = pTheirInventory->next(pNode))
+		{
+			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+			{
+				if (pNode->m_data.m_eItemType == TRADE_MAPS)
+				{
+					FAssert(GET_PLAYER(ePlayer).canTradeItem(getID(), pNode->m_data));
+
+					if (GET_PLAYER(ePlayer).getTradeDenial(getID(), pNode->m_data) == NO_DENIAL)
+					{
+						iWeight = GET_TEAM(getTeam()).AI_mapTradeVal(GET_PLAYER(ePlayer).getTeam());
+
+						if (iWeight > 0)
+						{
+							iHumanDealWeight += iWeight;
+							pTheirCounter->insertAtEnd(pNode->m_data);
+						}
+					}
+				}
+			}
+		}
+
+
+		iGoldWeight = iAIDealWeight - iHumanDealWeight;
+
+		if (iGoldWeight > 0)
+		{
+			if (pGoldNode)
+			{
+				iGoldData = iGoldWeight * 100;
+				iGoldData /= iGoldValuePercent;
+
+				if ((iGoldWeight * 100) > (iGoldData * iGoldValuePercent))
+				{
+					iGoldData++;
+				}
+
+				iGoldData = std::min(iGoldData, GET_PLAYER(ePlayer).getMaxGoldTrade(getID(), kTransport));
+
+				if (iGoldData > 0)
+				{
+					pGoldNode->m_data.m_iData1 = iGoldData;
+					iHumanDealWeight += (iGoldData * iGoldValuePercent) / 100;
+					pTheirCounter->insertAtEnd(pGoldNode->m_data);
+					pGoldNode = NULL;
+				}
+			}
+		}
+	}
+	else if (iHumanDealWeight > iAIDealWeight)
+	{
+		if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+		{
+				for (pNode = pOurInventory->head(); pNode; pNode = pOurInventory->next(pNode))
+				{
+					if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+					{
+						if (pNode->m_data.m_eItemType == TRADE_PEACE_TREATY)
+						{
+							pOurCounter->insertAtEnd(pNode->m_data);
+							break;
+						}
+					}
+				}
+
+			iBestValue = 0;
+			iBestWeight = 0;
+			pBestNode = NULL;
+
+			for (pNode = pOurInventory->head(); pNode && iHumanDealWeight > iAIDealWeight; pNode = pOurInventory->next(pNode))
+			{
+				if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+				{
+					if (pNode->m_data.m_eItemType == TRADE_CITIES)
+					{
+						FAssert(canTradeItem(ePlayer, pNode->m_data));
+
+						if (getTradeDenial(ePlayer, pNode->m_data) == NO_DENIAL)
+						{
+							pCity = getCity(pNode->m_data.m_iData1);
+
+							if (pCity != NULL)
+							{
+								iWeight = GET_PLAYER(ePlayer).AI_cityTradeVal(pCity);
+
+								if (iWeight > 0)
+								{
+									iValue = GET_PLAYER(ePlayer).AI_targetCityValue(pCity, false);
+
+									if (iValue > iBestValue)
+									{
+										if (iHumanDealWeight >= (iAIDealWeight + iWeight))
+										{
+											iBestValue = iValue;
+											iBestWeight = iWeight;
+											pBestNode = pNode;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+
+			if (pBestNode != NULL)
+			{
+				iAIDealWeight += iBestWeight;
+				pOurCounter->insertAtEnd(pBestNode->m_data);
+			}
+		}
+
+		for (pNode = pOurInventory->head(); pNode && iHumanDealWeight > iAIDealWeight; pNode = pOurInventory->next(pNode))
+		{
+			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+			{
+				FAssert(canTradeItem(ePlayer, pNode->m_data));
+
+				if (getTradeDenial(ePlayer, pNode->m_data) == NO_DENIAL)
+				{
+					switch (pNode->m_data.m_eItemType)
+					{
+					case TRADE_GOLD:
+						if (!bTheirGoldDeal)
+						{
+							pGoldNode = pNode;
+						}
+						break;
+					}
+				}
+			}
+		}
+
+		iGoldWeight = iHumanDealWeight - iAIDealWeight;
+
+		if (iGoldWeight > 0)
+		{
+			if (pGoldNode)
+			{
+				int iGoldData = iGoldWeight * 100;
+				iGoldData /= iGoldValuePercent;
+
+				if (getMaxGoldTrade(ePlayer, kTransport) >= iGoldData)
+				{
+					pGoldNode->m_data.m_iData1 = iGoldData;
+					iAIDealWeight += ((iGoldData * iGoldValuePercent) / 100);
+					pOurCounter->insertAtEnd(pGoldNode->m_data);
+					pGoldNode = NULL;
+				}
+			}
+		}
+
+		for (pNode = pOurInventory->head(); pNode && iHumanDealWeight > iAIDealWeight; pNode = pOurInventory->next(pNode))
+		{
+			if (!pNode->m_data.m_bOffering && !pNode->m_data.m_bHidden)
+			{
+				if (pNode->m_data.m_eItemType == TRADE_MAPS)
+				{
+					FAssert(canTradeItem(ePlayer, pNode->m_data));
+
+					if (getTradeDenial(ePlayer, pNode->m_data) == NO_DENIAL)
+					{
+						iWeight = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_mapTradeVal(getTeam());
+
+						if (iWeight > 0)
+						{
+							if (iHumanDealWeight >= (iAIDealWeight + iWeight))
+							{
+								iAIDealWeight += iWeight;
+								pOurCounter->insertAtEnd(pNode->m_data);
+							}
+						}
+					}
+				}
+			}
+		}
+
+		iGoldWeight = iHumanDealWeight - iAIDealWeight;
+		if (iGoldWeight > 0)
+		{
+			if (pGoldNode)
+			{
+				iGoldData = iGoldWeight * 100;
+				iGoldData /= AI_goldTradeValuePercent();
+
+				iGoldData = std::min(iGoldData, getMaxGoldTrade(ePlayer, kTransport));
+
+				if (iGoldData > 0)
+				{
+					pGoldNode->m_data.m_iData1 = iGoldData;
+					iAIDealWeight += (iGoldData * AI_goldTradeValuePercent()) / 100;
+					pOurCounter->insertAtEnd(pGoldNode->m_data);
+					pGoldNode = NULL;
+				}
+			}
+		}
+	}
+
+	return ((iAIDealWeight <= iHumanDealWeight) && ((pOurList->getLength() > 0) || (pOurCounter->getLength() > 0) || (pTheirCounter->getLength() > 0)));
+}
+
+
+int CvPlayerAI::AI_maxGoldTrade(PlayerTypes ePlayer) const
+{
+	int iMaxGold;
+
+	FAssert(ePlayer != getID());
+
+	if (isHuman() || (GET_PLAYER(ePlayer).getTeam() == getTeam()))
+	{
+		iMaxGold = getGold();
+	}
+	else
+	{
+		iMaxGold = getTotalPopulation() * 10;
+
+		iMaxGold *= (GET_TEAM(getTeam()).AI_getHasMetCounter(GET_PLAYER(ePlayer).getTeam()) + 10);
+
+		iMaxGold *= GC.getLeaderHeadInfo(getPersonalityType()).getMaxGoldTradePercent();
+		iMaxGold /= 100;
+
+		iMaxGold -= AI_getGoldTradedTo(ePlayer);
+		iMaxGold += GET_PLAYER(ePlayer).AI_getGoldTradedTo(getID());
+
+		iMaxGold = std::min(iMaxGold, getGold());
+
+		iMaxGold -= (iMaxGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+	}
+
+	return std::max(0, iMaxGold);
+}
+
+int CvPlayerAI::AI_cityTradeVal(CvCity* pCity, PlayerTypes eOwner)
+{
+	if (pCity == NULL)
+	{
+		return 0;
+	}
+
+	if (eOwner == NO_PLAYER)
+	{
+		eOwner = pCity->getOwnerINLINE();
+	}
+	FAssert(eOwner != getID());
+
+	int iValue = 300;
+
+	iValue += (pCity->getPopulation() * 50);
+	iValue += (pCity->getCultureLevel() * 200);
+	iValue += (((((pCity->getPopulation() * 50) + GC.getGameINLINE().getElapsedGameTurns() + 100) * 4) * pCity->plot()->calculateCulturePercent(eOwner)) / 100);
+
+	if (!(pCity->isEverOwned(getID())))
+	{
+		iValue *= 3;
+		iValue /= 2;
+	}
+
+	iValue -= (iValue % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+
+	if (isHuman())
+	{
+		return std::max(iValue, GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+	}
+	else
+	{
+		return iValue;
+	}
+}
+
+
+DenialTypes CvPlayerAI::AI_cityTrade(CvCity* pCity, PlayerTypes ePlayer) const
+{
+	FAssert(pCity->getOwnerINLINE() == getID());
+
+	if (pCity->getLiberationPlayer(false) == ePlayer)
+	{
+		return NO_DENIAL;
+	}
+
+	if (!(GET_PLAYER(ePlayer).isHuman()))
+	{
+		if (GET_PLAYER(ePlayer).getTeam() != getTeam())
+		{
+			if ((pCity->plot()->calculateCulturePercent(ePlayer) == 0) && !(pCity->isEverOwned(ePlayer)) && (GET_PLAYER(ePlayer).getNumCities() > 3))
+			{
+				CvCity* pNearestCity = GC.getMapINLINE().findCity(pCity->getX_INLINE(), pCity->getY_INLINE(), ePlayer, NO_TEAM, true, false, NO_TEAM, NO_DIRECTION, pCity);
+				if ((pNearestCity == NULL) || (plotDistance(pCity->getX_INLINE(), pCity->getY_INLINE(), pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE()) > 9))
+				{
+					return DENIAL_UNKNOWN;
+				}
+			}
+		}
+	}
+
+	if (isHuman())
+	{
+		return NO_DENIAL;
+	}
+
+	if (atWar(getTeam(), GET_PLAYER(ePlayer).getTeam()))
+	{
+		return NO_DENIAL;
+	}
+
+	if (isNative() && !GET_PLAYER(ePlayer).isNative())
+	{
+		return NO_DENIAL;
+	}
+
+	if (GET_PLAYER(ePlayer).getTeam() != getTeam())
+	{
+		return DENIAL_NEVER;
+	}
+
+	if (pCity->calculateCulturePercent(getID()) > 50)
+	{
+		return DENIAL_TOO_MUCH;
+	}
+
+	return NO_DENIAL;
+}
+
+
+int CvPlayerAI::AI_stopTradingTradeVal(TeamTypes eTradeTeam, PlayerTypes ePlayer)
+{
+	CvDeal* pLoopDeal;
+	int iModifier;
+	int iValue;
+	int iLoop;
+
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+	FAssertMsg(GET_PLAYER(ePlayer).getTeam() != getTeam(), "shouldn't call this function on ourselves");
+	FAssertMsg(eTradeTeam != getTeam(), "shouldn't call this function on ourselves");
+	FAssertMsg(GET_TEAM(eTradeTeam).isAlive(), "GET_TEAM(eWarTeam).isAlive is expected to be true");
+	FAssertMsg(!atWar(eTradeTeam, GET_PLAYER(ePlayer).getTeam()), "eTeam should be at peace with eWarTeam");
+
+	iValue = (50 + (GC.getGameINLINE().getGameTurn() / 2));
+	iValue += (GET_TEAM(eTradeTeam).getNumCities() * 5);
+
+	iModifier = 0;
+
+	switch (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).AI_getAttitude(eTradeTeam))
+	{
+	case ATTITUDE_FURIOUS:
+		break;
+
+	case ATTITUDE_ANNOYED:
+		iModifier += 25;
+		break;
+
+	case ATTITUDE_CAUTIOUS:
+		iModifier += 50;
+		break;
+
+	case ATTITUDE_PLEASED:
+		iModifier += 100;
+		break;
+
+	case ATTITUDE_FRIENDLY:
+		iModifier += 200;
+		break;
+
+	default:
+		FAssert(false);
+		break;
+	}
+
+	iValue *= std::max(0, (iModifier + 100));
+	iValue /= 100;
+
+	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isOpenBorders(eTradeTeam))
+	{
+		iValue *= 2;
+	}
+
+	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isDefensivePact(eTradeTeam))
+	{
+		iValue *= 3;
+	}
+
+	for(pLoopDeal = GC.getGameINLINE().firstDeal(&iLoop); pLoopDeal != NULL; pLoopDeal = GC.getGameINLINE().nextDeal(&iLoop))
+	{
+		if (pLoopDeal->isCancelable(getID()) && !(pLoopDeal->isPeaceDeal()))
+		{
+			if (GET_PLAYER(pLoopDeal->getFirstPlayer()).getTeam() == GET_PLAYER(ePlayer).getTeam())
+			{
+				if (pLoopDeal->getLengthSecondTrades() > 0)
+				{
+					iValue += (GET_PLAYER(pLoopDeal->getFirstPlayer()).AI_dealVal(pLoopDeal->getSecondPlayer(), pLoopDeal->getSecondTrades()) * ((pLoopDeal->getLengthFirstTrades() == 0) ? 2 : 1));
+				}
+			}
+
+			if (GET_PLAYER(pLoopDeal->getSecondPlayer()).getTeam() == GET_PLAYER(ePlayer).getTeam())
+			{
+				if (pLoopDeal->getLengthFirstTrades() > 0)
+				{
+					iValue += (GET_PLAYER(pLoopDeal->getSecondPlayer()).AI_dealVal(pLoopDeal->getFirstPlayer(), pLoopDeal->getFirstTrades()) * ((pLoopDeal->getLengthSecondTrades() == 0) ? 2 : 1));
+				}
+			}
+		}
+	}
+
+	iValue -= (iValue % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+
+	if (isHuman())
+	{
+		return std::max(iValue, GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+	}
+	else
+	{
+		return iValue;
+	}
+}
+
+
+DenialTypes CvPlayerAI::AI_stopTradingTrade(TeamTypes eTradeTeam, PlayerTypes ePlayer) const
+{
+	AttitudeTypes eAttitude;
+	AttitudeTypes eAttitudeThem;
+	int iI;
+
+	FAssertMsg(ePlayer != getID(), "shouldn't call this function on ourselves");
+	FAssertMsg(GET_PLAYER(ePlayer).getTeam() != getTeam(), "shouldn't call this function on ourselves");
+	FAssertMsg(eTradeTeam != getTeam(), "shouldn't call this function on ourselves");
+	FAssertMsg(GET_TEAM(eTradeTeam).isAlive(), "GET_TEAM(eTradeTeam).isAlive is expected to be true");
+	FAssertMsg(!atWar(getTeam(), eTradeTeam), "should be at peace with eTradeTeam");
+
+	if (isHuman())
+	{
+		return NO_DENIAL;
+	}
+
+	eAttitude = GET_TEAM(getTeam()).AI_getAttitude(GET_PLAYER(ePlayer).getTeam());
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			if (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
+			{
+				if (eAttitude <= GC.getLeaderHeadInfo(GET_PLAYER((PlayerTypes)iI).getPersonalityType()).getStopTradingRefuseAttitudeThreshold())
+				{
+					return DENIAL_ATTITUDE;
+				}
+			}
+		}
+	}
+
+	eAttitudeThem = GET_TEAM(getTeam()).AI_getAttitude(eTradeTeam);
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			if (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
+			{
+				if (eAttitudeThem > GC.getLeaderHeadInfo(GET_PLAYER((PlayerTypes)iI).getPersonalityType()).getStopTradingThemRefuseAttitudeThreshold())
+				{
+					return DENIAL_ATTITUDE_THEM;
+				}
+			}
+		}
+	}
+
+	return NO_DENIAL;
+}
+
+int CvPlayerAI::AI_yieldTradeVal(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer)
+{
+	int iValue = 0;
+	CvPlayerAI& kTradePlayer = GET_PLAYER(ePlayer);
+	CvUnit* pTransport = ::getUnit(kTransport);
+	if (pTransport != NULL)
+	{
+		int iAmount = kTradePlayer.getTradeYieldAmount(eYield, pTransport);
+		if (isNative())
+		{
+
+			int iTotalStored = countTotalYieldStored(eYield);
+			int iMaxStored;
+			if (eYield == YIELD_FOOD)
+			{
+				iMaxStored = getNumCities() * getGrowthThreshold(1);
+			}
+			///Tks Med
+//			else if (eYield == YIELD_HORSES && iAmount > 0)
+//			{
+//               int iRandomHorses = GC.getGame().getSorenRandNum(GC.getDefineINT("NATIVE_HORSES_FOR_SALE"), "AI Native Horses for sale");
+//			   iAmount = std::min(iRandomHorses, (iAmount * GC.getDefineINT("NATIVE_HORSES_FOR_SALE_PERCENT")) / 100);
+//			}
+            ///tke
+			else
+			{
+				iMaxStored = getNumCities() * GC.getGameINLINE().getCargoYieldCapacity();
+			}
+
+			int iNativeConsumptionPercent = GC.getYieldInfo(eYield).getNativeConsumptionPercent();
+			if (iNativeConsumptionPercent > 0)
+			{
+				iMaxStored *= iNativeConsumptionPercent;
+				iMaxStored /= 80;
+			}
+			else
+			{
+				iMaxStored *= 2;
+			}
+			int iBuyPrice = GC.getYieldInfo(eYield).getNativeBuyPrice();
+			CvCity* pCity = pTransport->plot()->getPlotCity();
+			if (pCity != NULL)
+			{
+				if (eYield == pCity->AI_getDesiredYield())
+				{
+					iBuyPrice *= 125;
+					iBuyPrice /= 100;
+				}
+			}
+
+			int iHighPricePercent = std::max(25, 100 - ((100 * iTotalStored) / iMaxStored));
+			int iLowPricePercent = std::max(25, 100 - ((100 * std::min(iMaxStored, iTotalStored + iAmount)) / iMaxStored));
+
+			iValue += (iAmount * iBuyPrice * (iHighPricePercent + iLowPricePercent)) / 200;
+		}
+		else if (kTradePlayer.isNative())
+		{
+			int iTotalStored = kTradePlayer.countTotalYieldStored(eYield);
+			int iMaxStored;
+			if (eYield == YIELD_FOOD)
+			{
+				iMaxStored = kTradePlayer.getNumCities() * getGrowthThreshold(1);
+			}
+			else
+			{
+				iMaxStored = kTradePlayer.getNumCities() * GC.getGameINLINE().getCargoYieldCapacity();
+			}
+
+			int iNativeConsumptionPercent = GC.getYieldInfo(eYield).getNativeConsumptionPercent();
+			if (iNativeConsumptionPercent > 0)
+			{
+				iMaxStored *= iNativeConsumptionPercent;
+				iMaxStored /= 80;
+			}
+			else
+			{
+				iMaxStored *= 2;
+			}
+			int iSellPrice = GC.getYieldInfo(eYield).getNativeSellPrice();
+
+			int iHighPricePercent = std::max(25, 100 - ((100 * iTotalStored) / std::max(1, iMaxStored)));
+			int iLowPricePercent = std::max(25, 100 - ((100 * std::max(0, iTotalStored - iAmount)) / std::max(1, iMaxStored)));
+
+			iValue += (iAmount * iSellPrice * (iHighPricePercent + iLowPricePercent)) / 200;
+			///TKe Med
+			if (iValue < 0)
+            {
+                iValue = 0;
+                CvCity* pCity = pTransport->plot()->getPlotCity();
+                if (pCity != NULL)
+                {
+                    if (ePlayer != pCity->getOwnerINLINE())
+                    {
+                        if (AI_isYieldFinalProduct(eYield))
+                        {
+                            iValue += GET_PLAYER(pCity->getOwnerINLINE()).getSellToEuropeProfit(eYield, iAmount) * 95 / 100;
+                        }
+                        else
+                        {
+                            iValue += GET_PLAYER(pCity->getOwnerINLINE()).AI_yieldValue(eYield, true, iAmount);
+                        }
+                    }
+                }
+            }
+			///TKe
+
+		}
+		else
+		{
+			CvCity* pCity = pTransport->plot()->getPlotCity();
+			if (pCity != NULL)
+			{
+				if (ePlayer == pCity->getOwnerINLINE())
+				{
+					if (AI_isYieldFinalProduct(eYield))
+					{
+						iValue += kTradePlayer.getSellToEuropeProfit(eYield, iAmount) * 95 / 100;
+					}
+					else
+					{
+						iValue += kTradePlayer.AI_yieldValue(eYield, true, iAmount);
+					}
+				}
+				else
+				{
+					iValue += kTradePlayer.AI_yieldValue(eYield, false, iAmount);
+				}
+			}
+		}
+	}
+
+	return iValue;
+}
+
+DenialTypes CvPlayerAI::AI_yieldTrade(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer) const
+{
+    ///TKs Invention Core Mod v 1.0
+    if (eYield == YIELD_IDEAS)
+    {
+        TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
+        if (isHuman())
+        {
+            return NO_DENIAL;
+        }
+
+        if (GET_TEAM(getTeam()).AI_shareWar(eTeam))
+        {
+            return NO_DENIAL;
+        }
+
+        if (GET_TEAM(getTeam()).AI_getMemoryCount(eTeam, MEMORY_CANCELLED_OPEN_BORDERS) > 0)
+        {
+            return DENIAL_RECENT_CANCEL;
+        }
+
+        if (GET_TEAM(getTeam()).AI_getWorstEnemy() == eTeam)
+        {
+            return DENIAL_WORST_ENEMY;
+        }
+        //TK Update 1.1
+        if (!isNative())
+        {
+            AttitudeTypes eAttitude = GET_TEAM(getTeam()).AI_getAttitude(eTeam);
+
+            if (eAttitude <= (AttitudeTypes)GC.getLeaderHeadInfo(getPersonalityType()).getNoGiveHelpAttitudeThreshold())
+            {
+    //            if (GET_PLAYER(ePlayer).isHuman())
+    //            {
+    //                 char szOut[1024];
+    //                sprintf(szOut, "######################## Player %d %S You Suck cause %S == %d\n", getID(), getNameKey(), GC.getAttitudeInfo(AI_getAttitude(ePlayer)).getTextKeyWide(), eAttitude);
+    //                gDLL->messageControlLog(szOut);
+    //            }
+                return DENIAL_ATTITUDE;
+            }
+        }
+        //TKe
+
+        return NO_DENIAL;
+    }
+
+    ///TKe
+	CvUnit* pTransport = ::getUnit(kTransport);
+	CvCity* pCity = pTransport->plot()->getPlotCity();
+	if (pCity != NULL)
+	{
+		CvPlayer& kPlayer = GET_PLAYER(pCity->getOwnerINLINE());
+		if (kPlayer.isNative())
+		{
+			if (getID() == pCity->getOwnerINLINE())
+			{
+				if (GC.getYieldInfo(eYield).getNativeSellPrice() == -1)
+				{
+					return DENIAL_NEVER;
+				}
+			}
+			else
+			{
+				if (pCity->AI_getDesiredYield() == eYield)
+				{
+					return NO_DENIAL;
+				}
+				if (GC.getYieldInfo(eYield).getNativeBuyPrice() == -1)
+				{
+					return DENIAL_NOT_INTERESTED;
+				}
+			}
+
+			bool bCanProduce = pCity->canProduceYield(eYield);
+			///TKs
+			if (GC.isEquipmentType(eYield, EQUIPMENT_ARMOR_HORSES))
+			{
+				bCanProduce = false;
+			}
+
+
+			if (getID() == pCity->getOwnerINLINE())
+			{
+				if (!bCanProduce)
+				{
+				    if (eYield != YIELD_HORSES)
+				    {
+                        return DENIAL_UNKNOWN;
+				    }
+				}
+				///TKe
+			}
+			else
+			{
+				if (bCanProduce)
+				{
+					return DENIAL_NO_GAIN;
+				}
+			}
+		}
+		else
+		{
+			if (getID() == pCity->getOwnerINLINE())
+			{
+			    ///Tks
+				if (GC.isEquipmentType(eYield, EQUIPMENT_ANY))
+				{
+					return DENIAL_NEVER;
+				}
+				if (pCity->AI_getDesiredYield() == eYield)
+				{
+					return DENIAL_NEVER;
+				}
+				///Tke
+				if (AI_shouldBuyFromEurope(eYield))
+				{
+					return DENIAL_NO_GAIN;
+				}
+				if (pCity->calculateActualYieldConsumed(eYield) > 0)
+				{
+					return DENIAL_NO_GAIN;
+				}
+			}
+		}
+	}
+
+	return NO_DENIAL;
+}
+
+int CvPlayerAI::AI_calculateDamages(TeamTypes eTeam)
+{
+	int iValue = 0;
+
+	int iStolenPlotCost = 0;
+	int iPopulationCost = 0;
+	for (int iI = 0; iI < MAX_PLAYERS; ++iI)
+	{
+		PlayerTypes ePlayer = (PlayerTypes)iI;
+		CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+		if (kPlayer.isAlive())
+		{
+			if (kPlayer.getTeam() == eTeam)
+			{
+				int iStolenPlots = 0;
+				for(int i=0;i<GC.getMapINLINE().numPlotsINLINE();i++)
+				{
+					CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(i);
+					if(pLoopPlot->getOwnerINLINE() == ePlayer && pLoopPlot->getCulture(getID()) > pLoopPlot->getCulture(ePlayer))
+					{
+						iStolenPlotCost += pLoopPlot->getBuyPrice(ePlayer);
+					}
+				}
+
+				iPopulationCost += kPlayer.getTotalPopulation() * 100;
+			}
+		}
+	}
+
+	iPopulationCost += 250;
+
+	iValue += iPopulationCost;
+
+	iValue += iStolenPlotCost / 4;
+
+	return iValue;
+}
+
+int CvPlayerAI::AI_unitImpassableCount(UnitTypes eUnit)
+{
+	int iCount = 0;
+	for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
+	{
+		if (GC.getUnitInfo(eUnit).getTerrainImpassable(iI))
+		{
+				iCount++;
+			}
+		}
+
+	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
+	{
+		if (GC.getUnitInfo(eUnit).getFeatureImpassable(iI))
+		{
+				iCount++;
+			}
+		}
+
+	return iCount;
+}
+
+//Calculates the value of the unit as "Profit generated in 20 turns" in pCity,
+//or if pCity is NULL it assumes that it will either found somewhere
+//or has some other role.
+int CvPlayerAI::AI_unitEconomicValue(UnitTypes eUnit, UnitAITypes* peUnitAI, CvCity* pCity)
+{
+	UnitAITypes eBestUnitAI = NO_UNITAI;
+
+	if (getNumCities() == 0)
+	{
+		return 1;
+	}
+
+	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
+	int iBestValue = 0;
+	if (kUnitInfo.getUnitAIType(UNITAI_COLONIST))
+	{
+		if (pCity == NULL)
+		{
+			//Do we have an ideal profession?
+			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
+			{
+				YieldTypes eYield = (YieldTypes)iI;
+
+				if (kUnitInfo.getYieldModifier(eYield) > 0)
+				{
+					for (int iJ = 0; iJ < GC.getNumProfessionInfos(); iJ++)
+					{
+						if (GC.getCivilizationInfo(getCivilizationType()).isValidProfession(iJ))
+						{
+							CvProfessionInfo& kProfessionInfo = GC.getProfessionInfo((ProfessionTypes)iJ);
+							// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+							if (kProfessionInfo.getYieldsProduced(0) == eYield)
+							{
+								if (kProfessionInfo.getYieldsConsumed(0, getID()) == NO_YIELD)
+								{
+									// MultipleYieldsProduced End
+									if (kProfessionInfo.isWorkPlot())
+									{
+										CvPlot* pCenter = AI_getTerritoryCenter();
+										int iRadius = AI_getTerritoryRadius();
+										for (int iX = -iRadius; iX <= iRadius; iX++)
+										{
+											for (int iY = -iRadius; iY <= iRadius; iY++)
+											{
+												CvPlot* pLoopPlot = plotXY(pCenter->getX_INLINE(), pCenter->getY_INLINE(), iX, iY);
+												if ((pLoopPlot != NULL) && (pLoopPlot->getOwnerINLINE() == getID()) && (!pLoopPlot->isCity()))
+												{
+													int iAmount = pLoopPlot->calculatePotentialYield(eYield, NULL, false);
+
+													iAmount *= 100 + kUnitInfo.getYieldModifier(eYield);
+													iAmount /= 100;
+
+													int iValue = 20 * AI_yieldValue(eYield) * iAmount;
+													bool bValid = true;
+													if (pLoopPlot->isBeingWorked())
+													{
+														iValue *= 75;
+														iValue /= 100;
+
+														CvCity* pCity = pLoopPlot->getWorkingCity();
+														FAssert(pCity!= NULL);
+
+														CvUnit* pWorkingUnit = pCity->getUnitWorkingPlot(pLoopPlot);
+														FAssert(pWorkingUnit != NULL);
+
+														if (pWorkingUnit != NULL)
+														{
+															FAssert(pWorkingUnit->getProfession() != NO_PROFESSION);
+															// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+															YieldTypes eTempYield = (YieldTypes)GC.getProfessionInfo(pWorkingUnit->getProfession()).getYieldsProduced(0);
+															// MultipleYieldsProduced End
+															int iTempAmount = pLoopPlot->getYield(eYield);
+															int iTempValue = 20 * AI_yieldValue(eTempYield) * iTempAmount;
+
+															if (iValue > (iTempValue * 4) / 3)
+															{
+																bValid = false;
+															}
+														}
+													}
+
+													if (bValid)
+													{
+														if (iValue > iBestValue)
+														{
+															iBestValue = iValue;
+															eBestUnitAI = UNITAI_COLONIST;
+														}
+													}
+												}
+											}
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (kUnitInfo.getUnitAIType(UNITAI_WAGON))
+	{
+		int iValue = 0;
+		if (pCity != NULL)
+		{
+			int iCityCount = pCity->area()->getCitiesPerPlayer(getID());
+			int iWagonCount = AI_totalAreaUnitAIs(pCity->area(), UNITAI_WAGON);
+
+			int iNeededWagons = iCityCount / 2;
+			if (iNeededWagons < iWagonCount)
+			{
+				iValue += 100 * kUnitInfo.getCargoSpace();
+			}
+		}
+
+		if (iValue > iBestValue)
+		{
+			iBestValue = iValue;
+			eBestUnitAI = UNITAI_WAGON;
+		}
+	}
+
+	if (peUnitAI != NULL)
+	{
+		*peUnitAI = eBestUnitAI;
+	}
+
+	return iBestValue;
+}
+
+int CvPlayerAI::AI_unitValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea)
+{
+	bool bValid;
+	int iCombatValue;
+	int iValue;
+
+	FAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
+	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
+	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
+
+	if (kUnitInfo.getDomainType() != AI_unitAIDomainType(eUnitAI))
+	{
+		return 0;
+	}
+
+	if (kUnitInfo.getNotUnitAIType(eUnitAI))
+	{
+		return 0;
+	}
+
+	bValid = kUnitInfo.getUnitAIType(eUnitAI);
+
+	if (!bValid)
+	{
+		switch (eUnitAI)
+		{
+		case UNITAI_UNKNOWN:
+        ///TKs Med
+        case UNITAI_ANIMAL:
+        ///TKe
+			break;
+		case UNITAI_COLONIST:
+			break;
+		case UNITAI_SETTLER:
+			break;
+		case UNITAI_WORKER:
+			break;
+		case UNITAI_MISSIONARY:
+			break;
+        ///TKs Med
+		case UNITAI_SCOUT:
+        case UNITAI_HUNTSMAN:
+			break;
+		case UNITAI_WAGON:
+        case UNITAI_MARAUDER:
+		case UNITAI_TRADER:
+		///TKe
+			break;
+		case UNITAI_TREASURE:
+			break;
+		case UNITAI_YIELD:
+			break;
+		case UNITAI_GENERAL:
+			break;
+		case UNITAI_DEFENSIVE:
+			break;
+		case UNITAI_OFFENSIVE:
+			break;
+		case UNITAI_COUNTER:
+			break;
+		case UNITAI_TRANSPORT_SEA:
+			break;
+		case UNITAI_ASSAULT_SEA:
+			if ((kUnitInfo.getCargoSpace() > 0) && kUnitInfo.getMoves() > 0)
+			{
+				bValid = true;
+			}
+			break;
+		case UNITAI_COMBAT_SEA:
+			break;
+		case UNITAI_PIRATE_SEA:
+			if (kUnitInfo.isHiddenNationality())
+			{
+				if ((kUnitInfo.getCombat() > 0) && kUnitInfo.getMoves() > 0)
+				{
+					bValid = true;
+				}
+			}
+			break;
+
+		default:
+			FAssert(false);
+			break;
+		}
+	}
+
+	if (!bValid)
+	{
+		return 0;
+	}
+
+	iCombatValue = GC.getGameINLINE().AI_combatValue(eUnit);
+
+	iValue = 100;
+
+	iValue += kUnitInfo.getAIWeight();
+
+	int iEuropeCost = getEuropeUnitBuyPrice(eUnit);
+	if (iEuropeCost > 0)
+	{
+		iValue += iEuropeCost;
+	}
+
+	return std::max(0, iValue);
+}
+
+
+//This function attempts to return how much gold this unit is worth.
+int CvPlayerAI::AI_unitGoldValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea)
+{
+	bool bValid = false;
+	int iValue = 0;
+
+	FAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
+	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
+	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
+
+	if (kUnitInfo.getDomainType() != AI_unitAIDomainType(eUnitAI))
+	{
+		return 0;
+	}
+
+	if (kUnitInfo.getNotUnitAIType(eUnitAI))
+	{
+		return 0;
+	}
+
+	bValid = kUnitInfo.getUnitAIType(eUnitAI);
+
+	if (!bValid)
+	{
+		switch (eUnitAI)
+		{
+		case UNITAI_UNKNOWN:
+		///TKs Animal
+		case UNITAI_ANIMAL:
+        case UNITAI_MARAUDER:
+		///Tke
+			break;
+
+		case UNITAI_COLONIST:
+		case UNITAI_SETTLER:
+		case UNITAI_WORKER:
+		case UNITAI_MISSIONARY:
+		case UNITAI_SCOUT:
+		///TKs Med
+        case UNITAI_HUNTSMAN:
+        ///TKe
+			if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
+			{
+				bValid = true;
+			}
+			break;
+
+		case UNITAI_WAGON:
+		///Tks Med
+		case UNITAI_TRADER:
+			if (kUnitInfo.getCargoSpace() > 0)
+			{
+				bValid = true;
+			}
+			break;
+        ///TKe
+		case UNITAI_TREASURE:
+			break;
+
+		case UNITAI_YIELD:
+			break;
+
+		case UNITAI_GENERAL:
+			break;
+
+		case UNITAI_DEFENSIVE:
+			if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
+			{
+				bValid = true;
+			}
+			break;
+
+		case UNITAI_OFFENSIVE:
+			if (kUnitInfo.getBombardRate() > 0)
+			{
+				bValid = true;
+			}
+			break;
+
+		case UNITAI_COUNTER:
+			if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
+			{
+				bValid = true;
+			}
+			break;
+
+		case UNITAI_TRANSPORT_SEA:
+			if (kUnitInfo.getCargoSpace() > 0)
+			{
+				bValid = true;
+			}
+			break;
+
+		case UNITAI_ASSAULT_SEA:
+			if ((kUnitInfo.getCargoSpace() > 0) && kUnitInfo.getMoves() > 0)
+			{
+				bValid = true;
+			}
+			break;
+
+		case UNITAI_COMBAT_SEA:
+			if (!kUnitInfo.isOnlyDefensive() && (kUnitInfo.getCombat() > 0) && kUnitInfo.getMoves() > 0)
+			{
+				bValid = true;
+			}
+			break;
+		case UNITAI_PIRATE_SEA:
+		///TKs Med
+        //case UNITAI_MARAUDER:
+        ///TKe
+			if (kUnitInfo.isHiddenNationality())
+			{
+				if ((kUnitInfo.getCombat() > 0) && kUnitInfo.getMoves() > 0)
+				{
+					bValid = true;
+				}
+			}
+			break;
+
+		default:
+			FAssert(false);
+			break;
+		}
+	}
+
+	if (!bValid)
+	{
+		return 0;
+	}
+	//This function specifically tries to estimate the gold value of a unit.
+
+	int iOffenseCombatValue = kUnitInfo.getCombat() * 100;
+	int iDefenseCombatValue = kUnitInfo.getCombat() * 100;
+
+	if (kUnitInfo.isOnlyDefensive())
+	{
+		iOffenseCombatValue /= 4;
+	}
+
+	int iCargoValue = kUnitInfo.getCargoSpace() * 250;
+
+	if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
+	{
+		iValue += std::max(0, kUnitInfo.getEuropeCost());
+	}
+
+	int iTempValue;
+
+	switch (eUnitAI)
+	{
+	case UNITAI_UNKNOWN:
+	///TKs Med
+    case UNITAI_ANIMAL:
+    ///TKe
+		break;
+
+	case UNITAI_COLONIST:
+	case UNITAI_SETTLER:
+	case UNITAI_WORKER:
+	case UNITAI_MISSIONARY:
+	case UNITAI_SCOUT:
+	///TKs Med
+    case UNITAI_HUNTSMAN:
+    case UNITAI_MARAUDER:
+    ///TKe
+		break;
+
+	case UNITAI_WAGON:
+	///TKs Med
+	case UNITAI_TRADER:
+		iTempValue = iCargoValue + iDefenseCombatValue / 2;
+		iTempValue *= 1 + kUnitInfo.getMoves();
+		iTempValue /= 2;
+		iValue += iTempValue;
+		break;
+    ///Tke
+	case UNITAI_TREASURE:
+		break;
+
+	case UNITAI_YIELD:
+		break;
+
+	case UNITAI_GENERAL:
+		break;
+
+	case UNITAI_DEFENSIVE:
+		iTempValue = iOffenseCombatValue / 2;
+		iTempValue += iDefenseCombatValue;
+		iTempValue += kUnitInfo.getBombardRate() * 50;
+		iValue += iTempValue;
+		break;
+
+	case UNITAI_OFFENSIVE:
+		iTempValue = iOffenseCombatValue;
+		iTempValue += iDefenseCombatValue / 2;
+		iTempValue += kUnitInfo.getBombardRate() * 50;
+
+		iTempValue *= 2 + kUnitInfo.getMoves();
+		iTempValue /= 3;
+		iValue += iTempValue;
+		break;
+
+	case UNITAI_COUNTER:
+		iTempValue = iOffenseCombatValue * 2 / 3;
+		iTempValue += iDefenseCombatValue * 2 / 3;
+		iTempValue += kUnitInfo.getBombardRate() * 50;
+
+		iTempValue *= 2 + kUnitInfo.getMoves();
+		iTempValue /= 3;
+		iValue += iTempValue;
+		break;
+
+	case UNITAI_TRANSPORT_SEA:
+
+		iValue += ((4 + kUnitInfo.getMoves()) * (iCargoValue + iDefenseCombatValue / 2)) / 7;
+
+		break;
+
+	case UNITAI_ASSAULT_SEA:
+		iTempValue = iDefenseCombatValue + iCargoValue;
+		iTempValue *= 4 + kUnitInfo.getMoves();
+		iTempValue /= 7;
+		if (kUnitInfo.isHiddenNationality())
+		{
+			iTempValue /= 2;
+		}
+		iValue += iTempValue;
+		break;
+
+	case UNITAI_COMBAT_SEA:
+		iTempValue = iOffenseCombatValue * 2 + iDefenseCombatValue;
+		iTempValue *= 4 + kUnitInfo.getMoves();
+		iTempValue /= 8;
+		if (kUnitInfo.isHiddenNationality())
+		{
+			iTempValue /= 2;
+		}
+		iValue += iTempValue;
+		break;
+
+	case UNITAI_PIRATE_SEA:
+		iTempValue = iOffenseCombatValue + iDefenseCombatValue + iCargoValue / 2;
+		iTempValue *= 3 + kUnitInfo.getMoves();
+		iTempValue /= 6;
+		iValue += iTempValue;
+		break;
+
+	default:
+		FAssert(false);
+		break;
+	}
+
+
+	iValue +=  kUnitInfo.getAIWeight();
+
+	return std::max(0, iValue);
+}
+
+//This function indicates how worthwhile the unit is to buy.
+int CvPlayerAI::AI_unitValuePercent(UnitTypes eUnit, UnitAITypes* peUnitAI, CvArea* pArea)
+{
+	FAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
+	CvUnitInfo& kUnitInfo = GC.getUnitInfo(eUnit);
+
+	int iValue = 0;
+
+	int iGoldCost = getEuropeUnitBuyPrice(eUnit);
+
+	if (iGoldCost <= 0)
+	{
+		return -1;
+	}
+
+
+	//Transport Sea
+	int iCargoSpace = kUnitInfo.getCargoSpace();
+	if ((iCargoSpace > 1) && (kUnitInfo.getDomainType() == DOMAIN_SEA))
+	{
+		//Do we need a transport, period?
+		int iTransportCount = AI_totalUnitAIs(UNITAI_TRANSPORT_SEA);
+		if (iTransportCount == 0)
+		{
+			iValue += 200 + 50 * iCargoSpace;
+		}
+		else if (AI_totalUnitAIs(UNITAI_TREASURE) > 0) //Do we need a treasure transport?
+		{
+			int iLargestTreasureUnit = 0;
+			int iTotalTreasure = 0;
+			bool bValid = true;
+
+			int iLoop;
+			CvUnit* pLoopUnit;
+			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+			{
+				if (pLoopUnit->canMove())
+				{
+					if (pLoopUnit->cargoSpace() > 0)
+					{
+						if (pLoopUnit->cargoSpace() >= iCargoSpace)
+						{
+							bValid = false;
+							break;
+						}
+					}
+					if (pLoopUnit->AI_getUnitAIType() == UNITAI_TREASURE)
+					{
+						int iSize = pLoopUnit->getUnitInfo().getRequiredTransportSize();
+						if (iSize > 1)
+						{
+							iLargestTreasureUnit = std::max(iLargestTreasureUnit, iSize);
+							if (iCargoSpace >= iSize)
+							{
+								iTotalTreasure += pLoopUnit->getYield();
+							}
+						}
+					}
+				}
+			}
+
+			if (kUnitInfo.getCargoSpace() >= iLargestTreasureUnit)
+			{
+				iValue += 100 + ((100 * iTotalTreasure) / iGoldCost);
+			}
+		}
+
+		if (iTransportCount < (1 + getNumCities() / 3))
+		{
+			int iBestTransportSize = 0;
+			int iLoop;
+			CvUnit* pLoopUnit;
+			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+			{
+				int iBestTransportSize = 1;
+				if (pLoopUnit->AI_getUnitAIType() == UNITAI_TRANSPORT_SEA)
+				{
+					iBestTransportSize = std::max(iBestTransportSize, pLoopUnit->cargoSpace());
+				}
+			}
+
+			if (iCargoSpace == iBestTransportSize)
+			{
+				iValue += 25;
+			}
+			else if (iCargoSpace > iBestTransportSize)
+			{
+				iValue += 50 + 10 * (iCargoSpace - iBestTransportSize);
+			}
+		}
+	}
+
+	//Warships
+	if (kUnitInfo.getDomainType() == DOMAIN_SEA)
+	{
+		if (kUnitInfo.getCombat() > 0)
+		{
+			//Pirate
+			if (getTotalPopulation() > 12)
+			{
+				if (kUnitInfo.isHiddenNationality())
+				{
+					if (AI_totalUnitAIs(UNITAI_PIRATE_SEA) <= (getNumCities() / 9))
+					{
+						iValue += 50 + getNumCities() * 5;
+					}
+				}
+			}
+		}
+	}
+	return iValue;
+}
+
+int CvPlayerAI::AI_totalUnitAIs(UnitAITypes eUnitAI)
+{
+	return (AI_getNumTrainAIUnits(eUnitAI) + AI_getNumAIUnits(eUnitAI));
+}
+
+
+int CvPlayerAI::AI_totalAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI)
+{
+	return (pArea->getNumTrainAIUnits(getID(), eUnitAI) + pArea->getNumAIUnits(getID(), eUnitAI));
+}
+
+
+int CvPlayerAI::AI_totalWaterAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI)
+{
+	CvCity* pLoopCity;
+	int iCount;
+	int iLoop;
+	int iI;
+
+	iCount = AI_totalAreaUnitAIs(pArea, eUnitAI);
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			for (pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
+			{
+				if (pLoopCity->waterArea() == pArea)
+				{
+					iCount += pLoopCity->plot()->plotCount(PUF_isUnitAIType, eUnitAI, -1, getID());
+
+					if (pLoopCity->getOwnerINLINE() == getID())
+					{
+						iCount += pLoopCity->getNumTrainUnitAI(eUnitAI);
+					}
+				}
+			}
+		}
+	}
+
+
+	return iCount;
+}
+
+bool CvPlayerAI::AI_hasSeaTransport(const CvUnit* pCargo) const
+{
+	int iLoop;
+	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+	{
+		if (pLoopUnit != pCargo && pLoopUnit->getDomainType() == DOMAIN_SEA)
+		{
+			if (pLoopUnit->cargoSpace() >= pCargo->getUnitInfo().getRequiredTransportSize())
+			{
+				return true;
+			}
+
+		}
+	}
+	return false;
+}
+
+int CvPlayerAI::AI_neededExplorers(CvArea* pArea)
+{
+	FAssert(pArea != NULL);
+	int iNeeded = 0;
+
+	if (pArea->isWater())
+	{
+		iNeeded = std::min(iNeeded + (pArea->getNumUnrevealedTiles(getTeam()) / 400), std::min(2, ((getNumCities() / 2) + 1)));
+	}
+	else
+	{
+		iNeeded = std::min(iNeeded + (pArea->getNumUnrevealedTiles(getTeam()) / 150), std::min(3, ((getNumCities() / 3) + 2)));
+	}
+
+	if (0 == iNeeded)
+	{
+		if ((GC.getGameINLINE().countCivTeamsAlive() - 1) > GET_TEAM(getTeam()).getHasMetCivCount())
+		{
+			if (pArea->isWater())
+			{
+				if (GC.getMap().findBiggestArea(true) == pArea)
+				{
+					iNeeded++;
+				}
+			}
+			else
+			{
+			    if (getPrimaryCity() != NULL && pArea->getID() == getPrimaryCity()->getArea())
+			    {
+                    for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
+                    {
+                        CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
+                        if (kPlayer.isAlive() && kPlayer.getTeam() != getTeam())
+                        {
+                            if (!GET_TEAM(getTeam()).isHasMet(kPlayer.getTeam()))
+                            {
+                                if (pArea->getCitiesPerPlayer(kPlayer.getID()) > 0)
+                                {
+                                    iNeeded++;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+			    }
+			}
+		}
+	}
+	return iNeeded;
+
+}
+
+
+int CvPlayerAI::AI_neededWorkers(CvArea* pArea)
+{
+	CvCity* pLoopCity;
+	int iCount;
+	int iLoop;
+
+	iCount = 0;
+
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if ((pArea == NULL) || (pLoopCity->getArea() == pArea->getID()))
+		{
+			iCount += pLoopCity->AI_getWorkersNeeded();
+		}
+	}
+
+	if (iCount == 0)
+	{
+		return 0;
+	}
+
+	return std::max(1, (iCount * 2) / 3);
+}
+
+int CvPlayerAI::AI_adjacentPotentialAttackers(CvPlot* pPlot, bool bTestCanMove)
+{
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	CvPlot* pLoopPlot;
+	int iCount;
+	int iI;
+
+	iCount = 0;
+
+	for (iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
+	{
+		pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), ((DirectionTypes)iI));
+
+		if (pLoopPlot != NULL)
+		{
+			if (pLoopPlot->area() == pPlot->area())
+			{
+				pUnitNode = pLoopPlot->headUnitNode();
+
+				while (pUnitNode != NULL)
+				{
+					pLoopUnit = ::getUnit(pUnitNode->m_data);
+					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+					if (pLoopUnit->getOwnerINLINE() == getID())
+					{
+						if (pLoopUnit->getDomainType() == ((pPlot->isWater()) ? DOMAIN_SEA : DOMAIN_LAND))
+						{
+							if (pLoopUnit->canAttack())
+							{
+								if (!bTestCanMove || pLoopUnit->canMove())
+								{
+									if (!(pLoopUnit->AI_isCityAIType()))
+									{
+										iCount++;
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+
+int CvPlayerAI::AI_totalMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
+{
+	PROFILE_FUNC();
+
+	CvSelectionGroup* pLoopSelectionGroup;
+	int iCount;
+	int iLoop;
+
+	iCount = 0;
+
+	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+	{
+		if (pLoopSelectionGroup != pSkipSelectionGroup)
+		{
+			if (pLoopSelectionGroup->AI_getMissionAIType() == eMissionAI)
+			{
+				iCount += pLoopSelectionGroup->getNumUnits();
+			}
+		}
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_areaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
+{
+	PROFILE_FUNC();
+
+	CvSelectionGroup* pLoopSelectionGroup;
+	CvPlot* pMissionPlot;
+	int iCount;
+	int iLoop;
+
+	iCount = 0;
+
+	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+	{
+		if (pLoopSelectionGroup != pSkipSelectionGroup)
+		{
+			if (pLoopSelectionGroup->AI_getMissionAIType() == eMissionAI)
+			{
+				pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
+
+				if (pMissionPlot != NULL)
+				{
+					if (pMissionPlot->getArea() == pArea->getID())
+					{
+						iCount += pLoopSelectionGroup->getNumUnits();
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+
+int CvPlayerAI::AI_adjacantToAreaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
+{
+	PROFILE_FUNC();
+
+	CvSelectionGroup* pLoopSelectionGroup;
+	CvPlot* pMissionPlot;
+	int iCount;
+	int iLoop;
+
+	iCount = 0;
+
+	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+	{
+		if (pLoopSelectionGroup != pSkipSelectionGroup)
+		{
+			if (pLoopSelectionGroup->AI_getMissionAIType() == eMissionAI)
+			{
+				pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
+
+				if (pMissionPlot != NULL)
+				{
+					if (pMissionPlot->isAdjacentToArea(pArea->getID()))
+					{
+						iCount += pLoopSelectionGroup->getNumUnits();
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+
+int CvPlayerAI::AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup, int iRange)
+{
+	int iClosestTargetRange;
+	return AI_plotTargetMissionAIs(pPlot, &eMissionAI, 1, iClosestTargetRange, pSkipSelectionGroup, iRange);
+}
+
+int CvPlayerAI::AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup, int iRange)
+{
+	return AI_plotTargetMissionAIs(pPlot, &eMissionAI, 1, iClosestTargetRange, pSkipSelectionGroup, iRange);
+}
+
+int CvPlayerAI::AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes* aeMissionAI, int iMissionAICount, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup, int iRange)
+{
+	PROFILE_FUNC();
+
+	int iCount = 0;
+	iClosestTargetRange = MAX_INT;
+
+	CvSelectionGroup* pTransportSelectionGroup = NULL;
+	if (pSkipSelectionGroup != NULL)
+	{
+		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
+		if (pHeadUnit->getTransportUnit() != NULL)
+		{
+			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
+		}
+	}
+	int iLoop;
+	for(CvSelectionGroup* pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+	{
+		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
+		{
+			CvPlot* pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
+
+			if (pMissionPlot != NULL)
+			{
+				MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
+				int iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pMissionPlot->getX_INLINE(), pMissionPlot->getY_INLINE());
+
+				if (iDistance <= iRange)
+				{
+					for (int iMissionAIIndex = 0; iMissionAIIndex < iMissionAICount; iMissionAIIndex++)
+					{
+						if (eGroupMissionAI == aeMissionAI[iMissionAIIndex] || aeMissionAI[iMissionAIIndex] == NO_MISSIONAI)
+						{
+							iCount += pLoopSelectionGroup->getNumUnits();
+
+							if (iDistance < iClosestTargetRange)
+							{
+								iClosestTargetRange = iDistance;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+
+int CvPlayerAI::AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
+{
+	return AI_unitTargetMissionAIs(pUnit, &eMissionAI, 1, pSkipSelectionGroup);
+}
+
+int CvPlayerAI::AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup)
+{
+	PROFILE_FUNC();
+
+	CvSelectionGroup* pLoopSelectionGroup;
+	int iCount;
+	int iLoop;
+
+	CvSelectionGroup* pTransportSelectionGroup = NULL;
+	if (pSkipSelectionGroup != NULL)
+	{
+		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
+		if (pHeadUnit->getTransportUnit() != NULL)
+		{
+			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
+		}
+	}
+
+	iCount = 0;
+	for(pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+	{
+		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
+		{
+			if (pLoopSelectionGroup->AI_getMissionAIUnit() == pUnit)
+			{
+				MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
+				for (int iMissionAIIndex = 0; iMissionAIIndex < iMissionAICount; iMissionAIIndex++)
+				{
+					if (eGroupMissionAI == aeMissionAI[iMissionAIIndex] || NO_MISSIONAI == aeMissionAI[iMissionAIIndex])
+					{
+						iCount += pLoopSelectionGroup->getNumUnits();
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_enemyTargetMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
+{
+	return AI_enemyTargetMissionAIs(&eMissionAI, 1, pSkipSelectionGroup);
+}
+
+int CvPlayerAI::AI_enemyTargetMissionAIs(MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup)
+{
+	PROFILE_FUNC();
+
+	CvSelectionGroup* pTransportSelectionGroup = NULL;
+	if (pSkipSelectionGroup != NULL)
+	{
+		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
+		if (pHeadUnit->getTransportUnit() != NULL)
+		{
+			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
+		}
+	}
+
+	int iCount = 0;
+	int iLoop;
+	for(CvSelectionGroup* pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+	{
+		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
+		{
+			CvPlot* pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
+
+			if (NULL != pMissionPlot && pMissionPlot->isOwned())
+			{
+				MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
+				for (int iMissionAIIndex = 0; iMissionAIIndex < iMissionAICount; iMissionAIIndex++)
+				{
+						if (eGroupMissionAI == aeMissionAI[iMissionAIIndex] || NO_MISSIONAI == aeMissionAI[iMissionAIIndex])
+					{
+						if (GET_TEAM(getTeam()).AI_isChosenWar(pMissionPlot->getTeam()))
+						{
+							iCount += pLoopSelectionGroup->getNumUnits();
+							iCount += pLoopSelectionGroup->getCargo();
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_wakePlotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup)
+{
+	PROFILE_FUNC();
+
+	FAssert(pPlot != NULL);
+
+	CvSelectionGroup* pTransportSelectionGroup = NULL;
+	if (pSkipSelectionGroup != NULL)
+	{
+		CvUnit* pHeadUnit = pSkipSelectionGroup->getHeadUnit();
+		if (pHeadUnit->getTransportUnit() != NULL)
+		{
+			pTransportSelectionGroup = pHeadUnit->getTransportUnit()->getGroup();
+		}
+	}
+
+	int iCount = 0;
+
+	int iLoop;
+	for(CvSelectionGroup* pLoopSelectionGroup = firstSelectionGroup(&iLoop); pLoopSelectionGroup; pLoopSelectionGroup = nextSelectionGroup(&iLoop))
+	{
+		if ((pSkipSelectionGroup == NULL) || ((pLoopSelectionGroup != pSkipSelectionGroup) && (pLoopSelectionGroup != pTransportSelectionGroup)))
+		{
+			MissionAITypes eGroupMissionAI = pLoopSelectionGroup->AI_getMissionAIType();
+			if (eMissionAI == NO_MISSIONAI || eMissionAI == eGroupMissionAI)
+			{
+				CvPlot* pMissionPlot = pLoopSelectionGroup->AI_getMissionAIPlot();
+				if (pMissionPlot != NULL && pMissionPlot == pPlot)
+				{
+					iCount += pLoopSelectionGroup->getNumUnits();
+					pLoopSelectionGroup->setActivityType(ACTIVITY_AWAKE);
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+ ///TKs Med
+CivicTypes CvPlayerAI::AI_bestCivic(CivicOptionTypes eCivicOption)
+{
+	CivicTypes eBestCivic;
+	int iValue;
+	int iBestValue;
+	int iI;
+
+	iBestValue = MIN_INT;
+	eBestCivic = NO_CIVIC;
+
+	for (iI = 0; iI < GC.getNumCivicInfos(); iI++)
+	{
+		if (GC.getCivicInfo((CivicTypes)iI).getCivicOptionType() == eCivicOption)
+		{
+			if (canDoCivics((CivicTypes)iI))
+			{
+				iValue = AI_civicValue((CivicTypes)iI);
+
+				if (isCivic((CivicTypes)iI))
+				{
+					iValue *= 16;
+					iValue /= 15;
+				}
+
+				if (iValue > iBestValue)
+				{
+					iBestValue = iValue;
+					eBestCivic = ((CivicTypes)iI);
+				}
+			}
+		}
+	}
+
+	return eBestCivic;
+}
+///TKe
+
+int CvPlayerAI::AI_civicValue(CivicTypes eCivic)
+{
+	PROFILE_FUNC();
+
+	FAssertMsg(eCivic < GC.getNumCivicInfos(), "eCivic is expected to be within maximum bounds (invalid Index)");
+	FAssertMsg(eCivic >= 0, "eCivic is expected to be non-negative (invalid Index)");
+
+	CvCivicInfo& kCivic = GC.getCivicInfo(eCivic);
+
+	int iValue = (getNumCities() * 6);
+
+	iValue += (GC.getCivicInfo(eCivic).getAIWeight() * getNumCities());
+
+	iValue *= 10 + GC.getGameINLINE().getSorenRandNum(90, "AI choose revolution civics");
+
+	return iValue;
+}
+
+int CvPlayerAI::AI_getAttackOddsChange()
+{
+	return m_iAttackOddsChange;
+}
+
+
+void CvPlayerAI::AI_setAttackOddsChange(int iNewValue)
+{
+	m_iAttackOddsChange = iNewValue;
+}
+
+int CvPlayerAI::AI_getExtraGoldTarget() const
+{
+	return m_iExtraGoldTarget;
+}
+
+void CvPlayerAI::AI_setExtraGoldTarget(int iNewValue)
+{
+	m_iExtraGoldTarget = iNewValue;
+}
+
+void CvPlayerAI::AI_chooseCivic(CivicOptionTypes eCivicOption)
+{
+	int iBestValue = MIN_INT;
+	CivicTypes eBestCivic = NO_CIVIC;
+
+	for (int iCivic = 0; iCivic < GC.getNumCivicInfos(); ++iCivic)
+	{
+		if (GC.getCivicInfo((CivicTypes) iCivic).getCivicOptionType() == eCivicOption)
+		{
+			if (canDoCivics((CivicTypes) iCivic))
+			{
+				int iValue = AI_civicValue((CivicTypes) iCivic);
+				if (iValue > iBestValue)
+				{
+					iBestValue = iValue;
+					eBestCivic = (CivicTypes) iCivic;
+				}
+			}
+		}
+	}
+
+	if (eBestCivic != NO_CIVIC)
+	{
+		setCivic(eCivicOption, eBestCivic);
+	}
+}
+
+bool CvPlayerAI::AI_chooseGoody(GoodyTypes eGoody)
+{
+	return true;
+}
+
+CvCity* CvPlayerAI::AI_findBestCity() const
+{
+	CvCity* pBestCity = NULL;
+	int iBestValue = 0;
+
+	CvPlot* pTerritoryCenter = AI_getTerritoryCenter();
+
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		int iValue = 1000 * (1 + pLoopCity->getPopulation());
+		iValue *= 100 + 20 * (pLoopCity->plot()->getYield(YIELD_FOOD) - GC.getFOOD_CONSUMPTION_PER_POPULATION());
+		iValue /= std::max(1, pLoopCity->plot()->getDistanceToOcean());
+
+		iValue *= 1 + pLoopCity->area()->getCitiesPerPlayer(getID());
+		iValue /= 4 + stepDistance(pTerritoryCenter->getX_INLINE(), pTerritoryCenter->getY_INLINE(), pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE());
+
+		if (iValue > iBestValue)
+		{
+			pBestCity = pLoopCity;
+			iBestValue = iValue;
+		}
+	}
+
+	FAssert(pBestCity != NULL);
+	return pBestCity;
+}
+
+CvCity* CvPlayerAI::AI_findBestPort() const
+{
+	if (getParent() == NO_PLAYER)
+	{
+		return NULL;
+	}
+
+	CvCity* pBestCity = NULL;
+	int iBestValue = 0;
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity->plot()->getNearestEurope() != NO_EUROPE)
+		{
+			int iPortValue = 100000 / std::max(2, pLoopCity->plot()->getDistanceToOcean());
+			iPortValue /= 100 + pLoopCity->getGameTurnFounded();
+
+			if (iPortValue > iBestValue)
+			{
+				pBestCity = pLoopCity;
+				iBestValue = iPortValue;
+			}
+		}
+	}
+
+	return pBestCity;
+}
+
+
+int CvPlayerAI::AI_getNumTrainAIUnits(UnitAITypes eIndex)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_aiNumTrainAIUnits[eIndex];
+}
+
+
+void CvPlayerAI::AI_changeNumTrainAIUnits(UnitAITypes eIndex, int iChange)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
+	m_aiNumTrainAIUnits[eIndex] += iChange;
+	FAssert(AI_getNumTrainAIUnits(eIndex) >= 0);
+}
+
+
+int CvPlayerAI::AI_getNumAIUnits(UnitAITypes eIndex)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_aiNumAIUnits[eIndex];
+}
+
+
+void CvPlayerAI::AI_changeNumAIUnits(UnitAITypes eIndex, int iChange)
+{
+	if (eIndex != NO_UNITAI)
+	{
+		m_aiNumAIUnits[eIndex] += iChange;
+		FAssert(AI_getNumAIUnits(eIndex) >= 0);
+
+#ifdef _DEBUG
+		if (iChange > 0)
+		{
+			int iLoop;
+			int iNumUnitAI = 0;
+			for (CvUnit* pLoopUnit = firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = nextUnit(&iLoop))
+			{
+				if (pLoopUnit->AI_getUnitAIType() == eIndex)
+				{
+					++iNumUnitAI;
+				}
+			}
+			for (uint i = 0; i < m_aEuropeUnits.size(); ++i)
+			{
+				if (m_aEuropeUnits[i]->AI_getUnitAIType() == eIndex)
+				{
+					++iNumUnitAI;
+				}
+			}
+			for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+			{
+				for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+				{
+					CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
+					if (pLoopUnit->AI_getUnitAIType() == eIndex)
+					{
+						++iNumUnitAI;
+					}
+				}
+			}
+			FAssert(AI_getNumAIUnits(eIndex) == iNumUnitAI);
+		}
+#endif
+	}
+}
+
+int CvPlayerAI::AI_getNumRetiredAIUnits(UnitAITypes eIndex)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_aiNumRetiredAIUnits[eIndex];
+}
+
+
+void CvPlayerAI::AI_changeNumRetiredAIUnits(UnitAITypes eIndex, int iChange)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < NUM_UNITAI_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
+	m_aiNumRetiredAIUnits[eIndex] += iChange;
+	FAssert(AI_getNumRetiredAIUnits(eIndex) >= 0);
+}
+
+int CvPlayerAI::AI_getPeacetimeTradeValue(PlayerTypes eIndex)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_aiPeacetimeTradeValue[eIndex];
+}
+
+
+void CvPlayerAI::AI_changePeacetimeTradeValue(PlayerTypes eIndex, int iChange)
+{
+	PROFILE_FUNC();
+
+	int iI;
+
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+
+	if (iChange != 0)
+	{
+		m_aiPeacetimeTradeValue[eIndex] = (m_aiPeacetimeTradeValue[eIndex] + iChange);
+		FAssert(AI_getPeacetimeTradeValue(eIndex) >= 0);
+
+		FAssert(iChange > 0);
+
+		if (iChange > 0)
+		{
+			if (GET_PLAYER(eIndex).getTeam() != getTeam())
+			{
+				for (iI = 0; iI < MAX_TEAMS; iI++)
+				{
+					if (GET_TEAM((TeamTypes)iI).isAlive())
+					{
+						if (GET_TEAM((TeamTypes)iI).AI_getWorstEnemy() == getTeam())
+						{
+							GET_TEAM((TeamTypes)iI).AI_changeEnemyPeacetimeTradeValue(GET_PLAYER(eIndex).getTeam(), iChange);
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+
+int CvPlayerAI::AI_getPeacetimeGrantValue(PlayerTypes eIndex)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_aiPeacetimeGrantValue[eIndex];
+}
+
+
+void CvPlayerAI::AI_changePeacetimeGrantValue(PlayerTypes eIndex, int iChange)
+{
+	PROFILE_FUNC();
+
+	int iI;
+
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+
+	if (iChange != 0)
+	{
+		m_aiPeacetimeGrantValue[eIndex] = (m_aiPeacetimeGrantValue[eIndex] + iChange);
+		FAssert(AI_getPeacetimeGrantValue(eIndex) >= 0);
+
+		FAssert(iChange > 0);
+
+		if (iChange > 0)
+		{
+			if (GET_PLAYER(eIndex).getTeam() != getTeam())
+			{
+				for (iI = 0; iI < MAX_TEAMS; iI++)
+				{
+					if (GET_TEAM((TeamTypes)iI).isAlive())
+					{
+						if (GET_TEAM((TeamTypes)iI).AI_getWorstEnemy() == getTeam())
+						{
+							GET_TEAM((TeamTypes)iI).AI_changeEnemyPeacetimeGrantValue(GET_PLAYER(eIndex).getTeam(), iChange);
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+
+int CvPlayerAI::AI_getGoldTradedTo(PlayerTypes eIndex) const
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_aiGoldTradedTo[eIndex];
+}
+
+
+void CvPlayerAI::AI_changeGoldTradedTo(PlayerTypes eIndex, int iChange)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	m_aiGoldTradedTo[eIndex] = (m_aiGoldTradedTo[eIndex] + iChange);
+	FAssert(AI_getGoldTradedTo(eIndex) >= 0);
+}
+
+
+int CvPlayerAI::AI_getAttitudeExtra(PlayerTypes eIndex)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_aiAttitudeExtra[eIndex];
+}
+
+
+void CvPlayerAI::AI_setAttitudeExtra(PlayerTypes eIndex, int iNewValue)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	m_aiAttitudeExtra[eIndex] = iNewValue;
+}
+
+
+void CvPlayerAI::AI_changeAttitudeExtra(PlayerTypes eIndex, int iChange)
+{
+	AI_setAttitudeExtra(eIndex, (AI_getAttitudeExtra(eIndex) + iChange));
+}
+
+
+bool CvPlayerAI::AI_isFirstContact(PlayerTypes eIndex)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	return m_abFirstContact[eIndex];
+}
+
+
+void CvPlayerAI::AI_setFirstContact(PlayerTypes eIndex, bool bNewValue)
+{
+	FAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
+	m_abFirstContact[eIndex] = bNewValue;
+}
+
+
+int CvPlayerAI::AI_getContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2)
+{
+	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
+	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex2 < NUM_CONTACT_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
+	return m_aaiContactTimer[eIndex1][eIndex2];
+}
+
+
+void CvPlayerAI::AI_changeContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2, int iChange)
+{
+	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
+	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex2 < NUM_CONTACT_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
+	m_aaiContactTimer[eIndex1][eIndex2] = (AI_getContactTimer(eIndex1, eIndex2) + iChange);
+	FAssert(AI_getContactTimer(eIndex1, eIndex2) >= 0);
+}
+
+
+int CvPlayerAI::AI_getMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2)
+{
+	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
+	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex2 < NUM_MEMORY_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
+	return m_aaiMemoryCount[eIndex1][eIndex2];
+}
+
+
+void CvPlayerAI::AI_changeMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2, int iChange)
+{
+	FAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be within maximum bounds (invalid Index)");
+	FAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
+	FAssertMsg(eIndex2 < NUM_MEMORY_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
+	m_aaiMemoryCount[eIndex1][eIndex2] += iChange;
+	FAssert(AI_getMemoryCount(eIndex1, eIndex2) >= 0);
+}
+
+// Protected Functions...
+
+void CvPlayerAI::AI_doTradeRoutes()
+{
+	//Yields are divided into several classes:
+	//1) Final Products - Port cities import these and export to europe. Other cities, export them.
+	//2) Utility such as Lumber, Tools - These are set Import/Export with the Maintain Level used to indicate how much are needed.
+	//3) Raw Materials - Cities which consume these to produce final products, Import/Export, with a high maintain level.
+	//	 Port cities Import/Export with no maintain level.
+
+	//Generally, utility yields are set to Import/Export
+
+	//Best Yield Destinations
+	std::vector<CvCity*> yield_dests(NUM_YIELD_TYPES, NULL);
+
+	for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+	{
+		YieldTypes eLoopYield = (YieldTypes)iYield;
+///TKs Med
+		if (GC.getYieldInfo(eLoopYield).isCargo() && eLoopYield != YIELD_FOOD && !YieldGroup_Luxury_Food(eLoopYield))
+		{
+			if (AI_isYieldFinalProduct(eLoopYield))
+			{
+				yield_dests[eLoopYield] = NULL;
+			}
+			else if ((eLoopYield == YIELD_TOOLS) || (eLoopYield == YIELD_LUMBER))
+			{
+				yield_dests[eLoopYield] = NULL;
+			}
+
+			else if (GC.isEquipmentType(eLoopYield, EQUIPMENT_ANY))
+			{
+				yield_dests[eLoopYield] = NULL;
+			}
+			///TKe
+			else
+			{
+				CvCity* pBestYieldCity = NULL;
+				int iBestCityValue = 0;
+
+				int iLoop;
+				CvCity* pLoopCity;
+				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+				{
+					for (int iProfession = 0; iProfession < GC.getNumProfessionInfos(); ++iProfession)
+					{
+						CvProfessionInfo& kLoopProfession = GC.getProfessionInfo((ProfessionTypes)iProfession);
+						if (kLoopProfession.getYieldsConsumed(0, getID()) == eLoopYield || kLoopProfession.getYieldsConsumed(1, getID()) == eLoopYield)
+						{
+							int iValue = pLoopCity->getProfessionOutput((ProfessionTypes)iProfession, NULL);
+							if (iValue > 0)
+							{
+								iValue *= 100;
+								iValue += pLoopCity->getPopulation();
+								if (iValue > iBestCityValue)
+								{
+									iBestCityValue = iValue;
+									pBestYieldCity = pLoopCity;
+								}
+							}
+						}
+					}
+				}
+				yield_dests[eLoopYield] = pBestYieldCity;
+				///Tks Med
+				FAssert(pBestYieldCity != NULL);
+				if (GC.getGameINLINE().getGameTurn() > 50 && pBestYieldCity != NULL)
+				{
+					pBestYieldCity->setMaintainLevel(eLoopYield, pBestYieldCity->getMaxYieldCapacity(eLoopYield) / 2);
+				}
+				///Tke
+			}
+		}
+	}
+
+	CvCity* pLoopCity;
+	int iLoop;
+	//Setup export trade routes.
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		int aiYields[NUM_YIELD_TYPES];
+		pLoopCity->calculateNetYields(aiYields);
+        ///TKs Med
+		//int iCapacity = pLoopCity->getMaxYieldCapacity();
+		for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+		{
+		    YieldTypes eLoopYield = (YieldTypes)iYield;
+		    int iCapacity = pLoopCity->getMaxYieldCapacity(eLoopYield);
+			bool bAvailable = (aiYields[eLoopYield] > 0) || (pLoopCity->getYieldStored(eLoopYield) > 0);
+			bool bShouldImport = false;
+			bool bShouldExport = false;
+			if (GC.getYieldInfo(eLoopYield).isCargo())
+			{
+				if (eLoopYield == YIELD_FOOD)
+				{
+					int iThreshold = pLoopCity->growthThreshold() / (2 + std::max(0, aiYields[eLoopYield]));
+                    pLoopCity->setMaintainLevel(eLoopYield, iThreshold);
+                    if (aiYields[eLoopYield] > 0)
+                    {
+                        bShouldExport = true;
+                        pLoopCity->AI_setAvoidGrowth(false);
+                    }
+                    else
+                    {
+                        bShouldImport = true;
+                        pLoopCity->AI_setAvoidGrowth(true);
+                    }
+				}
+#ifdef USE_NOBLE_CLASS
+				else if (eLoopYield == YIELD_GRAIN)
+				{
+					int iThreshold = pLoopCity->growthThreshold();
+                    if (pLoopCity->canProduceYield(YIELD_GRAIN))
+                    {
+                        pLoopCity->setMaintainLevel(eLoopYield, iThreshold);
+                        bShouldExport = false;
+                        bShouldImport = true;
+                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, true);
+                    }
+                    else
+                    {
+                        bShouldImport = false;
+                        bShouldExport = true;
+                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, false);
+                    }
+				}
+				else if (eLoopYield == YIELD_SPICES || eLoopYield == YIELD_CATTLE)
+				{
+					int iThreshold = pLoopCity->growthThreshold() * 50 / 100;
+                    if (pLoopCity->canProduceYield(YIELD_GRAIN))
+                    {
+                        pLoopCity->setMaintainLevel(eLoopYield, iThreshold);
+                        bShouldExport = false;
+                        bShouldImport = true;
+                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, true);
+                    }
+                    else
+                    {
+                        bShouldImport = false;
+                        bShouldExport = true;
+                        //pLoopCity->AI_setEmphasize(YIELD_GRAIN, false);
+                    }
+				}
+#endif
+				else
+				{
+					if ((AI_isYieldFinalProduct(eLoopYield)) || AI_isYieldForSale(eLoopYield))
+					{
+						if (pLoopCity->AI_isPort())
+						{
+							bShouldImport = true;
+						}
+						else if (bAvailable)
+						{
+							bShouldExport = true;
+						}
+					}
+
+					if (pLoopCity->AI_isPort())
+					{
+					    ///TKs
+						if ((eLoopYield == YIELD_TOOLS) || GC.isEquipmentType(eLoopYield, EQUIPMENT_ANY))
+						{
+							bShouldExport = true;
+						}
+						///Tke
+					}
+
+					if (yield_dests[eLoopYield] == pLoopCity)
+					{
+						bShouldImport = true;
+					}
+					else if (yield_dests[eLoopYield] != NULL)
+					{
+						if (bAvailable)
+						{
+							bShouldExport = true;
+						}
+					}
+					else
+					{
+						int iMaintainLevel = pLoopCity->getMaintainLevel(eLoopYield);
+						int iStored = pLoopCity->getYieldStored(eLoopYield);
+
+						if (iStored > iMaintainLevel)
+						{
+							if ((aiYields[eLoopYield] > 0) || (iStored > (iCapacity * 90) / 100) || pLoopCity->AI_isPort())
+							{
+								bShouldExport = true;
+							}
+						}
+						else if (iMaintainLevel > 0 && iStored < iMaintainLevel)
+						{
+							bShouldImport = true;
+						}
+					}
+				}
+				if (bShouldImport)
+				{
+					pLoopCity->addImport(eLoopYield);
+				}
+				else
+				{
+					pLoopCity->removeImport(eLoopYield);
+				}
+				if (bShouldExport)
+				{
+					pLoopCity->addExport(eLoopYield);
+				}
+				else
+				{
+					pLoopCity->removeExport(eLoopYield);
+				}
+			}
+		}
+	}
+}
+
+void CvPlayerAI::AI_doCounter()
+{
+	int iI, iJ;
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			for (iJ = 0; iJ < NUM_CONTACT_TYPES; iJ++)
+			{
+				if (AI_getContactTimer(((PlayerTypes)iI), ((ContactTypes)iJ)) > 0)
+				{
+					AI_changeContactTimer(((PlayerTypes)iI), ((ContactTypes)iJ), -1);
+				}
+			}
+		}
+	}
+
+	for (iI = 0; iI < MAX_PLAYERS; iI++)
+	{
+		if (GET_PLAYER((PlayerTypes)iI).isAlive())
+		{
+			for (iJ = 0; iJ < NUM_MEMORY_TYPES; iJ++)
+			{
+				if (AI_getMemoryCount(((PlayerTypes)iI), ((MemoryTypes)iJ)) > 0)
+				{
+				    ///Tks Med
+				    if ((MemoryTypes)iJ == MEMORY_MADE_VASSAL_DEMAND)
+				    {
+				        AI_changeMemoryCount(((PlayerTypes)iI), ((MemoryTypes)iJ), -1);
+				        continue;
+				    }
+                    ///Tke
+					if (GC.getLeaderHeadInfo(getPersonalityType()).getMemoryDecayRand(iJ) > 0)
+					{
+						if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getMemoryDecayRand(iJ), "Memory Decay") == 0)
+						{
+							AI_changeMemoryCount(((PlayerTypes)iI), ((MemoryTypes)iJ), -1);
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+
+void CvPlayerAI::AI_doMilitary()
+{
+
+
+	AI_setAttackOddsChange(GC.getLeaderHeadInfo(getPersonalityType()).getBaseAttackOddsChange() +
+		GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getAttackOddsChangeRand(), "AI Attack Odds Change #1") +
+		GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getAttackOddsChangeRand(), "AI Attack Odds Change #2"));
+}
+
+void CvPlayerAI::AI_doDiplo()
+{
+	PROFILE_FUNC();
+
+	FAssert(!isHuman());
+
+	// allow python to handle it
+	CyArgsList argsList;
+	argsList.add(getID());
+	long lResult=0;
+	gDLL->getPythonIFace()->callFunction(PYGameModule, "AI_doDiplo", argsList.makeFunctionArgs(), &lResult);
+	if (lResult == 1)
+	{
+		return;
+	}
+
+	std::vector<bool> abContacted(MAX_TEAMS, false);
+
+	for (int iPass = 0; iPass < 2; iPass++)
+	{
+		for (int iI = 0; iI < MAX_PLAYERS; iI++)
+		{
+			PlayerTypes ePlayer = (PlayerTypes) iI;
+			CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+			if (kPlayer.isAlive() && ePlayer != getID())
+			{
+				if (kPlayer.isHuman() == (iPass == 1))
+				{
+					if (AI_doDiploCancelDeals((PlayerTypes) iI))
+					{
+						if (kPlayer.isHuman())
+						{
+							abContacted[kPlayer.getTeam()] = true;
+						}
+					}
+
+					if (canContact(ePlayer) && AI_isWillingToTalk(ePlayer))
+					{
+						if (kPlayer.getTeam() != getTeam() && !(GET_TEAM(getTeam()).isHuman()) && (kPlayer.isHuman() || !(GET_TEAM(kPlayer.getTeam()).isHuman())))
+						{
+							FAssertMsg(iI != getID(), "iI is not expected to be equal with getID()");
+
+							if (!(GET_TEAM(getTeam()).isAtWar(kPlayer.getTeam())))
+							{
+							    ///TKs Med
+							    bool bOfferedVassal = false;
+							    if (AI_doDiploOfferVassalCity(ePlayer))
+								{
+								    bOfferedVassal = true;
+									if (kPlayer.isHuman())
+									{
+										abContacted[kPlayer.getTeam()] = true;
+									}
+								}
+                                if (!bOfferedVassal)
+                                {
+                                    if (AI_doDiploOfferCity(ePlayer))
+                                    {
+                                        if (kPlayer.isHuman())
+                                        {
+                                            abContacted[kPlayer.getTeam()] = true;
+                                        }
+                                    }
+                                }
+                                ///TKe
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploOfferAlliance(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+										else
+										{
+											// move on to the next player since we are on the same team now
+											break;
+										}
+									}
+								}
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploAskJoinWar(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploAskStopTrading(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploGiveHelp(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploAskForHelp(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploDemandTribute(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+                                ///TKs Med Dip
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploKissPinky(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+                                ///Tke
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploOpenBorders(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+
+                                ///TKs Invention Core Mod v 1.0
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploTradeResearch(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+								///Tke
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploDefensivePact(ePlayer))
+									{
+										if (kPlayer.isHuman())
+                                        {
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploTradeMap(ePlayer))
+									{
+										if (kPlayer.isHuman())
+										{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+
+								if (!kPlayer.isHuman() || !abContacted[kPlayer.getTeam()])
+								{
+									if (AI_doDiploDeclareWar(ePlayer))
+									{
+										if (kPlayer.isHuman())
+									{
+											abContacted[kPlayer.getTeam()] = true;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+
+bool CvPlayerAI::AI_doDiploCancelDeals(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (kPlayer.getTeam() == getTeam())
+	{
+		return false;
+	}
+
+	bool bKilled = false;
+
+	int iLoop;
+	for (CvDeal* pLoopDeal = GC.getGameINLINE().firstDeal(&iLoop); pLoopDeal != NULL; pLoopDeal = GC.getGameINLINE().nextDeal(&iLoop))
+	{
+		if (pLoopDeal->isCancelable(getID()))
+		{
+			if ((GC.getGameINLINE().getGameTurn() - pLoopDeal->getInitialGameTurn()) >= (GC.getCache_PEACE_TREATY_LENGTH() * 2))
+			{
+				bool bCancelDeal = false;
+
+				if ((pLoopDeal->getFirstPlayer() == getID()) && (pLoopDeal->getSecondPlayer() == ePlayer))
+				{
+					if (kPlayer.isHuman())
+					{
+						if (!AI_considerOffer(ePlayer, pLoopDeal->getSecondTrades(), pLoopDeal->getFirstTrades(), -1))
+						{
+							bCancelDeal = true;
+						}
+					}
+					else
+					{
+						for (CLLNode<TradeData>* pNode = pLoopDeal->getFirstTrades()->head(); pNode; pNode = pLoopDeal->getFirstTrades()->next(pNode))
+						{
+							if (getTradeDenial(ePlayer, pNode->m_data) != NO_DENIAL)
+							{
+								bCancelDeal = true;
+								break;
+							}
+						}
+					}
+				}
+				else if ((pLoopDeal->getFirstPlayer() == ePlayer) && (pLoopDeal->getSecondPlayer() == getID()))
+				{
+					if (kPlayer.isHuman())
+					{
+						if (!AI_considerOffer(ePlayer, pLoopDeal->getFirstTrades(), pLoopDeal->getSecondTrades(), -1))
+						{
+							bCancelDeal = true;
+						}
+					}
+					else
+					{
+						for (CLLNode<TradeData>* pNode = pLoopDeal->getSecondTrades()->head(); pNode; pNode = pLoopDeal->getSecondTrades()->next(pNode))
+						{
+							if (getTradeDenial(ePlayer, pNode->m_data) != NO_DENIAL)
+							{
+								bCancelDeal = true;
+								break;
+							}
+						}
+					}
+				}
+
+				if (bCancelDeal)
+				{
+					if (canContact(ePlayer) && AI_isWillingToTalk(ePlayer))
+					{
+						if (kPlayer.isHuman())
+						{
+							CLinkList<TradeData> ourList;
+							CLinkList<TradeData> theirList;
+
+							for (CLLNode<TradeData>* pNode = pLoopDeal->headFirstTradesNode(); (pNode != NULL); pNode = pLoopDeal->nextFirstTradesNode(pNode))
+							{
+								if (pLoopDeal->getFirstPlayer() == getID())
+								{
+									ourList.insertAtEnd(pNode->m_data);
+								}
+								else
+								{
+									theirList.insertAtEnd(pNode->m_data);
+								}
+							}
+
+							for (pNode = pLoopDeal->headSecondTradesNode(); (pNode != NULL); pNode = pLoopDeal->nextSecondTradesNode(pNode))
+							{
+								if (pLoopDeal->getSecondPlayer() == getID())
+								{
+									ourList.insertAtEnd(pNode->m_data);
+								}
+								else
+								{
+									theirList.insertAtEnd(pNode->m_data);
+								}
+							}
+
+							CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+							pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_CANCEL_DEAL"));
+							pDiplo->setAIContact(true);
+							pDiplo->setOurOfferList(theirList);
+							pDiplo->setTheirOfferList(ourList);
+							gDLL->beginDiplomacy(pDiplo, ePlayer);
+						}
+					}
+
+					pLoopDeal->kill(true, getTeam()); // XXX test this for AI...
+					bKilled = true;
+				}
+			}
+		}
+	}
+
+	return bKilled;
+}
+
+
+
+bool CvPlayerAI::AI_doDiploOfferCity(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (AI_getAttitude(ePlayer) < ATTITUDE_CAUTIOUS)
+	{
+		return false;
+	}
+	///Tks Med
+	if (GET_PLAYER(getID()).getVassalOwner() != NO_PLAYER)
+	{
+	    return false;
+	}
+	///Tke
+	bool bOffered = false;
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity->getPreviousOwner() != ePlayer)
+		{
+			if (((pLoopCity->getGameTurnAcquired() + 4) % 20) == (GC.getGameINLINE().getGameTurn() % 20))
+			{
+				int iCount = 0;
+				int iPossibleCount = 0;
+
+				for (int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)
+				{
+					CvPlot* pLoopPlot = plotCity(pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE(), iJ);
+
+					if (pLoopPlot != NULL)
+					{
+						if (pLoopPlot->getOwnerINLINE() == ePlayer)
+						{
+							++iCount;
+						}
+
+						++iPossibleCount;
+					}
+				}
+
+				if (iCount >= (iPossibleCount / 2))
+				{
+					TradeData item;
+					setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
+
+					if (canTradeItem((ePlayer), item, true))
+					{
+						CLinkList<TradeData> ourList;
+						ourList.insertAtEnd(item);
+
+						if (kPlayer.isHuman())
+						{
+							CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+							pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_CITY"));
+							pDiplo->setAIContact(true);
+							pDiplo->setTheirOfferList(ourList);
+							gDLL->beginDiplomacy(pDiplo, ePlayer);
+						}
+						else
+						{
+							GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, NULL);
+						}
+						bOffered = true;
+					}
+				}
+			}
+		}
+	}
+
+	return bOffered;
+}
+
+
+bool CvPlayerAI::AI_doDiploOfferAlliance(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (kPlayer.getParent() == getID())
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer((ePlayer), CONTACT_PERMANENT_ALLIANCE) > 0)
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_PERMANENT_ALLIANCE), "AI Diplo Alliance") != 0)
+	{
+		return false;
+	}
+
+	bool bOffered = false;
+	TradeData item;
+	setTradeItem(&item, TRADE_PERMANENT_ALLIANCE, 0, NULL);
+
+	if (canTradeItem((ePlayer), item, true) && kPlayer.canTradeItem(getID(), item, true))
+	{
+		CLinkList<TradeData> ourList;
+		CLinkList<TradeData> theirList;
+		ourList.insertAtEnd(item);
+		theirList.insertAtEnd(item);
+
+		bOffered = true;
+
+		if (kPlayer.isHuman())
+		{
+			AI_changeContactTimer(ePlayer, CONTACT_PERMANENT_ALLIANCE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_PERMANENT_ALLIANCE));
+			CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+			FAssertMsg(pDiplo != NULL, "pDiplo must be valid");
+			pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
+			pDiplo->setAIContact(true);
+			pDiplo->setOurOfferList(theirList);
+			pDiplo->setTheirOfferList(ourList);
+			gDLL->beginDiplomacy(pDiplo, ePlayer);
+		}
+		else
+		{
+			GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
+		}
+	}
+
+	return bOffered;
+}
+
+
+bool CvPlayerAI::AI_doDiploAskJoinWar(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (!kPlayer.isHuman())
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if ((AI_getMemoryCount(ePlayer, MEMORY_DECLARED_WAR) > 0) || (AI_getMemoryCount(ePlayer, MEMORY_HIRED_WAR_ALLY) > 0))
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer(ePlayer, CONTACT_JOIN_WAR) > 0)
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_JOIN_WAR), "AI Diplo Join War") != 0)
+	{
+		return false;
+	}
+
+	int iBestValue = 0;
+	TeamTypes eBestTeam = NO_TEAM;
+	for (int iJ = 0; iJ < MAX_TEAMS; ++iJ)
+	{
+		TeamTypes eLoopTeam = (TeamTypes) iJ;
+		CvTeam& kLoopTeam = GET_TEAM(eLoopTeam);
+		if (kLoopTeam.isAlive())
+		{
+			if (atWar(eLoopTeam, getTeam()) && !atWar(eLoopTeam, kPlayer.getTeam()))
+			{
+				if (GET_TEAM(kPlayer.getTeam()).isHasMet(eLoopTeam))
+				{
+					if (GET_TEAM(kPlayer.getTeam()).canDeclareWar(eLoopTeam))
+					{
+						int iValue = (1 + GC.getGameINLINE().getSorenRandNum(10000, "AI Joining War"));
+
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							eBestTeam = eLoopTeam;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (eBestTeam == NO_TEAM)
+	{
+		return false;
+	}
+
+	AI_changeContactTimer(ePlayer, CONTACT_JOIN_WAR, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_JOIN_WAR));
+	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_JOIN_WAR"));
+	pDiplo->addDiploCommentVariable(GET_PLAYER(GET_TEAM(eBestTeam).getLeaderID()).getCivilizationAdjectiveKey());
+	pDiplo->setAIContact(true);
+	pDiplo->setData(eBestTeam);
+	gDLL->beginDiplomacy(pDiplo, ePlayer);
+
+	return true;
+}
+
+bool CvPlayerAI::AI_doDiploAskStopTrading(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (!kPlayer.isHuman())
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer((ePlayer), CONTACT_STOP_TRADING) > 0)
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_STOP_TRADING), "AI Diplo Stop Trading") != 0)
+	{
+		return false;
+	}
+
+	TeamTypes eBestTeam = GET_TEAM(getTeam()).AI_getWorstEnemy();
+	if (eBestTeam == NO_TEAM)
+	{
+		return false;
+	}
+
+	if (!GET_TEAM(kPlayer.getTeam()).isHasMet(eBestTeam))
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).isParentOf(eBestTeam) && !::atWar(getTeam(), eBestTeam))
+	{
+		return false;
+	}
+
+	if (!kPlayer.canStopTradingWithTeam(eBestTeam))
+	{
+		return false;
+	}
+
+	FAssert(!atWar(kPlayer.getTeam(), eBestTeam));
+	FAssert(kPlayer.getTeam() != eBestTeam);
+
+	AI_changeContactTimer(ePlayer, CONTACT_STOP_TRADING, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_STOP_TRADING));
+	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_STOP_TRADING"));
+	pDiplo->addDiploCommentVariable(GET_PLAYER(GET_TEAM(eBestTeam).getLeaderID()).getCivilizationAdjectiveKey());
+	pDiplo->setAIContact(true);
+	pDiplo->setData(eBestTeam);
+	gDLL->beginDiplomacy(pDiplo, ePlayer);
+
+	return true;
+}
+
+bool CvPlayerAI::AI_doDiploGiveHelp(PlayerTypes ePlayer)
+									{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (!kPlayer.isHuman())
+	{
+		return false;
+	}
+
+	if (isNative())
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (AI_getAttitude(ePlayer) <= GC.getLeaderHeadInfo(kPlayer.getPersonalityType()).getNoGiveHelpAttitudeThreshold())
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer((ePlayer), CONTACT_GIVE_HELP) > 0)
+	{
+		return false;
+	}
+
+	if (GET_TEAM(kPlayer.getTeam()).getAssets() > GET_TEAM(getTeam()).getAssets() / 2)
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_GIVE_HELP), "AI Diplo Give Help") != 0)
+	{
+		return false;
+	}
+
+	int iGold = AI_maxGoldTrade(ePlayer);
+	if (iGold <= 0)
+	{
+		return false;
+	}
+
+	TradeData item;
+	setTradeItem(&item, TRADE_GOLD, iGold, NULL);
+	if (!canTradeItem(ePlayer, item, true))
+	{
+		return false;
+	}
+
+	CLinkList<TradeData> ourList;
+	ourList.insertAtEnd(item);
+
+	AI_changeContactTimer((ePlayer), CONTACT_GIVE_HELP, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_GIVE_HELP));
+	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_GIVE_HELP"));
+	pDiplo->setTheirOfferList(ourList);
+	pDiplo->setAIContact(true);
+	gDLL->beginDiplomacy(pDiplo, ePlayer);
+
+	return true;
+}
+
+
+bool CvPlayerAI::AI_doDiploAskForHelp(PlayerTypes ePlayer)
+									{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (!kPlayer.isHuman())
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer((ePlayer), CONTACT_ASK_FOR_HELP) > 0)
+	{
+		return false;
+	}
+
+	if (GET_TEAM(kPlayer.getTeam()).getAssets() <= GET_TEAM(getTeam()).getAssets() / 2)
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_ASK_FOR_HELP), "AI Diplo Ask for Help") != 0)
+	{
+		return false;
+	}
+
+	int iGold = kPlayer.AI_maxGoldTrade(getID()) * GC.getGameINLINE().getSorenRandNum(100, "Ask for gold percent") / 100;
+	if (iGold <= 0)
+	{
+		return false;
+	}
+
+	TradeData item;
+	setTradeItem(&item, TRADE_GOLD, iGold, NULL);
+	if (!canTradeItem(ePlayer, item, true))
+	{
+		return false;
+	}
+
+	CLinkList<TradeData> theirList;
+	theirList.insertAtEnd(item);
+
+	AI_changeContactTimer((ePlayer), CONTACT_GIVE_HELP, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_GIVE_HELP));
+	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_ASK_FOR_HELP"));
+	pDiplo->setOurOfferList(theirList);
+	pDiplo->setAIContact(true);
+	gDLL->beginDiplomacy(pDiplo, ePlayer);
+
+	return true;
+}
+
+
+bool CvPlayerAI::AI_doDiploDemandTribute(PlayerTypes ePlayer)
+{
+	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
+
+	if (!kPlayer.isHuman())
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (!GET_TEAM(getTeam()).canDeclareWar(kPlayer.getTeam()))
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).AI_isSneakAttackPreparing(kPlayer.getTeam()))
+	{
+		return false;
+	}
+
+	if (GET_TEAM(kPlayer.getTeam()).getDefensivePower() >= GET_TEAM(getTeam()).getPower())
+	{
+		return false;
+	}
+
+	if (AI_getAttitude(ePlayer) > GC.getLeaderHeadInfo(kPlayer.getPersonalityType()).getDemandTributeAttitudeThreshold())
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE) > 0)
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEMAND_TRIBUTE), "AI Diplo Demand Tribute") != 0)
+	{
+		return false;
+	}
+
+	TradeData item;
+	int iReceiveGold = std::min(std::max(0, (kPlayer.getGold() - 50)), kPlayer.AI_goldTarget());
+	iReceiveGold -= (iReceiveGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+	if (iReceiveGold > 50)
+	{
+		setTradeItem(&item, TRADE_GOLD, iReceiveGold, NULL);
+	}
+	else if (GET_TEAM(getTeam()).AI_mapTradeVal(kPlayer.getTeam()) > 100)
+	{
+		setTradeItem(&item, TRADE_MAPS, 0, NULL);
+	}
+
+	if (!canTradeItem(ePlayer, item, true))
+	{
+		return false;
+	}
+
+	CLinkList<TradeData> theirList;
+	theirList.insertAtEnd(item);
+
+	AI_changeContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEMAND_TRIBUTE));
+	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_DEMAND_TRIBUTE"));
+	pDiplo->setAIContact(true);
+	pDiplo->setOurOfferList(theirList);
+	gDLL->beginDiplomacy(pDiplo, ePlayer);
+
+	return true;
+}
+
+bool CvPlayerAI::AI_doDiploKissPinky(PlayerTypes ePlayer)
+{
+	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
+
+	if (!kPlayer.isHuman())
+	{
+		return false;
+	}
+
+	if (GC.getEraInfo(kPlayer.getCurrentEra()).isRevolution())
+	{
+		return false;
+	}
+
+	if (kPlayer.getNumCities() == 0)
+	{
+		return false;
+	}
+
+	if (kPlayer.getParent() != getID())
+	{
+		return false;
+	}
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+///Tks Med
+	bool bTesting = gDLL->ctrlKey() && gDLL->getChtLvl() > 0;
+	//bool bTesting = false;
+	if (AI_getContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE) > 0)
+	{
+		return false;
+	}
+	if (!kPlayer.isFeatAccomplished(FEAT_CITY_NO_FOOD))
+	{
+	    return false;
+	}
+
+
+	//if (AI_getMemoryCount(ePlayer, MEMORY_REFUSED_TAX)) ATTITUDE_ANNOYED
+	if (kPlayer.isHuman() && GC.getLeaderHeadInfo(kPlayer.getLeaderType()).getVictoryType() == 1)
+    {
+
+        if (AI_getAttitude(ePlayer, false) <= ATTITUDE_ANNOYED)
+        {
+            if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEMAND_TRIBUTE), "AI Diplo Upset At You") <= 2 || bTesting)
+            {
+                int iMaxGoldPercent = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIDeclareWarProb() * kPlayer.AI_maxGoldTrade(getID()) / 100;
+                int iReceiveGold = iMaxGoldPercent * GC.getGameINLINE().getSorenRandNum(100, "Ask for tithe gold percent") / 100;
+
+                iReceiveGold -= (iReceiveGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+                //iReceiveGold += iMaxGoldPercent * 50 / 100;
+                if (iReceiveGold <= 0)
+                {
+                    return false;
+                }
+                AI_changeContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEMAND_TRIBUTE));
+                CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+                pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_KING_ASK_FOR_GOLD_OR_ELSE"));
+                pDiplo->addDiploCommentVariable(iReceiveGold);
+                pDiplo->setData(iReceiveGold);
+                pDiplo->setAIContact(true);
+                gDLL->beginDiplomacy(pDiplo, ePlayer);
+
+                return true;
+            }
+        }
+        else if (bTesting)
+        {
+            AI_changeMemoryCount(ePlayer, MEMORY_REFUSED_TAX, 1);
+        }
+    }
+    ///tke
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEMAND_TRIBUTE), "AI Diplo Kiss Pinky") != 0)
+	{
+		return false;
+	}
+
+	int iMaxGoldPercent = GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAIDeclareWarProb() * kPlayer.AI_maxGoldTrade(getID()) / 100;
+	int iReceiveGold = iMaxGoldPercent * GC.getGameINLINE().getSorenRandNum(100, "Ask for pinky gold percent") / 100;
+	iReceiveGold -= (iReceiveGold % GC.getCache_DIPLOMACY_VALUE_REMAINDER());
+	if (iReceiveGold <= 0)
+	{
+		return false;
+	}
+
+	AI_changeContactTimer((ePlayer), CONTACT_DEMAND_TRIBUTE, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEMAND_TRIBUTE));
+
+	CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+	pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_KING_ASK_FOR_GOLD"));
+	pDiplo->addDiploCommentVariable(iReceiveGold);
+	pDiplo->setData(iReceiveGold);
+	pDiplo->setAIContact(true);
+	gDLL->beginDiplomacy(pDiplo, ePlayer);
+
+	return true;
+}
+
+bool CvPlayerAI::AI_doDiploOpenBorders(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (getNumCities() == 0)
+	{
+		return false;
+	}
+
+	if (kPlayer.getNumCities() == 0)
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer(ePlayer, CONTACT_OPEN_BORDERS) > 0)
+											{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_OPEN_BORDERS), "AI Diplo Open Borders") != 0)
+	{
+		return false;
+	}
+
+	TradeData item;
+	setTradeItem(&item, TRADE_OPEN_BORDERS, 0, NULL);
+
+	if (!canTradeItem(ePlayer, item, true) || !kPlayer.canTradeItem(getID(), item, true))
+	{
+		return false;
+	}
+
+	CLinkList<TradeData> theirList;
+	theirList.insertAtEnd(item);
+	CLinkList<TradeData> ourList;
+	ourList.insertAtEnd(item);
+
+	if (kPlayer.isHuman())
+	{
+		AI_changeContactTimer(ePlayer, CONTACT_OPEN_BORDERS, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_OPEN_BORDERS));
+		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
+		pDiplo->setAIContact(true);
+		pDiplo->setOurOfferList(theirList);
+		pDiplo->setTheirOfferList(ourList);
+		gDLL->beginDiplomacy(pDiplo, ePlayer);
+	}
+	else
+	{
+		GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
+	}
+
+	return true;
+}
+
+///TKs Med
+//int CvPlayerAI::AI_getInsultedAttitude(PlayerTypes ePlayer)
+//{
+//	return m_aiInsultedAttitudeCache[ePlayer];
+//}
+//void CvPlayerAI::AI_changeInsultedAttitude(PlayerTypes ePlayer, int Change)
+//{
+//    m_aiInsultedAttitudeCache[ePlayer] += Change;
+//}
+///TKs Invention Core Mod v 1.0
+bool CvPlayerAI::AI_doDiploCollaborateResearch(PlayerTypes ePlayer)
+{
+    return false;
+}
+bool CvPlayerAI::AI_doDiploTradeResearch(PlayerTypes ePlayer)
+{
+    CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+    if (kPlayer.getParent() == getID())
+	{
+		return false;
+	}
+
+	if (isEurope())
+	{
+		return false;
+	}
+
+//	if (isNative())
+//	{
+//	    return false;
+//	}
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (getNumCities() == 0)
+	{
+		return false;
+	}
+
+	if (kPlayer.getNumCities() == 0)
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer(ePlayer, CONTACT_TRADE_IDEAS) > 0)
+    {
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_TRADE_IDEAS), "AI Diplo Tech Trade") != 0)
+	{
+		return false;
+	}
+
+
+
+    if (isNative())
+    {
+        if (kPlayer.isNative())
+        {
+            return false;
+        }
+    }
+    //char szOut[1024];
+//    if (kPlayer.isHuman())
+//    {
+//
+//        sprintf(szOut, "######################## Player %d %S check 1 for trade\n", getID(), getNameKey());
+//        gDLL->messageControlLog(szOut);
+//    }
+
+    int iCivic = getIdea(false, ePlayer);
+	if (iCivic == -1)
+	{
+//	    sprintf(szOut, "######################## No Idea FOund\n");
+//        gDLL->messageControlLog(szOut);
+	    return false;
+	}
+
+	TradeData myitem;
+	setTradeItem(&myitem, TRADE_IDEAS, iCivic, NULL);
+	if (!canTradeItem(ePlayer, myitem, true))
+	{
+	    if (kPlayer.isHuman())
+        {
+//            sprintf(szOut, "######################## Player %d Can not Trade\n", ePlayer);
+//            gDLL->messageControlLog(szOut);
+            return false;
+        }
+	}
+
+	TradeData thereitem;
+
+    if (isNative())
+    {
+        int iGold = GC.getCache_TK_RESEARCH_TRADE_VALUE() + GC.getCivicInfo((CivicTypes)iCivic).getAIWeight();
+        setTradeItem(&thereitem, TRADE_GOLD, iGold, NULL);
+        if (!kPlayer.canTradeItem(getID(), thereitem, true))
+        {
+            return false;
+        }
+    }
+    else
+    {
+        /// THEIR TRADE
+        iCivic = kPlayer.getIdea(false, getID());
+        if (iCivic == -1)
+        {
+//            sprintf(szOut, "######################## No There Idea FOund\n");
+//            gDLL->messageControlLog(szOut);
+            return false;
+        }
+        setTradeItem(&thereitem, TRADE_IDEAS, iCivic, NULL);
+        if (!kPlayer.canTradeItem(getID(), thereitem, true))
+        {
+//            sprintf(szOut, "######################## Can There not Trade\n");
+//            gDLL->messageControlLog(szOut);
+            return false;
+        }
+    }
+
+	CLinkList<TradeData> theirList;
+	theirList.insertAtEnd(thereitem);
+	CLinkList<TradeData> ourList;
+	ourList.insertAtEnd(myitem);
+
+	if (kPlayer.isHuman())
+	{
+		AI_changeContactTimer(ePlayer, CONTACT_TRADE_IDEAS, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_TRADE_IDEAS));
+		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
+		pDiplo->setAIContact(true);
+		pDiplo->setOurOfferList(theirList);
+		pDiplo->setTheirOfferList(ourList);
+		gDLL->beginDiplomacy(pDiplo, ePlayer);
+	}
+	else
+	{
+		GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
+	}
+
+	return true;
+}
+///TKe
+
+bool CvPlayerAI::AI_doDiploDefensivePact(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (GET_TEAM(getTeam()).getLeaderID() != getID())
+	{
+		return false;
+	}
+
+	if (kPlayer.getParent() == getID())
+	{
+		return false;
+	}
+
+	if (isEurope())
+	{
+		return false;
+	}
+
+	if (AI_getContactTimer(ePlayer, CONTACT_DEFENSIVE_PACT) > 0)
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_DEFENSIVE_PACT), "AI Diplo Defensive Pact") != 0)
+	{
+		return false;
+	}
+
+	TradeData item;
+	setTradeItem(&item, TRADE_DEFENSIVE_PACT, 0, NULL);
+
+	if (!canTradeItem(ePlayer, item, true) || !kPlayer.canTradeItem(getID(), item, true))
+	{
+		return false;
+	}
+
+	CLinkList<TradeData> theirList;
+	theirList.insertAtEnd(item);
+	CLinkList<TradeData> ourList;
+	ourList.insertAtEnd(item);
+
+	if (kPlayer.isHuman())
+	{
+		AI_changeContactTimer(ePlayer, CONTACT_DEFENSIVE_PACT, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_DEFENSIVE_PACT));
+		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
+		pDiplo->setAIContact(true);
+		pDiplo->setOurOfferList(theirList);
+		pDiplo->setTheirOfferList(ourList);
+		gDLL->beginDiplomacy(pDiplo, ePlayer);
+	}
+	else
+	{
+		GC.getGameINLINE().implementDeal(getID(), ePlayer, &ourList, &theirList);
+	}
+
+	return true;
+}
+
+bool CvPlayerAI::AI_doDiploTradeMap(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (AI_getContactTimer(ePlayer, CONTACT_TRADE_MAP) > 0)
+	{
+		return false;
+	}
+
+	if (isEurope())
+	{
+		return false;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(GC.getLeaderHeadInfo(getPersonalityType()).getContactRand(CONTACT_TRADE_MAP), "AI Diplo Trade Map") != 0)
+	{
+		return false;
+	}
+
+	TradeData item;
+	setTradeItem(&item, TRADE_MAPS, 0, NULL);
+
+	if (!kPlayer.canTradeItem(getID(), item, true) || !canTradeItem(ePlayer, item, true))
+	{
+		return false;
+	}
+
+	if (kPlayer.isHuman() && GET_TEAM(getTeam()).AI_mapTradeVal(kPlayer.getTeam()) < GET_TEAM(kPlayer.getTeam()).AI_mapTradeVal(getTeam()))
+	{
+		return false;
+	}
+
+	CLinkList<TradeData> theirList;
+	theirList.insertAtEnd(item);
+	CLinkList<TradeData> ourList;
+	ourList.insertAtEnd(item);
+
+	if (kPlayer.isHuman())
+	{
+		AI_changeContactTimer((ePlayer), CONTACT_TRADE_MAP, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_TRADE_MAP));
+		CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+		pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_DEAL"));
+		pDiplo->setAIContact(true);
+		pDiplo->setOurOfferList(theirList);
+		pDiplo->setTheirOfferList(ourList);
+		gDLL->beginDiplomacy(pDiplo, ePlayer);
+	}
+	else
+	{
+		GC.getGameINLINE().implementDeal(getID(), ePlayer, &ourList, &theirList);
+	}
+
+	return true;
+}
+
+bool CvPlayerAI::AI_doDiploDeclareWar(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	int iDeclareWarTradeRand = GC.getLeaderHeadInfo(getPersonalityType()).getDeclareWarTradeRand();
+	int iMinAtWarCounter = MAX_INT;
+	for (int iJ = 0; iJ < MAX_TEAMS; iJ++)
+	{
+		if (GET_TEAM((TeamTypes)iJ).isAlive())
+		{
+			if (atWar(((TeamTypes)iJ), getTeam()))
+			{
+				int iAtWarCounter = GET_TEAM(getTeam()).AI_getAtWarCounter((TeamTypes)iJ);
+				if (GET_TEAM(getTeam()).AI_getWarPlan((TeamTypes)iJ) == WARPLAN_DOGPILE)
+				{
+					iAtWarCounter *= 2;
+					iAtWarCounter += 5;
+				}
+				iMinAtWarCounter = std::min(iAtWarCounter, iMinAtWarCounter);
+			}
+		}
+	}
+
+	if (iMinAtWarCounter < 10)
+	{
+		iDeclareWarTradeRand *= iMinAtWarCounter;
+		iDeclareWarTradeRand /= 10;
+		iDeclareWarTradeRand ++;
+	}
+
+	if (iMinAtWarCounter < 4)
+	{
+		iDeclareWarTradeRand /= 4;
+		iDeclareWarTradeRand ++;
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(iDeclareWarTradeRand, "AI Diplo Declare War Trade") != 0)
+	{
+		return false;
+	}
+
+	int iGoldValuePercent = AI_goldTradeValuePercent();
+
+	int iBestValue = 0;
+	TeamTypes eBestTeam = NO_TEAM;
+	for (int iJ = 0; iJ < MAX_TEAMS; iJ++)
+	{
+		if (GET_TEAM((TeamTypes)iJ).isAlive())
+		{
+			if (atWar(((TeamTypes) iJ), getTeam()) && !atWar(((TeamTypes) iJ), kPlayer.getTeam()))
+			{
+				if (GET_TEAM((TeamTypes)iJ).getAtWarCount() < std::max(2, (GC.getGameINLINE().countCivTeamsAlive() / 2)))
+				{
+					TradeData item;
+					setTradeItem(&item, TRADE_WAR, iJ, NULL);
+
+					if (kPlayer.canTradeItem(getID(), item, true))
+					{
+						int iValue = (1 + GC.getGameINLINE().getSorenRandNum(1000, "AI Declare War Trading"));
+
+						iValue *= (101 + GET_TEAM((TeamTypes)iJ).AI_getAttitudeWeight(getTeam()));
+						iValue /= 100;
+
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							eBestTeam = ((TeamTypes)iJ);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (eBestTeam == NO_TEAM)
+	{
+		return false;
+	}
+
+	iBestValue = 0;
+	int iOurValue = GET_TEAM(getTeam()).AI_declareWarTradeVal(eBestTeam, kPlayer.getTeam());
+	int iTheirValue = 0;
+	int iReceiveGold = 0;
+	int iGiveGold = 0;
+
+	if (iTheirValue > iOurValue)
+	{
+		int iGold = std::min(((iTheirValue - iOurValue) * 100) / iGoldValuePercent, kPlayer.AI_maxGoldTrade(getID()));
+
+		if (iGold > 0)
+		{
+			TradeData item;
+			setTradeItem(&item, TRADE_GOLD, iGold, NULL);
+
+			if (kPlayer.canTradeItem(getID(), item, true))
+			{
+				iReceiveGold = iGold;
+				iOurValue += (iGold * iGoldValuePercent) / 100;
+			}
+		}
+	}
+	else if (iOurValue > iTheirValue)
+	{
+		int iGold = std::min(((iOurValue - iTheirValue) * 100) / iGoldValuePercent, AI_maxGoldTrade(ePlayer));
+
+		if (iGold > 0)
+		{
+			TradeData item;
+			setTradeItem(&item, TRADE_GOLD, iGold, NULL);
+
+			if (canTradeItem((ePlayer), item, true))
+			{
+				iGiveGold = iGold;
+				iTheirValue += (iGold * iGoldValuePercent) / 100;
+			}
+		}
+	}
+
+	if (iTheirValue <= (iOurValue * 3 / 4))
+	{
+		return false;
+	}
+
+	CLinkList<TradeData> theirList;
+	CLinkList<TradeData> ourList;
+
+	TradeData item;
+	setTradeItem(&item, TRADE_WAR, eBestTeam, NULL);
+	theirList.insertAtEnd(item);
+
+	if (iGiveGold != 0)
+	{
+		setTradeItem(&item, TRADE_GOLD, iGiveGold, NULL);
+		ourList.insertAtEnd(item);
+	}
+
+	if (iReceiveGold != 0)
+	{
+		setTradeItem(&item, TRADE_GOLD, iReceiveGold, NULL);
+		theirList.insertAtEnd(item);
+	}
+
+	GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, &theirList);
+
+	return true;
+}
+
+
+//Convert units from city population to map units (such as pioneers)
+void CvPlayerAI::AI_doProfessions()
+{
+
+	std::map<int, bool> cityDanger;
+
+	{
+		int iLoop;
+		CvCity* pLoopCity;
+		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+		{
+			cityDanger[pLoopCity->getID()] = AI_getPlotDanger(pLoopCity->plot(), 5, true);
+		}
+	}
+
+	for (int iI = 0; iI < NUM_UNITAI_TYPES; ++iI)
+	{
+		UnitAITypes eUnitAI = (UnitAITypes)iI;
+
+		int iPriority = 0;
+
+		if ((AI_unitAIValueMultipler(eUnitAI) > 0) && eUnitAI != UNITAI_DEFENSIVE)
+		{
+			ProfessionTypes eProfession = AI_idealProfessionForUnitAIType(eUnitAI);
+
+			if ((eProfession != NO_PROFESSION) && (eUnitAI == UNITAI_SETTLER || (eProfession != (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession())))
+			{
+				CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+
+				bool bDone = false;
+
+				int iLoop;
+				CvCity* pLoopCity;
+
+				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+				{
+					if (pLoopCity->getPopulation() > ((pLoopCity->getHighestPopulation() * 2) / 3))
+					{
+						if (!cityDanger[pLoopCity->getID()] || AI_unitAIIsCombat(eUnitAI))
+						{
+							for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+							{
+								CvUnit* pUnit = pLoopCity->getPopulationUnitByIndex(i);
+								if (pUnit != NULL)
+								{
+									ProfessionTypes eIdealProfession = AI_idealProfessionForUnit(pUnit->getUnitType());
+									if (eIdealProfession == NO_PROFESSION || pUnit->getProfession() != eIdealProfession)
+									{
+										if (pUnit->canHaveProfession(eProfession, false) && (AI_professionSuitability(pUnit, eProfession, pLoopCity->plot()) > 100))
+										{
+											pLoopCity->removePopulationUnit(pUnit, false, eProfession);
+											pUnit->AI_setUnitAIType(eUnitAI);
+											bDone = true;
+											break;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+
+				if (!bDone)
+				{
+					for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+					{
+						int iBestValue = 0;
+						CvUnit* pBestUnit = NULL;
+
+						if (!cityDanger[pLoopCity->getID()] || AI_unitAIIsCombat(eUnitAI))
+						{
+							if (pLoopCity->getPopulation() > ((pLoopCity->getHighestPopulation() * 2) / 3))
+							{
+								for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+								{
+									CvUnit* pUnit = pLoopCity->getPopulationUnitByIndex(i);
+									if (pUnit != NULL)
+									{
+										if (pUnit->canHaveProfession(eProfession, false))
+										{
+											int iValue = AI_professionSuitability(pUnit, eProfession, pLoopCity->plot());
+
+											if (pUnit->getProfession() == NO_PROFESSION)
+											{
+
+											}
+											else if (pUnit->getProfession() == pUnit->AI_getIdealProfession())
+											{
+												iValue /= 4;
+											}
+
+											if (eUnitAI == UNITAI_SETTLER)
+											{
+												if (pUnit->AI_getIdealProfession() != NO_PROFESSION)
+												{
+													if ((pUnit->getProfession() != pUnit->AI_getIdealProfession()) && (GC.getProfessionInfo(pUnit->AI_getIdealProfession()).isWorkPlot()))
+													{
+														iValue *= 150;
+														iValue /= 100;
+													}
+												}
+												else
+												{
+													iValue *= 120;
+													iValue /= 100;
+												}
+											}
+
+											iValue *= 100;
+											iValue += GC.getGameINLINE().getSorenRandNum(100, "AI pick unit");
+
+											if (iValue > iBestValue)
+											{
+												iBestValue = iValue;
+												pBestUnit = pUnit;
+											}
+										}
+									}
+								}
+							}
+						}
+						if (pBestUnit != NULL)
+						{
+							pLoopCity->removePopulationUnit(pBestUnit, false, eProfession);
+							pBestUnit->AI_setUnitAIType(eUnitAI);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	//Military
+	int iLoop;
+	CvCity* pLoopCity;
+
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity->AI_isDanger())
+		{
+			ProfessionTypes eProfession = AI_idealProfessionForUnitAIType(UNITAI_DEFENSIVE, pLoopCity);
+
+			if ((eProfession != NO_PROFESSION) && (eProfession != (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()))
+			{
+				CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+				bool bDone = false;
+
+				int iNeededDefenders = pLoopCity->AI_neededDefenders();
+				int iHaveDefenders = pLoopCity->AI_numDefenders(true, false);
+
+				if (iHaveDefenders < iNeededDefenders)
+				{
+					while (!bDone)
+					{
+						int iBestValue = 0;
+						CvUnit* pBestUnit = NULL;
+
+						for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+						{
+							CvUnit* pUnit = pLoopCity->getPopulationUnitByIndex(i);
+							if (pUnit != NULL)
+							{
+								if (pUnit->canHaveProfession(eProfession, false))
+								{
+									int iValue = AI_professionSuitability(pUnit, eProfession, pLoopCity->plot());
+
+									if (pUnit->getProfession() == NO_PROFESSION)
+									{
+
+									}
+									else if (pUnit->getProfession() == pUnit->AI_getIdealProfession())
+									{
+										iValue /= 4;
+									}
+
+									iValue *= 100;
+									iValue += GC.getGameINLINE().getSorenRandNum(100, "AI pick unit");
+
+									if (iValue > iBestValue)
+									{
+										iBestValue = iValue;
+										pBestUnit = pUnit;
+									}
+								}
+							}
+						}
+
+						if (pBestUnit != NULL)
+						{
+							pLoopCity->removePopulationUnit(pBestUnit, false, eProfession);
+							pBestUnit->AI_setUnitAIType(UNITAI_DEFENSIVE);
+						}
+						else
+						{
+							bDone = true;
+						}
+					}
+				}
+			}
+		}
+	}
+
+}
+
+void CvPlayerAI::AI_doEurope()
+{
+	//Buy Units.
+	UnitTypes eBuyUnit;
+	UnitAITypes eBuyUnitAI;
+	int iBuyUnitValue;
+
+	if (!canTradeWithEurope())
+	{
+		return;
+	}
+
+	if (!isHuman() && !isNative() && !isEurope())
+	{
+		//Always refresh at start of new turn (maybe do this smarter but it's okay for now)
+		AI_updateNextBuyUnit();
+		AI_updateNextBuyProfession();
+	}
+
+
+	eBuyUnit = AI_nextBuyUnit(&eBuyUnitAI, &iBuyUnitValue);
+
+	UnitTypes eBuyProfessionUnit;
+	ProfessionTypes eBuyProfession;
+	UnitAITypes eBuyProfessionAI;
+	int iBuyProfessionValue;
+
+	eBuyProfessionUnit = AI_nextBuyProfessionUnit(&eBuyProfession, &eBuyProfessionAI, &iBuyProfessionValue);
+
+	int iUnitPrice = 0;
+
+	if (eBuyUnit != NO_UNIT)
+	{
+		iUnitPrice = getEuropeUnitBuyPrice(eBuyUnit);
+	}
+
+	if ((eBuyUnit != NO_UNIT) && ((iBuyUnitValue > iBuyProfessionValue) || (iUnitPrice < getGold())))
+	{
+		if (getGold() > iUnitPrice)
+		{
+			CvUnit* pUnit = buyEuropeUnit(eBuyUnit, 100);
+
+			FAssert(pUnit != NULL);
+			pUnit->AI_setUnitAIType(eBuyUnitAI);
+
+			AI_updateNextBuyUnit();
+		}
+	}
+
+	if ((eBuyProfession != NO_PROFESSION) && (iBuyProfessionValue > iBuyUnitValue))
+	{
+		ProfessionTypes eDefaultProfession = (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession();
+
+		int iBestValue = 0;
+		CvUnit* pBestUnit = NULL;
+
+		int iBuyPrice = -1;
+		if (eBuyProfessionUnit != NO_UNIT)
+		{
+			iBuyPrice = getEuropeUnitBuyPrice(eBuyProfessionUnit);
+		}
+
+		CvProfessionInfo& kProfession = GC.getProfessionInfo(eBuyProfession);
+
+		if (!kProfession.isCitizen() && (eBuyProfessionAI != UNITAI_COLONIST))
+		{
+			//Consider upgrading an existing unit.
+			for (int i = 0; i < getNumEuropeUnits(); ++i)
+			{
+				CvUnit* pLoopUnit = getEuropeUnit(i);
+				if (!pLoopUnit->AI_hasAIChanged(4))
+				{
+					if (pLoopUnit->getProfession() == eBuyProfession)
+					{
+						int iValue = 200;
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							pBestUnit = pLoopUnit;
+						}
+					}
+					else
+					{
+						if (pLoopUnit->getProfession() == eDefaultProfession)
+						{
+							if (pLoopUnit->canHaveProfession(eBuyProfession, false))
+							{
+								int iValue = AI_professionSuitability(pLoopUnit, eBuyProfession, NULL);
+
+								bool bValid = true;
+
+								if (eBuyProfessionAI == UNITAI_SCOUT)
+								{
+									if (iValue < 100)
+									{
+										bValid = false;
+									}
+								}
+								if (bValid)
+								{
+									iValue *= 100 + ((iBuyProfessionValue - 100) / 5);
+									iValue /= 100;
+
+									int iMinThreshold = 1;
+
+									if (iValue >= iMinThreshold)
+									{
+										iValue *= 2;
+
+										//XXX Perform Gold Cost of Upgrade Modification.
+										if (iValue > iBestValue)
+										{
+											iBestValue = iValue;
+											pBestUnit = pLoopUnit;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+
+		if (pBestUnit != NULL)
+		{
+			changeProfessionEurope(pBestUnit->getID(), eBuyProfession);
+			FAssert(pBestUnit->getProfession() == eBuyProfession);
+			pBestUnit->AI_setUnitAIType(eBuyProfessionAI);
+		}
+		else if (eBuyProfessionUnit != NO_UNIT)
+		{
+			FAssert(iBuyPrice >= 0);
+			if (getGold() > iBuyPrice)
+			{
+				CvUnit* pUnit = buyEuropeUnit(eBuyProfessionUnit, 100);
+				pUnit->AI_setUnitAIType(eBuyProfessionAI);
+			}
+		}
+	}
+
+	//arm any europe units that need it
+	for (int i = 0; i < getNumEuropeUnits(); i++)
+	{
+		CvUnit *pUnit = getEuropeUnit(i);
+
+		int iUndefended = 0;
+		int iNeeded = AI_totalDefendersNeeded(&iUndefended);
+		if (iNeeded > 0 || AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+		{
+			ProfessionTypes eBestProfession = NO_PROFESSION;
+			if (GC.getGameINLINE().getSorenRandNum(100, "") < 50)
+			{
+				eBestProfession = GET_PLAYER(pUnit->getOwnerINLINE()).AI_idealProfessionForUnitAIType(UNITAI_DEFENSIVE);
+			}
+			else
+			{
+				eBestProfession = GET_PLAYER(pUnit->getOwnerINLINE()).AI_idealProfessionForUnitAIType(UNITAI_COUNTER);
+			}
+
+			if (eBestProfession != NO_PROFESSION && pUnit->canHaveProfession(eBestProfession, false))
+			{
+				changeProfessionEurope(pUnit->getID(), eBestProfession);
+			}
+		}
+	}
+}
+
+void CvPlayerAI::AI_nativeYieldGift(CvUnit* pUnit)
+{
+	FAssert(pUnit != NULL);
+	FAssert(pUnit->isOnMap());
+	FAssert(pUnit->plot()->isCity());
+	FAssert(isNative());
+
+	CvCity* pHomeCity = pUnit->getHomeCity();
+	if (pHomeCity == NULL)
+	{
+		pHomeCity = GC.getMapINLINE().findCity(pUnit->getX_INLINE(), pUnit->getY_INLINE(), pUnit->getOwnerINLINE());
+		pUnit->setHomeCity(pHomeCity);
+	}
+
+	if (pHomeCity == NULL)
+	{
+		return;
+	}
+
+	YieldTypes eBestYield = NO_YIELD;
+	int iBestValue = 0;
+
+	for(int i=0;i<NUM_YIELD_TYPES;i++)
+	{
+		if (pHomeCity->canProduceYield((YieldTypes)i))
+		{
+		    ///Tks Med
+		    CvPlayer& kPlayer = GET_PLAYER(pUnit->plot()->getPlotCity()->getOwner());
+		    if (!kPlayer.canUnitBeTraded((YieldTypes)i))
+		    {
+		        continue;
+		    }
+			//if ((YIELD_FOOD != i) && (YIELD_HORSES != i))
+			if ((YIELD_FOOD != i) && !GC.isEquipmentType((YieldTypes)i, EQUIPMENT_ARMOR_HORSES))
+			{
+            ///TKe
+				YieldTypes eYield = (YieldTypes) i;
+				if (GC.getYieldInfo(eYield).getNativeSellPrice() > 0)
+				{
+					int iRandValue = 100 + GC.getGameINLINE().getSorenRandNum(900, "Native Yield Gift: pick yield");
+					iRandValue *= pHomeCity->getYieldStored(eYield);
+					if (iRandValue > iBestValue)
+					{
+						eBestYield = eYield;
+						iBestValue = iRandValue;
+					}
+				}
+			}
+		}
+	}
+
+	if (eBestYield == NO_YIELD)
+	{
+		return;
+	}
+
+	CvCity* pOtherCity = pUnit->plot()->getPlotCity();
+	FAssert(pOtherCity != NULL);
+	FAssert(!pOtherCity->isNative());
+
+	if(pOtherCity != NULL)
+	{
+		//give some yields from pBestCity to pOtherCity
+		int iYieldPercent = 5 * (AI_getAttitudeVal(pOtherCity->getOwnerINLINE(), false) + GC.getGameINLINE().getSorenRandNum(10, "Native Yield Gift: pick amount"));
+		int iYieldAmount = iYieldPercent * pHomeCity->getYieldStored(eBestYield) / 100;
+		iYieldAmount = std::min(iYieldAmount, pHomeCity->getYieldStored(eBestYield));
+		iYieldAmount = std::max(iYieldAmount, 0);
+		if(iYieldAmount > 0)
+		{
+			pHomeCity->changeYieldStored(eBestYield, -iYieldAmount);
+			pOtherCity->changeYieldStored(eBestYield, iYieldAmount);
+
+			//AI_changeContactTimer(pOtherCity->getOwnerINLINE(), CONTACT_YIELD_GIFT, GC.getLeaderHeadInfo(getPersonalityType()).getContactDelay(CONTACT_YIELD_GIFT));
+
+			//popup dialog
+			CvPlayer& kOtherPlayer = GET_PLAYER(pOtherCity->getOwnerINLINE());
+			if(kOtherPlayer.isHuman())
+			{
+				CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+				pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_NATIVES_YIELD_GIFT"));
+				pDiplo->addDiploCommentVariable(iYieldAmount);
+				pDiplo->addDiploCommentVariable(GC.getYieldInfo(eBestYield).getChar());
+				pDiplo->addDiploCommentVariable(pOtherCity->getNameKey());
+				pDiplo->setAIContact(true);
+				gDLL->beginDiplomacy(pDiplo, kOtherPlayer.getID());
+			}
+		}
+	}
+}
+
+#if 0
+// function is inlined and moved to header
+bool CvPlayerAI::AI_isYieldForSale(YieldTypes eYield) const
+{
+	if (!GC.getYieldInfo(eYield).isCargo())
+	{
+		return false;
+	}
+
+	return YieldGroup_AI_Sell_To_Europe(eYield) || (isNative() && (eYield == YIELD_TOOLS || eYield ==  YIELD_HORSES));
+
+#if 0
+	switch (eYield)
+	{
+		//case YIELD_FOOD:
+		//case YIELD_LUMBER:
+		///TK ME start
+		//case YIELD_STONE:///NEW*
+		///TKs Invention Core Mod v 1.0
+//        case YIELD_COAL:
+            //break;
+        ///TKe
+        //case YIELD_GRAIN:///NEW*
+			return false;
+			break;
+        ///Discoverys Bonus
+//        case YIELD_SILK:///NEW*
+//        case YIELD_PORCELAIN:///NEW*
+        ///Discoverys^
+        ///Food Goods
+	    //case YIELD_CATTLE:///NEW*
+	    //case YIELD_SHEEP:///NEW*
+        //case YIELD_WOOL:///NEW*
+        //case YIELD_SALT:///NEW*
+        ///Food Goods^
+//        case YIELD_LEATHER:///NEW*
+//        case YIELD_IVORY:///NEW*
+        //case YIELD_SPICES:///NEW*
+		//case YIELD_SILVER:
+		//case YIELD_COTTON:
+		//case YIELD_FUR:
+		//case YIELD_BARLEY:
+		//case YIELD_GRAPES:
+		//case YIELD_ORE:
+		//case YIELD_CLOTH:
+		//case YIELD_COATS:
+		//case YIELD_ALE:
+		//case YIELD_WINE:
+			return true;
+			break;
+
+		//case YIELD_TOOLS:
+		{
+		    if (isNative())
+		    {
+		        return true;
+		    }
+		    break;
+		}
+		//case YIELD_HORSES:
+		{
+		    if (isNative())
+		    {
+		        return true;
+		    }
+		    break;
+		}
+
+		//case YIELD_WEAPONS:
+		 ///Armor
+        //case YIELD_LEATHER_ARMOR:///NEW*
+        //case YIELD_SCALE_ARMOR:///NEW*
+        //case YIELD_MAIL_ARMOR:///NEW*
+        //case YIELD_PLATE_ARMOR:///NEW*
+        ///Armor^
+		//case YIELD_TRADE_GOODS:
+			return false;
+			break;
+        ///TK ME end
+        ///TKs Invention Core Mod v 1.0
+        case YIELD_IDEAS:
+        ///TKe
+		case YIELD_HAMMERS:
+		case YIELD_BELLS:
+		case YIELD_CROSSES:
+        case YIELD_GOLD:///NEW*
+			FAssertMsg(false, "Selling intangibles?");
+			break;
+		default:
+			FAssert(false);
+	}
+
+	return false;
+
+#endif
+}
+#endif
+
+bool CvPlayerAI::AI_isYieldFinalProduct(YieldTypes eYield) const
+{
+	if (!YieldGroup_AI_Sell(eYield) && !YieldGroup_AI_Raw_Material(eYield))
+	{
+		// only those two groups can provide a true return.
+		// No need to check anything unless eYield is part of at least one of them.
+		return false;
+	}
+
+	/*
+	if (!GC.getYieldInfo(eYield).isCargo())
+	{
+		return false;
+	}
+
+	if (YieldGroup_Virtual(eYield))
+	{
+		FAssertMsg(false, "Selling intangibles?");
+		return false;
+	}
+	*/
+	
+	if (YieldGroup_AI_Raw_Material(eYield))
+	{
+		{
+			int iLoop;
+			CvCity* pLoopCity = NULL;
+			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+			{
+				if (pLoopCity->AI_getNeededYield(eYield) > 0)
+				{
+					return false;
+				}
+			}
+		}
+		return true;
+	}
+
+	// eYield is in YieldGroup_AI_Sell.
+	return true;
+
+
+#if 0
+	bool bFinal = true;
+
+	switch (eYield)
+	{
+	    ///TK ME start
+		//case YIELD_FOOD:
+		//case YIELD_LUMBER:
+        //case YIELD_GRAIN:///NEW*
+			bFinal = false;
+			break;
+        ///Food Goods
+		//case YIELD_SILVER:
+		//	bFinal = true;
+		//	break;
+        ///Trade Goods
+//        case YIELD_LEATHER:///NEW*
+        ///Trade Goods^
+		//case YIELD_COTTON:
+		//case YIELD_BARLEY:
+		//case YIELD_GRAPES:
+		//case YIELD_ORE:
+        //case YIELD_CATTLE:///NEW*
+        //case YIELD_SPICES:///NEW*
+        //case YIELD_SHEEP:///NEW*
+        //case YIELD_WOOL:///NEW*
+        //case YIELD_SALT:///NEW*
+        //case YIELD_STONE:///NEW*
+        //case YIELD_FUR:
+		///TKs Invention Core Mod v 1.0
+//        case YIELD_COAL:
+        ///TKe
+		/*	{
+				int iLoop;
+				CvCity* pLoopCity = NULL;
+				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+				{
+					if (pLoopCity->AI_getNeededYield(eYield) > 0)
+					{
+						bFinal = false;
+						break;
+					}
+				}
+			}
+			break;
+			*/
+		//case YIELD_CLOTH:
+		//case YIELD_COATS:
+		//case YIELD_ALE:
+		//case YIELD_WINE:
+		//	bFinal = true;
+		//	break;
+
+		//case YIELD_TOOLS:
+		//case YIELD_WEAPONS:
+		//case YIELD_HORSES:
+		///Armor
+		//case YIELD_LEATHER_ARMOR:///NEW*
+		//case YIELD_SCALE_ARMOR:///NEW*
+		//case YIELD_MAIL_ARMOR:///NEW*
+		//case YIELD_PLATE_ARMOR:///NEW*
+        ///Armor^
+			bFinal = false;
+			break;
+
+		//case YIELD_TRADE_GOODS:
+			bFinal = true;
+			break;
+		///TKs Invention Core Mod v 1.0
+        //case YIELD_IDEAS:
+        ///TKe
+		//case YIELD_HAMMERS:
+		//case YIELD_BELLS:
+		//case YIELD_CROSSES:
+        //case YIELD_GOLD:///NEW*
+			bFinal = false;
+			FAssertMsg(false, "Selling intangibles?");
+			break;
+		default:
+			FAssert(false);
+	}
+
+	return bFinal;
+#endif
+}
+///TKs Med
+bool CvPlayerAI::AI_shouldBuyFromNative(YieldTypes eYield, CvUnit* pTransport) const
+{
+	if (!YieldGroup_AI_Buy_From_Natives(eYield))
+	{
+		return false;
+	}
+
+    CvCity* pNativeCity = pTransport->plot()->getPlotCity();
+    if (pNativeCity == NULL)
+    {
+        return false;
+    }
+    
+	/*
+	if (!GC.getYieldInfo(eYield).isCargo())
+	{
+		return false;
+	}
+	*/
+
+	if (GC.getYieldInfo(eYield).getNativeSellPrice() < 1)
+	{
+		return false;
+	}
+
+	if (GET_PLAYER(pNativeCity->getOwnerINLINE()).getTradeYieldAmount(eYield, pTransport) <= 0)
+    {
+        return false;
+    }
+
+	/*
+	if (YieldGroup_Virtual(eYield))
+	{
+		FAssertMsg(false, "Selling intangibles?");
+		return false;
+	}
+	*/
+
+	return true;
+
+#if 0
+	bool bBuy = false;
+
+	switch (eYield)
+	{
+	    //case YIELD_SPICES:
+	    //case YIELD_TOOLS:
+        //case YIELD_GRAIN:///NEW*
+        //case YIELD_CATTLE:///NEW*
+			bBuy = true;
+			break;
+        //case YIELD_SALT:
+		//case YIELD_FOOD:
+	    //case YIELD_SHEEP:///NEW*
+        //case YIELD_WOOL:///NEW*
+        //case YIELD_STONE:///NEW*
+		//case YIELD_LUMBER:
+		//case YIELD_SILVER:
+		//case YIELD_COTTON:
+		//case YIELD_FUR:
+		//case YIELD_BARLEY:
+		//case YIELD_GRAPES:
+		//case YIELD_ORE:
+		//case YIELD_CLOTH:
+		//case YIELD_COATS:
+		//case YIELD_ALE:
+		//case YIELD_WINE:
+        //case YIELD_LEATHER_ARMOR:///NEW*
+        //case YIELD_SCALE_ARMOR:///NEW*
+        //case YIELD_MAIL_ARMOR:///NEW*
+        //case YIELD_PLATE_ARMOR:///NEW*
+        ///Armor^
+		//case YIELD_WEAPONS:
+		//case YIELD_HORSES:
+		//case YIELD_TRADE_GOODS:
+			bBuy = false;
+			break;
+		///TKs Invention Core Mod v 1.0
+        //case YIELD_IDEAS:
+        ///TKe
+		//case YIELD_HAMMERS:
+		//case YIELD_BELLS:
+		//case YIELD_CROSSES:
+        //case YIELD_GOLD:///NEW*
+			bBuy = false;
+			FAssertMsg(false, "Selling intangibles?");
+			break;
+		default:
+			FAssert(false);
+	}
+
+	return bBuy;
+#endif
+}
+///tke
+#if 0
+// function is inlined and moved to header
+bool CvPlayerAI::AI_shouldBuyFromEurope(YieldTypes eYield) const
+{
+	if (!YieldGroup_AI_Buy_From_Europe(eYield))
+	{
+		return false;
+	}
+
+	if (!GC.getYieldInfo(eYield).isCargo())
+	{
+		return false;
+	}
+
+	if (YieldGroup_Virtual(eYield))
+	{
+		FAssertMsg(false, "Selling intangibles?");
+		return false;
+	}
+
+	return true;
+
+#if 0
+	bool bBuy = false;
+
+	switch (eYield)
+	{
+		//case YIELD_FOOD:
+	    //case YIELD_CATTLE:///NEW*
+	    //case YIELD_SHEEP:///NEW*
+        //case YIELD_GRAIN:///NEW*
+        //case YIELD_WOOL:///NEW*
+       // case YIELD_SALT:///NEW*
+        //case YIELD_STONE:///NEW*
+		//case YIELD_LUMBER:
+		//case YIELD_SILVER:
+		//case YIELD_COTTON:
+		//case YIELD_FUR:
+		//case YIELD_BARLEY:
+		//case YIELD_GRAPES:
+		//case YIELD_ORE:
+		//case YIELD_CLOTH:
+		//case YIELD_COATS:
+		//case YIELD_ALE:
+		//case YIELD_WINE:
+			bBuy = false;
+			break;
+         ///Armor
+        //case YIELD_LEATHER_ARMOR:///NEW*
+        //case YIELD_SCALE_ARMOR:///NEW*
+        //case YIELD_MAIL_ARMOR:///NEW*
+        //case YIELD_PLATE_ARMOR:///NEW*
+        ///Armor^
+		//case YIELD_TOOLS:
+		//case YIELD_WEAPONS:
+		//case YIELD_HORSES:
+		//case YIELD_TRADE_GOODS:
+        //case YIELD_SPICES:///NEW*
+			bBuy = true;
+			break;
+		///TKs Invention Core Mod v 1.0
+        //case YIELD_IDEAS:
+        ///TKe
+		//case YIELD_HAMMERS:
+		//case YIELD_BELLS:
+		//case YIELD_CROSSES:
+        //case YIELD_GOLD:///NEW*
+			bBuy = false;
+			FAssertMsg(false, "Selling intangibles?");
+			break;
+		default:
+			FAssert(false);
+	}
+
+	return bBuy;
+#endif
+}
+#endif
+///TKs Invention Core Mod v 1.0
+int CvPlayerAI::AI_yieldValue(YieldTypes eYield, bool bProduce, int iAmount)
+{
+	int iValue = 0;
+	if (bProduce)
+	{
+		iValue += 100 * (isNative() ? GC.getYieldInfo(eYield).getNativeBaseValue() : GC.getYieldInfo(eYield).getAIBaseValue());
+	}
+	if (eYield == YIELD_FOOD)
+	{
+
+	}
+	else if (isNative())
+	{
+		CvYieldInfo& kYieldInfo = GC.getYieldInfo(eYield);
+		int iPrice = 0;
+		int iValidPrices = 0;
+		if (kYieldInfo.getNativeBuyPrice() > 0)
+		{
+			iPrice += kYieldInfo.getNativeBuyPrice();
+			iValidPrices++;
+		}
+		if (kYieldInfo.getNativeSellPrice() > 0)
+		{
+			iPrice += kYieldInfo.getNativeSellPrice();
+			iValidPrices++;
+		}
+
+		if (iPrice > 0)
+		{
+			//If both buy and sell, use average. Otherwise, use 2/3rd the value.
+			iPrice *= 2;
+			iPrice /= 2 + iValidPrices;
+
+			iValue += iPrice * 100;
+		}
+	}
+	else
+	{
+		iValue += m_aiYieldValuesTimes100[eYield];
+	}
+
+	iValue *= AI_yieldWeight(eYield);
+	iValue /= 100;
+
+	if (bProduce)
+	{
+		int iWeaponsMultiplier = 100;
+		int iNoblesMultiplier = 100;
+		if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+		{
+		    iNoblesMultiplier += 50;
+			iWeaponsMultiplier += 50;
+		}
+
+		int iGoodsMultiplier = 100;
+		if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+		{
+			iGoodsMultiplier -= 15;
+			iNoblesMultiplier += 25;
+			iWeaponsMultiplier += 25;
+		}
+		else if (AI_isStrategy(STRATEGY_CASH_FOCUS))
+		{
+			iGoodsMultiplier += 50;
+			iNoblesMultiplier -= 25;
+		}
+
+		if (AI_isStrategy(STRATEGY_REVOLUTION))
+		{
+			iGoodsMultiplier -= 15;
+			iWeaponsMultiplier += 50;
+			iNoblesMultiplier += 25;
+		}
+
+#ifdef USE_NOBLE_CLASS
+		if (eYield == YIELD_CATTLE || eYield == YIELD_GRAIN || eYield == YIELD_SPICES)
+		{
+			iValue *= iNoblesMultiplier;
+			iValue /= 100;
+			if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+			{
+				iValue *= iNoblesMultiplier;
+				iValue /= 100;
+			}
+		} else 
+#endif	
+		if (YieldGroup_AI_Sell_To_Europe(eYield))
+		{
+			iValue *= iGoodsMultiplier;
+			iValue /= 100;
+		} else if (YieldGroup_Armor(eYield) || eYield == YIELD_WEAPONS || eYield == YIELD_HORSES)
+		{
+			iValue *= iWeaponsMultiplier;
+			iValue /= 100;
+		} else {
+		switch (eYield)
+		{
+			case YIELD_FOOD:
+				break;
+			case YIELD_LUMBER:
+            case YIELD_STONE:///NEW*
+				iValue *= 100;
+				iValue /= iGoodsMultiplier;
+				break;
+
+			case YIELD_TOOLS:
+				break;
+             ///Armor
+            //case YIELD_LEATHER_ARMOR:///NEW*
+            //case YIELD_SCALE_ARMOR:///NEW*
+            //case YIELD_MAIL_ARMOR:///NEW*
+            //case YIELD_PLATE_ARMOR:///NEW*
+            ///Armor^
+			//case YIELD_WEAPONS:
+			//case YIELD_HORSES:
+				iValue *= iWeaponsMultiplier;
+				iValue /= 100;
+				break;
+
+			case YIELD_TRADE_GOODS:
+				break;
+            ///TKs Invention Core Mod v 1.0
+            case YIELD_IDEAS:
+                if (getCurrentResearch() != NO_CIVIC)
+                {
+                    iValue *= iGoodsMultiplier;
+                    iValue /= GC.getCache_TK_IDEAS_CITY_VALUE();
+                }
+                else
+                {
+                   iValue = 0;
+                }
+				break;
+            //case YIELD_CATTLE:///NEW*
+            //case YIELD_GRAIN:///NEW*
+            //case YIELD_SPICES:///NEW*
+				//if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING) || AI_isStrategy(STRATEGY_BUILDUP))
+				{
+					iValue *= iNoblesMultiplier;
+					iValue /= 100;
+					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+					{
+						iValue *= iNoblesMultiplier;
+						iValue /= 100;
+					}
+				}
+				break;
+            ///TKe
+			case YIELD_HAMMERS:
+				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					iValue *= 125;
+					iValue /= 100;
+					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+					{
+						iValue *= 125;
+						iValue /= 100;
+					}
+				}
+				break;
+
+			case YIELD_BELLS:
+				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					iValue *= 150;
+					iValue /= 100;
+					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+					{
+						iValue *= 150;
+						iValue /= 100;
+					}
+				}
+				break;
+			case YIELD_CROSSES:
+			case YIELD_EDUCATION:
+            case YIELD_GOLD:///NEW*
+				iValue *= 100;
+				iValue /= iWeaponsMultiplier;
+				break;
+			default:
+			break;
+		}
+		}
+	}
+
+	iValue *= iAmount;
+	iValue /= 100;
+
+	return iValue;
+}
+///TKe
+void CvPlayerAI::AI_updateYieldValues()
+{
+	if (isNative())
+	{
+		return;
+	}
+
+	PlayerTypes eParent = getParent();
+
+	if (getParent() == NO_PLAYER)
+	{
+		eParent = getID();
+	}
+
+	CvPlayer& kParent = GET_PLAYER(eParent);
+	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
+	{
+		YieldTypes eYield = (YieldTypes)i;
+		int iValue = 0;
+
+		if (YieldGroup_AI_Buy_From_Europe(eYield))
+		{
+			iValue += kParent.getYieldSellPrice(eYield);
+		} else if (	YieldGroup_AI_Sell_To_Europe(eYield))
+		{	
+			iValue += kParent.getYieldBuyPrice(eYield);
+		} else if (eYield == YIELD_FOOD || YieldGroup_Luxury_Food(eYield) || eYield == YIELD_LUMBER || eYield == YIELD_STONE)
+		{
+			iValue += (kParent.getYieldSellPrice(eYield) + kParent.getYieldBuyPrice(eYield)) / 2;
+		} else if (!YieldGroup_Virtual(eYield))
+		{
+			FAssertMsg(false, CvString::format("No rule to set price for %s", GC.getYieldInfo(eYield).getType()));
+		}
+#if 0
+		switch (eYield)
+		{
+			//case YIELD_FOOD:
+            //case YIELD_GRAIN:///NEW*
+				iValue += (kParent.getYieldSellPrice(eYield) + kParent.getYieldBuyPrice(eYield)) / 2;
+				break;
+			//case YIELD_LUMBER:
+            //case YIELD_STONE:///NEW*
+				iValue += (kParent.getYieldSellPrice(eYield) + kParent.getYieldBuyPrice(eYield)) / 2;
+				break;
+            ///Bonus Resources
+            //case YIELD_SHEEP:///NEW*
+            //case YIELD_WOOL:///NEW*
+            //case YIELD_SALT:///NEW*
+            ///Food Goods^
+			//case YIELD_SILVER:
+			//case YIELD_COTTON:
+			//case YIELD_FUR:
+			//case YIELD_BARLEY:
+			//case YIELD_GRAPES:
+			//case YIELD_ORE:
+			//case YIELD_CLOTH:
+			//	iValue += kParent.getYieldBuyPrice(eYield);
+			//	break;
+
+			//case YIELD_COATS:
+			//case YIELD_ALE:
+			//case YIELD_WINE:
+				iValue += kParent.getYieldBuyPrice(eYield);
+				break;
+
+			//case YIELD_TOOLS:
+			//case YIELD_WEAPONS:
+			//case YIELD_HORSES:
+			///Armor
+            //case YIELD_LEATHER_ARMOR:///NEW*
+            //case YIELD_SCALE_ARMOR:///NEW*
+            //case YIELD_MAIL_ARMOR:///NEW*
+            //case YIELD_PLATE_ARMOR:///NEW*
+            ///Armor^
+            //case YIELD_SPICES:///NEW*
+            //case YIELD_CATTLE:///NEW*
+				iValue += kParent.getYieldSellPrice(eYield);
+				break;
+
+			//case YIELD_TRADE_GOODS:
+				iValue += kParent.getYieldSellPrice(eYield);
+				break;
+			///TKs Invention Core Mod v 1.0
+            case YIELD_IDEAS:
+            case YIELD_CULTURE:
+            ///TKe
+			case YIELD_HAMMERS:
+			case YIELD_BELLS:
+			case YIELD_CROSSES:
+			case YIELD_EDUCATION:
+            case YIELD_GOLD:///NEW*
+				break;
+			default:
+				FAssert(false);
+		}
+#endif
+		m_aiYieldValuesTimes100[i] = 100 * iValue;
+	}
+	int iCrossValue = m_aiYieldValuesTimes100[YIELD_FOOD] * getGrowthThreshold(1) / (50 + immigrationThreshold() * GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getGrowthPercent() / 100);
+	iCrossValue /= 2;
+
+	//Crosses
+	m_aiYieldValuesTimes100[YIELD_CROSSES] = std::max(m_aiYieldValuesTimes100[YIELD_CROSSES], iCrossValue);
+
+	//The function is quite simple. Iterate over every citizen which has input yield.
+	//Calculate the value of their output yield, and assign half of that to the input.
+	if (!isHuman())
+	{
+		int iLoop;
+		CvCity* pLoopCity;
+		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+		{
+			for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+			{
+				CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
+
+				ProfessionTypes eProfession = pLoopUnit->getProfession();
+				if (eProfession != NO_PROFESSION)
+				{
+					CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+					if (kProfession.getYieldsConsumed(0, getID()) != NO_YIELD)
+					{
+						int iValue = 0;
+						// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+						FAssert(kProfession.getYieldsProduced(0) != NO_YIELD);//damn welfware cheats.
+
+						int iInput = pLoopCity->getProfessionInput(eProfession, pLoopUnit);
+						int iOutput = pLoopCity->getProfessionOutput(eProfession, pLoopUnit);
+						///Tks Debug
+						if (iInput <= 0)
+						{
+							iInput = 1;
+						}
+						///TKe
+						int iProfit = (m_aiYieldValuesTimes100[kProfession.getYieldsProduced(0)] * iOutput);
+						// MultipleYieldsProduced End
+						int iInputValue = iProfit / (2 * iInput); //Assign 50% of the yield value to the input.
+						m_aiYieldValuesTimes100[kProfession.getYieldsConsumed(0, getID())] = std::max(iInputValue, m_aiYieldValuesTimes100[kProfession.getYieldsConsumed(0, getID())]);
+					}
+				}
+				ProfessionTypes eIdealProfesion = AI_idealProfessionForUnit(pLoopUnit->getUnitType());
+				if (eIdealProfesion != NO_PROFESSION && eIdealProfesion != eProfession)
+				{
+					CvProfessionInfo& kIdealPro = GC.getProfessionInfo(eIdealProfesion);
+					YieldTypes eYieldConsumed = (YieldTypes)kIdealPro.getYieldsConsumed(0, getID());
+					if (eYieldConsumed != NO_YIELD)
+					{
+						// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+						YieldTypes eYieldProduced = (YieldTypes)kIdealPro.getYieldsProduced(0);
+						FAssert(kIdealPro.getYieldsProduced(0) != NO_YIELD);
+						// MultipleYieldsProduced End
+						int iInputValue = m_aiYieldValuesTimes100[eYieldProduced] / 2;
+						m_aiYieldValuesTimes100[eYieldConsumed] = std::max(iInputValue, m_aiYieldValuesTimes100[eYieldConsumed]);
+					}
+				}
+			}
+		}
+	}
+}
+
+int CvPlayerAI::AI_transferYieldValue(const IDInfo target, YieldTypes eYield, int iAmount)
+{
+	FAssertMsg(eYield > NO_YIELD, "Index out of bounds");
+	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
+
+	const IDInfo kEurope(getID(), CvTradeRoute::EUROPE_CITY_ID);
+	CvCity* pCity = ::getCity(target);
+
+	int iValue = 0;
+	if (pCity != NULL)
+	{
+		int iStored = pCity->getYieldStored(eYield);
+		///TKs Med
+		int iMaxCapacity = (eYield == YIELD_FOOD || YieldGroup_Luxury_Food(eYield)) ? pCity->growthThreshold() : pCity->getMaxYieldCapacity(eYield);
+		///Tke
+		int iMaintainLevel = pCity->getMaintainLevel(eYield);
+		FAssert(iMaxCapacity > 0);
+		if (iAmount < 0) // Loading
+		{
+			int iSurplus = iStored - iMaintainLevel;
+			if (iSurplus > 0)
+			{
+				iValue = std::min(iSurplus, -iAmount);
+                ///TKs Med
+				int iMaxCapacity = (eYield == YIELD_FOOD || YieldGroup_Luxury_Food(eYield)) ? pCity->growthThreshold() : iMaxCapacity = pCity->getMaxYieldCapacity(eYield);
+				///TKe
+				FAssert(iMaxCapacity > 0);
+				iValue *= 50 + ((100 * iStored) / std::max(1, iMaxCapacity));
+				if (iStored >= iMaxCapacity)
+				{
+					iValue *= 125 + ((100 * (iStored - iMaxCapacity)) / iMaxCapacity);
+					iValue /= 100;
+				}
+			}
+		}
+		else //Unloading
+		{
+			if (iAmount > 0)
+			{
+				iStored += (pCity->AI_getTransitYield(eYield) * 75) / 100;
+			}
+
+			iValue = iAmount * 100;
+			if (iStored > iMaxCapacity)
+			{
+				iValue *= 10;
+				iValue /= 100 + ((100 * (iStored - iMaxCapacity)) / iMaxCapacity);
+			}
+			else
+			{
+				iValue *=  std::max(10, 10 + (100 * (iMaxCapacity - pCity->getYieldStored(eYield))) / std::max(1, 10 + iMaxCapacity));
+				iValue /= 100;
+			}
+
+			if (iStored < iMaintainLevel)
+			{
+				FAssert(iMaintainLevel > 0);
+				iValue *= 125 + 75 * (iMaintainLevel - iStored) / iMaintainLevel;
+				iValue /= 100;
+			}
+
+			int iProductionNeeded = 0;
+			UnitTypes eUnit = pCity->getProductionUnit();
+			if (eUnit != NO_UNIT)
+			{
+				iProductionNeeded = std::max(iProductionNeeded, pCity->getYieldProductionNeeded(eUnit, eYield));
+			}
+			BuildingTypes eBuilding = pCity->getProductionBuilding();
+			if (eBuilding != NO_BUILDING)
+			{
+				iProductionNeeded = std::max(iProductionNeeded, pCity->getYieldProductionNeeded(eBuilding, eYield));
+			}
+
+			if (iStored > 0 && iStored < iProductionNeeded)
+			{
+				iValue *= 150 + 100 * (iProductionNeeded - iStored) / iProductionNeeded;
+				iValue /= 100;
+			}
+		}
+	}
+	else if (target == kEurope)
+	{
+		if (iAmount < 0) //Loading
+		{
+			iValue = -iAmount;
+		}
+		else
+		{
+			iValue = iAmount;
+		}
+	}
+	else
+	{
+		FAssertMsg(false, "Invalid Route Destination");
+	}
+
+	return iValue;
+}
+
+int CvPlayerAI::AI_countYieldWaiting()
+{
+	int iCount = 0;
+	int iLoop;
+	CvCity* pLoopCity;
+
+	int iUnitSize = GC.getGameINLINE().getCargoYieldCapacity();
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity->AI_isPort())
+		{
+			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+			{
+				YieldTypes eLoopYield = (YieldTypes)iYield;
+				int iTotal = pLoopCity->getYieldStored(eLoopYield);
+				if (iTotal > 0)
+				{
+					if (pLoopCity->AI_shouldExportYield(eLoopYield))
+					{
+						iCount += (iTotal + iUnitSize / 2) / iUnitSize;
+					}
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_highestYieldAdvantage(YieldTypes eYield)
+{
+	int iBestValue = 0;
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		iBestValue = std::max(iBestValue, pLoopCity->AI_getYieldAdvantage(eYield));
+	}
+	return iBestValue;
+}
+
+//Big function to do everything.
+void CvPlayerAI::AI_manageEconomy()
+{
+	if (getNumCities() == 0)
+	{
+		return;
+	}
+
+	bool bAtWar = (GET_TEAM(getTeam()).getAnyWarPlanCount() > 0);
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
+		{
+			int iWeight = 100;
+			YieldTypes eLoopYield = (YieldTypes)iI;
+
+			if (isNative())
+			{
+				iWeight = 60 + GC.getGame().getSorenRandNum(40, "AI Native Yield Value Randomization 1");
+
+				if (pLoopCity->getTeachUnitClass() != NO_UNITCLASS)
+				{
+					UnitTypes eUnit = (UnitTypes)GC.getUnitClassInfo(pLoopCity->getTeachUnitClass()).getDefaultUnitIndex();
+					if (eUnit != NO_UNIT)
+					{
+						iWeight += GC.getUnitInfo(eUnit).getYieldModifier(eLoopYield);
+					}
+				}
+///Tks Med
+				if (eLoopYield == YIELD_FOOD || YieldGroup_Luxury_Food(eLoopYield))
+				{
+					iWeight += bAtWar ? 20 : 0;
+				}
+				else if (eLoopYield == YIELD_ORE)
+				{
+					iWeight *= 20 + GC.getGame().getSorenRandNum(80, "AI Native Yield Value Randomization 3");
+					iWeight /= 100;
+				}
+				else if (GC.isEquipmentType(eLoopYield, EQUIPMENT_ARMOR_HORSES))
+				{
+					iWeight += bAtWar ? 20 : 0;
+				}
+				///tke
+
+				int iTotalStored = countTotalYieldStored(eLoopYield);
+				int iMaxStored = getNumCities() * GC.getGameINLINE().getCargoYieldCapacity();
+				iMaxStored *= GC.getYieldInfo(eLoopYield).getNativeConsumptionPercent();
+
+				int iModifier = 1 + std::max(10, 100 - (100 * iTotalStored) / iMaxStored);
+				iWeight *= iModifier;
+				iWeight /= 100;
+			}
+
+			int iEmphasize = 0;
+			for (int i = 0; i < GC.getNumEmphasizeInfos(); ++i)
+			{
+				if (pLoopCity->AI_isEmphasize((EmphasizeTypes)i))
+				{
+					CvEmphasizeInfo& kEmphasize = GC.getEmphasizeInfo((EmphasizeTypes)i);
+					int iValue = kEmphasize.getYieldChange(eLoopYield);
+					if (iValue != 0)
+					{
+						iEmphasize = iValue;
+						break;
+					}
+				}
+			}
+
+			iWeight *= 100 + 133 * std::max(0, iEmphasize);
+			iWeight /= 100 + 166 * std::max(0, -iEmphasize);
+
+			pLoopCity->AI_setYieldOutputWeight(eLoopYield, iWeight);
+		}
+	}
+
+	//Calculate Comparative Advantage in producing various yields.
+
+	//For averages.
+	int aiBestYield[NUM_YIELD_TYPES];
+	int aiWorstYield[NUM_YIELD_TYPES];
+
+	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
+	{
+		aiBestYield[iYield] = 0;
+		aiWorstYield[iYield] = MAX_INT;
+	}
+
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		for (int i = 0; i < GC.getNumProfessionInfos(); ++i)
+		{
+			CvProfessionInfo& kProfession = GC.getProfessionInfo((ProfessionTypes)i);
+
+			if (kProfession.isCitizen())
+			{
+				// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+				YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
+				// MultipleYieldsProduced End
+				if (eYield != NO_YIELD)
+				{
+					int iOutput = pLoopCity->getProfessionOutput((ProfessionTypes)i, NULL);
+					pLoopCity->AI_setYieldAdvantage(eYield, iOutput);
+
+					aiBestYield[eYield] = std::max(aiBestYield[eYield], iOutput);
+					aiWorstYield[eYield] = std::min(aiWorstYield[eYield], iOutput);
+				}
+			}
+		}
+	}
+
+	if (!isNative())
+	{
+		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+		{
+			int iAdvantageCount = 0;
+			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+			{
+				YieldTypes eYield = (YieldTypes)iYield;
+				if (aiBestYield[eYield] > 0)
+				{
+					int iAdvantage = (100 * pLoopCity->AI_getYieldAdvantage(eYield)) / aiBestYield[eYield];
+					if (aiBestYield[eYield] == aiWorstYield[eYield])
+					{
+						iAdvantage *= 99;
+						iAdvantage /= 100;
+					}
+					if (iAdvantage == 100)
+					{
+						iAdvantageCount++;
+					}
+					pLoopCity->AI_setYieldAdvantage(eYield, iAdvantage);
+				}
+			}
+			pLoopCity->AI_setTargetSize(std::max(pLoopCity->getHighestPopulation(), 2 + iAdvantageCount * 3));
+		}
+	}
+
+}
+
+CvPlot* CvPlayerAI::AI_getTerritoryCenter() const
+{
+	if (getNumCities() == 0)
+	{
+		return NULL;
+	}
+
+	CvCity* pLoopCity;
+	int iLoop;
+
+	int iTotalX = 0;
+	int iTotalY = 0;
+	int iTotalWeight = 0;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		int iWeight = 1 + 10 * pLoopCity->AI_getTargetSize();
+		if (pLoopCity->area()->getCitiesPerPlayer(getID()) == 1)
+		{
+			iWeight /= 2;
+		}
+		iWeight = std::max(1, iWeight);
+
+		iTotalX += pLoopCity->getX_INLINE() * iWeight;
+		iTotalY += pLoopCity->getY_INLINE() * iWeight;
+		iTotalWeight += iWeight;
+	}
+
+	if (iTotalWeight == 0)
+	{
+		return NULL;
+	}
+
+	iTotalX += iTotalWeight / 2;
+	iTotalY += iTotalWeight / 2;
+
+	return GC.getMapINLINE().plotINLINE(iTotalX / iTotalWeight, iTotalY / iTotalWeight);
+}
+
+int CvPlayerAI::AI_getTerritoryRadius() const
+{
+	return 10;
+}
+
+void CvPlayerAI::AI_createNatives()
+{
+	AI_createNativeCities();
+	if (getNumCities() == 0)
+	{
+		return;
+	}
+
+	int iLoop;
+	CvCity* pLoopCity;
+	int iCount = 0;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+
+		int iExtraPop = std::max(1, ((getNumCities() - iCount) * 3) / getNumCities());
+
+		if (iCount == 0)
+		{
+			iExtraPop++;
+		}
+
+		//Require a certain minimum food surplus.
+		while ((pLoopCity->AI_getFoodGatherable(1 + iExtraPop, GC.getFOOD_CONSUMPTION_PER_POPULATION()) / 2) < GC.getFOOD_CONSUMPTION_PER_POPULATION() * (1 + iExtraPop))
+		{
+			iExtraPop--;
+			if (iExtraPop == 0)
+			{
+				iExtraPop = 1;
+				break;
+			}
+		}
+
+		pLoopCity->changePopulation(iExtraPop);
+		pLoopCity->AI_setTargetSize(pLoopCity->getPopulation());
+
+		iCount++;
+
+		int iBraveCount = pLoopCity->getPopulation() + 2;
+		for (int iI = 0; iI < iBraveCount; iI++)
+		{
+			UnitTypes eBrave = AI_bestUnit(UNITAI_DEFENSIVE);
+			if (eBrave != NO_UNIT)
+			{
+				initUnit(eBrave, (ProfessionTypes) GC.getUnitInfo(eBrave).getDefaultProfession(), pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE());
+			}
+		}
+	}
+
+	for (int iPass = 0; iPass < 2; ++iPass)
+	{
+		//Now provide some starting yield stockpiles.
+		AI_manageEconomy();
+		int aiYields[NUM_YIELD_TYPES];
+		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+		{
+			pLoopCity->AI_assignWorkingPlots();
+			pLoopCity->calculateNetYields(aiYields);
+
+			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+			{
+				YieldTypes eYield = (YieldTypes) iYield;
+				if (GC.getYieldInfo(eYield).isCargo())
+				{
+					pLoopCity->changeYieldStored(eYield, (aiYields[eYield] * (50 + GC.getGameINLINE().getSorenRandNum(50, "AI starting yields"))) / 10);
+				}
+			}
+		}
+	}
+}
+
+void CvPlayerAI::AI_createNativeCities()
+{
+	while (true)
+	{
+		int iBestValue = 0;
+		CvPlot* pBestPlot = NULL;
+		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+		{
+			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+			int iValue = AI_foundValueNative(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
+			if (iValue > iBestValue)
+			{
+				iBestValue = iValue;
+				pBestPlot = pLoopPlot;
+			}
+		}
+		if (pBestPlot == NULL)
+		{
+			break;
+		}
+
+		CvCity* pCity = pBestPlot->getPlotCity();
+		if (pCity != NULL)
+		{
+			FAssertMsg(false, "City already exists!");
+			break;
+		}
+
+		found(pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE());
+		pCity = pBestPlot->getPlotCity();
+		if (pCity == NULL)
+		{
+			FAssertMsg(false, "Cannot found city!");
+			break;
+		}
+		pCity->setCulture(getID(), 1, true);
+	}
+
+	for(int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+	{
+		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+		int iCulture = 0;
+		int iOursCount = 0;
+		if (pLoopPlot->isCityRadius())
+		{
+			if (pLoopPlot->getOwnerINLINE() == getID())
+			{
+				iCulture += 90;//XMLize and adjust for game speed...
+				if (pLoopPlot->getWorkingCity() != NULL)
+				{
+					iCulture += 10 * pLoopPlot->getWorkingCity()->getPopulation();
+				}
+			}
+		}
+		else
+		{
+			for (int iJ = 0; iJ < NUM_DIRECTION_TYPES; iJ++)
+			{
+				CvPlot* pDirectionPlot = plotDirection(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), (DirectionTypes)iJ);
+				if (pDirectionPlot != NULL)
+				{
+					if (pDirectionPlot->isCityRadius() && pDirectionPlot->getOwnerINLINE() == getID())
+					{
+						iOursCount++;
+					}
+				}
+			}
+
+			int iRand = GC.getGame().getSorenRandNum(2, "AI plot");
+			if ((iOursCount >= 3 + iRand) && (pLoopPlot->getOwnerINLINE() == getID() || !pLoopPlot->isOwned()))
+			{
+				iCulture += 40 + 10 * iOursCount;
+			}
+			else if (pLoopPlot->getOwnerINLINE() == getID())
+			{
+				pLoopPlot->setOwner(NO_PLAYER, false);
+			}
+		}
+
+		int iBestYield = 0;
+		int iTotalYield = 0;
+		if (iCulture > 0)
+		{
+			for (int i = 0; i < NUM_YIELD_TYPES; i++)
+			{
+				YieldTypes eYield = (YieldTypes)i;
+				iBestYield = std::max(iBestYield, pLoopPlot->getYield(eYield));
+				iTotalYield += pLoopPlot->getYield(eYield);
+			}
+
+			iCulture += 10 * iBestYield + (5 * (iTotalYield - iBestYield));
+
+			if (pLoopPlot->getFeatureType() != NO_FEATURE)
+			{
+				iCulture += pLoopPlot->getYield(YIELD_LUMBER) * 5;
+			}
+
+			iCulture *= 100 + GC.getGameINLINE().getSorenRandNum(40, "Native Plot Culture");
+			iCulture /= 100;
+			pLoopPlot->setCulture(getID(), iCulture, true);
+		}
+	}
+
+
+	for(int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+	{
+		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+
+
+		if (pLoopPlot->getOwnerINLINE() == getID())
+		{
+			int iOursCount = 0;
+			for (int iJ = 0; iJ < NUM_DIRECTION_TYPES; iJ++)
+			{
+				CvPlot* pDirectionPlot = plotDirection(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), (DirectionTypes)iJ);
+				if (pDirectionPlot != NULL)
+				{
+					if (pDirectionPlot->getOwnerINLINE() == getID())
+					{
+
+						if (pLoopPlot->getX_INLINE() == pDirectionPlot->getX_INLINE() || pLoopPlot->getY_INLINE() == pDirectionPlot->getY_INLINE())
+						{
+							iOursCount++;
+						}
+					}
+				}
+			}
+			if (iOursCount <= 1)
+			{
+				pLoopPlot->setCulture(getID(), 0, true);
+			}
+		}
+	}
+}
+
+bool CvPlayerAI::AI_isKing()
+{
+	return isEurope();
+}
+
+CvPlot* CvPlayerAI::AI_getImperialShipSpawnPlot()
+{
+	CvPlot* pBestPlot = NULL;
+	int iBestValue = 0;
+
+	std::deque<bool> zoneAllowable(GC.getNumEuropeInfos(), false);
+	bool bNoneAllowable = true;
+	for (int iI = 0; iI < MAX_PLAYERS; ++iI)
+	{
+		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);
+		if (kPlayer.isAlive() && (kPlayer.getParent() == getID()))
+		{
+			if (kPlayer.getStartingPlot() != NULL)
+			{
+				if (kPlayer.getStartingPlot()->getEurope() != NO_EUROPE)
+				{
+					zoneAllowable[kPlayer.getStartingPlot()->getEurope()] = true;
+					bNoneAllowable = false;
+				}
+			}
+		}
+	}
+
+	CvTeamAI& kTeam = GET_TEAM(getTeam());
+
+	CvPlot* pTargetPlot = NULL;
+
+	if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK))
+	{
+		pTargetPlot = GC.getMapINLINE().plotByIndexINLINE(AI_getStrategyData(STRATEGY_CONCENTRATED_ATTACK));
+	}
+
+	for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+	{
+		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+
+		EuropeTypes eEurope = pLoopPlot->getEurope();
+		if (eEurope != NO_EUROPE)
+		{
+			if (bNoneAllowable || zoneAllowable[eEurope])
+			{
+				int iEnemyDistance = kTeam.AI_enemyCityDistance(pLoopPlot);
+				int iValue = (bNoneAllowable || (!bNoneAllowable && iEnemyDistance == -1)) ? 100 : (10000 / (std::max(1, iEnemyDistance - 2)));
+
+				int iLocation = 50;
+				switch ((CardinalDirectionTypes)GC.getEuropeInfo(eEurope).getCardinalDirection())
+				{
+				case CARDINALDIRECTION_EAST:
+				case CARDINALDIRECTION_WEST:
+					iLocation = (100 * pLoopPlot->getY_INLINE() + 50) / GC.getMapINLINE().getGridHeightINLINE();
+					break;
+				case CARDINALDIRECTION_NORTH:
+				case CARDINALDIRECTION_SOUTH:
+					iLocation = (100 * pLoopPlot->getX_INLINE() + 50) / GC.getMapINLINE().getGridWidthINLINE();
+					break;
+				default:
+					break;
+				}
+
+				if (AI_isStrategy(STRATEGY_DISTRIBUTED_ATTACK))
+				{
+					iValue /= 1 + AI_plotTargetMissionAIs(pLoopPlot, MISSIONAI_ASSAULT, NULL, 1);
+
+					int iModifier = 2 * std::abs(iLocation - 50);
+
+					if (iModifier > 95)
+					{
+						iModifier = 1;
+					}
+					else if (iModifier > 80)
+					{
+						iModifier *= (100 - iModifier);
+						iModifier /= 100;
+					}
+					else
+					{
+						iModifier += 10;
+					}
+
+					iValue *= iModifier;
+					iValue /= 100;
+				}
+				if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK))
+				{
+					iValue /= 1 + AI_plotTargetMissionAIs(pLoopPlot, MISSIONAI_ASSAULT, NULL, 1);
+
+					if (pTargetPlot == NULL)
+					{
+						int iModifier = 100 - 2 * std::abs(iLocation - 50);
+
+						if (iModifier < 10)
+						{
+							iModifier = 1;
+						}
+						iValue *= iModifier;
+						iValue /= 100;
+					}
+					else
+					{
+						iValue *= 10;
+						iValue /= std::max(1, stepDistance(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE()) - 3);
+					}
+				}
+
+				iValue *= 25 + GC.getGameINLINE().getSorenRandNum(75, "AI best imperial ship spawn plot");
+
+				if (iValue > iBestValue)
+				{
+					iBestValue = iValue;
+					pBestPlot = pLoopPlot;
+				}
+			}
+		}
+	}
+
+	FAssert(pBestPlot != NULL);
+
+	return pBestPlot;
+}
+
+void CvPlayerAI::AI_addUnitToMoveQueue(CvUnit* pUnit)
+{
+	if (std::find(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), pUnit->getID()) == m_unitPriorityHeap.end())
+	{
+		m_unitPriorityHeap.push_back(pUnit->getID());
+		std::push_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
+	}
+	else
+	{
+		std::make_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
+	}
+}
+
+void CvPlayerAI::AI_removeUnitFromMoveQueue(CvUnit* pUnit)
+{
+	std::vector<int>::iterator it;
+	it = std::find(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), pUnit->getID());
+	if (it != m_unitPriorityHeap.end())
+	{
+		m_unitPriorityHeap.erase(it);
+		std::make_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
+	}
+}
+
+void CvPlayerAI::AI_verifyMoveQueue()
+{
+	std::vector<int>::iterator it = std::partition(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldUnitMove(getID()));
+	m_unitPriorityHeap.erase(it, m_unitPriorityHeap.end());
+	std::make_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
+}
+
+CvUnit* CvPlayerAI::AI_getNextMoveUnit()
+{
+	CvUnit* pUnit = getUnit(m_unitPriorityHeap.front());
+	std::pop_heap(m_unitPriorityHeap.begin(), m_unitPriorityHeap.end(), CvShouldMoveBefore(getID()));
+	m_unitPriorityHeap.pop_back();
+	return pUnit;
+}
+
+int CvPlayerAI::AI_highestProfessionOutput(ProfessionTypes eProfession, const CvCity* pIgnoreCity)
+{
+	int iLoop;
+	CvCity* pLoopCity;
+
+	int iBestYield = 0;
+
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity != pIgnoreCity)
+		{
+			iBestYield = std::max(iBestYield, pLoopCity->getProfessionOutput(eProfession, NULL));
+
+			//Also consider buildings under construction.
+			CLLNode<OrderData>* pOrderNode = pLoopCity->headOrderQueueNode();
+
+			while (pOrderNode != NULL)
+			{
+				switch (pOrderNode->m_data.eOrderType)
+				{
+				case ORDER_TRAIN:
+				case ORDER_CONVINCE:
+					break;
+
+				case ORDER_CONSTRUCT:
+					{
+						BuildingTypes eBuilding = ((BuildingTypes)(pOrderNode->m_data.iData1));
+						if (eBuilding != NO_BUILDING)
+						{
+							if (GC.getProfessionInfo(eProfession).getSpecialBuilding() == GC.getBuildingInfo(eBuilding).getSpecialBuildingType())
+							{
+								iBestYield = std::max(iBestYield, GC.getBuildingInfo(eBuilding).getProfessionOutput());
+							}
+						}
+						break;
+					}
+
+				default:
+					FAssertMsg(false, "pOrderNode->m_data.eOrderType failed to match a valid option");
+					break;
+				}
+				pOrderNode = pLoopCity->nextOrderQueueNode(pOrderNode);
+			}
+		}
+	}
+
+	return iBestYield;
+}
+
+CvCity* CvPlayerAI::AI_bestCityForBuilding(BuildingTypes eBuilding)
+{
+	int iBestValue = 0;
+	CvCity* pBestCity = NULL;
+
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (!pLoopCity->isHasConceptualBuilding(eBuilding))
+		{
+			int iValue = pLoopCity->AI_buildingValue(eBuilding);
+			if (iValue > iBestValue)
+			{
+				pBestCity = pLoopCity;
+				iBestValue = iValue;
+			}
+		}
+	}
+
+	return pBestCity;
+}
+
+UnitTypes CvPlayerAI::AI_bestUnit(UnitAITypes eUnitAI, CvArea* pArea)
+{
+	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
+
+	int iBestValue = 0;
+	UnitTypes eBestUnit = NO_UNIT;
+
+	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
+
+		if (eLoopUnit != NO_UNIT)
+		{
+			if (eUnitAI == NO_UNITAI || GC.getUnitInfo(eLoopUnit).getDefaultUnitAIType() == eUnitAI)
+			{
+
+				int iValue = AI_unitValue(eLoopUnit, eUnitAI, pArea);
+
+				if (iValue > 0)
+				{
+					iValue *= (GC.getGameINLINE().getSorenRandNum(40, "AI Best Unit") + 100);
+					iValue /= 100;
+
+					iValue *= (getNumCities() + 2);
+					iValue /= (getUnitClassCountPlusMaking((UnitClassTypes)iI) + getNumCities() + 2);
+
+					FAssert((MAX_INT / 1000) > iValue);
+					iValue *= 1000;
+
+					iValue = std::max(1, iValue);
+
+					if (iValue > iBestValue)
+					{
+						iBestValue = iValue;
+						eBestUnit = eLoopUnit;
+					}
+				}
+			}
+		}
+	}
+
+	return eBestUnit;
+}
+
+int CvPlayerAI::AI_desiredCityCount()
+{
+	bool bDense = AI_isStrategy(STRATEGY_DENSE_CITY_SPACING);
+	int iCount = 0;
+
+	int iStep = 4;
+
+	int iTotal = getTotalPopulation();
+	if (AI_isStrategy(STRATEGY_DENSE_CITY_SPACING))
+	{
+		iTotal *= 133;
+		iTotal /= 100;
+	}
+
+	while (iTotal > 0)
+	{
+		iTotal -= iStep;
+		iStep += 3 + std::max(0, iCount - 4);
+
+		iCount++;
+	}
+
+	return std::max(1, iCount);
+}
+
+int CvPlayerAI::AI_professionBasicValue(ProfessionTypes eProfession, UnitTypes eUnit, CvCity* pCity)
+{
+	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+	// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+	YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
+	// MultipleYieldsProduced End
+	if (eYield == NO_YIELD)
+	{
+		return 0;
+	}
+
+	CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
+	int iBestValue = 0;
+
+	if (kProfession.isCitizen())
+	{
+		if (!kProfession.isWorkPlot())
+		{
+			int iNewOutput = pCity->AI_professionBasicOutput(eProfession, eUnit, NULL);
+			int iProfessionCount = 0;
+			bool bDone = false;
+			for (int i = 0; i < pCity->getPopulation(); ++i)
+			{
+				CvUnit* pLoopUnit = pCity->getPopulationUnitByIndex(i);
+				if (pLoopUnit->getProfession() == eProfession)
+				{
+					int iOldOutput = pCity->AI_professionBasicOutput(eProfession, pLoopUnit->getUnitType(), NULL);
+
+					if (iNewOutput > iOldOutput)
+					{
+						int iValue = AI_yieldValue(eYield, true, iNewOutput);
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							break;
+						}
+					}
+					else
+					{
+						iProfessionCount ++;
+					}
+				}
+			}
+			if (iBestValue == 0)
+			{
+				if (iProfessionCount < pCity->getNumProfessionBuildingSlots(eProfession))
+				{
+					iBestValue = AI_yieldValue(eYield, true, iNewOutput);
+				}
+			}
+		}
+		else
+		{
+			for (int i = 0; i < NUM_CITY_PLOTS; ++i)
+			{
+				CvPlot* pLoopPlot = plotCity(pCity->getX_INLINE(), pCity->getY_INLINE(), i);
+				if ((pLoopPlot != NULL) && (pLoopPlot->getWorkingCity()==pCity))
+				{
+					int iNewOutput = pCity->AI_professionBasicOutput(eProfession, eUnit, pLoopPlot);
+					int iOldOutput = 0;
+					if (pLoopPlot->isBeingWorked())
+					{
+						CvUnit* pWorkingUnit = pCity->getUnitWorkingPlot(pLoopPlot);
+						if (pWorkingUnit != NULL)
+						{
+							if ((pWorkingUnit->getProfession() == eProfession))
+							{
+								iOldOutput = pCity->AI_professionBasicOutput(eProfession, pWorkingUnit->getUnitType(), pLoopPlot);
+								if (iNewOutput <= iOldOutput)
+								{
+									iNewOutput = 0;
+								}
+							}
+							else
+							{
+								bool bOverride = false;
+								if ((pLoopPlot->getBonusType() != NO_BONUS) && (GC.getBonusInfo(pLoopPlot->getBonusType()).getYieldChange(eYield) > 0))
+								{
+									bOverride = true;
+								}
+								if (!bOverride)
+								{
+									int iBestYield = AI_getBestPlotYield(eYield);
+									if (pLoopPlot->getBonusType() == NO_BONUS)
+									{
+										if (pLoopPlot->calculateBestNatureYield(eYield, getTeam()) >= iBestYield)
+										{
+											bOverride = true;
+										}
+									}
+								}
+								if (!bOverride)
+								{
+									iNewOutput = 0;
+								}
+							}
+						}
+					}
+
+					if (iNewOutput > iOldOutput)
+					{
+						int iValue = AI_yieldValue(eYield, true, iNewOutput);
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return iBestValue;
+}
+
+int CvPlayerAI::AI_professionUpgradeValue(ProfessionTypes eProfession, UnitTypes eUnit)
+{
+	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+	// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+	YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
+	// MultipleYieldsProduced End
+	if (eYield == NO_YIELD)
+	{
+		return 0;
+	}
+
+	CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
+
+	int iBestValue = 0;
+	CvCity* pBestCity = NULL;
+
+	int iLoop;
+	CvCity* pLoopCity;
+
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+		{
+			CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
+
+			if (pLoopUnit->getProfession() == eProfession)
+			{
+				int iExistingYield = 0;
+				int iNewYield = 0;
+				int iExtraMultiplier = 0;
+				if (kProfession.isWorkPlot())
+				{
+					CvPlot* pWorkedPlot = pLoopCity->getPlotWorkedByUnit(pLoopUnit);
+					if (pWorkedPlot != NULL)
+					{
+						iExistingYield = pWorkedPlot->calculatePotentialYield(eYield, getID(), pWorkedPlot->getImprovementType(), false, pWorkedPlot->getRouteType(), pLoopUnit->getUnitType(), false);
+						iNewYield = pWorkedPlot->calculatePotentialYield(eYield, getID(), pWorkedPlot->getImprovementType(), false, pWorkedPlot->getRouteType(), eUnit, false);
+						if (pWorkedPlot->getBonusType() != NO_BONUS && GC.getBonusInfo(pWorkedPlot->getBonusType()).getYieldChange(eYield) > 0)
+						{
+							iExtraMultiplier += 100;
+						}
+					}
+				}
+				else
+				{
+					CvUnitInfo& kLoopUnit = GC.getUnitInfo(pLoopUnit->getUnitType());
+					iExistingYield = pLoopCity->getProfessionOutput(eProfession, pLoopUnit);
+					iNewYield = (iExistingYield * 100) / (100 + kLoopUnit.getYieldModifier(eYield));
+					iNewYield -= kLoopUnit.getYieldChange(eYield);
+					iNewYield += kUnit.getYieldChange(eYield);
+					iNewYield = iNewYield * (100 + kUnit.getYieldModifier(eYield)) / 100;
+				}
+
+				if (iNewYield > iExistingYield)
+				{
+					int iValue = AI_yieldValue(eYield, true, iNewYield - iExistingYield);
+					iValue *= 100 + iExtraMultiplier;
+					iValue /= 100;
+					if (iValue > iBestValue)
+					{
+						iBestValue = iValue;
+						pBestCity = pLoopCity;
+					}
+				}
+			}
+		}
+	}
+
+	return iBestValue;
+}
+
+int CvPlayerAI::AI_professionValue(ProfessionTypes eProfession, UnitAITypes eUnitAI)
+{
+	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+	if (kProfession.isCitizen())
+	{
+		return 0;
+	}
+
+	int iValue = 0;
+	switch (eUnitAI)
+	{
+		case UNITAI_UNKNOWN:
+			break;
+
+		case UNITAI_COLONIST:
+			{
+				if (GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession() == eProfession)
+				{
+					iValue += 100;
+				}
+			}
+			break;
+
+		case UNITAI_SETTLER:
+			{
+				if (kProfession.canFound())
+				{
+					iValue += 100;
+				}
+			}
+			break;
+
+		case UNITAI_WORKER:
+			{
+				if (kProfession.getWorkRate() > 0)
+				{
+					iValue += kProfession.getWorkRate();
+				}
+			}
+			break;
+
+		case UNITAI_MISSIONARY:
+			{
+				if (kProfession.getMissionaryRate() > 0)
+				{
+					iValue += kProfession.getMissionaryRate();
+				}
+			}
+			break;
+		case UNITAI_SCOUT:
+			{
+				if (kProfession.isScout())
+				{
+					iValue += 50;
+				}
+				iValue += 50 * kProfession.getMovesChange();
+			}
+			break;
+        ///Tks Med
+		case UNITAI_TRADER:
+			{
+			    if (kProfession.getDefaultUnitAIType() != eUnitAI || AI_isKing())
+                {
+                    return 0;
+                }
+				iValue += 100 * kProfession.getMovesChange();
+			}
+			break;
+        ///Tke
+		case UNITAI_WAGON:
+		case UNITAI_TREASURE:
+		case UNITAI_YIELD:
+		case UNITAI_GENERAL:
+			break;
+
+		case UNITAI_DEFENSIVE:
+			{
+				int iExtraCombatStrength = kProfession.getCombatChange() - GC.getProfessionInfo((ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()).getCombatChange();
+				if (isNative())
+				{
+					iValue += 10;
+				}
+
+				if (!kProfession.isUnarmed() && iExtraCombatStrength > 0)
+				{
+					if (kProfession.isCityDefender())
+					{
+						iValue += iExtraCombatStrength * 25;
+					}
+				}
+			}
+			break;
+
+		case UNITAI_OFFENSIVE:
+			if (isNative())
+			{
+				iValue += 10;
+				int iExtraCombatStrength = kProfession.getCombatChange() - GC.getProfessionInfo((ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()).getCombatChange();
+				if (!kProfession.isUnarmed() && iExtraCombatStrength > 0)
+				{
+					iValue += iExtraCombatStrength * 15;
+					iValue += kProfession.getMovesChange() * 15;
+				}
+			}
+			break;
+		case UNITAI_COUNTER:
+			{
+				int iExtraCombatStrength = kProfession.getCombatChange() - GC.getProfessionInfo((ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession()).getCombatChange();
+				if (isNative())
+				{
+					iValue += 10;
+				}
+
+				if (isNative() || (!kProfession.isUnarmed() && iExtraCombatStrength > 0))
+				{
+					iValue += iExtraCombatStrength * 15;
+					iValue *= 1 + kProfession.getMovesChange();
+				}
+			}
+			break;
+
+		case UNITAI_TRANSPORT_SEA:
+		case UNITAI_ASSAULT_SEA:
+		case UNITAI_COMBAT_SEA:
+		case UNITAI_PIRATE_SEA:
+			break;
+		default:
+			FAssert(false);
+			break;
+	}
+	return iValue;
+}
+
+ProfessionTypes CvPlayerAI::AI_idealProfessionForUnit(UnitTypes eUnitType)
+{
+	int iBestValue = 0;
+	int iSecondBestValue = 0;
+	ProfessionTypes eBestProfession = NO_PROFESSION;
+	CvUnitInfo& kUnit = GC.getUnitInfo(eUnitType);
+
+	for (int iI = 0; iI < GC.getNumProfessionInfos(); ++iI)
+	{
+		ProfessionTypes eLoopProfession = (ProfessionTypes)iI;
+		CvProfessionInfo& kProfession = GC.getProfessionInfo(eLoopProfession);
+
+		if (kProfession.isCitizen())
+		{
+			// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+			YieldTypes eYield = (YieldTypes)kProfession.getYieldsProduced(0);
+			// MultipleYieldsProduced End
+			if (eYield != NO_YIELD)
+			{
+				int iValue = 0;
+
+				if (kProfession.isWater())
+				{
+					if (kUnit.isWaterYieldChanges())
+					{
+						iValue += kUnit.getYieldModifier(eYield);
+						iValue += 22 * kUnit.getYieldChange(eYield);
+						iValue += 17 * kUnit.getBonusYieldChange(eYield);
+					}
+				}
+				else
+				{
+					if (kUnit.isLandYieldChanges())
+					{
+						iValue += kUnit.getYieldModifier(eYield);
+						iValue += 22 * kUnit.getYieldChange(eYield);
+						iValue += 17 * kUnit.getBonusYieldChange(eYield);
+					}
+				}
+
+				if (iValue > iBestValue)
+				{
+					iBestValue = iValue;
+					eBestProfession = eLoopProfession;
+				}
+				else
+				{
+					iSecondBestValue = std::max(iSecondBestValue, iValue);
+				}
+			}
+		}
+	}
+	if (iBestValue == iSecondBestValue)
+	{
+		return NO_PROFESSION;
+	}
+	return eBestProfession;
+}
+
+
+ProfessionTypes CvPlayerAI::AI_idealProfessionForUnitAIType(UnitAITypes eUnitAI, CvCity* pCity)
+{
+	int iBestValue = 0;
+	ProfessionTypes eBestProfession = NO_PROFESSION;
+
+	for (int iI = 0; iI < GC.getNumProfessionInfos(); ++iI)
+	{
+		ProfessionTypes eLoopProfession = (ProfessionTypes)iI;
+		CvProfessionInfo& kProfession = GC.getProfessionInfo(eLoopProfession);
+
+		if (!(kProfession.isCitizen() || kProfession.isWorkPlot()))
+		{
+			if (GC.getCivilizationInfo(getCivilizationType()).isValidProfession(eLoopProfession))
+			{
+				CvUnit* pUnit = NULL;
+				if (pCity != NULL)
+				{
+					pUnit = pCity->getPopulationUnitByIndex(0);
+				}
+				if (pUnit == NULL || pUnit->canHaveProfession(eLoopProfession, true))
+				{
+					int iValue = AI_professionValue(eLoopProfession, eUnitAI);
+
+					if (iValue > iBestValue)
+					{
+						iBestValue = iValue;
+						eBestProfession = eLoopProfession;
+					}
+				}
+			}
+		}
+	}
+
+	return eBestProfession;
+}
+
+//100 means "An average use for Gold", so a higher multiplier here, means a higher priority on buying that unit type.
+//Most notably a "0" means "Don't bother".
+int CvPlayerAI::AI_unitAIValueMultipler(UnitAITypes eUnitAI)
+{
+	int iCount = AI_totalUnitAIs(eUnitAI) + AI_getNumRetiredAIUnits(eUnitAI);
+	int iPopulation = AI_getPopulation() + AI_getNumRetiredAIUnits(UNITAI_MISSIONARY);
+	int iValue = 0;
+	switch (eUnitAI)
+	{
+		case UNITAI_UNKNOWN:
+		case UNITAI_MARAUDER:
+			break;
+
+		case UNITAI_COLONIST:
+			{
+				iValue = std::min(75, 20 + iPopulation);
+				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					iValue *= 75;
+					iValue /= 100;
+					if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+					{
+						iValue *= 75;
+						iValue /= 100;
+					}
+				}
+			}
+			break;
+
+		case UNITAI_SETTLER:
+			{
+				if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					int iDesiredCities = AI_desiredCityCount();
+					if (iDesiredCities > (getNumCities() + iCount))
+					{
+						iValue = 100 + 150 * (iDesiredCities - (getNumCities() + iCount));
+					}
+				}
+			}
+			break;
+
+		case UNITAI_WORKER:
+			if (!AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+			{
+				int iNeeded = AI_neededWorkers(NULL);
+
+				if (iNeeded > iCount)
+				{
+					iValue = 100 + 20 * iNeeded + (50 * iNeeded) / (iCount + 1);
+				}
+			}
+			break;
+
+		case UNITAI_MISSIONARY:
+			if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+			{
+				int iLowerPop = 12;
+				int iPop = 15 + iCount * 5;
+				int iModifier = 0;
+				iModifier -= getNativeCombatModifier() * 4;
+				iModifier += getMissionaryRateModifier();
+				iModifier += 10 * GC.getLeaderHeadInfo(getLeaderType()).getNativeAttitude();
+				iModifier += getMissionarySuccessPercent() - 50;
+				if (iModifier != 0)
+				{
+					iLowerPop *= 100 + std::max(0, -iModifier);
+					iLowerPop /= 100 + std::max(0, iModifier);
+					iPop *= 100 + std::max(0, -iModifier);
+					iPop /= 100 + std::max(0, iModifier);
+				}
+
+				iValue = (100 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
+				if (iValue > 0)
+				{
+					iValue += 100;
+				}
+			}
+			break;
+
+		case UNITAI_SCOUT:
+			if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+			{
+				if (iCount <= 1)
+				{
+					int iTotalUnexploredPlots = 0;
+
+					CvArea* pLoopArea;
+					int iLoop;
+					for(pLoopArea = GC.getMapINLINE().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMapINLINE().nextArea(&iLoop))
+					{
+						if (!(pLoopArea->isWater()))
+						{
+							iTotalUnexploredPlots += pLoopArea->getNumRevealedTiles(getTeam());
+						}
+					}
+
+					if (iTotalUnexploredPlots > 10)
+					{
+						if (iCount == 0)
+						{
+							iValue = 500;//scout is important.
+						}
+						else if (iCount == 1)
+						{
+							if ((iTotalUnexploredPlots > 500) && (iPopulation > 5))
+							{
+								iValue = 150;
+							}
+						}
+					}
+				}
+			}
+			break;
+
+		case UNITAI_WAGON:
+			{
+				int iNeeded = 1 + getNumCities() + (getNumCities() - countNumCoastalCities());
+				iNeeded /= 3;
+				if (getNumCities() > 1)
+				{
+					iNeeded = std::max(1, iNeeded);
+				}
+
+				if (iCount < iNeeded)
+				{
+					iValue = 100 + (100 * (iNeeded - iCount)) / iNeeded;
+				}
+			}
+			break;
+
+		case UNITAI_TREASURE:
+		///TKs Med Animal
+		case UNITAI_ANIMAL:
+		case UNITAI_HUNTSMAN:
+		case UNITAI_TRADER:
+		///TKe
+		case UNITAI_YIELD:
+		case UNITAI_GENERAL:
+			break;
+
+		case UNITAI_DEFENSIVE:
+			{
+				if (isNative())
+				{
+					return 100;
+				}
+				bool bAtWar = GET_TEAM(getTeam()).getAnyWarPlanCount();
+				int iLowerPop = bAtWar ? 8 : 15;
+				int iPop = bAtWar ? (10 + 5 * iCount) : 17 + 6 * iCount;
+				iValue = 110 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
+
+				int iUndefended = 0;
+				int iNeeded = AI_totalDefendersNeeded(&iUndefended);
+				if (iUndefended > 0)
+				{
+					iValue += 100 + ((200 * iUndefended) / (1 + getNumCities()));
+				}
+				iValue += (200 * iNeeded) / (1 + getNumCities());
+
+				if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+				{
+					iValue += 3000 / (25 + iCount);
+				}
+
+				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					iValue += 3000 / (25 + iCount);
+				}
+
+				if (getGold() > 5000)
+				{
+					iValue += 1;
+					iValue *= 2;
+				}
+			}
+			break;
+
+		case UNITAI_OFFENSIVE:
+			{
+				bool bAtWar = GET_TEAM(getTeam()).getAnyWarPlanCount();
+				int iLowerPop = bAtWar ? 9 : 15 ;
+				int iPop = bAtWar ? 10 : 20;
+				iValue = 100 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
+
+				if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+				{
+					iValue += 3000 / (40 + iCount);
+				}
+				else
+				{
+					if (iValue > 0)
+					{
+						iValue += 50 + getNativeCombatModifier() * 2;
+					}
+				}
+
+				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					iValue += 1500 / (40 + iCount);
+				}
+			}
+			break;
+
+		case UNITAI_COUNTER:
+			{
+				bool bAtWar = GET_TEAM(getTeam()).getAnyWarPlanCount();
+				int iPop = bAtWar ? 12 : 20;
+				int iLowerPop = bAtWar ? 8 : 14;
+				iValue = 100 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
+				if (iValue > 0)
+				{
+					iValue += 25;
+				}
+
+				if (AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+				{
+					iValue += 3000 / (25 + iCount);
+				}
+
+				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					iValue += 3000 / (25 + iCount);
+				}
+
+				if (getGold() > 5000)
+				{
+					iValue += 1;
+					iValue *= 2;
+				}
+			}
+			break;
+
+		case UNITAI_TRANSPORT_SEA:
+			if (!AI_isStrategy(STRATEGY_REVOLUTION))
+			{
+				if (iCount < 6)
+				{
+					int iLowerPop = 5 - countNumCoastalCities();
+					int iPop = 13 + 26 * iCount;
+					iValue = 150 * std::max(0, iPopulation - (iLowerPop + iPop * iCount)) / iPop;
+
+					iValue += 25 * std::max(0, AI_countYieldWaiting() - 4 * iCount);
+				}
+			}
+			break;
+
+		case UNITAI_ASSAULT_SEA:
+			{
+				int iLowerPop = 5;
+				int iPop = 15 + 50 * iCount;
+				iValue = (160 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
+			}
+		case UNITAI_COMBAT_SEA:
+			{
+				int iLowerPop = 5;
+				int iPop = 40 + 30 * iCount;
+				if (AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+				{
+					iPop /= 2;
+				}
+				iValue = (140 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
+			}
+			break;
+
+		case UNITAI_PIRATE_SEA:
+			{
+				if (iCount < 2)
+				{
+					int iLowerPop = 5;
+					int iPop = 16 + 6 * iCount;
+					iValue = (140 * std::max(0, iPopulation - (iLowerPop + iPop * iCount))) / iPop;
+				}
+			}
+			break;
+		default:
+			FAssert(false);
+			break;
+	}
+
+	iValue *= 100 + m_aiUnitAIStrategyWeights[eUnitAI];
+	iValue /= 100;
+
+	return iValue;
+}
+
+bool CvPlayerAI::AI_isCityAcceptingYield(CvCity* pCity, YieldTypes eYield)
+{
+	for (CvIdVector<CvTradeRoute>::iterator it = m_tradeRoutes.begin(); it != m_tradeRoutes.end(); ++it)
+	{
+		CvTradeRoute* pTradeRoute = it->second;
+
+		if (pTradeRoute->getYield() == eYield)
+		{
+			if (pTradeRoute->getDestinationCity() == pCity->getIDInfo())
+			{
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+int CvPlayerAI::AI_professionSuitability(UnitTypes eUnit, ProfessionTypes eProfession)
+{
+	if (eProfession == NO_PROFESSION)
+	{
+		return 0;
+	}
+
+	if (!GC.getCivilizationInfo(getCivilizationType()).isValidProfession(eProfession))
+	{
+		return 0;
+	}
+
+
+	CvUnitInfo& kUnit = GC.getUnitInfo(eUnit);
+
+	if (kUnit.getDefaultProfession() == NO_PROFESSION)
+	{
+		return 0;
+	}
+
+	if (eProfession == (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession())
+	{
+		return 100;
+	}
+
+	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+	int iValue = 100;
+
+	int iPositiveYields = 0;
+	int iNegativeYields = 0;
+
+	int iProModifiers = 0;
+	int iConModifiers = 0;
+
+	if (kProfession.isWater() && kUnit.isWaterYieldChanges() || !kProfession.isWater() && kUnit.isLandYieldChanges())
+	{
+
+		for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+		{
+			YieldTypes eLoopYield = (YieldTypes)iYield;
+
+
+			int iModifier = kUnit.getYieldModifier(eLoopYield);
+			// XXX account for kUnit.getYieldChange, kUnit.getBonusYieldChange
+			int iYieldChange = kUnit.getYieldChange(eLoopYield) * 2 + kUnit.getBonusYieldChange(eLoopYield);
+			iModifier += 10 * iYieldChange;
+
+			if (iModifier != 0)
+			{
+				// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+				if (kProfession.getYieldsProduced(0) == eLoopYield)
+				// MultipleYieldsProduced End
+				{
+					//We produce enhanced yield for this profession.
+					if (iModifier > 0)
+					{
+						iProModifiers += iModifier;
+					}
+					else //We produce reduced yield for this profession.
+					{
+						iConModifiers += iModifier;
+					}
+				}
+				else
+				{
+					//We produce enhanced yield for ANOTHER profession.
+					if (iModifier > 0)
+					{
+						iNegativeYields = std::max(iModifier, iNegativeYields);
+					}
+				}
+			}
+		}
+
+		iProModifiers += iPositiveYields / 8;
+		iConModifiers += iNegativeYields / 20;
+
+	}
+
+	if (!kProfession.isCitizen())
+	{
+		int iChange = kUnit.getYieldModifier(YIELD_FOOD) / 10 + kUnit.getYieldChange(YIELD_FOOD) * 3 + kUnit.getYieldChange(YIELD_FOOD) * 2;
+		if (iChange > 0)
+		{
+			iConModifiers += iChange;
+		}
+	}
+
+	if (kProfession.getMissionaryRate() > 0)
+	{
+		int iModifier = kUnit.getMissionaryRateModifier();
+		if (iModifier > 0)
+		{
+			iProModifiers += iModifier;
+		}
+		else
+		{
+			iConModifiers += iModifier / 8;
+		}
+	}
+
+	if (kProfession.getWorkRate() > 0)
+	{
+		int iModifier = kUnit.getWorkRate();
+		if (iModifier > 0)
+		{
+			iProModifiers += iModifier;
+		}
+		else
+		{
+			iConModifiers += iModifier / 8;
+		}
+	}
+
+	if (kProfession.isScout())
+	{
+		if (kUnit.isNoBadGoodies())
+		{
+			iProModifiers += 100;
+		}
+		else
+		{
+			iConModifiers += 5;
+		}
+	}
+
+	for (int i = 0; i < GC.getNumPromotionInfos(); ++i)
+	{
+		if (kUnit.getFreePromotions(i))
+		{
+			if (kProfession.isUnarmed())
+			{
+				iConModifiers += 25;
+			}
+			else
+			{
+				iProModifiers += 25;
+			}
+		}
+	}
+
+	if (eProfession != (ProfessionTypes)GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession())
+	{
+		if (kUnit.getDefaultProfession() == eProfession)
+		{
+			iProModifiers = std::max(100, iProModifiers);//Just in case.
+		}
+		else
+		{
+			if (hasContentsYieldEquipmentAmount((ProfessionTypes)kUnit.getDefaultProfession())) // cache CvPlayer::getYieldEquipmentAmount - Nightinggale
+			{
+				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+				{
+					if (getYieldEquipmentAmount((ProfessionTypes)kUnit.getDefaultProfession(), (YieldTypes) iYield) > 0)
+					{
+						if (getYieldEquipmentAmount(eProfession, (YieldTypes) iYield) == 0)
+						{
+							iConModifiers += 50;
+						}
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	iValue *= 100 + iProModifiers;
+	iValue /= 100 + iConModifiers;
+
+	return iValue;
+}
+
+int CvPlayerAI::AI_professionSuitability(const CvUnit* pUnit, ProfessionTypes eProfession, const CvPlot* pPlot, UnitAITypes eUnitAI)
+{
+	CvPlot* pCityPlot = NULL;
+ 	if (pPlot != NULL)
+	{
+		CvCity* pCity = pPlot->getPlotCity();
+		if (pCity == NULL)
+		{
+			pCity = pPlot->getWorkingCity();
+		}
+
+		if (pCity != NULL)
+		{
+			pCityPlot = pCity->plot();
+		}
+	}
+
+	if (!pUnit->canHaveProfession(eProfession, true, pCityPlot))
+	{
+		return 0;
+	}
+
+	int iValue = AI_professionSuitability(pUnit->getUnitType(), eProfession);
+
+	if (eUnitAI != NO_UNITAI && pUnit != NULL)
+	{
+		int iPromotionCount = 0;
+		for (int i = 0; i < GC.getNumPromotionInfos(); ++i)
+		{
+			PromotionTypes eLoopPromotion = (PromotionTypes)i;
+
+			if (pUnit->isHasPromotion(eLoopPromotion))
+			{
+				iPromotionCount ++;
+			}
+		}
+		iValue *= 100 + 5 * iPromotionCount;
+		iValue /= 100;
+
+		if (eUnitAI == UNITAI_OFFENSIVE)
+		{
+			iValue *= 100 + pUnit->cityAttackModifier();
+			iValue /= 100;
+		}
+		else if (eUnitAI == UNITAI_DEFENSIVE)
+		{
+			iValue *= 100 + pUnit->cityDefenseModifier();
+			iValue /= 100;
+		}
+	}
+
+	if (pPlot == NULL)
+	{
+		return iValue;
+	}
+
+	CvProfessionInfo& kProfession = GC.getProfessionInfo(eProfession);
+	CvUnitInfo& kUnit = GC.getUnitInfo(pUnit->getUnitType());
+
+	CvCity* pCity = pPlot->getPlotCity();
+	if (pCity == NULL)
+	{
+		pCity = pPlot->getWorkingCity();
+	}
+
+	if (pCity == NULL || pCity->getOwnerINLINE() != getID())
+	{
+		return iValue;
+	}
+
+	bool bMismatchedBonus = false;
+	int iExtraValue = 0;
+	if (kProfession.isCitizen())
+	{
+		// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+		YieldTypes eYieldProducedType = (YieldTypes)kProfession.getYieldsProduced(0);
+		// MultipleYieldsProduced End
+		FAssert(eYieldProducedType != NO_YIELD);
+
+		if (kProfession.isWorkPlot())
+		{
+			if (pPlot->getWorkingCity() == pCity)
+			{
+				if (kProfession.isWater() == pPlot->isWater())
+				{
+					if (pPlot->getBonusType() != NO_BONUS)
+					{
+						int iBonusYield = GC.getBonusInfo(pPlot->getBonusType()).getYieldChange(eYieldProducedType);
+						if (iBonusYield > 0)
+						{
+							int iPlotYield = pPlot->calculateNatureYield(eYieldProducedType, getTeam());
+							if (iPlotYield > 0)
+							{
+								int iExtraYield = kUnit.getYieldChange(eYieldProducedType);
+								iExtraYield += kUnit.getBonusYieldChange(eYieldProducedType);
+
+								iExtraValue += (100 * iExtraYield) / iPlotYield;
+							}
+						}
+						else
+						{
+							bMismatchedBonus = true;
+						}
+					}
+				}
+			}
+		}
+		else
+		{
+			if (pCity != NULL)
+			{
+				int iModifier = kUnit.getYieldModifier(eYieldProducedType);
+				iModifier += kUnit.getYieldChange(eYieldProducedType) * 10;
+
+				iModifier *= pCity->AI_getYieldAdvantage(eYieldProducedType);
+				iModifier /= 100;
+
+				iExtraValue += iModifier;
+			}
+		}
+	}
+
+	iValue += iExtraValue;
+	if (bMismatchedBonus)
+	{
+		iValue *= 95;
+		iValue /= 100;
+	}
+	return iValue;
+}
+
+void CvPlayerAI::AI_swapUnitJobs(CvUnit* pUnitA, CvUnit* pUnitB)
+{
+	FAssert(pUnitA->plot() == pUnitB->plot());
+
+	UnitAITypes eUnitAI_A = pUnitA->AI_getUnitAIType();
+	ProfessionTypes eProfession_A = pUnitA->getProfession();
+	int iMovePriorityA = pUnitA->AI_getMovePriority();
+
+	UnitAITypes eUnitAI_B = pUnitB->AI_getUnitAIType();
+	ProfessionTypes eProfession_B = pUnitB->getProfession();
+	int iMovePriorityB = pUnitB->AI_getMovePriority();
+
+	CvProfessionInfo& kProfessionA = GC.getProfessionInfo(eProfession_A);
+	CvProfessionInfo& kProfessionB = GC.getProfessionInfo(eProfession_B);
+
+	CvCity* pCity = getPopulationUnitCity(pUnitA->getID());
+	if (pCity == NULL)
+	{
+		FAssert(pUnitA->isOnMap());
+		pCity = pUnitA->plot()->getPlotCity();
+	}
+	FAssert(pCity != NULL);
+
+	ProfessionTypes eDefaultProfession = (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession();
+
+	//Ensure all units are added to city.
+	if (pUnitA->isOnMap())
+	{
+		pCity->addPopulationUnit(pUnitA, NO_PROFESSION);
+	}
+	else
+	{
+		pUnitA->setProfession(NO_PROFESSION);
+	}
+
+	if (pUnitB->isOnMap())
+	{
+		pCity->addPopulationUnit(pUnitB, NO_PROFESSION);
+	}
+	else
+	{
+		pUnitB->setProfession(NO_PROFESSION);
+	}
+
+	if (kProfessionA.isCitizen())
+	{
+		pUnitB->setProfession(eProfession_A);
+	}
+	else
+	{
+		pCity->removePopulationUnit(pUnitB, false, eProfession_A);
+		pUnitB->AI_setUnitAIType(eUnitAI_A);
+		pUnitB->AI_setMovePriority(iMovePriorityA);
+	}
+
+	if (kProfessionB.isCitizen())
+	{
+		pUnitA->setProfession(eProfession_B);
+	}
+	else
+	{
+		pCity->removePopulationUnit(pUnitA, false, eProfession_B);
+		pUnitA->AI_setMovePriority(iMovePriorityB);
+		pUnitA->AI_setUnitAIType(eUnitAI_B);
+	}
+}
+
+int CvPlayerAI::AI_sumAttackerStrength(CvPlot* pPlot, CvPlot* pAttackedPlot, int iRange, DomainTypes eDomainType, bool bCheckCanAttack, bool bCheckCanMove)
+{
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	int	strSum = 0;
+
+	for (int iX = -iRange; iX <= iRange; ++iX)
+	{
+		for (int iY = -iRange; iY <= iRange; ++iY)
+		{
+			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
+			if (pLoopPlot != NULL)
+			{
+				pUnitNode = pLoopPlot->headUnitNode();
+
+				while (pUnitNode != NULL)
+				{
+					pLoopUnit = ::getUnit(pUnitNode->m_data);
+					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+					if (pLoopUnit->getOwnerINLINE() == getID())
+					{
+						if (!pLoopUnit->isDead())
+						{
+							bool bCanAttack = pLoopUnit->canAttack();
+
+							if (!bCheckCanAttack || bCanAttack)
+							{
+								if (!bCheckCanMove || pLoopUnit->canMove())
+									if (!bCheckCanMove || pAttackedPlot == NULL || pLoopUnit->canMoveInto(pAttackedPlot, /*bAttack*/ true, /*bDeclareWar*/ true))
+										if (eDomainType == NO_DOMAIN || pLoopUnit->getDomainType() == eDomainType)
+											strSum += pLoopUnit->currEffectiveStr(pAttackedPlot, pLoopUnit);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return strSum;
+}
+
+int CvPlayerAI::AI_sumEnemyStrength(CvPlot* pPlot, int iRange, bool bAttack, DomainTypes eDomainType)
+{
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	int	strSum = 0;
+
+	for (int iX = -iRange; iX <= iRange; ++iX)
+	{
+		for (int iY = -iRange; iY <= iRange; ++iY)
+		{
+			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
+			if (pLoopPlot != NULL)
+			{
+				pUnitNode = pLoopPlot->headUnitNode();
+
+				while (pUnitNode != NULL)
+				{
+					pLoopUnit = ::getUnit(pUnitNode->m_data);
+					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+					if (pLoopUnit->isEnemy(getTeam(), pLoopPlot))
+					{
+						if (!pLoopUnit->isDead())
+						{
+							if (eDomainType == NO_DOMAIN || pLoopUnit->getDomainType() == eDomainType)
+							{
+								strSum += pLoopUnit->currEffectiveStr(pLoopPlot, bAttack ? pLoopUnit : NULL);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return strSum;
+}
+
+int CvPlayerAI::AI_setUnitAIStatesRange(CvPlot* pPlot, int iRange, UnitAIStates eNewUnitAIState, UnitAIStates eValidUnitAIState, const std::vector<UnitAITypes>& validUnitAITypes)
+{
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	int iCount = 0;
+
+	for (int iX = -iRange; iX <= iRange; ++iX)
+	{
+		for (int iY = -iRange; iY <= iRange; ++iY)
+		{
+			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
+			if (pLoopPlot != NULL)
+			{
+				pUnitNode = pLoopPlot->headUnitNode();
+
+				while (pUnitNode != NULL)
+				{
+					pLoopUnit = ::getUnit(pUnitNode->m_data);
+					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+					if ((eValidUnitAIState == NO_UNITAI_STATE) || (pLoopUnit->AI_getUnitAIState() == eValidUnitAIState))
+					{
+						if (std::find(validUnitAITypes.begin(), validUnitAITypes.end(), pLoopUnit->AI_getUnitAIType()) != validUnitAITypes.end())
+						{
+							pLoopUnit->AI_setUnitAIState(eNewUnitAIState);
+							iCount++;
+						}
+					}
+				}
+			}
+		}
+	}
+	return iCount;
+}
+
+//
+// read object from a stream
+// used during load
+//
+void CvPlayerAI::read(FDataStreamBase* pStream)
+{
+	CvPlayer::read(pStream);	// read base class data first
+
+	uint uiFlag=0;
+	pStream->Read(&uiFlag);	// flags for expansion
+
+	if (uiFlag > 0)
+	{
+		uint iSize;
+		pStream->Read(&iSize);
+		if (iSize > 0)
+		{
+			m_distanceMap.resize(iSize);
+			pStream->Read(iSize, &m_distanceMap[0]);
+		}
+
+		pStream->Read(&m_iDistanceMapDistance);
+	}
+
+	pStream->Read(&m_iAttackOddsChange);
+	pStream->Read(&m_iExtraGoldTarget);
+
+	pStream->Read(&m_iAveragesCacheTurn);
+
+	pStream->Read((int*)&m_eNextBuyUnit);
+	pStream->Read((int*)&m_eNextBuyUnitAI);
+	pStream->Read(&m_iNextBuyUnitValue);
+	pStream->Read((int*)&m_eNextBuyProfession);
+	pStream->Read((int*)&m_eNextBuyProfessionUnit);
+	pStream->Read((int*)&m_eNextBuyProfessionAI);
+	pStream->Read(&m_iNextBuyProfessionValue);
+
+	pStream->Read(&m_iTotalIncome);
+	pStream->Read(&m_iHurrySpending);
+
+	pStream->Read(NUM_YIELD_TYPES, m_aiAverageYieldMultiplier);
+	pStream->Read(NUM_YIELD_TYPES, m_aiBestWorkedYieldPlots);
+	pStream->Read(NUM_YIELD_TYPES, m_aiBestUnworkedYieldPlots);
+	pStream->Read(NUM_YIELD_TYPES, m_aiYieldValuesTimes100);
+
+	pStream->Read(&m_iUpgradeUnitsCacheTurn);
+	pStream->Read(&m_iUpgradeUnitsCachedExpThreshold);
+	pStream->Read(&m_iUpgradeUnitsCachedGold);
+
+	pStream->Read(NUM_UNITAI_TYPES, m_aiNumTrainAIUnits);
+	pStream->Read(NUM_UNITAI_TYPES, m_aiNumAIUnits);
+	pStream->Read(NUM_UNITAI_TYPES, m_aiNumRetiredAIUnits);
+	pStream->Read(NUM_UNITAI_TYPES, m_aiUnitAIStrategyWeights);
+	pStream->Read(MAX_PLAYERS, m_aiPeacetimeTradeValue);
+	pStream->Read(MAX_PLAYERS, m_aiPeacetimeGrantValue);
+	pStream->Read(MAX_PLAYERS, m_aiGoldTradedTo);
+	pStream->Read(MAX_PLAYERS, m_aiAttitudeExtra);
+
+	pStream->Read(MAX_PLAYERS, m_abFirstContact);
+
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		pStream->Read(NUM_CONTACT_TYPES, m_aaiContactTimer[i]);
+	}
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		pStream->Read(uiFlag > 1 ? NUM_MEMORY_TYPES : NUM_MEMORY_TYPES - 1, m_aaiMemoryCount[i]);
+	}
+
+	pStream->Read(&m_iTurnLastProductionDirty);
+	pStream->Read(&m_iTurnLastManagedPop);
+	pStream->Read(&m_iMoveQueuePasses);
+
+	{
+		m_aiAICitySites.clear();
+		uint iSize;
+		pStream->Read(&iSize);
+		for (uint i = 0; i < iSize; i++)
+		{
+			int iCitySite;
+			pStream->Read(&iCitySite);
+			m_aiAICitySites.push_back(iCitySite);
+		}
+	}
+
+	if (uiFlag > 0)
+	{
+		uint iSize;
+		pStream->Read(&iSize);
+		if (iSize > 0)
+		{
+			m_unitPriorityHeap.resize(iSize);
+			pStream->Read(iSize, &m_unitPriorityHeap[0]);
+		}
+	}
+
+	pStream->Read(GC.getNumUnitClassInfos(), m_aiUnitClassWeights);
+	pStream->Read(GC.getNumUnitCombatInfos(), m_aiUnitCombatWeights);
+	pStream->Read(MAX_PLAYERS, m_aiCloseBordersAttitudeCache);
+	pStream->Read(MAX_PLAYERS, m_aiStolenPlotsAttitudeCache);
+	///TKs Med
+	//pStream->Read(MAX_PLAYERS, m_aiInsultedAttitudeCache);
+	//tkend
+	pStream->Read(NUM_EMOTION_TYPES, m_aiEmotions);
+	pStream->Read(NUM_STRATEGY_TYPES, m_aiStrategyStartedTurn);
+	pStream->Read(NUM_STRATEGY_TYPES, m_aiStrategyData);
+
+}
+
+
+//
+// save object to a stream
+// used during save
+//
+void CvPlayerAI::write(FDataStreamBase* pStream)
+{
+	CvPlayer::write(pStream);	// write base class data first
+
+	uint uiFlag=2;
+	pStream->Write(uiFlag);		// flag for expansion
+
+	pStream->Write(m_distanceMap.size());
+	if (!m_distanceMap.empty())
+	{
+		pStream->Write(m_distanceMap.size(), &m_distanceMap[0]);
+	}
+	pStream->Write(m_iDistanceMapDistance);
+
+	pStream->Write(m_iAttackOddsChange);
+	pStream->Write(m_iExtraGoldTarget);
+
+	pStream->Write(m_iAveragesCacheTurn);
+
+	pStream->Write(m_eNextBuyUnit);
+	pStream->Write(m_eNextBuyUnitAI);
+	pStream->Write(m_iNextBuyUnitValue);
+	pStream->Write(m_eNextBuyProfession);
+	pStream->Write(m_eNextBuyProfessionUnit);
+	pStream->Write(m_eNextBuyProfessionAI);
+	pStream->Write(m_iNextBuyProfessionValue);
+
+	pStream->Write(m_iTotalIncome);
+	pStream->Write(m_iHurrySpending);
+
+	pStream->Write(NUM_YIELD_TYPES, m_aiAverageYieldMultiplier);
+	pStream->Write(NUM_YIELD_TYPES, m_aiBestWorkedYieldPlots);
+	pStream->Write(NUM_YIELD_TYPES, m_aiBestUnworkedYieldPlots);
+	pStream->Write(NUM_YIELD_TYPES, m_aiYieldValuesTimes100);
+
+	pStream->Write(m_iUpgradeUnitsCacheTurn);
+	pStream->Write(m_iUpgradeUnitsCachedExpThreshold);
+	pStream->Write(m_iUpgradeUnitsCachedGold);
+
+	pStream->Write(NUM_UNITAI_TYPES, m_aiNumTrainAIUnits);
+	pStream->Write(NUM_UNITAI_TYPES, m_aiNumAIUnits);
+	pStream->Write(NUM_UNITAI_TYPES, m_aiNumRetiredAIUnits);
+	pStream->Write(NUM_UNITAI_TYPES, m_aiUnitAIStrategyWeights);
+	pStream->Write(MAX_PLAYERS, m_aiPeacetimeTradeValue);
+	pStream->Write(MAX_PLAYERS, m_aiPeacetimeGrantValue);
+	pStream->Write(MAX_PLAYERS, m_aiGoldTradedTo);
+	pStream->Write(MAX_PLAYERS, m_aiAttitudeExtra);
+
+	pStream->Write(MAX_PLAYERS, m_abFirstContact);
+
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		pStream->Write(NUM_CONTACT_TYPES, m_aaiContactTimer[i]);
+	}
+	for (int i = 0; i < MAX_PLAYERS; i++)
+	{
+		pStream->Write(NUM_MEMORY_TYPES, m_aaiMemoryCount[i]);
+	}
+
+	pStream->Write(m_iTurnLastProductionDirty);
+	pStream->Write(m_iTurnLastManagedPop);
+	pStream->Write(m_iMoveQueuePasses);
+
+	{
+		uint iSize = m_aiAICitySites.size();
+		pStream->Write(iSize);
+		std::vector<int>::iterator it;
+		for (it = m_aiAICitySites.begin(); it != m_aiAICitySites.end(); ++it)
+		{
+			pStream->Write((*it));
+		}
+	}
+
+	pStream->Write(m_unitPriorityHeap.size());
+	if (!m_unitPriorityHeap.empty())
+	{
+		pStream->Write(m_unitPriorityHeap.size(), &m_unitPriorityHeap[0]);
+	}
+
+	pStream->Write(GC.getNumUnitClassInfos(), m_aiUnitClassWeights);
+	pStream->Write(GC.getNumUnitCombatInfos(), m_aiUnitCombatWeights);
+	pStream->Write(MAX_PLAYERS, m_aiCloseBordersAttitudeCache);
+	pStream->Write(MAX_PLAYERS, m_aiStolenPlotsAttitudeCache);
+	///TKs MEd
+	//pStream->Write(MAX_PLAYERS, m_aiInsultedAttitudeCache);
+	//tkend
+	pStream->Write(NUM_EMOTION_TYPES, m_aiEmotions);
+	pStream->Write(NUM_STRATEGY_TYPES, m_aiStrategyStartedTurn);
+	pStream->Write(NUM_STRATEGY_TYPES, m_aiStrategyData);
+}
+
+
+int CvPlayerAI::AI_eventValue(EventTypes eEvent, const EventTriggeredData& kTriggeredData)
+{
+	CvEventTriggerInfo& kTrigger = GC.getEventTriggerInfo(kTriggeredData.m_eTrigger);
+	CvEventInfo& kEvent = GC.getEventInfo(eEvent);
+
+	int iNumCities = getNumCities();
+	CvCity* pCity = getCity(kTriggeredData.m_iCityId);
+	CvPlot* pPlot = GC.getMapINLINE().plot(kTriggeredData.m_iPlotX, kTriggeredData.m_iPlotY);
+	CvUnit* pUnit = getUnit(kTriggeredData.m_iUnitId);
+
+	int aiYields[NUM_YIELD_TYPES];
+
+	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
+	{
+		aiYields[iI] = 0;
+	}
+
+	if (NO_PLAYER != kTriggeredData.m_eOtherPlayer)
+	{
+		if (kEvent.isDeclareWar())
+		{
+			switch (AI_getAttitude(kTriggeredData.m_eOtherPlayer))
+			{
+			case ATTITUDE_FURIOUS:
+			case ATTITUDE_ANNOYED:
+			case ATTITUDE_CAUTIOUS:
+				if (GET_TEAM(getTeam()).getDefensivePower() < GET_TEAM(GET_PLAYER(kTriggeredData.m_eOtherPlayer).getTeam()).getPower())
+				{
+					return -MAX_INT + 1;
+				}
+				break;
+			case ATTITUDE_PLEASED:
+			case ATTITUDE_FRIENDLY:
+				return -MAX_INT + 1;
+				break;
+			}
+		}
+	}
+
+	//Proportional to #turns in the game...
+	//(AI evaluation will generally assume proper game speed scaling!)
+	int iGameSpeedPercent = 100;
+
+	int iValue = GC.getGameINLINE().getSorenRandNum(kEvent.getAIValue(), "AI Event choice");
+	iValue += (getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, false) + getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, true)) / 2;
+	if (kEvent.getUnitClass() != NO_UNITCLASS)
+	{
+		UnitTypes eUnit = (UnitTypes)GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(kEvent.getUnitClass());
+		if (eUnit != NO_UNIT)
+		{
+			//Although AI_unitValue compares well within units, the value is somewhat independent of cost
+			int iUnitValue = 0;
+			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+			{
+				iUnitValue += GC.getUnitInfo(eUnit).getYieldCost(iYield);
+			}
+			if (iUnitValue > 0)
+			{
+				iUnitValue *= 2;
+			}
+			else
+			{
+				iUnitValue = 200;
+			}
+
+			iUnitValue *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();
+			iValue += kEvent.getNumUnits() * iUnitValue;
+		}
+	}
+
+	if (kEvent.isDisbandUnit())
+	{
+		CvUnit* pUnit = getUnit(kTriggeredData.m_iUnitId);
+		if (NULL != pUnit)
+		{
+			int iUnitValue = 0;
+			for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+			{
+				iUnitValue += pUnit->getUnitInfo().getYieldCost(iYield);
+			}
+			if (iUnitValue > 0)
+			{
+				iUnitValue *= 2;
+			}
+			else
+			{
+				iUnitValue = 200;
+			}
+
+			iUnitValue *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent();
+			iValue -= iUnitValue;
+		}
+	}
+
+	if (kEvent.getBuildingClass() != NO_BUILDINGCLASS)
+	{
+		BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(getCivilizationType()).getCivilizationBuildings(kEvent.getBuildingClass());
+		if (eBuilding != NO_BUILDING)
+		{
+			if (pCity)
+			{
+				//iValue += kEvent.getBuildingChange() * pCity->AI_buildingValue(eBuilding);
+				int iBuildingValue = 0;
+				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+				{
+					iBuildingValue += GC.getBuildingInfo(eBuilding).getYieldCost(iYield);
+				}
+				if (iBuildingValue > 0)
+				{
+					iBuildingValue *= 2;
+				}
+				else if (iBuildingValue == -1)
+				{
+					iBuildingValue = 300;
+				}
+
+				iBuildingValue *= GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getConstructPercent();
+				iValue += kEvent.getBuildingChange() * iBuildingValue;
+			}
+		}
+	}
+
+	{	//Yield and other changes
+		if (kEvent.getNumBuildingYieldChanges() > 0)
+		{
+			for (int iBuildingClass = 0; iBuildingClass < GC.getNumBuildingClassInfos(); ++iBuildingClass)
+			{
+				for (int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
+				{
+					aiYields[iYield] += kEvent.getBuildingYieldChange(iBuildingClass, iYield);
+				}
+			}
+		}
+	}
+
+	if (kEvent.isCityEffect())
+	{
+		int iCityPopulation = -1;
+		int iCityTurnValue = 0;
+		if (NULL != pCity)
+		{
+			iCityPopulation = pCity->getPopulation();
+		}
+
+		if (-1 == iCityPopulation)
+		{
+			//What is going on here?
+			iCityPopulation = 5;
+		}
+
+		iCityTurnValue += aiYields[YIELD_FOOD] * 5;
+
+		iCityTurnValue += aiYields[YIELD_BELLS] * 3;
+		iCityTurnValue += aiYields[YIELD_CROSSES] * 1;
+
+		iValue += (iCityTurnValue * 20 * iGameSpeedPercent) / 100;
+
+		iValue += kEvent.getFood();
+		iValue += kEvent.getFoodPercent() / 4;
+		iValue += kEvent.getPopulationChange() * 30;
+		iValue -= kEvent.getRevoltTurns() * (12 + iCityPopulation * 16);
+		iValue += kEvent.getCulture() / 2;
+	}
+	else if (!kEvent.isOtherPlayerCityEffect())
+	{
+		int iPerTurnValue = 0;
+
+		iValue += (iPerTurnValue * 20 * iGameSpeedPercent) / 100;
+
+		iValue += (kEvent.getFood() * iNumCities);
+		iValue += (kEvent.getFoodPercent() * iNumCities) / 4;
+		iValue += (kEvent.getPopulationChange() * iNumCities * 40);
+		iValue += iNumCities * kEvent.getCulture() / 2;
+	}
+
+	if (NULL != pPlot)
+	{
+		if (kEvent.getImprovementChange() > 0)
+		{
+			iValue += (30 * iGameSpeedPercent) / 100;
+		}
+		else if (kEvent.getImprovementChange() < 0)
+		{
+			iValue -= (30 * iGameSpeedPercent) / 100;
+		}
+
+		if (kEvent.getRouteChange() > 0)
+		{
+			iValue += (10 * iGameSpeedPercent) / 100;
+		}
+		else if (kEvent.getRouteChange() < 0)
+		{
+			iValue -= (10 * iGameSpeedPercent) / 100;
+		}
+
+		for (int i = 0; i < NUM_YIELD_TYPES; ++i)
+		{
+			if (0 != kEvent.getPlotExtraYield(i))
+			{
+				if (pPlot->getWorkingCity() != NULL)
+				{
+					FAssertMsg(pPlot->getWorkingCity()->getOwner() == getID(), "Event creates a boni for another player?");
+					aiYields[i] += kEvent.getPlotExtraYield(i);
+				}
+				else
+				{
+					iValue += (20 * 8 * kEvent.getPlotExtraYield(i) * iGameSpeedPercent) / 100;
+				}
+			}
+		}
+	}
+
+	if (NULL != pUnit)
+	{
+		iValue += (2 * pUnit->baseCombatStr() * kEvent.getUnitExperience() * GC.getGameSpeedInfo(GC.getGameINLINE().getGameSpeedType()).getTrainPercent()) / 100;
+
+		iValue -= 10 * kEvent.getUnitImmobileTurns();
+	}
+
+	{
+		int iPromotionValue = 0;
+
+		for (int i = 0; i < GC.getNumUnitCombatInfos(); ++i)
+		{
+			if (NO_PROMOTION != kEvent.getUnitCombatPromotion(i))
+			{
+				int iLoop;
+				for (CvUnit* pLoopUnit = firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = nextUnit(&iLoop))
+				{
+					if (pLoopUnit->getUnitCombatType() == i)
+					{
+						if (!pLoopUnit->isHasPromotion((PromotionTypes)kEvent.getUnitCombatPromotion(i)))
+						{
+							iPromotionValue += 5 * pLoopUnit->baseCombatStr();
+						}
+					}
+				}
+
+				iPromotionValue += iNumCities * 50;
+			}
+		}
+
+		iValue += (iPromotionValue * iGameSpeedPercent) / 100;
+	}
+
+	int iOtherPlayerAttitudeWeight = 0;
+	if (kTriggeredData.m_eOtherPlayer != NO_PLAYER)
+	{
+		iOtherPlayerAttitudeWeight = AI_getAttitudeWeight(kTriggeredData.m_eOtherPlayer);
+		iOtherPlayerAttitudeWeight += 10 - GC.getGame().getSorenRandNum(20, "AI event value attitude");
+	}
+
+	if (NO_PLAYER != kTriggeredData.m_eOtherPlayer)
+	{
+		CvPlayerAI& kOtherPlayer = GET_PLAYER(kTriggeredData.m_eOtherPlayer);
+
+		int iDiploValue = 0;
+		//if we like this player then value positive attitude, if however we really hate them then
+		//actually value negative attitude.
+		iDiploValue += ((iOtherPlayerAttitudeWeight + 50) * kEvent.getAttitudeModifier() * GET_PLAYER(kTriggeredData.m_eOtherPlayer).getPower()) / std::max(1, getPower());
+
+		if (kEvent.getTheirEnemyAttitudeModifier() != 0)
+		{
+			//Oh wow this sure is mildly complicated.
+			TeamTypes eWorstEnemy = GET_TEAM(GET_PLAYER(kTriggeredData.m_eOtherPlayer).getTeam()).AI_getWorstEnemy();
+
+			if (NO_TEAM != eWorstEnemy && eWorstEnemy != getTeam())
+			{
+			int iThirdPartyAttitudeWeight = GET_TEAM(getTeam()).AI_getAttitudeWeight(eWorstEnemy);
+
+			//If we like both teams, we want them to get along.
+			//If we like otherPlayer but not enemy (or vice-verca), we don't want them to get along.
+			//If we don't like either, we don't want them to get along.
+			//Also just value stirring up trouble in general.
+
+			int iThirdPartyDiploValue = 50 * kEvent.getTheirEnemyAttitudeModifier();
+			iThirdPartyDiploValue *= (iThirdPartyAttitudeWeight - 10);
+			iThirdPartyDiploValue *= (iOtherPlayerAttitudeWeight - 10);
+			iThirdPartyDiploValue /= 10000;
+
+			if ((iOtherPlayerAttitudeWeight) < 0 && (iThirdPartyAttitudeWeight < 0))
+			{
+				iThirdPartyDiploValue *= -1;
+			}
+
+			iThirdPartyDiploValue /= 2;
+
+			iDiploValue += iThirdPartyDiploValue;
+		}
+		}
+
+		iDiploValue *= iGameSpeedPercent;
+		iDiploValue /= 100;
+
+		if (GC.getGameINLINE().isOption(GAMEOPTION_AGGRESSIVE_AI))
+		{
+			//What is this "relationships" thing?
+			iDiploValue /= 2;
+		}
+
+		if (kEvent.isGoldToPlayer())
+		{
+			//If the gold goes to another player instead of the void, then this is a positive
+			//thing if we like the player, otherwise it's a negative thing.
+			int iGiftValue = (getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, false) + getEventCost(eEvent, kTriggeredData.m_eOtherPlayer, true)) / 2;
+			iGiftValue *= -iOtherPlayerAttitudeWeight;
+			iGiftValue /= 110;
+
+			iValue += iGiftValue;
+		}
+
+		if (kEvent.isDeclareWar())
+		{
+			int iWarValue = (GET_TEAM(getTeam()).getDefensivePower() - GET_TEAM(GET_PLAYER(kTriggeredData.m_eOtherPlayer).getTeam()).getPower());// / std::max(1, GET_TEAM(getTeam()).getDefensivePower());
+			iWarValue -= 30 * AI_getAttitudeVal(kTriggeredData.m_eOtherPlayer);
+		}
+
+		if (kEvent.getMaxPillage() > 0)
+		{
+			int iPillageValue = (40 * (kEvent.getMinPillage() + kEvent.getMaxPillage())) / 2;
+			//If we hate them, this is good to do.
+			iPillageValue *= 25 - iOtherPlayerAttitudeWeight;
+			iPillageValue *= iGameSpeedPercent;
+			iPillageValue /= 12500;
+		}
+
+		iValue += (iDiploValue * iGameSpeedPercent) / 100;
+	}
+
+	int iThisEventValue = iValue;
+	//XXX THIS IS VULNERABLE TO NON-TRIVIAL RECURSIONS!
+	//Event A effects Event B, Event B effects Event A
+	for (int iEvent = 0; iEvent < GC.getNumEventInfos(); ++iEvent)
+	{
+		if (kEvent.getAdditionalEventChance(iEvent) > 0)
+		{
+			if (iEvent == eEvent)
+			{
+				//Infinite recursion is not our friend.
+				//Fortunately we have the event value for this event - sans values of other events
+				//disabled or cleared. Hopefully no events will be that complicated...
+				//Double the value since it's recursive.
+				iValue += (kEvent.getAdditionalEventChance(iEvent) * iThisEventValue) / 50;
+			}
+			else
+			{
+				iValue += (kEvent.getAdditionalEventChance(iEvent) * AI_eventValue((EventTypes)iEvent, kTriggeredData)) / 100;
+			}
+		}
+
+		if (kEvent.getClearEventChance(iEvent) > 0)
+		{
+			if (iEvent == eEvent)
+			{
+				iValue -= (kEvent.getClearEventChance(iEvent) * iThisEventValue) / 50;
+			}
+			else
+			{
+				iValue -= (kEvent.getClearEventChance(iEvent) * AI_eventValue((EventTypes)iEvent, kTriggeredData)) / 100;
+			}
+		}
+	}
+
+	iValue *= 100 + GC.getGameINLINE().getSorenRandNum(20, "AI Event choice");
+	iValue /= 100;
+
+	return iValue;
+}
+
+EventTypes CvPlayerAI::AI_chooseEvent(int iTriggeredId)
+{
+	EventTriggeredData* pTriggeredData = getEventTriggered(iTriggeredId);
+	if (NULL == pTriggeredData)
+	{
+		return NO_EVENT;
+	}
+
+	CvEventTriggerInfo& kTrigger = GC.getEventTriggerInfo(pTriggeredData->m_eTrigger);
+
+	int iBestValue = -MAX_INT;
+	EventTypes eBestEvent = NO_EVENT;
+
+	for (int i = 0; i < kTrigger.getNumEvents(); i++)
+	{
+		int iValue = -MAX_INT;
+		if (kTrigger.getEvent(i) != NO_EVENT)
+		{
+			CvEventInfo& kEvent = GC.getEventInfo((EventTypes)kTrigger.getEvent(i));
+			if (canDoEvent((EventTypes)kTrigger.getEvent(i), *pTriggeredData))
+			{
+				iValue = AI_eventValue((EventTypes)kTrigger.getEvent(i), *pTriggeredData);
+			}
+		}
+
+		if (iValue > iBestValue)
+		{
+			iBestValue = iValue;
+			eBestEvent = (EventTypes)kTrigger.getEvent(i);
+		}
+	}
+
+	return eBestEvent;
+}
+
+void CvPlayerAI::AI_doNativeArmy(TeamTypes eTeam)
+{
+	CvTeamAI& kTeam = GET_TEAM(getTeam());
+	FAssert(eTeam != NO_TEAM && eTeam != getTeam());
+
+	int iTotalUnitCount = getTotalPopulation();
+
+	int iGameTurn = GC.getGameINLINE().getGameTurn();
+	int iEndTurn = GC.getGameINLINE().getEstimateEndTurn();
+
+	iEndTurn *= GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getNativePacifismPercent();
+	iEndTurn /= 100;
+
+	int iOffensivePercent = std::max(40, 30 * iGameTurn * 2 / iEndTurn);
+	int iCounterPercent = std::max(25, 15 * iGameTurn * 3 / iEndTurn);
+
+	if (kTeam.AI_getWarPlan(eTeam) == WARPLAN_TOTAL || kTeam.AI_getWarPlan(eTeam) == WARPLAN_PREPARING_TOTAL)
+	{
+		iOffensivePercent *= 3;
+		iOffensivePercent /= 2;
+	}
+	else if (kTeam.AI_getWarPlan(eTeam) == WARPLAN_ATTACKED_RECENT)
+	{
+		iOffensivePercent += 3;
+		iOffensivePercent /= 4;
+	}
+	else
+	{
+		iCounterPercent += (iOffensivePercent * 1 + 2) / 3;
+		iOffensivePercent = (iOffensivePercent * 2 + 1) / 3;
+	}
+
+	//First convert units which are already on the map.
+	int iLoop;
+	CvUnit* pLoopUnit;
+	for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+	{
+		CvArea* pArea = pLoopUnit->area();
+		AreaAITypes eAreaAI = pArea->getAreaAIType(getTeam());
+		if (pLoopUnit->AI_getUnitAIType() == UNITAI_DEFENSIVE)
+		{
+			int iValue = 0;
+
+			int iAreaPopulation = pArea->getPopulationPerPlayer(getID()) + pArea->getUnitsPerPlayer(getID());
+
+			CvCity* pLoopCity = pLoopUnit->plot()->getPlotCity();
+			if (pLoopCity != NULL && pLoopCity->getOwnerINLINE() != getID())
+			{
+				pLoopCity = NULL;
+			}
+			if (pLoopCity == NULL || pLoopCity->AI_isDefended())
+			{
+				int iOffenseValue = iOffensivePercent * (iOffensivePercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_OFFENSIVE) / iAreaPopulation);
+				int iCounterValue = iCounterPercent * (iCounterPercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_COUNTER) / iAreaPopulation);
+
+				if (iOffenseValue >= 0 && iOffenseValue >= iCounterValue)
+				{
+					pLoopUnit->AI_setUnitAIType(UNITAI_OFFENSIVE);
+				}
+				else if (iCounterValue > 0)
+				{
+					pLoopUnit->AI_setUnitAIType(UNITAI_COUNTER);
+				}
+			}
+		}
+		else if (eAreaAI == AREAAI_NEUTRAL)
+		{		    ///TKs Med
+		    if (!pLoopUnit->isAlwaysHostile(pLoopUnit->plot()))
+            {
+                pLoopUnit->AI_setUnitAIType(UNITAI_DEFENSIVE);
+            }
+            ///TKe
+		}
+	}
+
+	int iBestValue = 0;
+	CvCity* pBestCity = NULL;
+
+	int iInfiniteLoop = 0;
+	while (true)
+	{
+		int iBestValue = 0;
+		UnitAITypes eBestUnitAI = NO_UNITAI;
+		CvCity* pBestCity = NULL;
+
+
+		CvCity* pLoopCity;
+		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+		{
+			if (pLoopCity->getPopulation() > 1)
+			{
+				CvArea* pArea = pLoopCity->area();
+				AreaAITypes eAreaAI = pArea->getAreaAIType(getTeam());
+
+				if (eAreaAI != AREAAI_NEUTRAL)
+				{
+					int iAreaPopulation = pArea->getPopulationPerPlayer(getID()) + pArea->getUnitsPerPlayer(getID());
+					int iOffenseValue = iOffensivePercent * (iOffensivePercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_OFFENSIVE) / iAreaPopulation);
+					int iCounterValue = iCounterPercent * (iCounterPercent - 100 * pArea->getNumAIUnits(getID(), UNITAI_COUNTER) / iAreaPopulation);
+
+					if (iOffenseValue > 0 || iCounterValue > 0)
+					{
+						int iValue = (100 * pLoopCity->getPopulation()) / pLoopCity->getHighestPopulation();
+
+						iValue /= (3 + kTeam.AI_enemyCityDistance(pLoopCity->plot()));
+
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							pBestCity = pLoopCity;
+							eBestUnitAI = (iOffenseValue > iCounterValue) ? UNITAI_OFFENSIVE : UNITAI_COUNTER;
+						}
+					}
+				}
+			}
+		}
+
+		if (pBestCity == NULL)
+		{
+			break;
+		}
+		if (iInfiniteLoop > 100)
+		{
+			FAssertMsg(false, "Infinite Loop in Native War Preperations");
+			break;
+		}
+		CvUnit* pEjectUnit = pBestCity->AI_bestPopulationUnit(eBestUnitAI);
+		if (pEjectUnit == NULL)
+		{
+			FAssertMsg(false, "Could not eject unit");
+			break;
+		}
+	}
+}
+
+CvCity* CvPlayerAI::AI_getPrimaryCity()
+{
+	int iLoop;
+	CvCity* pCity = firstCity(&iLoop);
+	if (pCity != NULL)
+	{
+		return pCity;
+	}
+	return NULL;
+
+}
+
+int CvPlayerAI::AI_getOverpopulationPercent()
+{
+	int iCityPopulation = getTotalPopulation() - getNumUnits();
+
+	if (iCityPopulation <= 0)
+	{
+		return 0;
+	}
+
+	int iTargetPop = (iCityPopulation + getNumCities()) * (100 + 100 / GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAITrainPercent());
+	iTargetPop /= 100;
+
+	return (100 * getNumUnits() / std::max(1, iTargetPop) - 100);
+}
+
+int CvPlayerAI::AI_countNumHomedUnits(CvCity* pCity, UnitAITypes eUnitAI, UnitAIStates eUnitAIState)
+{
+	int iCount = 0;
+
+	int iLoop;
+	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+	{
+		if (pCity == NULL || pLoopUnit->getHomeCity() == pCity)
+		{
+			if (eUnitAI == NO_UNITAI || pLoopUnit->AI_getUnitAIType() == eUnitAI)
+			{
+				if (eUnitAIState == NO_UNITAI_STATE || pLoopUnit->AI_getUnitAIState() == eUnitAIState)
+				{
+					iCount++;
+				}
+			}
+		}
+	}
+
+	return iCount;
+}
+
+void CvPlayerAI::AI_doMilitaryStrategy()
+{
+
+	//Iterate over every enemy city.
+	//If we are sieging that city then evaluate the strength of our units vs the strength of the local defense (blah blah blah)
+
+	//If we are in a strong position : CHARGE
+	//If we are waiting for reinforcements: CAMP
+	//If we are weak and no reinforcements are coming: RETREAT
+
+	std::vector<UnitAITypes> militaryUnitAIs;
+
+	militaryUnitAIs.push_back(UNITAI_COUNTER);
+	militaryUnitAIs.push_back(UNITAI_OFFENSIVE);
+
+	CvTeamAI& kTeam = GET_TEAM(getTeam());
+	for (int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
+	{
+		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
+		WarPlanTypes eWarPlan = kTeam.AI_getWarPlan(kLoopPlayer.getTeam());
+		if (kLoopPlayer.isAlive() && (kLoopPlayer.getTeam() != getTeam()) && (eWarPlan != NO_WARPLAN))
+		{
+			bool bKnockKnock_WhoseThere_Monty_MontyWho_MontyAndHisHordeDieDieDie = false;
+			int iLoop;
+			CvCity* pLoopCity;
+			for (pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))
+			{
+				if (pLoopCity->plot()->isVisible(getTeam(), false) || isNative())
+				{
+					int iOurStrength = AI_sumAttackerStrength(pLoopCity->plot(), pLoopCity->plot(), 3, DOMAIN_LAND);
+					if ((iOurStrength > 0) && (GC.getGameINLINE().getSorenRandNum(100, "AI new wave") < 25))
+					{
+						//Only consider enemy strength for total war, otherwise dribble on in.
+						int iEnemyStrength = (eWarPlan == WARPLAN_TOTAL) ? AI_sumEnemyStrength(pLoopCity->plot(), 1, false, DOMAIN_LAND) : 0;
+						if ((iOurStrength * 100) > iEnemyStrength * 150)
+						{
+							AI_setUnitAIStatesRange(pLoopCity->plot(), 3, UNITAI_STATE_CHARGING, UNITAI_STATE_GROUPING, militaryUnitAIs);
+							bKnockKnock_WhoseThere_Monty_MontyWho_MontyAndHisHordeDieDieDie = true;
+						}
+					}
+				}
+			}
+
+			if (bKnockKnock_WhoseThere_Monty_MontyWho_MontyAndHisHordeDieDieDie)
+			{
+				if (!atWar(getTeam(), kLoopPlayer.getTeam()))
+				{
+					WarPlanTypes eNewWarplan = WARPLAN_TOTAL;
+
+					//Do the whole extortion thing
+					kTeam.declareWar(kLoopPlayer.getTeam(), true, eNewWarplan);
+				}
+			}
+		}
+	}
+	return;
+}
+
+void CvPlayerAI::AI_doSuppressRevolution()
+{
+	bool bContinue = false;
+	PlayerTypes eColony = NO_PLAYER;
+	for (int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
+	{
+		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
+		if (kLoopPlayer.isAlive())
+		{
+			if (GET_TEAM(getTeam()).isParentOf(kLoopPlayer.getTeam()))
+			{
+				if (atWar(getTeam(), kLoopPlayer.getTeam()))
+				{
+					eColony = (PlayerTypes)iPlayer;
+					bContinue = true;
+					break;
+				}
+			}
+		}
+	}
+
+	if (!bContinue)
+	{
+		return;
+	}
+
+	CvPlayerAI& kColony = GET_PLAYER(eColony);
+
+	if (!AI_isAnyStrategy())
+	{
+		AI_setStrategy(STRATEGY_SMALL_WAVES);
+
+		int iTactics = GC.getGameINLINE().getSorenRandNum(5, "AI Choose Strategy");
+		switch (iTactics)
+		{
+			case 0:
+			case 1:
+			case 2:
+				AI_setStrategy(STRATEGY_CONCENTRATED_ATTACK);
+				break;
+			case 3:
+			case 4:
+				AI_setStrategy(STRATEGY_DISTRIBUTED_ATTACK);
+				break;
+			default:
+				break;
+		}
+	}
+
+	if (GC.getGameINLINE().getSorenRandNum(100, "AI change King Strategy") < 33)
+	{
+		if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK) && (AI_getStrategyDuration(STRATEGY_CONCENTRATED_ATTACK) > 7))
+		{
+			AI_clearStrategy(STRATEGY_CONCENTRATED_ATTACK);
+
+			AI_setStrategy(STRATEGY_DISTRIBUTED_ATTACK);
+		}
+		else if (AI_isStrategy(STRATEGY_DISTRIBUTED_ATTACK) && (AI_getStrategyDuration(STRATEGY_DISTRIBUTED_ATTACK) > 4))
+		{
+			AI_clearStrategy(STRATEGY_DISTRIBUTED_ATTACK);
+
+			AI_setStrategy(STRATEGY_CONCENTRATED_ATTACK);
+		}
+	}
+
+	if (AI_isStrategy(STRATEGY_CONCENTRATED_ATTACK) && AI_getStrategyData(STRATEGY_CONCENTRATED_ATTACK) == -1)
+	{
+		int iBestValue = 0;
+		CvPlot* pBestPlot = NULL;
+		//Select a target city.
+		int iLoop;
+		CvCity* pLoopCity;
+		for (pLoopCity = kColony.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kColony.nextCity(&iLoop))
+		{
+			if (pLoopCity->plot()->getNearestEurope() != NO_EUROPE)
+			{
+				int iValue = pLoopCity->getHighestPopulation() * 50 + pLoopCity->plot()->getCrumbs();
+
+				iValue *= 25 + GC.getGameINLINE().getSorenRandNum(75, "AI choose target for concentrated attack");
+				if (iValue > iBestValue)
+				{
+					iBestValue = iValue;
+					pBestPlot = pLoopCity->plot();
+				}
+			}
+		}
+		if (pBestPlot != NULL)
+		{
+			AI_setStrategy(STRATEGY_CONCENTRATED_ATTACK, GC.getMap().plotNum(pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE()));
+		}
+	}
+
+	int iShipCount = 0;
+	int iSoldierCount = 0;
+	int iCargoSpace = 0;
+
+	std::vector<CvUnit*> ships;
+	std::vector<CvUnit*> soldiers;
+
+	int iLoop;
+	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+	{
+		if (pLoopUnit->getDomainType() == DOMAIN_SEA)
+		{
+			if (pLoopUnit->getUnitTravelState() == UNIT_TRAVEL_STATE_IN_EUROPE)
+			{
+				ships.push_back(pLoopUnit);
+				iShipCount++;
+				iCargoSpace += pLoopUnit->cargoSpace();
+			}
+	    }
+	}
+
+	std::vector<int> shuffle(getNumEuropeUnits());
+	for (int i = 0; i < getNumEuropeUnits(); ++i)
+	{
+		shuffle[i] = i;
+	}
+	GC.getGameINLINE().getSorenRand().shuffleArray(shuffle, NULL);
+
+	for (int i = 0; i < getNumEuropeUnits(); ++i)
+	{
+		CvUnit* pLoopUnit = getEuropeUnit(shuffle[i]);
+		FAssert(pLoopUnit != NULL);
+        if (pLoopUnit->getDomainType() == DOMAIN_LAND)
+		{
+			soldiers.push_back(pLoopUnit);
+			iSoldierCount++;
+		}
+	}
+
+	if (iShipCount == 0)
+	{
+		//FAssertMsg(iSoldierCount == 0, "Uh oh, soldiers stuck in europe");
+		return;
+	}
+
+	int iTotalShipCount = AI_getNumAIUnits(UNITAI_COMBAT_SEA);
+
+	int iShipsToLaunch = 0;
+
+	if (AI_isStrategy(STRATEGY_SMALL_WAVES))//Set at start of revolution.
+	{
+		iShipsToLaunch = (iTotalShipCount + 9) / 10;
+	}
+	else if (AI_isStrategy(STRATEGY_BUILDUP))//Set when first ship gets back.
+	{
+		if (iShipCount > (iTotalShipCount / 2))
+		{
+			iShipsToLaunch = (iTotalShipCount + 2) / 3;
+
+			AI_clearStrategy(STRATEGY_BUILDUP);
+			AI_setStrategy(STRATEGY_SMALL_WAVES);
+		}
+	}
+
+	int iMinWaveSize = 3;
+
+	if (iShipCount < iMinWaveSize)
+	{
+		if (iTotalShipCount >= iMinWaveSize)
+		{
+			return;
+		}
+	}
+
+	iShipsToLaunch = std::max(iShipsToLaunch, iMinWaveSize);
+	iShipsToLaunch = std::min(iShipsToLaunch, iShipCount);
+
+
+	int iSoldiersToLoad = 0;
+
+	int iMaxCargo = iCargoSpace * iShipsToLaunch / iShipCount;
+	if (iSoldierCount < iMaxCargo)
+	{
+		iSoldiersToLoad = iSoldierCount;
+	}
+	else if (iSoldierCount < iMaxCargo * 2)
+	{
+		iSoldiersToLoad = iSoldierCount / 2;
+	}
+	else
+	{
+		iSoldiersToLoad = iMaxCargo;
+	}
+
+	if (iSoldiersToLoad > 0)
+	{
+		int iSoldiersLoaded = 0;
+		for (int i = 0; i < iShipCount; ++i)
+		{
+			CvUnit* pLoopUnit = ships[i];
+			FAssert(pLoopUnit != NULL);
+			if (i < iShipsToLaunch)
+			{
+				while (iSoldiersLoaded < iSoldiersToLoad)
+				{
+					CvUnit* pSoldier = soldiers[iSoldiersLoaded];
+					FAssert(pSoldier != NULL);
+
+					iSoldiersLoaded++;
+					loadUnitFromEurope(pSoldier, pLoopUnit);
+					if (pLoopUnit->isFull())
+					{
+						break;
+					}
+				}
+
+				CvPlot* pTargetPlot = AI_getImperialShipSpawnPlot();
+
+				if (!pLoopUnit->atPlot(pTargetPlot))
+				{
+					pLoopUnit->setXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), false, false, false);
+				}
+
+
+				pLoopUnit->crossOcean(UNIT_TRAVEL_STATE_FROM_EUROPE);
+			}
+		}
+	}
+	else if (iSoldierCount == 0)
+	{
+		//Lets wander around the New World!
+		for (int i = 0; i < iShipCount; ++i)
+		{
+			CvUnit* pLoopUnit = ships[i];
+			FAssert(pLoopUnit != NULL);
+
+			CvPlot* pTargetPlot = AI_getImperialShipSpawnPlot();
+
+			if (!pLoopUnit->atPlot(pTargetPlot))
+			{
+				pLoopUnit->setXY(pTargetPlot->getX_INLINE(), pTargetPlot->getY_INLINE(), false, false, false);
+			}
+
+			pLoopUnit->crossOcean(UNIT_TRAVEL_STATE_FROM_EUROPE);
+		}
+	}
+
+}
+
+void CvPlayerAI::AI_doUnitAIWeights()
+{
+	if ((GC.getGame().getGameTurn() == 2) || (GC.getGameINLINE().getSorenRandNum(50, "AI do Unit AI Weight Calculations") == 0))
+	for (int i = 0; i < NUM_UNITAI_TYPES; ++i)
+	{
+		int iWeight = 90 + GC.getGameINLINE().getSorenRandNum(20, "AI Unit AI Weights");
+
+		m_aiUnitAIStrategyWeights[i] = iWeight;
+	}
+}
+
+void CvPlayerAI::AI_doEmotions()
+{
+	CvMap& kMap = GC.getMap();
+
+	std::vector<short> const &distanceMap = *AI_getDistanceMap();
+
+	int iGreedValue = 0;
+	int iAnxietyValue = 0;
+	int iAngerValue = 0;
+	int iEnvyValue = 0;
+
+	for (int i = 0; i < kMap.numPlotsINLINE(); ++i)
+	{
+		CvPlot* pLoopPlot = kMap.plotByIndexINLINE(i);
+		if (distanceMap[i] != -1)
+		{
+			if (!pLoopPlot->isOwned())
+			{
+				if (pLoopPlot->getBonusType() != NO_BONUS)
+				{
+					if (pLoopPlot->isWater())
+					{
+						iGreedValue += 1;
+					}
+					else
+					{
+						iGreedValue += 2;
+					}
+				}
+			}
+			if (pLoopPlot->isVisible(getTeam(), false))
+			{
+				int iEnemyUnits = 0;
+				int iFriendlyUnits = 0;
+				int iNeutralColonialUnits = 0;
+				int iTreasureUnits = 0;
+
+
+				CLLNode<IDInfo>* pUnitNode;
+				CvUnit* pLoopUnit;
+				pUnitNode = pLoopPlot->headUnitNode();
+
+				while (pUnitNode != NULL)
+				{
+					pLoopUnit = ::getUnit(pUnitNode->m_data);
+					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+					if (pLoopUnit->getTeam() == getTeam())
+					{
+						iFriendlyUnits++;
+					}
+					else if (pLoopUnit->isEnemy(getTeam(), pLoopPlot))
+					{
+						iEnemyUnits++;
+					}
+					else
+					{
+						if (!pLoopUnit->isNative())
+						{
+							iNeutralColonialUnits++;
+						}
+					}
+
+					if (pLoopUnit->getTeam() != getTeam())
+					{
+						if ((pLoopUnit->getUnitInfo().isTreasure()) && pLoopUnit->getYieldStored() > 0)
+						{
+							iEnvyValue += pLoopUnit->getYieldStored() / 40;
+						}
+					}
+
+					if (pLoopPlot->getOwnerINLINE() == getID())
+					{
+						iAnxietyValue += 5 * iEnemyUnits;
+						if (isNative())
+						{
+							iAngerValue += 3 * iNeutralColonialUnits;
+						}
+					}
+					else
+					{
+						if (isNative())
+						{
+							iAngerValue += iNeutralColonialUnits;
+						}
+						iAngerValue += 1 * iEnemyUnits;
+						iAnxietyValue += 1 * iEnemyUnits;
+					}
+				}
+			}
+		}
+	}
+	iGreedValue /= 2;
+	AI_changeEmotion(EMOTION_GREED, iGreedValue);
+	AI_changeEmotion(EMOTION_ANXIETY, iAnxietyValue);
+	AI_changeEmotion(EMOTION_ANGER, iAngerValue);
+
+	//Anxiety
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (!pLoopCity->AI_isDefended())
+		{
+			AI_changeEmotion(EMOTION_ANXIETY, pLoopCity->getPopulation());
+		}
+	}
+}
+
+void CvPlayerAI::AI_doStrategy()
+{
+	int iGameTurn = GC.getGameINLINE().getGameTurn();
+	CvTeamAI& kTeam = GET_TEAM(getTeam());
+
+	int iPercent = 10000 / GC.getGame().AI_adjustedTurn(100);;
+
+	if (getParent() != NO_PLAYER)
+	{
+		if (iGameTurn == 1)
+		{
+			AI_setStrategy(STRATEGY_CASH_FOCUS);
+			AI_setStrategy(STRATEGY_SELL_TO_NATIVES);
+		}
+
+		if (iGameTurn == GC.getGameINLINE().AI_adjustedTurn(10))
+		{
+			//Set initial strategies.
+			if (GC.getGame().getSorenRandNum(100, "AI Fast Bells") < 30)
+			{
+				AI_setStrategy(STRATEGY_FAST_BELLS);
+			}
+
+			if (GC.getGameINLINE().getSorenRandNum(100, "AI Dense Spacing") < 50)
+			{
+				AI_setStrategy(STRATEGY_DENSE_CITY_SPACING);
+			}
+		}
+
+		if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+		{
+			if (!AI_isStrategy(STRATEGY_FAST_BELLS) && GC.getGameINLINE().getSorenRandNum(10000, "AI Fast Bells") < (2 * iPercent))
+			{
+				AI_setStrategy(STRATEGY_FAST_BELLS);
+			}
+
+			if (iGameTurn > GC.getGameINLINE().AI_adjustedTurn(35))
+			{
+				if (AI_isStrategy(STRATEGY_CASH_FOCUS) && GC.getGameINLINE().getSorenRandNum(10000, "AI Cash Focus") < (3 * iPercent))
+				{
+					AI_clearStrategy(STRATEGY_CASH_FOCUS);
+				}
+			}
+
+			if (!AI_isStrategy(STRATEGY_SELL_TO_NATIVES) && GC.getGameINLINE().getSorenRandNum(10000, "AI Sell to Natives") < (6 * iPercent))
+			{
+				AI_setStrategy(STRATEGY_SELL_TO_NATIVES);
+			}
+
+			if (GC.getGameINLINE().getSorenRandNum(10000, "AI toggle spacing strategy") < (4 * iPercent))
+			{
+				if (AI_isStrategy(STRATEGY_DENSE_CITY_SPACING))
+				{
+					AI_clearStrategy(STRATEGY_DENSE_CITY_SPACING);
+				}
+				else
+				{
+					AI_setStrategy(STRATEGY_DENSE_CITY_SPACING);
+				}
+			}
+		}
+
+		if (iGameTurn > GC.getGameINLINE().AI_adjustedTurn(100))
+		{
+			int iProb = 3 * iPercent;
+			int iRebelPercent = GET_TEAM(getTeam()).getRebelPercent();
+			iProb *= (100 + iRebelPercent + ((200 * iGameTurn) / GC.getGameINLINE().getEstimateEndTurn()));
+			iProb /= 100;
+
+			if (!AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+			{
+				if (GC.getGameINLINE().getSorenRandNum(10000, "AI Start Revolution") < iProb)
+				{
+					AI_setStrategy(STRATEGY_REVOLUTION_PREPARING);
+					AI_clearStrategy(STRATEGY_FAST_BELLS);
+				}
+			}
+			else if (!AI_isStrategy(STRATEGY_REVOLUTION_DECLARING))
+			{
+				if ((iRebelPercent > 70) &&  (AI_getStrategyDuration(STRATEGY_REVOLUTION_PREPARING) > GC.getGameINLINE().AI_adjustedTurn(20)))
+				{
+					if (GC.getGameINLINE().getSorenRandNum(10000, "AI Start Revolution") < iProb * 6)
+					{
+						AI_setStrategy(STRATEGY_REVOLUTION_DECLARING);
+					}
+				}
+			}
+			else
+			{
+				FAssert(AI_isStrategy(STRATEGY_REVOLUTION_DECLARING));
+				if (AI_getStrategyDuration(STRATEGY_REVOLUTION_DECLARING) > GC.getGameINLINE().AI_adjustedTurn(20))
+				{
+				    ///TKs Med
+					int iValue = iRebelPercent + 100 * AI_getStrategyDuration(STRATEGY_REVOLUTION_DECLARING) / GC.getGameINLINE().AI_adjustedTurn(50);
+
+					if (iValue > 125)
+					{
+					    int iID = getID();
+					    int iDefendersNeeded = AI_totalDefendersNeeded(NULL);
+					    int iTechValues = 0;
+					    for (int iI = 0; iI < GC.getNumCivicInfos(); iI++)
+                        {
+                            if (getIdeasResearched((CivicTypes)iI) > 0)
+                            {
+                                iTechValues += GC.getCivicInfo((CivicTypes)iI).getAIWeight();
+                            }
+                        }
+                        iTechValues += iValue;
+
+					    int iValueB =  iDefendersNeeded - AI_totalUnitAIs(UNITAI_OFFENSIVE) - AI_totalUnitAIs(UNITAI_COUNTER) - getNumCities();
+						if (iValueB <= 0 && iTechValues >= 1700)
+						{
+							if (kTeam.canDoRevolution())
+							{
+							    char szTKdebug[1024];
+                                sprintf( szTKdebug, "Player %d is Revolting in the turn %d with %d defenders needed\n", getID(), GC.getGameINLINE().getGameTurn(), AI_totalDefendersNeeded(NULL));
+                                gDLL->messageControlLog(szTKdebug);
+								kTeam.doRevolution();
+								AI_setStrategy(STRATEGY_REVOLUTION);
+							}
+						}
+					}
+					///Tks
+				}
+			}
+		}
+	}
+
+	if (isNative())
+	{
+		if (AI_isStrategy(STRATEGY_DIE_FIGHTING))
+		{
+			if (AI_getNumAIUnits(UNITAI_OFFENSIVE) == 0)
+			{
+				AI_clearStrategy(STRATEGY_DIE_FIGHTING);
+			}
+		}
+		else if (kTeam.getAnyWarPlanCount() > 0)
+		{
+			for (int i = 0; i < MAX_PLAYERS; ++i)
+			{
+				PlayerTypes eLoopPlayer = (PlayerTypes)i;
+				if (GET_PLAYER(eLoopPlayer).isAlive())
+				{
+					TeamTypes eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();
+					if (kTeam.isAtWar((TeamTypes)i))
+					{
+						WarPlanTypes eWarPlan = kTeam.AI_getWarPlan(eLoopTeam);
+						int iDuration = kTeam.AI_getWarPlanStateCounter(eLoopTeam);
+
+						bool bRazedCity = AI_getMemoryAttitude(eLoopPlayer, MEMORY_RAZED_CITY) > 0;
+
+						if (eWarPlan == WARPLAN_ATTACKED || eWarPlan == WARPLAN_TOTAL)
+						{
+							AI_setStrategy(STRATEGY_DIE_FIGHTING);
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+int CvPlayerAI::AI_countDeadlockedBonuses(CvPlot* pPlot)
+{
+    CvPlot* pLoopPlot;
+    CvPlot* pLoopPlot2;
+    int iDX, iDY;
+    int iI;
+
+    int iMinRange = GC.getMIN_CITY_RANGE();
+    int iRange = iMinRange * 2;
+    int iCount = 0;
+
+    for (iDX = -(iRange); iDX <= iRange; iDX++)
+    {
+        for (iDY = -(iRange); iDY <= iRange; iDY++)
+        {
+            if (plotDistance(iDX, iDY, 0, 0) > CITY_PLOTS_RADIUS)
+            {
+                pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+
+                if (pLoopPlot != NULL)
+                {
+                    if (pLoopPlot->getBonusType() != NO_BONUS)
+                    {
+                        if (!pLoopPlot->isCityRadius() && ((pLoopPlot->area() == pPlot->area()) || pLoopPlot->isWater()))
+                        {
+                            bool bCanFound = false;
+                            bool bNeverFound = true;
+                            //potentially blockable resource
+                            //look for a city site within a city radius
+                            for (iI = 0; iI < NUM_CITY_PLOTS; iI++)
+                            {
+                                pLoopPlot2 = plotCity(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), iI);
+                                if (pLoopPlot2 != NULL)
+                                {
+                                    //canFound usually returns very quickly
+                                    if (canFound(pLoopPlot2->getX_INLINE(), pLoopPlot2->getY_INLINE(), false))
+                                    {
+                                        bNeverFound = false;
+                                        if (stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot2->getX_INLINE(), pLoopPlot2->getY_INLINE()) > iMinRange)
+                                        {
+                                            bCanFound = true;
+                                            break;
+                                        }
+                                    }
+                                }
+                            }
+                            if (!bNeverFound && !bCanFound)
+                            {
+                                iCount++;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return iCount;
+}
+
+int CvPlayerAI::AI_getOurPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves)
+{
+	PROFILE_FUNC();
+
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	CvPlot* pLoopPlot;
+	int iValue;
+	int iDistance;
+	int iDX, iDY;
+
+	iValue = 0;
+
+	for (iDX = -(iRange); iDX <= iRange; iDX++)
+	{
+		for (iDY = -(iRange); iDY <= iRange; iDY++)
+		{
+			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+
+			if (pLoopPlot != NULL)
+			{
+				if (pLoopPlot->area() == pPlot->area())
+				{
+				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
+					pUnitNode = pLoopPlot->headUnitNode();
+
+					while (pUnitNode != NULL)
+					{
+						pLoopUnit = ::getUnit(pUnitNode->m_data);
+						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+						if (pLoopUnit->getOwnerINLINE() == getID())
+						{
+							if ((bDefensiveBonuses && pLoopUnit->canDefend()) || pLoopUnit->canAttack())
+							{
+								if (!(pLoopUnit->isInvisible(getTeam(), false)))
+								{
+								    if (pLoopUnit->atPlot(pPlot) || pLoopUnit->canMoveInto(pPlot) || pLoopUnit->canMoveInto(pPlot, /*bAttack*/ true))
+								    {
+                                        if (!bTestMoves)
+                                        {
+                                        	iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
+                                        }
+                                        else
+                                        {
+											if (pLoopUnit->baseMoves() >= iDistance)
+                                            {
+                                                iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
+                                            }
+                                        }
+								    }
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+
+	return iValue;
+}
+
+int CvPlayerAI::AI_getEnemyPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves)
+{
+	PROFILE_FUNC();
+
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	CvPlot* pLoopPlot;
+	int iValue;
+	int iDistance;
+	int iDX, iDY;
+
+	iValue = 0;
+
+	for (iDX = -(iRange); iDX <= iRange; iDX++)
+	{
+		for (iDY = -(iRange); iDY <= iRange; iDY++)
+		{
+			pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iDX, iDY);
+
+			if (pLoopPlot != NULL)
+			{
+				if (pLoopPlot->area() == pPlot->area())
+				{
+				    iDistance = stepDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE());
+					pUnitNode = pLoopPlot->headUnitNode();
+
+					while (pUnitNode != NULL)
+					{
+						pLoopUnit = ::getUnit(pUnitNode->m_data);
+						pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+						if (atWar(pLoopUnit->getTeam(), getTeam()))
+						{
+							if ((bDefensiveBonuses && pLoopUnit->canDefend()) || pLoopUnit->canAttack())
+							{
+								if (!(pLoopUnit->isInvisible(getTeam(), false)))
+								{
+								    if (pPlot->isValidDomainForAction(*pLoopUnit))
+								    {
+                                        if (!bTestMoves)
+                                        {
+                                            iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
+                                        }
+                                        else
+                                        {
+                                            int iDangerRange = pLoopUnit->baseMoves();
+                                            iDangerRange += ((pLoopPlot->isValidRoute(pLoopUnit)) ? 1 : 0);
+                                            if (iDangerRange >= iDistance)
+                                            {
+                                                iValue += pLoopUnit->currEffectiveStr((bDefensiveBonuses ? pPlot : NULL), NULL);
+                                            }
+                                        }
+								    }
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+
+	return iValue;
+
+}
+
+int CvPlayerAI::AI_goldToUpgradeAllUnits(int iExpThreshold)
+{
+	if (m_iUpgradeUnitsCacheTurn == GC.getGameINLINE().getGameTurn() && m_iUpgradeUnitsCachedExpThreshold == iExpThreshold)
+	{
+		return m_iUpgradeUnitsCachedGold;
+	}
+
+	int iTotalGold = 0;
+
+	CvCivilizationInfo& kCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
+
+	// cache the value for each unit type
+	std::vector<int> aiUnitUpgradePrice(GC.getNumUnitInfos(), 0);	// initializes to zeros
+
+	int iLoop;
+	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+	{
+		// if experience is below threshold, skip this unit
+		if (pLoopUnit->getExperience() < iExpThreshold)
+		{
+			continue;
+		}
+
+		UnitTypes eUnitType = pLoopUnit->getUnitType();
+
+		// check cached value for this unit type
+		int iCachedUnitGold = aiUnitUpgradePrice[eUnitType];
+		if (iCachedUnitGold != 0)
+		{
+			// if positive, add it to the sum
+			if (iCachedUnitGold > 0)
+			{
+				iTotalGold += iCachedUnitGold;
+			}
+
+			// either way, done with this unit
+			continue;
+		}
+
+		int iUnitGold = 0;
+		int iUnitUpgradePossibilities = 0;
+
+		UnitAITypes eUnitAIType = pLoopUnit->AI_getUnitAIType();
+		CvArea* pUnitArea = pLoopUnit->area();
+		int iUnitValue = AI_unitValue(eUnitType, eUnitAIType, pUnitArea);
+
+		for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+		{
+			UnitClassTypes eUpgradeUnitClassType = (UnitClassTypes) iI;
+			UnitTypes eUpgradeUnitType = (UnitTypes)(kCivilizationInfo.getCivilizationUnits(iI));
+
+			if (NO_UNIT != eUpgradeUnitType)
+			{
+				// is it better?
+				int iUpgradeValue = AI_unitValue(eUpgradeUnitType, eUnitAIType, pUnitArea);
+				if (iUpgradeValue > iUnitValue)
+				{
+					// is this a valid upgrade?
+					if (pLoopUnit->upgradeAvailable(eUnitType, eUpgradeUnitClassType))
+					{
+						// can we actually make this upgrade?
+						bool bCanUpgrade = false;
+						CvCity* pCapitalCity = getPrimaryCity();
+						if (pCapitalCity != NULL && pCapitalCity->canTrain(eUpgradeUnitType))
+						{
+							bCanUpgrade = true;
+						}
+						else
+						{
+							CvCity* pCloseCity = GC.getMapINLINE().findCity(pLoopUnit->getX_INLINE(), pLoopUnit->getY_INLINE(), getID(), NO_TEAM, true, (pLoopUnit->getDomainType() == DOMAIN_SEA));
+							if (pCloseCity != NULL && pCloseCity->canTrain(eUpgradeUnitType))
+							{
+								bCanUpgrade = true;
+							}
+						}
+
+						if (bCanUpgrade)
+						{
+							iUnitGold += pLoopUnit->upgradePrice(eUpgradeUnitType);
+							iUnitUpgradePossibilities++;
+						}
+					}
+				}
+			}
+		}
+
+		// if we found any, find average and add to total
+		if (iUnitUpgradePossibilities > 0)
+		{
+			iUnitGold /= iUnitUpgradePossibilities;
+
+			// add to cache
+			aiUnitUpgradePrice[eUnitType] = iUnitGold;
+
+			// add to sum
+			iTotalGold += iUnitGold;
+		}
+		else
+		{
+			// add to cache, dont upgrade to this type
+			aiUnitUpgradePrice[eUnitType] = -1;
+		}
+	}
+
+	m_iUpgradeUnitsCacheTurn = GC.getGameINLINE().getGameTurn();
+	m_iUpgradeUnitsCachedExpThreshold = iExpThreshold;
+	m_iUpgradeUnitsCachedGold = iTotalGold;
+
+	return iTotalGold;
+}
+
+int CvPlayerAI::AI_goldTradeValuePercent()
+{
+	return 100;
+}
+
+int CvPlayerAI::AI_playerCloseness(PlayerTypes eIndex, int iMaxDistance)
+{
+	PROFILE_FUNC();
+	CvCity* pLoopCity;
+	int iLoop;
+	int iValue;
+
+	FAssert(GET_PLAYER(eIndex).isAlive());
+	FAssert(eIndex != getID());
+
+	iValue = 0;
+	for (pLoopCity = GET_PLAYER(eIndex).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(eIndex).nextCity(&iLoop))
+	{
+		iValue += pLoopCity->AI_playerCloseness(eIndex, iMaxDistance);
+	}
+
+	return iValue;
+}
+
+int CvPlayerAI::AI_targetValidity(PlayerTypes ePlayer)
+{
+	FAssert(ePlayer != NO_PLAYER);
+
+	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
+
+	if (!kPlayer.isAlive())
+	{
+		return 0;
+	}
+	if (kPlayer.getTeam() == getTeam())
+	{
+		return 0;
+	}
+
+	int iAggressionRange = 10;
+	if (isNative())
+	{
+		iAggressionRange = 5;
+	}
+
+	int iValidTargetCount = 0;
+	int iTotalValue = 0;
+
+	if (!kPlayer.isAlive())
+	{
+		return 0;
+	}
+
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
+	{
+		bool bLandTarget = (pLoopCity->area()->getCitiesPerPlayer(getID()) > 0);
+
+		if (bLandTarget || !isNative())
+		{
+			int iDistance = AI_cityDistance(pLoopCity->plot());
+			int iAdjustedRange = iAggressionRange;
+			if (!bLandTarget)
+			{
+				iAdjustedRange *= 2;
+			}
+
+			if (iDistance <= iAdjustedRange)
+			{
+				iTotalValue += 100 - (100 * (iDistance - 1)) / iAdjustedRange;
+				iValidTargetCount++;
+			}
+		}
+	}
+
+	int iValue = (2 * iTotalValue) / (1 + kPlayer.getNumCities() + iValidTargetCount);
+	return iValue;
+}
+
+int CvPlayerAI::AI_totalDefendersNeeded(int* piUndefendedCityCount)
+{
+	PROFILE_FUNC();
+	CvCity* pLoopCity;
+	int iLoop;
+	int iValue;
+
+	int iTotalNeeded = 0;
+	int iUndefendedCount = 0;
+
+	iValue = 0;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		int iHave = pLoopCity->AI_numDefenders(true, true);
+		int iNeeded = pLoopCity->AI_neededDefenders();
+
+		if (iNeeded > 0)
+		{
+			if (iHave == 0)
+			{
+				iUndefendedCount++;
+			}
+			iTotalNeeded += iNeeded - iHave;
+		}
+	}
+
+	if (piUndefendedCityCount != NULL)
+	{
+		*piUndefendedCityCount = iUndefendedCount;
+	}
+
+	return iTotalNeeded;
+}
+
+
+int CvPlayerAI::AI_getTotalAreaCityThreat(CvArea* pArea)
+{
+	PROFILE_FUNC();
+	CvCity* pLoopCity;
+	int iLoop;
+	int iValue;
+
+	iValue = 0;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity->getArea() == pArea->getID())
+		{
+			iValue += pLoopCity->AI_cityThreat();
+		}
+	}
+	return iValue;
+}
+
+int CvPlayerAI::AI_countNumAreaHostileUnits(CvArea* pArea, bool bPlayer, bool bTeam, bool bNeutral, bool bHostile)
+{
+	PROFILE_FUNC();
+	CvPlot* pLoopPlot;
+	int iCount;
+	int iI;
+
+	iCount = 0;
+
+	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+	{
+		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+		if ((pLoopPlot->area() == pArea) && pLoopPlot->isVisible(getTeam(), false) &&
+			((bPlayer && pLoopPlot->getOwnerINLINE() == getID()) || (bTeam && pLoopPlot->getTeam() == getTeam())
+				|| (bNeutral && !pLoopPlot->isOwned()) || (bHostile && pLoopPlot->isOwned() && GET_TEAM(getTeam()).isAtWar(pLoopPlot->getTeam()))))
+			{
+			iCount += pLoopPlot->plotCount(PUF_isEnemy, getID(), false, NO_PLAYER, NO_TEAM, PUF_isVisible, getID());
+		}
+	}
+	return iCount;
+}
+
+//this doesn't include the minimal one or two garrison units in each city.
+int CvPlayerAI::AI_getTotalFloatingDefendersNeeded(CvArea* pArea)
+{
+	PROFILE_FUNC();
+	int iDefenders;
+	int iCurrentEra = getCurrentEra();
+	int iAreaCities = pArea->getCitiesPerPlayer(getID());
+
+	iCurrentEra = std::max(0, iCurrentEra - GC.getGame().getStartEra() / 2);
+
+	iDefenders = 1 + ((iCurrentEra + ((GC.getGameINLINE().getMaxCityElimination() > 0) ? 3 : 2)) * iAreaCities);
+	iDefenders /= 3;
+	iDefenders += pArea->getPopulationPerPlayer(getID()) / 7;
+
+	if (pArea->getAreaAIType(getTeam()) == AREAAI_DEFENSIVE)
+	{
+		iDefenders *= 2;
+	}
+	else if ((pArea->getAreaAIType(getTeam()) == AREAAI_OFFENSIVE) || (pArea->getAreaAIType(getTeam()) == AREAAI_MASSING))
+	{
+		iDefenders *= 2;
+		iDefenders /= 3;
+	}
+
+	if (AI_getTotalAreaCityThreat(pArea) == 0)
+	{
+		iDefenders /= 2;
+	}
+
+	if (!GC.getGameINLINE().isOption(GAMEOPTION_AGGRESSIVE_AI))
+	{
+		iDefenders *= 2;
+		iDefenders /= 3;
+	}
+
+	iDefenders *= 60;
+	iDefenders /= std::max(30, (GC.getHandicapInfo(GC.getGameINLINE().getHandicapType()).getAITrainPercent() - 20));
+
+	if (getPrimaryCity() != NULL)
+	{
+		if (getPrimaryCity()->area() != pArea)
+		{
+			//Defend offshore islands only lightly.
+			iDefenders = std::min(iDefenders, iAreaCities * iAreaCities - 1);
+		}
+	}
+
+	return iDefenders;
+}
+
+int CvPlayerAI::AI_getTotalFloatingDefenders(CvArea* pArea)
+{
+	PROFILE_FUNC();
+	int iCount = 0;
+
+	iCount += AI_totalAreaUnitAIs(pArea, UNITAI_DEFENSIVE);
+	iCount += AI_totalAreaUnitAIs(pArea, UNITAI_OFFENSIVE);
+	iCount += AI_totalAreaUnitAIs(pArea, UNITAI_COUNTER);
+	return iCount / 2;
+}
+
+RouteTypes CvPlayerAI::AI_bestAdvancedStartRoute(CvPlot* pPlot, int* piYieldValue)
+{
+	RouteTypes eBestRoute = NO_ROUTE;
+	int iBestValue = -1;
+    for (int iI = 0; iI < GC.getNumRouteInfos(); iI++)
+    {
+        RouteTypes eRoute = (RouteTypes)iI;
+
+		int iValue = 0;
+		int iCost = getAdvancedStartRouteCost(eRoute, true, pPlot);
+
+		if (iCost >= 0)
+		{
+			iValue += GC.getRouteInfo(eRoute).getValue();
+
+			if (iValue > 0)
+			{
+				int iYieldValue = 0;
+				if (pPlot->getImprovementType() != NO_IMPROVEMENT)
+				{
+					iYieldValue += ((GC.getImprovementInfo(pPlot->getImprovementType()).getRouteYieldChanges(eRoute, YIELD_FOOD)) * 100);
+				}
+				iValue *= 1000;
+				iValue /= (1 + iCost);
+
+				if (iValue > iBestValue)
+				{
+					iBestValue = iValue;
+					eBestRoute = eRoute;
+					if (piYieldValue != NULL)
+					{
+						*piYieldValue = iYieldValue;
+					}
+				}
+			}
+		}
+	}
+	return eBestRoute;
+}
+
+UnitTypes CvPlayerAI::AI_bestAdvancedStartUnitAI(CvPlot* pPlot, UnitAITypes eUnitAI)
+{
+	UnitTypes eLoopUnit;
+	UnitTypes eBestUnit;
+	int iValue;
+	int iBestValue;
+	int iI, iJ, iK;
+
+	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
+
+	iBestValue = 0;
+	eBestUnit = NO_UNIT;
+
+	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
+
+		if (eLoopUnit != NO_UNIT)
+		{
+			if (GC.getUnitInfo(eLoopUnit).getDefaultUnitAIType() == eUnitAI)
+			{
+				int iUnitCost = getAdvancedStartUnitCost(eLoopUnit, true, pPlot);
+				if (iUnitCost >= 0)
+				{
+					iValue = AI_unitValue(eLoopUnit, eUnitAI, pPlot->area());
+
+					if (iValue > 0)
+					{
+						//free promotions. slow?
+						//only 1 promotion per source is counted (ie protective isn't counted twice)
+						int iPromotionValue = 0;
+
+						//special to the unit
+						for (iJ = 0; iJ < GC.getNumPromotionInfos(); iJ++)
+						{
+							if (GC.getUnitInfo(eLoopUnit).getFreePromotions(iJ))
+							{
+								iPromotionValue += 15;
+								break;
+							}
+						}
+
+						for (iK = 0; iK < GC.getNumPromotionInfos(); iK++)
+						{
+							if (isFreePromotion((UnitCombatTypes)GC.getUnitInfo(eLoopUnit).getUnitCombatType(), (PromotionTypes)iK))
+							{
+								iPromotionValue += 15;
+								break;
+							}
+
+							if (isFreePromotion((UnitClassTypes)GC.getUnitInfo(eLoopUnit).getUnitClassType(), (PromotionTypes)iK))
+							{
+								iPromotionValue += 15;
+								break;
+							}
+						}
+
+						//traits
+						for (iJ = 0; iJ < GC.getNumTraitInfos(); iJ++)
+						{
+							if (hasTrait((TraitTypes)iJ))
+							{
+								for (iK = 0; iK < GC.getNumPromotionInfos(); iK++)
+								{
+									if (GC.getTraitInfo((TraitTypes) iJ).isFreePromotion(iK))
+									{
+										if ((GC.getUnitInfo(eLoopUnit).getUnitCombatType() != NO_UNITCOMBAT) && GC.getTraitInfo((TraitTypes) iJ).isFreePromotionUnitCombat(GC.getUnitInfo(eLoopUnit).getUnitCombatType()))
+										{
+											iPromotionValue += 15;
+											break;
+										}
+									}
+								}
+							}
+						}
+
+						iValue *= (iPromotionValue + 100);
+						iValue /= 100;
+
+						iValue *= (GC.getGameINLINE().getSorenRandNum(40, "AI Best Advanced Start Unit") + 100);
+						iValue /= 100;
+
+						iValue *= (getNumCities() + 2);
+						iValue /= (getUnitClassCountPlusMaking((UnitClassTypes)iI) + getNumCities() + 2);
+
+						FAssert((MAX_INT / 1000) > iValue);
+						iValue *= 1000;
+
+						iValue /= 1 + iUnitCost;
+
+						iValue = std::max(1, iValue);
+
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							eBestUnit = eLoopUnit;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return eBestUnit;
+}
+
+CvPlot* CvPlayerAI::AI_advancedStartFindCapitalPlot()
+{
+	CvPlot* pBestPlot = NULL;
+	int iBestValue = -1;
+
+	for (int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)
+	{
+		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
+		if (kPlayer.isAlive())
+		{
+			if (kPlayer.getTeam() == getTeam())
+			{
+				CvPlot* pLoopPlot = kPlayer.getStartingPlot();
+				if (pLoopPlot != NULL)
+				{
+					if (getAdvancedStartCityCost(true, pLoopPlot) > 0)
+					{
+					int iX = pLoopPlot->getX_INLINE();
+					int iY = pLoopPlot->getY_INLINE();
+
+						int iValue = 1000;
+						if (iPlayer == getID())
+						{
+							iValue += 1000;
+						}
+						else
+						{
+							iValue += GC.getGame().getSorenRandNum(100, "AI Advanced Start Choose Team Start");
+						}
+						CvCity * pNearestCity = GC.getMapINLINE().findCity(iX, iY, NO_PLAYER, getTeam());
+						if (NULL != pNearestCity)
+						{
+							FAssert(pNearestCity->getTeam() == getTeam());
+							int iDistance = stepDistance(iX, iY, pNearestCity->getX_INLINE(), pNearestCity->getY_INLINE());
+							if (iDistance < 10)
+							{
+								iValue /= (10 - iDistance);
+							}
+						}
+
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							pBestPlot = pLoopPlot;
+						}
+					}
+				}
+				else
+				{
+					FAssertMsg(false, "StartingPlot for a live player is NULL!");
+				}
+			}
+		}
+	}
+
+	if (pBestPlot != NULL)
+	{
+		return pBestPlot;
+	}
+
+	FAssertMsg(false, "AS: Failed to find a starting plot for a player");
+
+	//Execution should almost never reach here.
+
+	//Update found values just in case - particulary important for simultaneous turns.
+	AI_updateFoundValues();
+
+	pBestPlot = NULL;
+	iBestValue = -1;
+
+	if (NULL != getStartingPlot())
+	{
+		for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+		{
+			CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+			if (pLoopPlot->getArea() == getStartingPlot()->getArea())
+			{
+				int iValue = pLoopPlot->getFoundValue(getID());
+				if (iValue > 0)
+				{
+					if (getAdvancedStartCityCost(true, pLoopPlot) > 0)
+					{
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							pBestPlot = pLoopPlot;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (pBestPlot != NULL)
+	{
+		return pBestPlot;
+	}
+
+	//Commence panic.
+	FAssertMsg(false, "Failed to find an advanced start starting plot");
+	return NULL;
+}
+
+
+bool CvPlayerAI::AI_advancedStartPlaceExploreUnits(bool bLand)
+{
+	CvPlot* pBestExplorePlot = NULL;
+	int iBestExploreValue = 0;
+	UnitTypes eBestUnitType = NO_UNIT;
+
+	UnitAITypes eUnitAI = NO_UNITAI;
+	if (bLand)
+	{
+		eUnitAI = UNITAI_SCOUT;
+	}
+	else if (!bLand)
+	{
+		return false;
+	}
+
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		CvPlot* pLoopPlot = pLoopCity->plot();
+		CvArea* pLoopArea = bLand ? pLoopCity->area() : pLoopPlot->waterArea();
+
+		if (pLoopArea != NULL)
+			{
+			int iValue = std::max(0, pLoopArea->getNumUnrevealedTiles(getTeam()) - 10) * 10;
+			iValue += std::max(0, pLoopArea->getNumTiles() - 50);
+
+				if (iValue > 0)
+				{
+					int iOtherPlotCount = 0;
+					int iGoodyCount = 0;
+					int iExplorerCount = 0;
+				int iAreaId = pLoopArea->getID();
+
+				int iRange = 4;
+					for (int iX = -iRange; iX <= iRange; iX++)
+					{
+						for (int iY = -iRange; iY <= iRange; iY++)
+						{
+							CvPlot* pLoopPlot2 = plotXY(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), iX, iY);
+						if (NULL != pLoopPlot2)
+							{
+								iExplorerCount += pLoopPlot2->plotCount(PUF_isUnitAIType, eUnitAI, -1, NO_PLAYER, getTeam());
+							if (pLoopPlot2->getArea() == iAreaId)
+							{
+								if (pLoopPlot2->isGoody())
+								{
+									iGoodyCount++;
+								}
+								if (pLoopPlot2->getTeam() != getTeam())
+								{
+									iOtherPlotCount++;
+								}
+							}
+						}
+					}
+				}
+
+					iValue -= 300 * iExplorerCount;
+					iValue += 200 * iGoodyCount;
+					iValue += 10 * iOtherPlotCount;
+					if (iValue > iBestExploreValue)
+					{
+						UnitTypes eUnit = AI_bestAdvancedStartUnitAI(pLoopPlot, eUnitAI);
+						if (eUnit != NO_UNIT)
+						{
+							eBestUnitType = eUnit;
+							iBestExploreValue = iValue;
+							pBestExplorePlot = pLoopPlot;
+						}
+					}
+				}
+			}
+		}
+
+	if (pBestExplorePlot != NULL)
+	{
+		doAdvancedStartAction(ADVANCEDSTARTACTION_UNIT, pBestExplorePlot->getX_INLINE(), pBestExplorePlot->getY_INLINE(), eBestUnitType, true);
+		return true;
+	}
+	return false;
+}
+
+void CvPlayerAI::AI_advancedStartRevealRadius(CvPlot* pPlot, int iRadius)
+{
+	for (int iRange = 1; iRange <=iRadius; iRange++)
+	{
+		for (int iX = -iRange; iX <= iRange; iX++)
+		{
+			for (int iY = -iRange; iY <= iRange; iY++)
+			{
+				if (plotDistance(0, 0, iX, iY) <= iRadius)
+				{
+					CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
+
+					if (NULL != pLoopPlot)
+					{
+						if (getAdvancedStartVisibilityCost(true, pLoopPlot) > 0)
+						{
+							doAdvancedStartAction(ADVANCEDSTARTACTION_VISIBILITY, pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), -1, true);
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+bool CvPlayerAI::AI_advancedStartPlaceCity(CvPlot* pPlot)
+{
+	if (isNative())
+	{
+		doAdvancedStartAction(ADVANCEDSTARTACTION_CITY, pPlot->getX(), pPlot->getY(), -1, true);
+		return true;
+	}
+	//If there is already a city, then improve it.
+	CvCity* pCity = pPlot->getPlotCity();
+	if (pCity == NULL)
+	{
+		doAdvancedStartAction(ADVANCEDSTARTACTION_CITY, pPlot->getX(), pPlot->getY(), -1, true);
+
+		pCity = pPlot->getPlotCity();
+		if ((pCity == NULL) || (pCity->getOwnerINLINE() != getID()))
+		{
+			//this should never happen since the cost for a city should be 0 if
+			//the city can't be placed.
+			//(It can happen if another player has placed a city in the fog)
+			FAssertMsg(false, "ADVANCEDSTARTACTION_CITY failed in unexpected way");
+			return false;
+		}
+	}
+
+	/*
+	if (pCity->getCultureLevel() <= 1)
+	{
+		doAdvancedStartAction(ADVANCEDSTARTACTION_CULTURE, pPlot->getX(), pPlot->getY(), -1, true);
+	}
+	*/
+
+	//to account for culture expansion.
+	pCity->AI_updateBestBuild();
+
+	int iPlotsImproved = 0;
+	for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
+	{
+		if (iI != CITY_HOME_PLOT)
+		{
+			CvPlot* pLoopPlot = plotCity(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iI);
+			if ((pLoopPlot != NULL) && (pLoopPlot->getWorkingCity() == pCity))
+			{
+				if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
+				{
+					iPlotsImproved++;
+				}
+			}
+		}
+	}
+
+	int iTargetPopulation = (getCurrentEra() / 2 + 3);
+
+	while (iPlotsImproved < iTargetPopulation)
+	{
+		CvPlot* pBestPlot;
+		ImprovementTypes eBestImprovement = NO_IMPROVEMENT;
+		int iBestValue = 0;
+		for (int iI = 0; iI < NUM_CITY_PLOTS; iI++)
+		{
+			int iValue = pCity->AI_getBestBuildValue(iI);
+			if (iValue > iBestValue)
+			{
+				BuildTypes eBuild = pCity->AI_getBestBuild(iI);
+				if (eBuild != NO_BUILD)
+				{
+					ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild).getImprovement();
+					if (eImprovement != NO_IMPROVEMENT)
+					{
+						CvPlot* pLoopPlot = plotCity(pCity->getX_INLINE(), pCity->getY_INLINE(), iI);
+						if ((pLoopPlot != NULL) && (pLoopPlot->getImprovementType() != eImprovement))
+						{
+							eBestImprovement = eImprovement;
+							pBestPlot = pLoopPlot;
+							iBestValue = iValue;
+						}
+					}
+				}
+			}
+		}
+
+		if (iBestValue > 0)
+		{
+
+			FAssert(pBestPlot != NULL);
+			doAdvancedStartAction(ADVANCEDSTARTACTION_IMPROVEMENT, pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE(), eBestImprovement, true);
+			iPlotsImproved++;
+			if (pCity->getPopulation() < iPlotsImproved)
+			{
+				doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pBestPlot->getX_INLINE(), pBestPlot->getY_INLINE(), -1, true);
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+
+	while (iPlotsImproved > pCity->getPopulation())
+	{
+		int iPopCost = getAdvancedStartPopCost(true, pCity);
+		if (iPopCost <= 0 || iPopCost > getAdvancedStartPoints())
+		{
+			break;
+		}
+		doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pPlot->getX_INLINE(), pPlot->getY_INLINE(), -1, true);
+	}
+
+	while (iTargetPopulation > pCity->getPopulation())
+	{
+		int iPopCost = getAdvancedStartPopCost(true, pCity);
+		if (iPopCost <= 0 || iPopCost > getAdvancedStartPoints())
+		{
+			break;
+		}
+		doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pPlot->getX_INLINE(), pPlot->getY_INLINE(), -1, true);
+	}
+
+	pCity->AI_updateAssignWork();
+
+	return true;
+}
+
+
+
+
+//Returns false if we have no more points.
+bool CvPlayerAI::AI_advancedStartDoRoute(CvPlot* pFromPlot, CvPlot* pToPlot)
+{
+	FAssert(pFromPlot != NULL);
+	FAssert(pToPlot != NULL);
+
+	FAStarNode* pNode;
+	gDLL->getFAStarIFace()->ForceReset(&GC.getStepFinder());
+	if (gDLL->getFAStarIFace()->GeneratePath(&GC.getStepFinder(), pFromPlot->getX_INLINE(), pFromPlot->getY_INLINE(), pToPlot->getX_INLINE(), pToPlot->getY_INLINE(), false, 0, true))
+	{
+		pNode = gDLL->getFAStarIFace()->GetLastNode(&GC.getStepFinder());
+		if (pNode != NULL)
+		{
+			if (pNode->m_iData1 > (1 + stepDistance(pFromPlot->getX(), pFromPlot->getY(), pToPlot->getX(), pToPlot->getY())))
+			{
+				//Don't build convulted paths.
+				return true;
+			}
+		}
+
+		while (pNode != NULL)
+		{
+			CvPlot* pPlot = GC.getMapINLINE().plotSorenINLINE(pNode->m_iX, pNode->m_iY);
+			RouteTypes eRoute = AI_bestAdvancedStartRoute(pPlot);
+			if (eRoute != NO_ROUTE)
+			{
+				if (getAdvancedStartRouteCost(eRoute, true, pPlot) > getAdvancedStartPoints())
+				{
+					return false;
+				}
+				doAdvancedStartAction(ADVANCEDSTARTACTION_ROUTE, pNode->m_iX, pNode->m_iY, eRoute, true);
+			}
+			pNode = pNode->m_pParent;
+		}
+	}
+	return true;
+}
+void CvPlayerAI::AI_advancedStartRouteTerritory()
+{
+	CvPlot* pLoopPlot;
+	int iI;
+
+	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+	{
+		pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+		if ((pLoopPlot != NULL) && (pLoopPlot->getOwner() == getID()) && (pLoopPlot->getRouteType() == NO_ROUTE))
+		{
+			if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
+			{
+				if (pLoopPlot->getRouteType() == NO_ROUTE)
+				{
+					int iRouteYieldValue = 0;
+					RouteTypes eRoute = (AI_bestAdvancedStartRoute(pLoopPlot, &iRouteYieldValue));
+					if (eRoute != NO_ROUTE && iRouteYieldValue > 0)
+					{
+						doAdvancedStartAction(ADVANCEDSTARTACTION_ROUTE, pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), eRoute, true);
+					}
+				}
+			}
+		}
+	}
+}
+
+
+void CvPlayerAI::AI_doAdvancedStart(bool bNoExit)
+{
+	if (NULL == getStartingPlot())
+	{
+		FAssert(false);
+		return;
+	}
+
+	int iTargetCityCount = GC.getWorldInfo(GC.getMapINLINE().getWorldSize()).getTargetNumCities();
+
+	iTargetCityCount = 1 + iTargetCityCount + GC.getGameINLINE().getSorenRandNum(2 * iTargetCityCount, "AI Native Civilization Size");
+	iTargetCityCount /= 2;
+
+	int iLoop;
+	CvCity* pLoopCity;
+	int iStartingPoints = getAdvancedStartPoints();
+	int iRevealPoints;
+	int iMilitaryPoints;
+	int iCityPoints;
+
+	bool bIsNative = isNative();
+
+	if (bIsNative)
+	{
+		AI_createNatives();
+		if (bNoExit)
+		{
+			return;
+		}
+		else
+		{
+			doAdvancedStartAction(ADVANCEDSTARTACTION_EXIT, -1, -1, -1, true);
+		}
+	}
+
+	if (isNative())
+	{
+		iRevealPoints = (iStartingPoints * 20) / 100;
+		iMilitaryPoints = (iStartingPoints * 40) / 100;
+		iCityPoints = iStartingPoints - (iMilitaryPoints + iRevealPoints);
+	}
+	else
+	{
+		iRevealPoints = (iStartingPoints * 10) / 100;
+		iMilitaryPoints = (iStartingPoints * (isHuman() ? 17 : 20)) / 100;
+		iCityPoints = iStartingPoints - (iMilitaryPoints + iRevealPoints);
+	}
+
+	if (!bIsNative)
+	{
+
+		if (getPrimaryCity() != NULL)
+		{
+			AI_advancedStartPlaceCity(getPrimaryCity()->plot());
+		}
+		else
+		{
+			for (int iPass = 0; iPass < 2 && NULL == getPrimaryCity(); ++iPass)
+			{
+				CvPlot* pBestCapitalPlot = AI_advancedStartFindCapitalPlot();
+
+				if (pBestCapitalPlot != NULL)
+				{
+					if (!AI_advancedStartPlaceCity(pBestCapitalPlot))
+					{
+						FAssertMsg(false, "AS AI: Unexpected failure placing capital");
+					}
+					break;
+				}
+				else
+				{
+					//If this point is reached, the advanced start system is broken.
+					//Find a new starting plot for this player
+					setStartingPlot(findStartingPlot(false), true);
+					//Redo Starting visibility
+					CvPlot* pStartingPlot = getStartingPlot();
+					if (NULL != pStartingPlot)
+					{
+						for (int iPlotLoop = 0; iPlotLoop < GC.getMapINLINE().numPlots(); ++iPlotLoop)
+						{
+							CvPlot* pPlot = GC.getMapINLINE().plotByIndex(iPlotLoop);
+
+							if (plotDistance(pPlot->getX_INLINE(), pPlot->getY_INLINE(), pStartingPlot->getX_INLINE(), pStartingPlot->getY_INLINE()) <= GC.getCache_ADVANCED_START_SIGHT_RANGE())
+							{
+								pPlot->setRevealed(getTeam(), true, false, NO_TEAM);
+							}
+						}
+					}
+				}
+			}
+
+			if (getPrimaryCity() == NULL)
+			{
+				if (!bNoExit)
+				{
+					doAdvancedStartAction(ADVANCEDSTARTACTION_EXIT, -1, -1, -1, true);
+				}
+				return;
+			}
+		}
+
+		iCityPoints -= (iStartingPoints - getAdvancedStartPoints());
+
+		int iLastPointsTotal = getAdvancedStartPoints();
+
+		for (int iPass = 0; iPass < 6; iPass++)
+		{
+			for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+			{
+				CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+				if (pLoopPlot->isRevealed(getTeam(), false))
+				{
+					if (pLoopPlot->getBonusType() != NO_BONUS)
+					{
+						AI_advancedStartRevealRadius(pLoopPlot, CITY_PLOTS_RADIUS);
+					}
+					else
+					{
+						for (int iJ = 0; iJ < NUM_CARDINALDIRECTION_TYPES; iJ++)
+						{
+							CvPlot* pLoopPlot2 = plotCardinalDirection(pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE(), (CardinalDirectionTypes)iJ);
+							if ((pLoopPlot2 != NULL) && (getAdvancedStartVisibilityCost(true, pLoopPlot2) > 0))
+							{
+								//Mildly maphackery but any smart human can see the terrain type of a tile.
+								pLoopPlot2->getTerrainType();
+								int iFoodYield = GC.getTerrainInfo(pLoopPlot2->getTerrainType()).getYield(YIELD_FOOD);
+								if (pLoopPlot2->getFeatureType() != NO_FEATURE)
+								{
+									iFoodYield += GC.getFeatureInfo(pLoopPlot2->getFeatureType()).getYieldChange(YIELD_FOOD);
+								}
+								if (iFoodYield >= 2 || pLoopPlot2->isHills() || pLoopPlot2->isPeak() || pLoopPlot2->isRiver())
+								{
+									doAdvancedStartAction(ADVANCEDSTARTACTION_VISIBILITY, pLoopPlot2->getX_INLINE(), pLoopPlot2->getY_INLINE(), -1, true);
+								}
+							}
+						}
+					}
+				}
+				if ((iLastPointsTotal - getAdvancedStartPoints()) > iRevealPoints)
+				{
+					break;
+				}
+			}
+		}
+
+		iLastPointsTotal = getAdvancedStartPoints();
+		iCityPoints = std::min(iCityPoints, iLastPointsTotal);
+		int iArea = -1; //getStartingPlot()->getArea();
+		bool bDonePlacingCities = false;
+		for (int iPass = 0; iPass < 100; ++iPass)
+		{
+			int iBestFoundValue = 0;
+			CvPlot* pBestFoundPlot = NULL;
+			AI_updateFoundValues(false);
+			for (int iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+			{
+				CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+				if (plotDistance(getStartingPlot()->getX_INLINE(), getStartingPlot()->getY_INLINE(), pLoopPlot->getX_INLINE(), pLoopPlot->getY_INLINE()) < 19)
+				{
+					int iFoundValue = pLoopPlot->getFoundValue(getID());
+					if (isNative())
+					{
+						iFoundValue = iFoundValue + GC.getGameINLINE().getSorenRandNum(iFoundValue * 2, "AI place native city");
+					}
+					if (pLoopPlot->getFoundValue(getID()) > iBestFoundValue)
+					{
+						if (getAdvancedStartCityCost(true, pLoopPlot) > 0)
+						{
+							pBestFoundPlot = pLoopPlot;
+							iBestFoundValue = pLoopPlot->getFoundValue(getID());
+						}
+					}
+				}
+			}
+
+			if (isNative())
+			{
+				if (getNumCities() >= iTargetCityCount)
+				{
+					bDonePlacingCities = true;
+				}
+			}
+			else if (iBestFoundValue < ((getNumCities() == 0) ? 1 : (500 + 250 * getNumCities())))
+			{
+				bDonePlacingCities = true;
+			}
+
+			if (pBestFoundPlot == NULL)
+			{
+				bDonePlacingCities = true;
+			}
+
+			if (!bDonePlacingCities)
+			{
+				int iCost = getAdvancedStartCityCost(true, pBestFoundPlot);
+				if (iCost > getAdvancedStartPoints())
+				{
+					bDonePlacingCities = true;
+				}// at 500pts, we have 200, we spend 100.
+				else if (((iLastPointsTotal - getAdvancedStartPoints()) + iCost) > iCityPoints)
+				{
+					bDonePlacingCities = true;
+				}
+			}
+
+			if (!bDonePlacingCities)
+			{
+				if (!AI_advancedStartPlaceCity(pBestFoundPlot))
+				{
+					FAssertMsg(false, "AS AI: Failed to place city (non-capital)");
+					bDonePlacingCities = true;
+				}
+			}
+
+			if (bDonePlacingCities)
+			{
+				break;
+			}
+		}
+
+
+		//Land
+		AI_advancedStartPlaceExploreUnits(true);
+		if (getCurrentEra() > 2)
+		{
+			//Sea
+			AI_advancedStartPlaceExploreUnits(false);
+		}
+
+		if (!isNative())
+		{
+			AI_advancedStartRouteTerritory();
+		}
+
+		bool bDoneBuildings = (iLastPointsTotal - getAdvancedStartPoints()) > iCityPoints;
+		for (int iPass = 0; iPass < 10 && !bDoneBuildings; ++iPass)
+		{
+			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+			{
+				BuildingTypes eBuilding = pLoopCity->AI_bestAdvancedStartBuilding(iPass);
+				if (eBuilding != NO_BUILDING)
+				{
+					bDoneBuildings = (iLastPointsTotal - (getAdvancedStartPoints() - getAdvancedStartBuildingCost(eBuilding, true, pLoopCity))) > iCityPoints;
+					if (!bDoneBuildings)
+					{
+						doAdvancedStartAction(ADVANCEDSTARTACTION_BUILDING, pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE(), eBuilding, true);
+					}
+					else
+					{
+						//continue there might be cheaper buildings in other cities we can afford
+					}
+				}
+			}
+		}
+	}
+
+	//Units
+	std::vector<UnitAITypes> aeUnitAITypes;
+	if (!isNative())
+	{
+		aeUnitAITypes.push_back(UNITAI_COLONIST);
+	}
+	else
+	{
+		aeUnitAITypes.push_back(UNITAI_DEFENSIVE);
+	}
+
+
+	bool bDone = false;
+	for (int iPass = 0; iPass < 6; ++iPass)
+	{
+		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+		{
+
+			{
+				if (iPass > 0)
+			{
+					if (getAdvancedStartPopCost(true, pLoopCity) > getAdvancedStartPoints())
+					{
+						bDone = true;
+						break;
+					}
+					doAdvancedStartAction(ADVANCEDSTARTACTION_POP, pLoopCity->getX(), pLoopCity->getY(), -1, true);
+				}
+				CvPlot* pUnitPlot = pLoopCity->plot();
+				//Token defender
+				UnitTypes eBestUnit = AI_bestAdvancedStartUnitAI(pUnitPlot, aeUnitAITypes[iPass % aeUnitAITypes.size()]);
+				if (eBestUnit != NO_UNIT)
+				{
+
+					if (getAdvancedStartUnitCost(eBestUnit, true, pUnitPlot) > getAdvancedStartPoints())
+					{
+						bDone = true;
+						break;
+					}
+					doAdvancedStartAction(ADVANCEDSTARTACTION_UNIT, pUnitPlot->getX(), pUnitPlot->getY(), eBestUnit, true);
+				}
+			}
+		}
+	}
+
+	if (!bNoExit)
+	{
+		doAdvancedStartAction(ADVANCEDSTARTACTION_EXIT, -1, -1, -1, true);
+	}
+
+}
+
+int CvPlayerAI::AI_getMinFoundValue()
+{
+	return 600;
+}
+
+int CvPlayerAI::AI_bestAreaUnitAIValue(UnitAITypes eUnitAI, CvArea* pArea, UnitTypes* peBestUnitType)
+{
+
+	CvCity* pCity = NULL;
+
+	if (pArea != NULL)
+	{
+	if (getPrimaryCity() != NULL)
+	{
+		if (pArea->isWater())
+		{
+			if (getPrimaryCity()->plot()->isAdjacentToArea(pArea))
+			{
+				pCity = getPrimaryCity();
+			}
+		}
+		else
+		{
+			if (getPrimaryCity()->getArea() == pArea->getID())
+			{
+				pCity = getPrimaryCity();
+			}
+		}
+	}
+
+	if (NULL == pCity)
+	{
+		CvCity* pLoopCity;
+		int iLoop;
+		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+		{
+			if (pArea->isWater())
+			{
+				if (pLoopCity->plot()->isAdjacentToArea(pArea))
+				{
+					pCity = pLoopCity;
+					break;
+				}
+			}
+			else
+			{
+				if (pLoopCity->getArea() == pArea->getID())
+				{
+					pCity = pLoopCity;
+					break;
+				}
+			}
+		}
+	}
+	}
+
+	return AI_bestCityUnitAIValue(eUnitAI, pCity, peBestUnitType);
+
+}
+
+int CvPlayerAI::AI_bestCityUnitAIValue(UnitAITypes eUnitAI, CvCity* pCity, UnitTypes* peBestUnitType)
+{
+	UnitTypes eLoopUnit;
+	int iValue;
+	int iBestValue;
+	int iI;
+
+	FAssertMsg(eUnitAI != NO_UNITAI, "UnitAI is not assigned a valid value");
+
+	iBestValue = 0;
+
+	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
+
+		if (eLoopUnit != NO_UNIT)
+		{
+			if (!isHuman() || (GC.getUnitInfo(eLoopUnit).getDefaultUnitAIType() == eUnitAI))
+			{
+				if (NULL == pCity ? canTrain(eLoopUnit) : pCity->canTrain(eLoopUnit))
+				{
+					iValue = AI_unitValue(eLoopUnit, eUnitAI, (pCity == NULL) ? NULL : pCity->area());
+					if (iValue > iBestValue)
+					{
+						iBestValue = iValue;
+						if (peBestUnitType != NULL)
+						{
+							*peBestUnitType = eLoopUnit;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return iBestValue;
+}
+
+int CvPlayerAI::AI_calculateTotalBombard(DomainTypes eDomain)
+{
+	int iI;
+	int iTotalBombard = 0;
+
+	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
+		if (eLoopUnit != NO_UNIT)
+		{
+			if (GC.getUnitInfo(eLoopUnit).getDomainType() == eDomain)
+			{
+				int iBombardRate = GC.getUnitInfo(eLoopUnit).getBombardRate();
+
+				if (iBombardRate > 0)
+				{
+					iTotalBombard += iBombardRate * getUnitClassCount((UnitClassTypes)iI);
+				}
+			}
+		}
+	}
+
+	return iTotalBombard;
+}
+
+int CvPlayerAI::AI_getUnitClassWeight(UnitClassTypes eUnitClass)
+{
+	return m_aiUnitClassWeights[eUnitClass] / 100;
+}
+
+int CvPlayerAI::AI_getUnitCombatWeight(UnitCombatTypes eUnitCombat)
+{
+	return m_aiUnitCombatWeights[eUnitCombat] / 100;
+}
+
+void CvPlayerAI::AI_doEnemyUnitData()
+{
+	std::vector<int> aiUnitCounts(GC.getNumUnitInfos(), 0);
+
+	std::vector<int> aiDomainSums(NUM_DOMAIN_TYPES, 0);
+
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	int iI;
+
+	int iOldTotal = 0;
+	int iNewTotal = 0;
+
+
+	for (iI = 0; iI < GC.getMapINLINE().numPlotsINLINE(); iI++)
+	{
+
+		CvPlot* pLoopPlot = GC.getMapINLINE().plotByIndexINLINE(iI);
+		int iAdjacentAttackers = -1;
+		if (pLoopPlot->isVisible(getTeam(), false))
+		{
+			pUnitNode = pLoopPlot->headUnitNode();
+
+			while (pUnitNode != NULL)
+			{
+				pLoopUnit = ::getUnit(pUnitNode->m_data);
+				pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+				if (pLoopUnit->canFight())
+				{
+					int iUnitValue = 1;
+					if (atWar(getTeam(), pLoopUnit->getTeam()))
+					{
+						iUnitValue += 10;
+
+						if ((pLoopPlot->getOwnerINLINE() == getID()))
+						{
+							iUnitValue += 15;
+						}
+						else if (atWar(getTeam(), pLoopPlot->getTeam()))
+						{
+							if (iAdjacentAttackers == -1)
+							{
+								iAdjacentAttackers = GET_PLAYER(pLoopPlot->getOwnerINLINE()).AI_adjacentPotentialAttackers(pLoopPlot);
+							}
+							if (iAdjacentAttackers > 0)
+							{
+								iUnitValue += 15;
+							}
+						}
+					}
+					else if (pLoopUnit->getOwnerINLINE() != getID())
+					{
+						iUnitValue += pLoopUnit->canAttack() ? 4 : 1;
+						if (pLoopPlot->getCulture(getID()) > 0)
+						{
+							iUnitValue += pLoopUnit->canAttack() ? 4 : 1;
+						}
+					}
+
+					if (m_aiUnitClassWeights[pLoopUnit->getUnitClassType()] == 0)
+					{
+						iUnitValue *= 4;
+					}
+
+					iUnitValue *= pLoopUnit->baseCombatStr();
+					aiUnitCounts[pLoopUnit->getUnitType()] += iUnitValue;
+					aiDomainSums[pLoopUnit->getDomainType()] += iUnitValue;
+					iNewTotal += iUnitValue;
+				}
+			}
+		}
+	}
+
+	if (iNewTotal == 0)
+	{
+		//This should rarely happen.
+		return;
+	}
+
+	//Decay
+	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		m_aiUnitClassWeights[iI] -= 100;
+		m_aiUnitClassWeights[iI] *= 3;
+		m_aiUnitClassWeights[iI] /= 4;
+		m_aiUnitClassWeights[iI] = std::max(0, m_aiUnitClassWeights[iI]);
+	}
+
+	for (iI = 0; iI < GC.getNumUnitInfos(); iI++)
+	{
+		if (aiUnitCounts[iI] > 0)
+		{
+			UnitTypes eLoopUnit = (UnitTypes)iI;
+			aiUnitCounts[iI] = 0;
+			FAssert(aiDomainSums[GC.getUnitInfo(eLoopUnit).getDomainType()] > 0);
+			m_aiUnitClassWeights[GC.getUnitInfo(eLoopUnit).getUnitClassType()] += (5000 * aiUnitCounts[iI]) / std::max(1, aiDomainSums[GC.getUnitInfo(eLoopUnit).getDomainType()]);
+		}
+	}
+
+	for (iI = 0; iI < GC.getNumUnitCombatInfos(); ++iI)
+	{
+		m_aiUnitCombatWeights[iI] = 0;
+	}
+
+	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		if (m_aiUnitClassWeights[iI] > 0)
+		{
+			UnitTypes eUnit = (UnitTypes)GC.getUnitClassInfo((UnitClassTypes)iI).getDefaultUnitIndex();
+			m_aiUnitCombatWeights[GC.getUnitInfo(eUnit).getUnitCombatType()] += m_aiUnitClassWeights[iI];
+
+		}
+	}
+
+	for (iI = 0; iI < GC.getNumUnitCombatInfos(); iI++)
+	{
+		if (m_aiUnitCombatWeights[iI] > 25)
+		{
+			m_aiUnitCombatWeights[iI] += 2500;
+		}
+		else if (m_aiUnitCombatWeights[iI] > 0)
+		{
+			m_aiUnitCombatWeights[iI] += 1000;
+		}
+	}
+}
+
+int CvPlayerAI::AI_calculateUnitAIViability(UnitAITypes eUnitAI, DomainTypes eDomain)
+{
+	int iBestUnitAIStrength = 0;
+	int iBestOtherStrength = 0;
+
+	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		UnitTypes eLoopUnit = (UnitTypes)GC.getUnitClassInfo((UnitClassTypes)iI).getDefaultUnitIndex();
+		CvUnitInfo& kUnitInfo = GC.getUnitInfo((UnitTypes)iI);
+		if (kUnitInfo.getDomainType() == eDomain)
+		{
+			if (m_aiUnitClassWeights[iI] > 0)
+			{
+				if (kUnitInfo.getUnitAIType(eUnitAI))
+				{
+					iBestUnitAIStrength = std::max(iBestUnitAIStrength, kUnitInfo.getCombat());
+				}
+
+				iBestOtherStrength = std::max(iBestOtherStrength, kUnitInfo.getCombat());
+			}
+		}
+	}
+
+	return (100 * iBestUnitAIStrength) / std::max(1, iBestOtherStrength);
+}
+
+int CvPlayerAI::AI_getAttitudeWeight(PlayerTypes ePlayer)
+{
+	int iAttitudeWeight = 0;
+	switch (AI_getAttitude(ePlayer))
+	{
+	case ATTITUDE_FURIOUS:
+		iAttitudeWeight = -100;
+		break;
+	case ATTITUDE_ANNOYED:
+		iAttitudeWeight = -50;
+		break;
+	case ATTITUDE_CAUTIOUS:
+		iAttitudeWeight = 0;
+		break;
+	case ATTITUDE_PLEASED:
+		iAttitudeWeight = 50;
+		break;
+	case ATTITUDE_FRIENDLY:
+		iAttitudeWeight = 100;
+		break;
+	}
+
+	return iAttitudeWeight;
+}
+
+int CvPlayerAI::AI_getPlotCanalValue(CvPlot* pPlot)
+{
+	PROFILE_FUNC();
+
+	FAssert(pPlot != NULL);
+
+	if (pPlot->isOwned())
+	{
+		if (pPlot->getTeam() != getTeam())
+		{
+			return 0;
+		}
+		if (pPlot->isCityRadius())
+		{
+			CvCity* pWorkingCity = pPlot->getWorkingCity();
+			if (pWorkingCity != NULL)
+			{
+				if (pWorkingCity->AI_getBestBuild(pWorkingCity->getCityPlotIndex(pPlot)) != NO_BUILD)
+				{
+					return 0;
+				}
+				if (pPlot->getImprovementType() != NO_IMPROVEMENT)
+				{
+					CvImprovementInfo &kImprovementInfo = GC.getImprovementInfo(pPlot->getImprovementType());
+					if (!kImprovementInfo.isActsAsCity())
+					{
+						return 0;
+					}
+				}
+			}
+		}
+	}
+
+	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
+	{
+		CvPlot* pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), (DirectionTypes)iI);
+		if (pLoopPlot != NULL)
+		{
+			if (pLoopPlot->isCity(true))
+			{
+				return 0;
+			}
+		}
+	}
+
+	CvArea* pSecondWaterArea = pPlot->secondWaterArea();
+	if (pSecondWaterArea == NULL)
+	{
+		return 0;
+	}
+
+	return 10 * std::min(0, pSecondWaterArea->getNumTiles() - 2);
+}
+
+void CvPlayerAI::AI_diplomaticHissyFit(PlayerTypes ePlayer, int iAttitudeChange)
+{
+	if (ePlayer == NO_PLAYER)
+	{
+		FAssert(false);
+		return;
+	}
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (iAttitudeChange >= 0)
+	{
+		return;
+	}
+
+	if (atWar(getTeam(), kPlayer.getTeam()))
+	{
+		return;
+	}
+
+	if (!kPlayer.isHuman())
+	{
+		return;
+	}
+
+	if (GET_TEAM(getTeam()).AI_performNoWarRolls(kPlayer.getTeam()))
+	{
+		return;
+	}
+
+	//Out of 1000, so 100 is a 10% chance.
+	//Note this could be modified by all sorts of things. Difficulty level might be a good one.
+	int iProbability = -iAttitudeChange * 100;
+
+	iProbability /= (GET_TEAM(getTeam()).getNumMembers() * GET_TEAM(kPlayer.getTeam()).getNumMembers());
+
+	if (iProbability < GC.getGameINLINE().getSorenRandNum(1000, "AI Diplomatic Hissy Fit"))
+	{
+		return;
+	}
+
+	GET_TEAM(getTeam()).declareWar(kPlayer.getTeam(), true, WARPLAN_EXTORTION);
+
+}
+
+UnitTypes CvPlayerAI::AI_nextBuyUnit(UnitAITypes* peUnitAI, int* piValue)
+{
+	if (peUnitAI != NULL)
+	{
+		*peUnitAI = m_eNextBuyUnitAI;
+	}
+	if (piValue != NULL)
+	{
+		*piValue = m_iNextBuyUnitValue;
+	}
+	return m_eNextBuyUnit;
+}
+
+UnitTypes CvPlayerAI::AI_nextBuyProfessionUnit(ProfessionTypes* peProfession, UnitAITypes* peUnitAI, int* piValue)
+{
+	if (peProfession != NULL)
+	{
+		*peProfession = m_eNextBuyProfession;
+	}
+	if (peUnitAI != NULL)
+	{
+		*peUnitAI = m_eNextBuyProfessionAI;
+	}
+	if (peUnitAI != NULL)
+	{
+		*piValue = m_iNextBuyProfessionValue;
+	}
+	return m_eNextBuyProfessionUnit;
+}
+
+void CvPlayerAI::AI_updateNextBuyUnit()
+{
+	PROFILE_FUNC();
+	int iBestValue = 0;
+	UnitTypes eBestUnit = NO_UNIT;
+	UnitAITypes eBestUnitAI = NO_UNITAI;
+
+	for (int iUnitAI = 0; iUnitAI < NUM_UNITAI_TYPES; ++iUnitAI)
+	{
+		UnitAITypes eLoopUnitAI = (UnitAITypes) iUnitAI;
+		bool bValid = false;
+
+		int iMultipler = AI_unitAIValueMultipler(eLoopUnitAI);
+		if (iMultipler > 0)
+		{
+			bValid = true;
+		}
+		int iTreasureSum = -1;
+		int iTreasureSize = -1;
+
+		if ((eLoopUnitAI == UNITAI_TRANSPORT_SEA) && (AI_totalUnitAIs(UNITAI_TREASURE) > 0))
+		{
+			int iLoop;
+			CvUnit* pLoopUnit;
+			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+			{
+				if (pLoopUnit->canMove())
+				{
+					if (pLoopUnit->AI_getUnitAIType() == UNITAI_TREASURE)
+					{
+						int iSize = pLoopUnit->getUnitInfo().getRequiredTransportSize();
+						if (iSize > 1)
+						{
+							iTreasureSize = std::max(iTreasureSize, iSize);
+							iTreasureSum += pLoopUnit->getYieldStored();
+						}
+					}
+				}
+			}
+
+			for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
+			{
+				if (pLoopUnit->AI_getUnitAIType() == UNITAI_TRANSPORT_SEA)
+				{
+					if (pLoopUnit->cargoSpace() >= iTreasureSize)
+					{
+						//Can already transport all treasure, cancel.
+						iTreasureSize = -1;
+						iTreasureSum = -1;
+						break;
+					}
+				}
+			}
+		}
+
+		if (iTreasureSum < 1)
+		{
+			iTreasureSum = 1;
+		}
+
+		if (iTreasureSize < 1)
+		{
+			iTreasureSize = 1;
+		}
+
+		if (iTreasureSum > 0)
+		{
+			bValid = true;
+		}
+
+		if (bValid)
+		{
+			for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+			{
+				UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
+
+				if (eLoopUnit != NO_UNIT)
+				{
+					CvUnitInfo& kUnitInfo = GC.getUnitInfo(eLoopUnit);
+					if (kUnitInfo.getDefaultProfession() == NO_PROFESSION || kUnitInfo.getDefaultUnitAIType() == UNITAI_DEFENSIVE || kUnitInfo.getDefaultUnitAIType() == UNITAI_COUNTER)
+					{
+						int iPrice = getEuropeUnitBuyPrice(eLoopUnit);
+						if (iPrice > 0)// && !kUnitInfo.getUnitAIType(eLoopUnitAI))
+						{
+							if (iTreasureSum > 0) //Perform treasure calculations
+							{
+								if (kUnitInfo.getCargoSpace() >= iTreasureSize)
+								{
+									iMultipler += 100 + (100 * iTreasureSum) / iPrice;
+									iPrice = std::max(iPrice / 3, iPrice - iTreasureSum);
+								}
+							}
+
+							if (kUnitInfo.getDefaultUnitAIType() == UNITAI_COMBAT_SEA)
+							{
+								iMultipler += 100 + (100 * (kUnitInfo.getCombat() * 1000)) / iPrice;
+								if (getGold() > iPrice)
+								{
+									iPrice /= 4;
+								}
+							}
+
+							int iGoldValue = AI_unitGoldValue(eLoopUnit, eLoopUnitAI, NULL);
+
+							int iValue = (iMultipler * iGoldValue) / iPrice;
+
+							if (iValue > iBestValue)
+							{
+								iBestValue = iValue;
+								eBestUnit = eLoopUnit;
+								eBestUnitAI = eLoopUnitAI;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	m_eNextBuyUnit = eBestUnit;
+	m_eNextBuyUnitAI = eBestUnitAI;
+	m_iNextBuyUnitValue = iBestValue;
+}
+
+int CvPlayerAI::AI_highestNextBuyValue()
+{
+	return std::max(m_iNextBuyUnitValue, m_iNextBuyProfessionValue);
+}
+
+void CvPlayerAI::AI_updateNextBuyProfession()
+{
+	PROFILE_FUNC();
+	int iBestValue = 0;
+	UnitTypes eBestProfessionUnit = NO_UNIT;
+	ProfessionTypes eBestProfession = NO_PROFESSION;
+	UnitAITypes eBestUnitAI = NO_UNITAI;
+
+	ProfessionTypes eDefaultProfession = (ProfessionTypes) GC.getCivilizationInfo(getCivilizationType()).getDefaultProfession();
+
+	int iColMultiplier = AI_unitAIValueMultipler(UNITAI_COLONIST);
+	//Professions which work in cities.
+	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+	{
+		UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
+
+		if (eLoopUnit != NO_UNIT)
+		{
+			CvUnitInfo& kUnitInfo = GC.getUnitInfo(eLoopUnit);
+
+			int iPrice = getEuropeUnitBuyPrice(eLoopUnit);
+			if (iPrice > 0)
+			{
+				if (kUnitInfo.getDefaultProfession() != NO_PROFESSION)
+				{
+					int iValue = 0;
+					UnitAITypes eUnitAI = NO_UNITAI;
+					//if (kUnitInfo.getDefaultProfession() == eDefaultProfession)
+					{
+						ProfessionTypes eProfession = AI_idealProfessionForUnit(eLoopUnit);
+						if (eProfession != NO_PROFESSION)
+						{
+
+							int iValue = 50 + 3 * AI_professionUpgradeValue(eProfession, eLoopUnit);
+
+							iValue *= iColMultiplier;
+							iValue /= 100;
+
+							int iExisting = getUnitClassCountPlusMaking((UnitClassTypes)iI);
+
+							if (iExisting < 3)
+							{
+								iValue *= 100 + (5 + getTotalPopulation()) * kUnitInfo.getYieldModifier(YIELD_LUMBER) / (5 * (1 + iExisting));
+								iValue /= 100;
+
+								iValue *= 100 + (5 + getTotalPopulation()) * (44 * kUnitInfo.getYieldChange(YIELD_FOOD) + 34 * kUnitInfo.getBonusYieldChange(YIELD_FOOD)) / (5 * (1 + iExisting)) ;
+								iValue /= 100;
+
+								if (AI_isStrategy(STRATEGY_FAST_BELLS))
+								{
+									iValue *= 100 + kUnitInfo.getYieldModifier(YIELD_BELLS) / (2 + iExisting);
+									iValue /= 100;
+								}
+								///TKs Med
+								//else if (AI_isStrategy(STRATEGY_BUILDUP) || AI_isStrategy(STRATEGY_REVOLUTION_PREPARING))
+#ifdef USE_NOBLE_CLASS
+                                else
+								{
+									iValue *= 100 + kUnitInfo.getYieldModifier(YIELD_GRAIN) / (2 + iExisting);
+									iValue /= 100;
+								}
+#endif
+								///TKe
+							}
+
+							for (int i = 0; i < NUM_YIELD_TYPES; ++i)
+							{
+								YieldTypes eLoopYield = (YieldTypes)i;
+
+								int iModifier = kUnitInfo.getYieldModifier(eLoopYield);
+								if (iModifier > 0)
+								{
+									if (AI_highestYieldAdvantage(eLoopYield) == 100)
+									{
+										if (!AI_isYieldFinalProduct(eLoopYield))
+										{
+											iModifier /= 4;
+										}
+										iValue *= 100 + iModifier;
+										iValue /= 100;
+									}
+								}
+							}
+
+							if (iExisting < 4)
+							{
+								iValue *= 2;
+								iValue /= 2 + iExisting;
+								if (iValue > iBestValue)
+								{
+									iBestValue = iValue;
+									eBestProfession = eDefaultProfession;
+									eBestProfessionUnit = eLoopUnit;
+									eBestUnitAI = UNITAI_COLONIST;
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	for (int iUnitAI = 0; iUnitAI < NUM_UNITAI_TYPES; ++iUnitAI)
+	{
+		UnitAITypes eLoopUnitAI = (UnitAITypes) iUnitAI;
+
+		if (eLoopUnitAI != UNITAI_COLONIST)
+		{
+			int iMultiplier = AI_unitAIValueMultipler(eLoopUnitAI);
+
+			if (iMultiplier > 0)
+			{
+				ProfessionTypes eProfession = AI_idealProfessionForUnitAIType(eLoopUnitAI);
+
+				if (eProfession != NO_PROFESSION)
+				{
+					UnitTypes eBestUnit = NO_UNIT;
+
+					for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
+					{
+						UnitTypes eLoopUnit = ((UnitTypes)(GC.getCivilizationInfo(getCivilizationType()).getCivilizationUnits(iI)));
+
+						if (eLoopUnit != NO_UNIT)
+						{
+							CvUnitInfo& kUnitInfo = GC.getUnitInfo(eLoopUnit);
+
+							int iPrice = getEuropeUnitBuyPrice(eLoopUnit);
+							if (iPrice > 0)
+							{
+
+								int iValue = AI_professionSuitability(eLoopUnit, eProfession);
+								if (iValue >= 100)
+								{
+									iValue *= 2 * iMultiplier;
+									iValue /= 3 * 100;
+
+									if (iValue > iBestValue)
+									{
+										iBestValue = iValue;
+										eBestProfession = eProfession;
+										eBestProfessionUnit = eLoopUnit;
+										eBestUnitAI = eLoopUnitAI;
+									}
+								}
+							}
+						}
+					}
+
+					if (eBestUnit == NO_UNIT)
+					{
+						//Special Case.
+						int iValue = iMultiplier;
+
+
+						if (iValue > iBestValue)
+						{
+							iBestValue = iValue;
+							eBestProfession = eProfession;
+							eBestProfessionUnit = NO_UNIT;
+							eBestUnitAI = eLoopUnitAI;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	m_eNextBuyProfession = eBestProfession;
+	m_eNextBuyProfessionUnit = eBestProfessionUnit;
+	m_eNextBuyProfessionAI = eBestUnitAI;
+	m_iNextBuyProfessionValue = iBestValue;
+}
+
+void CvPlayerAI::AI_invalidateCloseBordersAttitudeCache()
+{
+	for (int i = 0; i < MAX_PLAYERS; ++i)
+	{
+		m_aiCloseBordersAttitudeCache[i] = MAX_INT;
+		m_aiStolenPlotsAttitudeCache[i] = MAX_INT;
+	}
+}
+
+
+EmotionTypes CvPlayerAI::AI_strongestEmotion()
+{
+	int iBestValue = 0;
+	EmotionTypes eBestEmotion = NO_EMOTION;
+
+	for (int i = 0; i < NUM_EMOTION_TYPES; ++i)
+	{
+		if (m_aiEmotions[i] > iBestValue)
+		{
+			iBestValue = m_aiEmotions[i];
+			eBestEmotion = (EmotionTypes)i;
+		}
+	}
+
+	return eBestEmotion;
+}
+
+int CvPlayerAI::AI_emotionWeight(EmotionTypes eEmotion)
+{
+	EmotionTypes eBestEmotion = AI_strongestEmotion();
+	if (eBestEmotion == NO_EMOTION)
+	{
+		return 0;
+	}
+	return (100 * m_aiEmotions[eEmotion]) / (m_aiEmotions[eBestEmotion]);
+}
+
+int CvPlayerAI::AI_getEmotion(EmotionTypes eEmotion)
+{
+	FAssert(eEmotion > NO_EMOTION);
+	FAssert(eEmotion < NUM_EMOTION_TYPES);
+	return m_aiEmotions[eEmotion];
+}
+
+void CvPlayerAI::AI_setEmotion(EmotionTypes eEmotion, int iNewValue)
+{
+	FAssert(eEmotion > NO_EMOTION);
+	FAssert(eEmotion < NUM_EMOTION_TYPES);
+	m_aiEmotions[eEmotion] = iNewValue;
+}
+
+void CvPlayerAI::AI_changeEmotion(EmotionTypes eEmotion, int iChange)
+{
+	FAssert(eEmotion > NO_EMOTION);
+	FAssert(eEmotion < NUM_EMOTION_TYPES);
+	m_aiEmotions[eEmotion] += iChange;
+}
+
+bool CvPlayerAI::AI_isAnyStrategy() const
+{
+	for (int i = 0; i < NUM_STRATEGY_TYPES; ++i)
+	{
+		if (AI_isStrategy((StrategyTypes)i))
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool CvPlayerAI::AI_isStrategy(StrategyTypes eStrategy) const
+{
+	FAssert(eStrategy > NO_STRATEGY);
+	FAssert(eStrategy < NUM_STRATEGY_TYPES);
+	return (m_aiStrategyStartedTurn[eStrategy] != -1);
+}
+
+int CvPlayerAI::AI_getStrategyDuration(StrategyTypes eStrategy) const
+{
+	FAssert(eStrategy > NO_STRATEGY);
+	FAssert(eStrategy < NUM_STRATEGY_TYPES);
+	if (!AI_isStrategy(eStrategy))
+	{
+		return -1;
+	}
+
+	return (GC.getGameINLINE().getGameTurn() - m_aiStrategyStartedTurn[eStrategy]);
+}
+
+int CvPlayerAI::AI_getStrategyData(StrategyTypes eStrategy)
+{
+	FAssert(eStrategy > NO_STRATEGY);
+	FAssert(eStrategy < NUM_STRATEGY_TYPES);
+	return m_aiStrategyData[eStrategy];
+}
+
+void CvPlayerAI::AI_setStrategy(StrategyTypes eStrategy, int iData)
+{
+	FAssert(eStrategy > NO_STRATEGY);
+	FAssert(eStrategy < NUM_STRATEGY_TYPES);
+	m_aiStrategyStartedTurn[eStrategy] = GC.getGameINLINE().getGameTurn();
+	m_aiStrategyData[eStrategy] = iData;
+}
+
+void CvPlayerAI::AI_clearStrategy(StrategyTypes eStrategy)
+{
+	FAssert(eStrategy > NO_STRATEGY);
+	FAssert(eStrategy < NUM_STRATEGY_TYPES);
+	m_aiStrategyStartedTurn[eStrategy] = -1;
+	m_aiStrategyData[eStrategy] = -1;
+}
+
+int CvPlayerAI::AI_cityDistance(CvPlot* pPlot)
+{
+	FAssert(pPlot != NULL);
+
+	if (m_iDistanceMapDistance == -1)
+	{
+		AI_getDistanceMap();
+	}
+
+	return m_distanceMap[GC.getMapINLINE().plotNumINLINE(pPlot->getX_INLINE(), pPlot->getY_INLINE())];
+}
+
+//There's no need to save this (it is very fast to generate anyway)
+std::vector<short>* CvPlayerAI::AI_getDistanceMap()
+{
+	if (m_iDistanceMapDistance != -1)
+	{
+		return &m_distanceMap;
+	}
+
+	int iMaxRange = MAX_SHORT;
+	CvMap& kMap = GC.getMap();
+
+	std::deque<int>plotQueue;
+	m_distanceMap.resize(kMap.numPlotsINLINE());
+
+	for (int i = 0; i < kMap.numPlotsINLINE(); ++i)
+	{
+		CvPlot* pLoopPlot = kMap.plotByIndexINLINE(i);
+
+		if (pLoopPlot->isCity() && (pLoopPlot->getOwnerINLINE() == getID()))
+		{
+			plotQueue.push_back(i);
+			m_distanceMap[i] = 0;
+		}
+		else
+		{
+			m_distanceMap[i] = iMaxRange;
+		}
+	}
+
+	int iVisits = 0;
+	while (!plotQueue.empty())
+	{
+		iVisits++;
+		int iPlot = plotQueue.front();
+		CvPlot* pPlot = kMap.plotByIndexINLINE(iPlot);
+		plotQueue.pop_front();
+
+		int iDistance = m_distanceMap[iPlot];
+		iDistance += 1;
+
+		if (iDistance < iMaxRange)
+		{
+			for (int iDirection = 0; iDirection < NUM_DIRECTION_TYPES; iDirection++)
+			{
+				CvPlot* pDirectionPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), (DirectionTypes)iDirection);
+				if (pDirectionPlot != NULL)
+				{
+					if ((pDirectionPlot->isWater() && pPlot->isWater())
+						|| (!pDirectionPlot->isWater() && !pPlot->isWater())
+							|| (pDirectionPlot->isWater() && (pPlot->isCity() && (pPlot->getOwnerINLINE() == getID()))))
+					{
+
+						int iPlotNum = kMap.plotNumINLINE(pDirectionPlot->getX_INLINE(), pDirectionPlot->getY_INLINE());
+						if (iDistance < m_distanceMap[iPlotNum])
+						{
+							m_distanceMap[iPlotNum] = iDistance;
+							plotQueue.push_back(iPlotNum);
+						}
+					}
+				}
+			}
+		}
+	}
+	m_iDistanceMapDistance = iMaxRange;
+	return &m_distanceMap;
+}
+
+void CvPlayerAI::AI_invalidateDistanceMap()
+{
+	m_iDistanceMapDistance = -1;
+}
+
+void CvPlayerAI::AI_updateBestYieldPlots()
+{
+	int aiBestWorkedYield[NUM_YIELD_TYPES];
+	int aiBestUnworkedYield[NUM_YIELD_TYPES];
+
+	for (int i = 0; i < NUM_YIELD_TYPES; ++i)
+	{
+		m_aiBestWorkedYieldPlots[i] = -1;
+		m_aiBestUnworkedYieldPlots[i] = -1;
+
+		aiBestWorkedYield[i] = 0;
+		aiBestUnworkedYield[i] = 0;
+	}
+	CvMap& kMap = GC.getMapINLINE();
+	for (int i = 0; i < kMap.numPlotsINLINE(); ++i)
+	{
+		CvPlot* pLoopPlot = kMap.plotByIndex(i);
+
+		if (pLoopPlot->isCityRadius() && (pLoopPlot->getOwnerINLINE() == getID()))
+		{
+			for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
+			{
+				int iPlotYield = std::max(pLoopPlot->calculateNatureYield((YieldTypes)iYield, getTeam(), false), pLoopPlot->calculateNatureYield((YieldTypes)iYield, getTeam(), true));
+				if (iPlotYield > 0)
+				{
+					if (pLoopPlot->isBeingWorked() && pLoopPlot->getYield((YieldTypes)iYield) > 0)
+					{
+						if (iPlotYield > aiBestWorkedYield[iYield])
+						{
+							aiBestWorkedYield[iYield] = iPlotYield;
+							m_aiBestWorkedYieldPlots[iYield] = i;
+						}
+					}
+					else
+					{
+						if (iPlotYield > aiBestUnworkedYield[iYield])
+						{
+							aiBestUnworkedYield[iYield] = iPlotYield;
+							m_aiBestUnworkedYieldPlots[iYield] = i;
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+CvPlot* CvPlayerAI::AI_getBestWorkedYieldPlot(YieldTypes eYield)
+{
+	FAssertMsg(eYield > NO_YIELD, "Index out of bounds");
+	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
+
+	//Automatically returns NULL, if -1.
+	return GC.getMapINLINE().plotByIndexINLINE(m_aiBestWorkedYieldPlots[eYield]);
+}
+
+CvPlot* CvPlayerAI::AI_getBestUnworkedYieldPlot(YieldTypes eYield)
+{
+	FAssertMsg(eYield > NO_YIELD, "Index out of bounds");
+	FAssertMsg(eYield < NUM_YIELD_TYPES, "Index out of bounds");
+
+	//Automatically returns NULL, if -1.
+	return GC.getMapINLINE().plotByIndexINLINE(m_aiBestUnworkedYieldPlots[eYield]);
+}
+
+int CvPlayerAI::AI_getBestPlotYield(YieldTypes eYield)
+{
+	CvPlot* pPlot = AI_getBestWorkedYieldPlot(eYield);
+	if (pPlot == NULL)
+	{
+		pPlot = AI_getBestUnworkedYieldPlot(eYield);
+	}
+	if (pPlot == NULL)
+	{
+		return 0;
+	}
+	return pPlot->calculateBestNatureYield(eYield, getTeam());
+}
+
+void CvPlayerAI::AI_changeTotalIncome(int iChange)
+{
+	m_iTotalIncome += iChange;
+}
+
+int CvPlayerAI::AI_getTotalIncome()
+{
+	return m_iTotalIncome;
+}
+
+void CvPlayerAI::AI_changeHurrySpending(int iChange)
+{
+	m_iHurrySpending += iChange;
+}
+
+int CvPlayerAI::AI_getHurrySpending()
+{
+	return m_iHurrySpending;
+}
+
+int CvPlayerAI::AI_getPopulation()
+{
+	int iTotal = 0;
+
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		iTotal += pLoopCity->getPopulation();
+	}
+
+	return iTotal;
+}
+
+bool CvPlayerAI::AI_shouldAttackAdjacentCity(CvPlot* pPlot)
+{
+	FAssert(pPlot != NULL);
+
+	for (int i = 0; i < NUM_DIRECTION_TYPES; ++i)
+	{
+		CvPlot* pLoopPlot = plotDirection(pPlot->getX_INLINE(), pPlot->getY_INLINE(), (DirectionTypes)i);
+		if (pLoopPlot != NULL)
+		{
+			if (atWar(getTeam(), pLoopPlot->getTeam()))
+			{
+				CvCity* pPlotCity = pLoopPlot->getPlotCity();
+				if (pPlotCity != NULL)
+				{
+					if (!pPlotCity->isBombarded())
+					{
+						return true;
+					}
+
+					if (((100 * pPlotCity->getDefenseDamage()) / std::max(1, GC.getMAX_CITY_DEFENSE_DAMAGE())) > 90)
+					{
+						return true;
+					}
+				}
+			}
+		}
+	}
+	return false;
+}
+
+int CvPlayerAI::AI_getNumProfessionUnits(ProfessionTypes eProfession)
+{
+	int iCount = 0;
+
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+		{
+			CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
+
+			if (pLoopUnit->getProfession() == eProfession)
+			{
+				iCount ++;
+			}
+		}
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_countNumCityUnits(UnitTypes eUnit)
+{
+	int iCount = 0;
+
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		for (int i = 0; i < pLoopCity->getPopulation(); ++i)
+		{
+			CvUnit* pLoopUnit = pLoopCity->getPopulationUnitByIndex(i);
+
+			if (pLoopUnit->getUnitType() == eUnit)
+			{
+				iCount ++;
+			}
+		}
+	}
+
+	return iCount;
+}
+
+int CvPlayerAI::AI_getNumCityUnitsNeeded(UnitTypes eUnit)
+{
+	int iCount = 0;
+	ProfessionTypes eIdealProfession = AI_idealProfessionForUnit(eUnit);
+
+	if (eIdealProfession == NO_PROFESSION)
+	{
+		return 0;
+	}
+	// MultipleYieldsProduced Start by Aymerick 22/01/2010**
+	YieldTypes eYieldProducedType = (YieldTypes)GC.getProfessionInfo(eIdealProfession).getYieldsProduced(0);
+	// MultipleYieldsProduced End
+	if (eYieldProducedType == NO_YIELD)
+	{
+		return 0;
+	}
+
+	if (GC.getProfessionInfo(eIdealProfession).isWorkPlot())
+	{
+		return 0;//XXX
+	}
+
+	int iLoop;
+	CvCity* pLoopCity;
+	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity->AI_getYieldAdvantage(eYieldProducedType) == 100)
+		{
+			iCount += pLoopCity->getNumProfessionBuildingSlots(eIdealProfession);
+		}
+	}
+	return iCount;
+}
+
+int CvPlayerAI::AI_countPromotions(PromotionTypes ePromotion, CvPlot* pPlot, int iRange, int* piUnitCount)
+{
+	CLLNode<IDInfo>* pUnitNode;
+	CvUnit* pLoopUnit;
+	int iCount = 0;
+	int iUnitCount = 0;
+
+	for (int iX = -iRange; iX <= iRange; ++iX)
+	{
+		for (int iY = -iRange; iY <= iRange; ++iY)
+		{
+			CvPlot* pLoopPlot = plotXY(pPlot->getX_INLINE(), pPlot->getY_INLINE(), iX, iY);
+			if (pLoopPlot != NULL)
+			{
+				pUnitNode = pLoopPlot->headUnitNode();
+
+				while (pUnitNode != NULL)
+				{
+					pLoopUnit = ::getUnit(pUnitNode->m_data);
+					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);
+
+					if (pLoopUnit->getOwnerINLINE() == getID())
+					{
+						if (pLoopUnit->isHasPromotion(ePromotion))
+						{
+							iCount++;
+						}
+
+						iUnitCount++;
+					}
+				}
+			}
+		}
+	}
+
+	if (piUnitCount != NULL)
+	{
+		*piUnitCount = iUnitCount;
+	}
+	return iCount;
+}
+///TKs Med
+bool CvPlayerAI::AI_doDiploOfferVassalCity(PlayerTypes ePlayer)
+{
+	CvPlayer& kPlayer = GET_PLAYER(ePlayer);
+
+	if (AI_getAttitude(ePlayer) < ATTITUDE_CAUTIOUS)
+	{
+		return false;
+	}
+
+	if (GET_PLAYER(getID()).getVassalOwner() == ePlayer)
+	{
+	    return false;
+	}
+
+	if (!isNative())
+	{
+	    return false;
+	}
+
+//	for (int iI = 0; iI < MAX_PLAYERS; iI++)
+//	{
+//	    if (GET_PLAYER((PlayerTypes)iI).getVassalOwner() == ePlayer)
+//        {
+//            return false;
+//        }
+//	}
+    ///TKs Testing (false means no longer testing)
+    bool bTesting = false;
+	bool bOffered = false;
+	int iLoop;
+	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
+	{
+		if (pLoopCity->getPreviousOwner() != ePlayer)
+		{
+			if ((((pLoopCity->getGameTurnAcquired() + 4) % 20) == (GC.getGameINLINE().getGameTurn() % 20)) || bTesting)
+			{
+				int iCount = 0;
+				int iPossibleCount = 0;
+
+				for (int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)
+				{
+					CvPlot* pLoopPlot = plotCity(pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE(), iJ);
+
+					if (pLoopPlot != NULL)
+					{
+						if (pLoopPlot->getOwnerINLINE() == ePlayer)
+						{
+							++iCount;
+						}
+
+						++iPossibleCount;
+					}
+				}
+
+				if (iCount >= (iPossibleCount / 2))
+				{
+
+                    if (GET_PLAYER(getID()).getNumCities() > 1)
+                    {
+                        CvPopupInfo* pInfo = new CvPopupInfo(BUTTONPOPUP_NOBLES_JOIN, getID(), pLoopCity->getID());
+                        if (pInfo)
+                        {
+                            gDLL->getInterfaceIFace()->addPopup(pInfo, ePlayer, true);
+                            bOffered = true;
+                        }
+                    }
+                    else
+                    {
+                        TradeData item;
+                        setTradeItem(&item, TRADE_CITIES, pLoopCity->getID(), NULL);
+                        //if (canTradeItem((ePlayer), item, true))
+                       // {
+                            CLinkList<TradeData> ourList;
+                            ourList.insertAtEnd(item);
+
+                            if (kPlayer.isHuman())
+                            {
+                                CvDiploParameters* pDiplo = new CvDiploParameters(getID());
+                                pDiplo->setDiploComment((DiploCommentTypes)GC.getInfoTypeForString("AI_DIPLOCOMMENT_OFFER_VASSAL"));
+                                pDiplo->setAIContact(true);
+                                pDiplo->setData(pLoopCity->getID());
+                                pDiplo->setTheirOfferList(ourList);
+                                gDLL->beginDiplomacy(pDiplo, ePlayer);
+                            }
+    //						else
+    //						{
+    //							GC.getGameINLINE().implementDeal(getID(), (ePlayer), &ourList, NULL);
+    //						}
+                            bOffered = true;
+                        //}
+                    }
+				}
+			}
+		}
+	}
+
+	return bOffered;
+}
+///TKe
diff --git a/DLL_Sources/CvPlayerAI.h b/DLL_Sources/CvPlayerAI.h
index b709f98..7f2f6de 100644
--- a/DLL_Sources/CvPlayerAI.h
+++ b/DLL_Sources/CvPlayerAI.h
@@ -1,494 +1,505 @@
-#pragma once
-
-// playerAI.h
-
-#ifndef CIV4_PLAYER_AI_H
-#define CIV4_PLAYER_AI_H
-
-#include "CvPlayer.h"
-
-class CvEventTriggerInfo;
-
-class CvPlayerAI : public CvPlayer
-{
-
-public:
-
-	CvPlayerAI();
-	virtual ~CvPlayerAI();
-
-  // inlined for performance reasons
-#ifdef _USRDLL
-  static CvPlayerAI& getPlayer(PlayerTypes ePlayer)
-  {
-	  FAssertMsg(ePlayer >= 0, "Player is not assigned a valid value");
-	  FAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
-	  return m_aPlayers[ePlayer];
-  }
-#endif
-	DllExport static CvPlayerAI& getPlayerNonInl(PlayerTypes ePlayer);
-
-	static void initStatics();
-	static void freeStatics();
-	DllExport static bool areStaticsInitialized();
-	///TKs Med
-	///TKs Med
-	bool AI_shouldBuyFromNative(YieldTypes eYield, CvUnit* pTransport=NULL) const;
-	//tkend
-	//TKe
-	void AI_init();
-	void AI_uninit();
-	void AI_reset();
-
-	void AI_doTurnPre();
-	void AI_doTurnPost();
-	void AI_doTurnUnitsPre();
-	void AI_doTurnUnitsPost();
-
-	void AI_doPeace();
-
-	void AI_doEurope();
-
-	void AI_updateFoundValues(bool bStartingLoc = false);
-	void AI_updateAreaTargets();
-
-	int AI_movementPriority(CvSelectionGroup* pGroup);
-	void AI_unitUpdate();
-
-	void AI_makeAssignWorkDirty();
-	void AI_assignWorkingPlots();
-	void AI_updateAssignWork();
-
-	void AI_makeProductionDirty();
-
-	void AI_conquerCity(CvCity* pCity);
-
-	bool AI_acceptUnit(CvUnit* pUnit);
-	bool AI_captureUnit(UnitTypes eUnit, CvPlot* pPlot);
-
-	DomainTypes AI_unitAIDomainType(UnitAITypes eUnitAI);
-	bool AI_unitAIIsCombat(UnitAITypes eUnitAI);
-
-	int AI_yieldWeight(YieldTypes eYield);
-
-	int AI_estimatedColonistIncome(CvPlot* pPlot, CvUnit* pColonist);
-	int AI_foundValue(int iX, int iY, int iMinRivalRange = -1, bool bStartingLoc = false);
-
-	int AI_foundValueNative(int iX, int iY);
-
-	bool AI_isAreaAlone(CvArea* pArea);
-	bool AI_isCapitalAreaAlone();
-	bool AI_isPrimaryArea(CvArea* pArea);
-
-	int AI_militaryWeight(CvArea* pArea);
-
-	int AI_targetCityValue(CvCity* pCity, bool bRandomize, bool bIgnoreAttackers = false);
-	CvCity* AI_findTargetCity(CvArea* pArea);
-
-	int AI_getPlotDanger(CvPlot* pPlot, int iRange = -1, bool bTestMoves = true, bool bOffensive = false);
-	int AI_getUnitDanger(CvUnit* pUnit, int iRange = -1, bool bTestMoves = true, bool bAnyDanger = true);
-	int AI_getWaterDanger(CvPlot* pPlot, int iRange, bool bTestMoves = true);
-	int AI_goldTarget();
-	DllExport DiploCommentTypes AI_getGreeting(PlayerTypes ePlayer);
-	bool AI_isWillingToTalk(PlayerTypes ePlayer);
-	bool AI_demandRebukedSneak(PlayerTypes ePlayer);
-	bool AI_demandRebukedWar(PlayerTypes ePlayer);
-	DllExport bool AI_hasTradedWithTeam(TeamTypes eTeam);
-
-	AttitudeTypes AI_getAttitude(PlayerTypes ePlayer, bool bForced = true);
-	int AI_getAttitudeVal(PlayerTypes ePlayer, bool bForced = true);
-	static AttitudeTypes AI_getAttitude(int iAttitudeVal);
-
-	int AI_calculateStolenCityRadiusPlots(PlayerTypes ePlayer);
-	int AI_getCloseBordersAttitude(PlayerTypes ePlayer);
-	int AI_getStolenPlotsAttitude(PlayerTypes ePlayer);
-	int AI_getAlarmAttitude(PlayerTypes ePlayer);
-	int AI_getRebelAttitude(PlayerTypes ePlayer);
-	void AI_invalidateCloseBordersAttitudeCache();
-	int AI_getWarAttitude(PlayerTypes ePlayer);
-	int AI_getPeaceAttitude(PlayerTypes ePlayer);
-	int AI_getOpenBordersAttitude(PlayerTypes ePlayer);
-	int AI_getDefensivePactAttitude(PlayerTypes ePlayer);
-	int AI_getRivalDefensivePactAttitude(PlayerTypes ePlayer);
-	int AI_getShareWarAttitude(PlayerTypes ePlayer);
-	int AI_getTradeAttitude(PlayerTypes ePlayer);
-	int AI_getRivalTradeAttitude(PlayerTypes ePlayer);
-	int AI_getMemoryAttitude(PlayerTypes ePlayer, MemoryTypes eMemory);
-
-	int AI_dealVal(PlayerTypes ePlayer, const CLinkList<TradeData>* pList, bool bIgnoreAnnual = false, int iExtra = 1);
-	bool AI_goldDeal(const CLinkList<TradeData>* pList);
-	bool AI_considerOffer(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, int iChange = 1);
-	bool AI_counterPropose(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, CLinkList<TradeData>* pTheirInventory, CLinkList<TradeData>* pOurInventory, CLinkList<TradeData>* pTheirCounter, CLinkList<TradeData>* pOurCounter, const IDInfo& kTransport);
-	int AI_militaryHelp(PlayerTypes ePlayer, int& iNumUnits, UnitTypes& eUnit, ProfessionTypes& eProfession);
-
-	int AI_maxGoldTrade(PlayerTypes ePlayer) const;
-
-	int AI_cityTradeVal(CvCity* pCity, PlayerTypes eOwner = NO_PLAYER);
-	DenialTypes AI_cityTrade(CvCity* pCity, PlayerTypes ePlayer) const;
-
-	int AI_stopTradingTradeVal(TeamTypes eTradeTeam, PlayerTypes ePlayer);
-	DenialTypes AI_stopTradingTrade(TeamTypes eTradeTeam, PlayerTypes ePlayer) const;
-
-	int AI_yieldTradeVal(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer);
-	DenialTypes AI_yieldTrade(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer) const;
-
-	int AI_calculateDamages(TeamTypes eTeam);
-
-	int AI_unitImpassableCount(UnitTypes eUnit);
-	int AI_unitEconomicValue(UnitTypes eUnit, UnitAITypes* peUnitAI, CvCity* pCity);
-	int AI_unitValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea);
-	int AI_unitGoldValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea);
-	int AI_unitValuePercent(UnitTypes eUnit, UnitAITypes* peUnitAI, CvArea* pArea);
-	int AI_totalUnitAIs(UnitAITypes eUnitAI);
-	int AI_totalAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI);
-	int AI_totalWaterAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI);
-	bool AI_hasSeaTransport(const CvUnit* pCargo) const;
-
-	int AI_neededExplorers(CvArea* pArea);
-	int AI_neededWorkers(CvArea* pArea);
-	int AI_neededMissionary(CvArea* pArea);
-
-	int AI_adjacentPotentialAttackers(CvPlot* pPlot, bool bTestCanMove = false);
-	int AI_totalMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
-	int AI_areaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
-	int AI_adjacantToAreaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
-	int AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL, int iRange = 0);
-	int AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup = NULL, int iRange = 0);
-	int AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes* aeMissionAI, int iMissionAICount, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup = NULL, int iRange = 0);
-	int AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
-	int AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup = NULL);
-	int AI_enemyTargetMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
-	int AI_enemyTargetMissionAIs(MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup = NULL);
-	int AI_wakePlotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
-
-
-	CivicTypes AI_bestCivic(CivicOptionTypes eCivicOption);
-	int AI_civicValue(CivicTypes eCivic);
-
-	int AI_getAttackOddsChange();
-	void AI_setAttackOddsChange(int iNewValue);
-
-	int AI_getExtraGoldTarget() const;
-	void AI_setExtraGoldTarget(int iNewValue);
-
-	void AI_chooseCivic(CivicOptionTypes eCivicOption);
-	bool AI_chooseGoody(GoodyTypes eGoody);
-
-	CvCity* AI_findBestCity() const;
-	CvCity* AI_findBestPort() const;
-
-	int AI_getNumTrainAIUnits(UnitAITypes eIndex);
-	void AI_changeNumTrainAIUnits(UnitAITypes eIndex, int iChange);
-
-	int AI_getNumAIUnits(UnitAITypes eIndex);
-	void AI_changeNumAIUnits(UnitAITypes eIndex, int iChange);
-
-	int AI_getNumRetiredAIUnits(UnitAITypes eIndex);
-	void AI_changeNumRetiredAIUnits(UnitAITypes eIndex, int iChange);
-
-	int AI_getPeacetimeTradeValue(PlayerTypes eIndex);
-	void AI_changePeacetimeTradeValue(PlayerTypes eIndex, int iChange);
-
-	int AI_getPeacetimeGrantValue(PlayerTypes eIndex);
-	void AI_changePeacetimeGrantValue(PlayerTypes eIndex, int iChange);
-
-	int AI_getGoldTradedTo(PlayerTypes eIndex) const;
-	void AI_changeGoldTradedTo(PlayerTypes eIndex, int iChange);
-
-	int AI_getAttitudeExtra(PlayerTypes eIndex);
-	void AI_setAttitudeExtra(PlayerTypes eIndex, int iNewValue);
-	void AI_changeAttitudeExtra(PlayerTypes eIndex, int iChange);
-
-	bool AI_isFirstContact(PlayerTypes eIndex);
-	void AI_setFirstContact(PlayerTypes eIndex, bool bNewValue);
-
-	int AI_getContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2);
-	void AI_changeContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2, int iChange);
-
-	int AI_getMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2);
-	void AI_changeMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2, int iChange);
-
-	EventTypes AI_chooseEvent(int iTriggeredId);
-
-    int AI_countDeadlockedBonuses(CvPlot* pPlot);
-
-    int AI_getOurPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves);
-    int AI_getEnemyPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves);
-
-	int AI_goldToUpgradeAllUnits(int iExpThreshold = 0);
-
-	int AI_goldTradeValuePercent();
-
-	int AI_averageYieldMultiplier(YieldTypes eYield);
-
-	int AI_playerCloseness(PlayerTypes eIndex, int iMaxDistance);
-	int AI_targetValidity(PlayerTypes ePlayer);
-
-	int AI_totalDefendersNeeded(int* piUndefendedCityCount);
-	int AI_getTotalCityThreat();
-	int AI_getTotalFloatingDefenseNeeded();
-
-
-	int AI_getTotalAreaCityThreat(CvArea* pArea);
-	int AI_countNumAreaHostileUnits(CvArea* pArea, bool bPlayer, bool bTeam, bool bNeutral, bool bHostile);
-	int AI_getTotalFloatingDefendersNeeded(CvArea* pArea);
-	int AI_getTotalFloatingDefenders(CvArea* pArea);
-
-	RouteTypes AI_bestAdvancedStartRoute(CvPlot* pPlot, int* piYieldValue = NULL);
-	UnitTypes AI_bestAdvancedStartUnitAI(CvPlot* pPlot, UnitAITypes eUnitAI);
-	CvPlot* AI_advancedStartFindCapitalPlot();
-
-	bool AI_advancedStartPlaceExploreUnits(bool bLand);
-	void AI_advancedStartRevealRadius(CvPlot* pPlot, int iRadius);
-	bool AI_advancedStartPlaceCity(CvPlot* pPlot);
-	bool AI_advancedStartDoRoute(CvPlot* pFromPlot, CvPlot* pToPlot);
-	void AI_advancedStartRouteTerritory();
-	void AI_doAdvancedStart(bool bNoExit = false);
-
-	int AI_getMinFoundValue();
-
-	int AI_bestAreaUnitAIValue(UnitAITypes eUnitAI, CvArea* pArea, UnitTypes* peBestUnitType = NULL);
-	int AI_bestCityUnitAIValue(UnitAITypes eUnitAI, CvCity* pCity, UnitTypes* peBestUnitType = NULL);
-
-	int AI_calculateTotalBombard(DomainTypes eDomain);
-
-	int AI_getUnitClassWeight(UnitClassTypes eUnitClass);
-	int AI_getUnitCombatWeight(UnitCombatTypes eUnitCombat);
-	int AI_calculateUnitAIViability(UnitAITypes eUnitAI, DomainTypes eDomain);
-
-	int AI_getAttitudeWeight(PlayerTypes ePlayer);
-
-	int AI_getPlotCanalValue(CvPlot* pPlot);
-
-	void AI_nativeYieldGift(CvUnit* pUnit);
-
-	bool AI_isYieldForSale(YieldTypes eYield) const;
-	bool AI_isYieldFinalProduct(YieldTypes eYield) const;
-	bool AI_shouldBuyFromEurope(YieldTypes eYield) const;
-
-	int AI_yieldValue(YieldTypes eYield, bool bProduce = true, int iAmount = 1);
-	void AI_updateYieldValues();
-	int AI_transferYieldValue(const IDInfo target, YieldTypes eYield, int iAmount);
-
-	int AI_countYieldWaiting();
-	int AI_highestYieldAdvantage(YieldTypes eYield);
-
-	void AI_manageEconomy();
-
-	CvPlot* AI_getTerritoryCenter() const;
-	int AI_getTerritoryRadius() const;
-
-	void AI_createNatives();
-	void AI_createNativeCities();
-
-	bool AI_isKing();
-
-	CvPlot* AI_getImperialShipSpawnPlot();
-
-	void AI_addUnitToMoveQueue(CvUnit* pUnit);
-	void AI_removeUnitFromMoveQueue(CvUnit* pUnit);
-	void AI_verifyMoveQueue();
-	CvUnit* AI_getNextMoveUnit();
-
-	int AI_highestProfessionOutput(ProfessionTypes eProfession, const CvCity* pIgnoreCity = NULL);
-
-	CvCity* AI_bestCityForBuilding(BuildingTypes eBuilding);
-
-	UnitTypes AI_bestUnit(UnitAITypes eUnitAI = NO_UNITAI, CvArea* pArea = NULL);
-
-	int AI_desiredCityCount();
-
-	int AI_professionValue(ProfessionTypes eProfession, UnitAITypes eUnitAI);
-	int AI_professionGoldValue(ProfessionTypes eProfession);
-	ProfessionTypes AI_idealProfessionForUnit(UnitTypes eUnitType);
-	ProfessionTypes AI_idealProfessionForUnitAIType(UnitAITypes eUnitAI, CvCity* pCity = NULL);
-
-	int AI_professionBasicValue(ProfessionTypes eProfession, UnitTypes eUnit, CvCity* pCity);
-	int AI_professionUpgradeValue(ProfessionTypes eProfession, UnitTypes eUnit);
-
-	int AI_unitAIValueMultipler(UnitAITypes eUnitAI);
-	int AI_professionSuitability(UnitTypes eUnit, ProfessionTypes eProfession);
-	int AI_professionSuitability(const CvUnit* pUnit, ProfessionTypes eProfession, const CvPlot* pPlot, UnitAITypes eUnitAI = NO_UNITAI);
-
-	void AI_swapUnitJobs(CvUnit* pUnitA, CvUnit* pUnitB);
-
-	bool AI_isCityAcceptingYield(CvCity* pCity, YieldTypes eYield);
-
-	int AI_sumAttackerStrength(CvPlot* pPlot, CvPlot* pAttackedPlot, int iRange = 1, DomainTypes eDomainType = NO_DOMAIN, bool bCheckCanAttack = false, bool bCheckCanMove = false);
-	int AI_sumEnemyStrength(CvPlot* pPlot, int iRange = 0, bool bAttack = false, DomainTypes eDomainType = NO_DOMAIN);
-
-	int AI_setUnitAIStatesRange(CvPlot* pPlot, int iRange, UnitAIStates eNewUnitAIState, UnitAIStates eValidUnitAIState, const std::vector<UnitAITypes>& validUnitAITypes);
-
-	void AI_diplomaticHissyFit(PlayerTypes ePlayer, int iAttitudeChange);
-
-	UnitTypes AI_nextBuyUnit(UnitAITypes* peUnitAI = NULL, int* piValue = NULL);
-	UnitTypes AI_nextBuyProfessionUnit(ProfessionTypes* peProfession = NULL, UnitAITypes* peUnitAI = NULL, int* piValue = NULL);
-
-	void AI_updateNextBuyUnit();
-	void AI_updateNextBuyProfession();
-	int AI_highestNextBuyValue();
-
-	EmotionTypes AI_strongestEmotion();
-	int AI_emotionWeight(EmotionTypes eEmotion);
-	int AI_getEmotion(EmotionTypes eEmotion);
-	void AI_setEmotion(EmotionTypes eEmotion, int iNewValue);
-	void AI_changeEmotion(EmotionTypes eEmotion, int iChange);
-
-	bool AI_isAnyStrategy() const;
-	bool AI_isStrategy(StrategyTypes eStrategy) const;
-	int AI_getStrategyDuration(StrategyTypes eStrategy) const;
-	int AI_getStrategyData(StrategyTypes eStrategy);
-	void AI_setStrategy(StrategyTypes eStrategy, int iData = -1);
-	void AI_clearStrategy(StrategyTypes eStrategy);
-
-	int AI_cityDistance(CvPlot* pPlot);
-	std::vector<short> *AI_getDistanceMap();
-	void AI_invalidateDistanceMap();
-
-	void AI_updateBestYieldPlots();
-
-	CvPlot* AI_getBestWorkedYieldPlot(YieldTypes eYield);
-	CvPlot* AI_getBestUnworkedYieldPlot(YieldTypes eYield);
-	int AI_getBestPlotYield(YieldTypes eYield);
-
-	void AI_changeTotalIncome(int iChange);
-	int AI_getTotalIncome();
-
-	void AI_changeHurrySpending(int iChange);
-	int AI_getHurrySpending();
-
-	int AI_getPopulation();
-	bool AI_shouldAttackAdjacentCity(CvPlot* pPlot);
-
-	int AI_getNumProfessionUnits(ProfessionTypes eProfession);
-	int AI_countNumCityUnits(UnitTypes eUnit);
-
-	int AI_getNumCityUnitsNeeded(UnitTypes eUnit);
-
-	int AI_countPromotions(PromotionTypes ePromotion, CvPlot* pPlot, int iRange, int* piUnitCount = NULL);
-
-	void AI_doNativeArmy(TeamTypes eTeam);
-
-	CvCity* AI_getPrimaryCity();
-	int AI_getOverpopulationPercent();
-	int AI_countNumHomedUnits(CvCity* pCity, UnitAITypes eUnitAI, UnitAIStates eUnitAIState);
-
-	// for serialization
-  virtual void read(FDataStreamBase* pStream);
-  virtual void write(FDataStreamBase* pStream);
-
-protected:
-
-	static CvPlayerAI* m_aPlayers;
-
-	std::vector<short> m_distanceMap;
-	int m_iDistanceMapDistance;
-
-	int m_iAttackOddsChange;
-	int m_iExtraGoldTarget;
-
-	UnitTypes m_eNextBuyUnit;
-	UnitAITypes m_eNextBuyUnitAI;
-	int m_iNextBuyUnitValue;
-
-	ProfessionTypes m_eNextBuyProfession;
-	UnitTypes m_eNextBuyProfessionUnit;
-	UnitAITypes m_eNextBuyProfessionAI;
-	int m_iNextBuyProfessionValue;
-
-	int m_iTotalIncome;
-	int m_iHurrySpending;
-
-	int m_iAveragesCacheTurn;
-
-	int *m_aiAverageYieldMultiplier;
-	int* m_aiYieldValuesTimes100;
-	int* m_aiBestWorkedYieldPlots;
-	int* m_aiBestUnworkedYieldPlots;
-
-	int m_iUpgradeUnitsCacheTurn;
-	int m_iUpgradeUnitsCachedExpThreshold;
-	int m_iUpgradeUnitsCachedGold;
-
-
-	int* m_aiNumTrainAIUnits;
-	int* m_aiNumAIUnits;
-	int* m_aiNumRetiredAIUnits;
-	int* m_aiUnitAIStrategyWeights;
-	int* m_aiPeacetimeTradeValue;
-	int* m_aiPeacetimeGrantValue;
-	int* m_aiGoldTradedTo;
-	int* m_aiAttitudeExtra;
-	int* m_aiUnitClassWeights;
-	int* m_aiUnitCombatWeights;
-	int* m_aiEmotions;
-	int* m_aiStrategyStartedTurn;
-	int* m_aiStrategyData;
-
-	mutable int* m_aiCloseBordersAttitudeCache;
-	mutable int* m_aiStolenPlotsAttitudeCache;
-
-	bool* m_abFirstContact;
-
-	int** m_aaiContactTimer;
-	int** m_aaiMemoryCount;
-
-	std::vector<int> m_aiAICitySites;
-
-	std::vector<int> m_unitPriorityHeap;
-
-	int m_iTurnLastProductionDirty;
-	int m_iTurnLastManagedPop;
-	int m_iMoveQueuePasses;
-
-	void AI_doTradeRoutes();
-	void AI_doCounter();
-	void AI_doMilitary();
-	void AI_doDiplo();
-	bool AI_doDiploCancelDeals(PlayerTypes ePlayer);
-	bool AI_doDiploOfferCity(PlayerTypes ePlayer);
-	bool AI_doDiploOfferAlliance(PlayerTypes ePlayer);
-	bool AI_doDiploAskJoinWar(PlayerTypes ePlayer);
-	bool AI_doDiploAskStopTrading(PlayerTypes ePlayer);
-	bool AI_doDiploGiveHelp(PlayerTypes ePlayer);
-	bool AI_doDiploAskForHelp(PlayerTypes ePlayer);
-	bool AI_doDiploDemandTribute(PlayerTypes ePlayer);
-	bool AI_doDiploKissPinky(PlayerTypes ePlayer);
-	bool AI_doDiploOpenBorders(PlayerTypes ePlayer);
-	///TKs Invention Core Mod v 1.0
-	bool AI_doDiploOfferVassalCity(PlayerTypes ePlayer);
-	bool AI_doDiploTradeResearch(PlayerTypes ePlayer);
-	bool AI_doDiploCollaborateResearch(PlayerTypes ePlayer);
-	///TKe
-	bool AI_doDiploDefensivePact(PlayerTypes ePlayer);
-	bool AI_doDiploTradeMap(PlayerTypes ePlayer);
-	bool AI_doDiploDeclareWar(PlayerTypes ePlayer);
-
-	void AI_doProfessions();
-
-	void AI_doMilitaryStrategy();
-	void AI_doSuppressRevolution();
-	void AI_doUnitAIWeights();
-	void AI_doEmotions();
-	void AI_doStrategy();
-
-	void AI_calculateAverages();
-
-	void AI_convertUnitAITypesForCrush();
-	int AI_eventValue(EventTypes eEvent, const EventTriggeredData& kTriggeredData);
-
-	void AI_doEnemyUnitData();
-
-
-
-	friend class CvGameTextMgr;
-};
-
-// helper for accessing static functions
-#ifdef _USRDLL
-#define GET_PLAYER CvPlayerAI::getPlayer
-#else
-#define GET_PLAYER CvPlayerAI::getPlayerNonInl
-#endif
-
-#endif
+#pragma once
+
+// playerAI.h
+
+#ifndef CIV4_PLAYER_AI_H
+#define CIV4_PLAYER_AI_H
+
+#include "CvPlayer.h"
+
+class CvEventTriggerInfo;
+
+class CvPlayerAI : public CvPlayer
+{
+
+public:
+
+	CvPlayerAI();
+	virtual ~CvPlayerAI();
+
+  // inlined for performance reasons
+#ifdef _USRDLL
+  static CvPlayerAI& getPlayer(PlayerTypes ePlayer)
+  {
+	  FAssertMsg(ePlayer >= 0, "Player is not assigned a valid value");
+	  FAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
+	  return m_aPlayers[ePlayer];
+  }
+#endif
+	DllExport static CvPlayerAI& getPlayerNonInl(PlayerTypes ePlayer);
+
+	static void initStatics();
+	static void freeStatics();
+	DllExport static bool areStaticsInitialized();
+	///TKs Med
+	///TKs Med
+	bool AI_shouldBuyFromNative(YieldTypes eYield, CvUnit* pTransport=NULL) const;
+	//tkend
+	//TKe
+	void AI_init();
+	void AI_uninit();
+	void AI_reset();
+
+	void AI_doTurnPre();
+	void AI_doTurnPost();
+	void AI_doTurnUnitsPre();
+	void AI_doTurnUnitsPost();
+
+	void AI_doPeace();
+
+	void AI_doEurope();
+
+	void AI_updateFoundValues(bool bStartingLoc = false);
+	void AI_updateAreaTargets();
+
+	int AI_movementPriority(CvSelectionGroup* pGroup);
+	void AI_unitUpdate();
+
+	void AI_makeAssignWorkDirty();
+	void AI_assignWorkingPlots();
+	void AI_updateAssignWork();
+
+	void AI_makeProductionDirty();
+
+	void AI_conquerCity(CvCity* pCity);
+
+	bool AI_acceptUnit(CvUnit* pUnit);
+	bool AI_captureUnit(UnitTypes eUnit, CvPlot* pPlot);
+
+	DomainTypes AI_unitAIDomainType(UnitAITypes eUnitAI);
+	bool AI_unitAIIsCombat(UnitAITypes eUnitAI);
+
+	int AI_yieldWeight(YieldTypes eYield);
+
+	int AI_estimatedColonistIncome(CvPlot* pPlot, CvUnit* pColonist);
+	int AI_foundValue(int iX, int iY, int iMinRivalRange = -1, bool bStartingLoc = false);
+
+	int AI_foundValueNative(int iX, int iY);
+
+	bool AI_isAreaAlone(CvArea* pArea);
+	bool AI_isCapitalAreaAlone();
+	bool AI_isPrimaryArea(CvArea* pArea);
+
+	int AI_militaryWeight(CvArea* pArea);
+
+	int AI_targetCityValue(CvCity* pCity, bool bRandomize, bool bIgnoreAttackers = false);
+	CvCity* AI_findTargetCity(CvArea* pArea);
+
+	int AI_getPlotDanger(CvPlot* pPlot, int iRange = -1, bool bTestMoves = true, bool bOffensive = false);
+	int AI_getUnitDanger(CvUnit* pUnit, int iRange = -1, bool bTestMoves = true, bool bAnyDanger = true);
+	int AI_getWaterDanger(CvPlot* pPlot, int iRange, bool bTestMoves = true);
+	int AI_goldTarget();
+	DllExport DiploCommentTypes AI_getGreeting(PlayerTypes ePlayer);
+	bool AI_isWillingToTalk(PlayerTypes ePlayer);
+	bool AI_demandRebukedSneak(PlayerTypes ePlayer);
+	bool AI_demandRebukedWar(PlayerTypes ePlayer);
+	DllExport bool AI_hasTradedWithTeam(TeamTypes eTeam);
+
+	AttitudeTypes AI_getAttitude(PlayerTypes ePlayer, bool bForced = true);
+	int AI_getAttitudeVal(PlayerTypes ePlayer, bool bForced = true);
+	static AttitudeTypes AI_getAttitude(int iAttitudeVal);
+
+	int AI_calculateStolenCityRadiusPlots(PlayerTypes ePlayer);
+	int AI_getCloseBordersAttitude(PlayerTypes ePlayer);
+	int AI_getStolenPlotsAttitude(PlayerTypes ePlayer);
+	int AI_getAlarmAttitude(PlayerTypes ePlayer);
+	int AI_getRebelAttitude(PlayerTypes ePlayer);
+	void AI_invalidateCloseBordersAttitudeCache();
+	int AI_getWarAttitude(PlayerTypes ePlayer);
+	int AI_getPeaceAttitude(PlayerTypes ePlayer);
+	int AI_getOpenBordersAttitude(PlayerTypes ePlayer);
+	int AI_getDefensivePactAttitude(PlayerTypes ePlayer);
+	int AI_getRivalDefensivePactAttitude(PlayerTypes ePlayer);
+	int AI_getShareWarAttitude(PlayerTypes ePlayer);
+	int AI_getTradeAttitude(PlayerTypes ePlayer);
+	int AI_getRivalTradeAttitude(PlayerTypes ePlayer);
+	int AI_getMemoryAttitude(PlayerTypes ePlayer, MemoryTypes eMemory);
+
+	int AI_dealVal(PlayerTypes ePlayer, const CLinkList<TradeData>* pList, bool bIgnoreAnnual = false, int iExtra = 1);
+	bool AI_goldDeal(const CLinkList<TradeData>* pList);
+	bool AI_considerOffer(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, int iChange = 1);
+	bool AI_counterPropose(PlayerTypes ePlayer, const CLinkList<TradeData>* pTheirList, const CLinkList<TradeData>* pOurList, CLinkList<TradeData>* pTheirInventory, CLinkList<TradeData>* pOurInventory, CLinkList<TradeData>* pTheirCounter, CLinkList<TradeData>* pOurCounter, const IDInfo& kTransport);
+	int AI_militaryHelp(PlayerTypes ePlayer, int& iNumUnits, UnitTypes& eUnit, ProfessionTypes& eProfession);
+
+	int AI_maxGoldTrade(PlayerTypes ePlayer) const;
+
+	int AI_cityTradeVal(CvCity* pCity, PlayerTypes eOwner = NO_PLAYER);
+	DenialTypes AI_cityTrade(CvCity* pCity, PlayerTypes ePlayer) const;
+
+	int AI_stopTradingTradeVal(TeamTypes eTradeTeam, PlayerTypes ePlayer);
+	DenialTypes AI_stopTradingTrade(TeamTypes eTradeTeam, PlayerTypes ePlayer) const;
+
+	int AI_yieldTradeVal(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer);
+	DenialTypes AI_yieldTrade(YieldTypes eYield, const IDInfo& kTransport, PlayerTypes ePlayer) const;
+
+	int AI_calculateDamages(TeamTypes eTeam);
+
+	int AI_unitImpassableCount(UnitTypes eUnit);
+	int AI_unitEconomicValue(UnitTypes eUnit, UnitAITypes* peUnitAI, CvCity* pCity);
+	int AI_unitValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea);
+	int AI_unitGoldValue(UnitTypes eUnit, UnitAITypes eUnitAI, CvArea* pArea);
+	int AI_unitValuePercent(UnitTypes eUnit, UnitAITypes* peUnitAI, CvArea* pArea);
+	int AI_totalUnitAIs(UnitAITypes eUnitAI);
+	int AI_totalAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI);
+	int AI_totalWaterAreaUnitAIs(CvArea* pArea, UnitAITypes eUnitAI);
+	bool AI_hasSeaTransport(const CvUnit* pCargo) const;
+
+	int AI_neededExplorers(CvArea* pArea);
+	int AI_neededWorkers(CvArea* pArea);
+	int AI_neededMissionary(CvArea* pArea);
+
+	int AI_adjacentPotentialAttackers(CvPlot* pPlot, bool bTestCanMove = false);
+	int AI_totalMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
+	int AI_areaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
+	int AI_adjacantToAreaMissionAIs(CvArea* pArea, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
+	int AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL, int iRange = 0);
+	int AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup = NULL, int iRange = 0);
+	int AI_plotTargetMissionAIs(CvPlot* pPlot, MissionAITypes* aeMissionAI, int iMissionAICount, int& iClosestTargetRange, CvSelectionGroup* pSkipSelectionGroup = NULL, int iRange = 0);
+	int AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
+	int AI_unitTargetMissionAIs(CvUnit* pUnit, MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup = NULL);
+	int AI_enemyTargetMissionAIs(MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
+	int AI_enemyTargetMissionAIs(MissionAITypes* aeMissionAI, int iMissionAICount, CvSelectionGroup* pSkipSelectionGroup = NULL);
+	int AI_wakePlotTargetMissionAIs(CvPlot* pPlot, MissionAITypes eMissionAI, CvSelectionGroup* pSkipSelectionGroup = NULL);
+
+
+	CivicTypes AI_bestCivic(CivicOptionTypes eCivicOption);
+	int AI_civicValue(CivicTypes eCivic);
+
+	int AI_getAttackOddsChange();
+	void AI_setAttackOddsChange(int iNewValue);
+
+	int AI_getExtraGoldTarget() const;
+	void AI_setExtraGoldTarget(int iNewValue);
+
+	void AI_chooseCivic(CivicOptionTypes eCivicOption);
+	bool AI_chooseGoody(GoodyTypes eGoody);
+
+	CvCity* AI_findBestCity() const;
+	CvCity* AI_findBestPort() const;
+
+	int AI_getNumTrainAIUnits(UnitAITypes eIndex);
+	void AI_changeNumTrainAIUnits(UnitAITypes eIndex, int iChange);
+
+	int AI_getNumAIUnits(UnitAITypes eIndex);
+	void AI_changeNumAIUnits(UnitAITypes eIndex, int iChange);
+
+	int AI_getNumRetiredAIUnits(UnitAITypes eIndex);
+	void AI_changeNumRetiredAIUnits(UnitAITypes eIndex, int iChange);
+
+	int AI_getPeacetimeTradeValue(PlayerTypes eIndex);
+	void AI_changePeacetimeTradeValue(PlayerTypes eIndex, int iChange);
+
+	int AI_getPeacetimeGrantValue(PlayerTypes eIndex);
+	void AI_changePeacetimeGrantValue(PlayerTypes eIndex, int iChange);
+
+	int AI_getGoldTradedTo(PlayerTypes eIndex) const;
+	void AI_changeGoldTradedTo(PlayerTypes eIndex, int iChange);
+
+	int AI_getAttitudeExtra(PlayerTypes eIndex);
+	void AI_setAttitudeExtra(PlayerTypes eIndex, int iNewValue);
+	void AI_changeAttitudeExtra(PlayerTypes eIndex, int iChange);
+
+	bool AI_isFirstContact(PlayerTypes eIndex);
+	void AI_setFirstContact(PlayerTypes eIndex, bool bNewValue);
+
+	int AI_getContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2);
+	void AI_changeContactTimer(PlayerTypes eIndex1, ContactTypes eIndex2, int iChange);
+
+	int AI_getMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2);
+	void AI_changeMemoryCount(PlayerTypes eIndex1, MemoryTypes eIndex2, int iChange);
+
+	EventTypes AI_chooseEvent(int iTriggeredId);
+
+    int AI_countDeadlockedBonuses(CvPlot* pPlot);
+
+    int AI_getOurPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves);
+    int AI_getEnemyPlotStrength(CvPlot* pPlot, int iRange, bool bDefensiveBonuses, bool bTestMoves);
+
+	int AI_goldToUpgradeAllUnits(int iExpThreshold = 0);
+
+	int AI_goldTradeValuePercent();
+
+	int AI_averageYieldMultiplier(YieldTypes eYield);
+
+	int AI_playerCloseness(PlayerTypes eIndex, int iMaxDistance);
+	int AI_targetValidity(PlayerTypes ePlayer);
+
+	int AI_totalDefendersNeeded(int* piUndefendedCityCount);
+	int AI_getTotalCityThreat();
+	int AI_getTotalFloatingDefenseNeeded();
+
+
+	int AI_getTotalAreaCityThreat(CvArea* pArea);
+	int AI_countNumAreaHostileUnits(CvArea* pArea, bool bPlayer, bool bTeam, bool bNeutral, bool bHostile);
+	int AI_getTotalFloatingDefendersNeeded(CvArea* pArea);
+	int AI_getTotalFloatingDefenders(CvArea* pArea);
+
+	RouteTypes AI_bestAdvancedStartRoute(CvPlot* pPlot, int* piYieldValue = NULL);
+	UnitTypes AI_bestAdvancedStartUnitAI(CvPlot* pPlot, UnitAITypes eUnitAI);
+	CvPlot* AI_advancedStartFindCapitalPlot();
+
+	bool AI_advancedStartPlaceExploreUnits(bool bLand);
+	void AI_advancedStartRevealRadius(CvPlot* pPlot, int iRadius);
+	bool AI_advancedStartPlaceCity(CvPlot* pPlot);
+	bool AI_advancedStartDoRoute(CvPlot* pFromPlot, CvPlot* pToPlot);
+	void AI_advancedStartRouteTerritory();
+	void AI_doAdvancedStart(bool bNoExit = false);
+
+	int AI_getMinFoundValue();
+
+	int AI_bestAreaUnitAIValue(UnitAITypes eUnitAI, CvArea* pArea, UnitTypes* peBestUnitType = NULL);
+	int AI_bestCityUnitAIValue(UnitAITypes eUnitAI, CvCity* pCity, UnitTypes* peBestUnitType = NULL);
+
+	int AI_calculateTotalBombard(DomainTypes eDomain);
+
+	int AI_getUnitClassWeight(UnitClassTypes eUnitClass);
+	int AI_getUnitCombatWeight(UnitCombatTypes eUnitCombat);
+	int AI_calculateUnitAIViability(UnitAITypes eUnitAI, DomainTypes eDomain);
+
+	int AI_getAttitudeWeight(PlayerTypes ePlayer);
+
+	int AI_getPlotCanalValue(CvPlot* pPlot);
+
+	void AI_nativeYieldGift(CvUnit* pUnit);
+
+	bool AI_isYieldForSale(YieldTypes eYield) const;
+	bool AI_isYieldFinalProduct(YieldTypes eYield) const;
+	bool AI_shouldBuyFromEurope(YieldTypes eYield) const;
+
+	int AI_yieldValue(YieldTypes eYield, bool bProduce = true, int iAmount = 1);
+	void AI_updateYieldValues();
+	int AI_transferYieldValue(const IDInfo target, YieldTypes eYield, int iAmount);
+
+	int AI_countYieldWaiting();
+	int AI_highestYieldAdvantage(YieldTypes eYield);
+
+	void AI_manageEconomy();
+
+	CvPlot* AI_getTerritoryCenter() const;
+	int AI_getTerritoryRadius() const;
+
+	void AI_createNatives();
+	void AI_createNativeCities();
+
+	bool AI_isKing();
+
+	CvPlot* AI_getImperialShipSpawnPlot();
+
+	void AI_addUnitToMoveQueue(CvUnit* pUnit);
+	void AI_removeUnitFromMoveQueue(CvUnit* pUnit);
+	void AI_verifyMoveQueue();
+	CvUnit* AI_getNextMoveUnit();
+
+	int AI_highestProfessionOutput(ProfessionTypes eProfession, const CvCity* pIgnoreCity = NULL);
+
+	CvCity* AI_bestCityForBuilding(BuildingTypes eBuilding);
+
+	UnitTypes AI_bestUnit(UnitAITypes eUnitAI = NO_UNITAI, CvArea* pArea = NULL);
+
+	int AI_desiredCityCount();
+
+	int AI_professionValue(ProfessionTypes eProfession, UnitAITypes eUnitAI);
+	int AI_professionGoldValue(ProfessionTypes eProfession);
+	ProfessionTypes AI_idealProfessionForUnit(UnitTypes eUnitType);
+	ProfessionTypes AI_idealProfessionForUnitAIType(UnitAITypes eUnitAI, CvCity* pCity = NULL);
+
+	int AI_professionBasicValue(ProfessionTypes eProfession, UnitTypes eUnit, CvCity* pCity);
+	int AI_professionUpgradeValue(ProfessionTypes eProfession, UnitTypes eUnit);
+
+	int AI_unitAIValueMultipler(UnitAITypes eUnitAI);
+	int AI_professionSuitability(UnitTypes eUnit, ProfessionTypes eProfession);
+	int AI_professionSuitability(const CvUnit* pUnit, ProfessionTypes eProfession, const CvPlot* pPlot, UnitAITypes eUnitAI = NO_UNITAI);
+
+	void AI_swapUnitJobs(CvUnit* pUnitA, CvUnit* pUnitB);
+
+	bool AI_isCityAcceptingYield(CvCity* pCity, YieldTypes eYield);
+
+	int AI_sumAttackerStrength(CvPlot* pPlot, CvPlot* pAttackedPlot, int iRange = 1, DomainTypes eDomainType = NO_DOMAIN, bool bCheckCanAttack = false, bool bCheckCanMove = false);
+	int AI_sumEnemyStrength(CvPlot* pPlot, int iRange = 0, bool bAttack = false, DomainTypes eDomainType = NO_DOMAIN);
+
+	int AI_setUnitAIStatesRange(CvPlot* pPlot, int iRange, UnitAIStates eNewUnitAIState, UnitAIStates eValidUnitAIState, const std::vector<UnitAITypes>& validUnitAITypes);
+
+	void AI_diplomaticHissyFit(PlayerTypes ePlayer, int iAttitudeChange);
+
+	UnitTypes AI_nextBuyUnit(UnitAITypes* peUnitAI = NULL, int* piValue = NULL);
+	UnitTypes AI_nextBuyProfessionUnit(ProfessionTypes* peProfession = NULL, UnitAITypes* peUnitAI = NULL, int* piValue = NULL);
+
+	void AI_updateNextBuyUnit();
+	void AI_updateNextBuyProfession();
+	int AI_highestNextBuyValue();
+
+	EmotionTypes AI_strongestEmotion();
+	int AI_emotionWeight(EmotionTypes eEmotion);
+	int AI_getEmotion(EmotionTypes eEmotion);
+	void AI_setEmotion(EmotionTypes eEmotion, int iNewValue);
+	void AI_changeEmotion(EmotionTypes eEmotion, int iChange);
+
+	bool AI_isAnyStrategy() const;
+	bool AI_isStrategy(StrategyTypes eStrategy) const;
+	int AI_getStrategyDuration(StrategyTypes eStrategy) const;
+	int AI_getStrategyData(StrategyTypes eStrategy);
+	void AI_setStrategy(StrategyTypes eStrategy, int iData = -1);
+	void AI_clearStrategy(StrategyTypes eStrategy);
+
+	int AI_cityDistance(CvPlot* pPlot);
+	std::vector<short> *AI_getDistanceMap();
+	void AI_invalidateDistanceMap();
+
+	void AI_updateBestYieldPlots();
+
+	CvPlot* AI_getBestWorkedYieldPlot(YieldTypes eYield);
+	CvPlot* AI_getBestUnworkedYieldPlot(YieldTypes eYield);
+	int AI_getBestPlotYield(YieldTypes eYield);
+
+	void AI_changeTotalIncome(int iChange);
+	int AI_getTotalIncome();
+
+	void AI_changeHurrySpending(int iChange);
+	int AI_getHurrySpending();
+
+	int AI_getPopulation();
+	bool AI_shouldAttackAdjacentCity(CvPlot* pPlot);
+
+	int AI_getNumProfessionUnits(ProfessionTypes eProfession);
+	int AI_countNumCityUnits(UnitTypes eUnit);
+
+	int AI_getNumCityUnitsNeeded(UnitTypes eUnit);
+
+	int AI_countPromotions(PromotionTypes ePromotion, CvPlot* pPlot, int iRange, int* piUnitCount = NULL);
+
+	void AI_doNativeArmy(TeamTypes eTeam);
+
+	CvCity* AI_getPrimaryCity();
+	int AI_getOverpopulationPercent();
+	int AI_countNumHomedUnits(CvCity* pCity, UnitAITypes eUnitAI, UnitAIStates eUnitAIState);
+
+	// for serialization
+  virtual void read(FDataStreamBase* pStream);
+  virtual void write(FDataStreamBase* pStream);
+
+protected:
+
+	static CvPlayerAI* m_aPlayers;
+
+	std::vector<short> m_distanceMap;
+	int m_iDistanceMapDistance;
+
+	int m_iAttackOddsChange;
+	int m_iExtraGoldTarget;
+
+	UnitTypes m_eNextBuyUnit;
+	UnitAITypes m_eNextBuyUnitAI;
+	int m_iNextBuyUnitValue;
+
+	ProfessionTypes m_eNextBuyProfession;
+	UnitTypes m_eNextBuyProfessionUnit;
+	UnitAITypes m_eNextBuyProfessionAI;
+	int m_iNextBuyProfessionValue;
+
+	int m_iTotalIncome;
+	int m_iHurrySpending;
+
+	int m_iAveragesCacheTurn;
+
+	int *m_aiAverageYieldMultiplier;
+	int* m_aiYieldValuesTimes100;
+	int* m_aiBestWorkedYieldPlots;
+	int* m_aiBestUnworkedYieldPlots;
+
+	int m_iUpgradeUnitsCacheTurn;
+	int m_iUpgradeUnitsCachedExpThreshold;
+	int m_iUpgradeUnitsCachedGold;
+
+
+	int* m_aiNumTrainAIUnits;
+	int* m_aiNumAIUnits;
+	int* m_aiNumRetiredAIUnits;
+	int* m_aiUnitAIStrategyWeights;
+	int* m_aiPeacetimeTradeValue;
+	int* m_aiPeacetimeGrantValue;
+	int* m_aiGoldTradedTo;
+	int* m_aiAttitudeExtra;
+	int* m_aiUnitClassWeights;
+	int* m_aiUnitCombatWeights;
+	int* m_aiEmotions;
+	int* m_aiStrategyStartedTurn;
+	int* m_aiStrategyData;
+
+	mutable int* m_aiCloseBordersAttitudeCache;
+	mutable int* m_aiStolenPlotsAttitudeCache;
+
+	bool* m_abFirstContact;
+
+	int** m_aaiContactTimer;
+	int** m_aaiMemoryCount;
+
+	std::vector<int> m_aiAICitySites;
+
+	std::vector<int> m_unitPriorityHeap;
+
+	int m_iTurnLastProductionDirty;
+	int m_iTurnLastManagedPop;
+	int m_iMoveQueuePasses;
+
+	void AI_doTradeRoutes();
+	void AI_doCounter();
+	void AI_doMilitary();
+	void AI_doDiplo();
+	bool AI_doDiploCancelDeals(PlayerTypes ePlayer);
+	bool AI_doDiploOfferCity(PlayerTypes ePlayer);
+	bool AI_doDiploOfferAlliance(PlayerTypes ePlayer);
+	bool AI_doDiploAskJoinWar(PlayerTypes ePlayer);
+	bool AI_doDiploAskStopTrading(PlayerTypes ePlayer);
+	bool AI_doDiploGiveHelp(PlayerTypes ePlayer);
+	bool AI_doDiploAskForHelp(PlayerTypes ePlayer);
+	bool AI_doDiploDemandTribute(PlayerTypes ePlayer);
+	bool AI_doDiploKissPinky(PlayerTypes ePlayer);
+	bool AI_doDiploOpenBorders(PlayerTypes ePlayer);
+	///TKs Invention Core Mod v 1.0
+	bool AI_doDiploOfferVassalCity(PlayerTypes ePlayer);
+	bool AI_doDiploTradeResearch(PlayerTypes ePlayer);
+	bool AI_doDiploCollaborateResearch(PlayerTypes ePlayer);
+	///TKe
+	bool AI_doDiploDefensivePact(PlayerTypes ePlayer);
+	bool AI_doDiploTradeMap(PlayerTypes ePlayer);
+	bool AI_doDiploDeclareWar(PlayerTypes ePlayer);
+
+	void AI_doProfessions();
+
+	void AI_doMilitaryStrategy();
+	void AI_doSuppressRevolution();
+	void AI_doUnitAIWeights();
+	void AI_doEmotions();
+	void AI_doStrategy();
+
+	void AI_calculateAverages();
+
+	void AI_convertUnitAITypesForCrush();
+	int AI_eventValue(EventTypes eEvent, const EventTriggeredData& kTriggeredData);
+
+	void AI_doEnemyUnitData();
+
+
+
+	friend class CvGameTextMgr;
+};
+
+// helper for accessing static functions
+#ifdef _USRDLL
+#define GET_PLAYER CvPlayerAI::getPlayer
+#else
+#define GET_PLAYER CvPlayerAI::getPlayerNonInl
+#endif
+
+#endif
+
+
+inline bool CvPlayerAI::AI_isYieldForSale(YieldTypes eYield) const
+{
+	return YieldGroup_AI_Sell_To_Europe(eYield) || (isNative() && (eYield == YIELD_TOOLS || eYield ==  YIELD_HORSES));
+}
+
+inline bool CvPlayerAI::AI_shouldBuyFromEurope(YieldTypes eYield) const
+{
+	return YieldGroup_AI_Buy_From_Europe(eYield);
+}
\ No newline at end of file
diff --git a/DLL_Sources/CvStructs.h b/DLL_Sources/CvStructs.h
index cd6ba8c..5dd956d 100644
--- a/DLL_Sources/CvStructs.h
+++ b/DLL_Sources/CvStructs.h
@@ -7,6 +7,7 @@
 
 //#include "CvEnums.h"
 #include "CvString.h"
+#include "Yields.h"
 
 // XXX these should not be in the DLL per se (if the user changes them, we are screwed...)
 
diff --git a/DLL_Sources/CvUnit.cpp b/DLL_Sources/CvUnit.cpp
index a092f47..43f32d6 100644
--- a/DLL_Sources/CvUnit.cpp
+++ b/DLL_Sources/CvUnit.cpp
@@ -2617,6 +2617,7 @@ bool CvUnit::canDoCommand(CommandTypes eCommand, int iData1, int iData2, bool bT
 //			    }
 //			}
 			break;
+#ifdef USE_NOBLE_CLASS
         case COMMAND_HOLD_FEAST:
             if (!canMove())
             {
@@ -2647,6 +2648,7 @@ bool CvUnit::canDoCommand(CommandTypes eCommand, int iData1, int iData2, bool bT
                 }
             }
             break;
+#endif
 
 	default:
 		FAssert(false);
@@ -2894,6 +2896,7 @@ void CvUnit::doCommand(CommandTypes eCommand, int iData1, int iData2)
         case COMMAND_CONVERT_UNIT:
 			doKingTransport();
 			break;
+#ifdef USE_NOBLE_CLASS
         case COMMAND_HOLD_FEAST:
 			{
 				CvCity* ePlotCity = plot()->getPlotCity();
@@ -2910,6 +2913,7 @@ void CvUnit::doCommand(CommandTypes eCommand, int iData1, int iData2)
 				}
 			}
             break;
+#endif
         ///Tke
 
 		default:
@@ -7671,17 +7675,17 @@ UnitTypes CvUnit::getCaptureUnitType(CivilizationTypes eCivilization) const
 	}
 
 	///TKs Med
-	 if (eCaptureUnit != NO_UNIT)
+	 if (YIELD_FROM_ANIMALS != NO_YIELD && eCaptureUnit != NO_UNIT)
 	 {
 	    //YieldTypes eCapturedYield = (YieldTypes)m_pUnitInfo->getYield();
-	    if (GC.getYieldInfo(YIELD_GRAIN).getUnitClass() == m_pUnitInfo->getUnitCaptureClassType())
+	    if (GC.getYieldInfo(YIELD_FROM_ANIMALS).getUnitClass() == m_pUnitInfo->getUnitCaptureClassType())
 	    {
             for (int iCivic = 0; iCivic < GC.getNumCivicInfos(); ++iCivic)
             {
                 if (GC.getCivicInfo((CivicTypes) iCivic).getCivicOptionType() == (CivicOptionTypes)GC.getCache_CIVICOPTION_INVENTIONS())
                 {
                     CvCivicInfo& kCivicInfo = GC.getCivicInfo((CivicTypes) iCivic);
-                    if (kCivicInfo.getAllowsYields(YIELD_GRAIN) > 0)
+                    if (kCivicInfo.getAllowsYields(YIELD_FROM_ANIMALS) > 0)
                     {
                         if (GET_PLAYER(GC.getGameINLINE().getActivePlayer()).getIdeasResearched((CivicTypes) iCivic) == 0)
                         {
@@ -10169,20 +10173,20 @@ void CvUnit::setXY(int iX, int iY, bool bGroup, bool bUpdate, bool bShow, bool b
                     }
                     if (bKill)
                     {
-                        if (m_pUnitInfo->isAnimal())
+                        if (YIELD_FROM_ANIMALS != NO_YIELD && m_pUnitInfo->isAnimal())
                         {
                             if (pWorkingCity != NULL)
                             {
 
                                 int iYieldStored = GC.getCache_CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT();
                                 iYieldStored = (GC.getGameINLINE().getSorenRandNum(iYieldStored, "Random City Kill") + 1);
-                                int iCityYieldStore = pWorkingCity->getYieldStored(YIELD_GRAIN) + iYieldStored;
-                                pWorkingCity->setYieldStored(YIELD_GRAIN, iCityYieldStore);
+                                int iCityYieldStore = pWorkingCity->getYieldStored(YIELD_FROM_ANIMALS) + iYieldStored;
+                                pWorkingCity->setYieldStored(YIELD_FROM_ANIMALS, iCityYieldStore);
                                 if (pWorkingCity->isHuman())
                                 {
                                     PlayerTypes eCityOwner = pWorkingCity->getOwnerINLINE();
                                     CvWString szBuffer;
-                                    szBuffer = gDLL->getText("TXT_KEY_CITY_CAPTURE_ANIMAL", GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide(), iYieldStored, GC.getYieldInfo(YIELD_GRAIN).getChar(), pWorkingCity->getNameKey());
+                                    szBuffer = gDLL->getText("TXT_KEY_CITY_CAPTURE_ANIMAL", GC.getImprovementInfo(pNewPlot->getImprovementType()).getTextKeyWide(), iYieldStored, GC.getYieldInfo(YIELD_FROM_ANIMALS).getChar(), pWorkingCity->getNameKey());
                                     gDLL->getInterfaceIFace()->addMessage(eCityOwner, false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNITCAPTURE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pWorkingCity->getX_INLINE(), pWorkingCity->getY_INLINE());
                                 }
                             }
@@ -10240,20 +10244,20 @@ void CvUnit::setXY(int iX, int iY, bool bGroup, bool bUpdate, bool bShow, bool b
                                 }
                                 if (bKill)
                                 {
-                                    if (m_pUnitInfo->isAnimal())
+                                    if (YIELD_FROM_ANIMALS != NO_YIELD && m_pUnitInfo->isAnimal())
                                     {
                                         if (pLoopCity != NULL)
                                         {
 
                                             int iYieldStored = GC.getCache_CAPTURED_LUXURY_FOOD_RANDOM_AMOUNT();
                                             iYieldStored = (GC.getGameINLINE().getSorenRandNum(iYieldStored, "Random City Kill") + 1);
-                                            int iCityYieldStore = pLoopCity->getYieldStored(YIELD_GRAIN) + iYieldStored;
-                                            pLoopCity->setYieldStored(YIELD_GRAIN, iCityYieldStore);
+                                            int iCityYieldStore = pLoopCity->getYieldStored(YIELD_FROM_ANIMALS) + iYieldStored;
+                                            pLoopCity->setYieldStored(YIELD_FROM_ANIMALS, iCityYieldStore);
                                             if (pLoopCity->isHuman())
                                             {
                                                 PlayerTypes eCityOwner = pLoopCity->getOwnerINLINE();
                                                 CvWString szBuffer;
-                                                szBuffer = gDLL->getText("TXT_KEY_CITY_CAPTURE_ANIMAL", GC.getImprovementInfo(pLoopPlot->getImprovementType()).getTextKeyWide(), iYieldStored, GC.getYieldInfo(YIELD_GRAIN).getChar(), pLoopCity->getNameKey());
+                                                szBuffer = gDLL->getText("TXT_KEY_CITY_CAPTURE_ANIMAL", GC.getImprovementInfo(pLoopPlot->getImprovementType()).getTextKeyWide(), iYieldStored, GC.getYieldInfo(YIELD_FROM_ANIMALS).getChar(), pLoopCity->getNameKey());
                                                 gDLL->getInterfaceIFace()->addMessage(eCityOwner, false, GC.getEVENT_MESSAGE_TIME(), szBuffer, "AS2D_UNITCAPTURE", MESSAGE_TYPE_INFO, getButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pLoopCity->getX_INLINE(), pLoopCity->getY_INLINE());
                                             }
                                         }
diff --git a/DLL_Sources/CvUnitAI.cpp b/DLL_Sources/CvUnitAI.cpp
index f9a594d..b5a19fc 100644
--- a/DLL_Sources/CvUnitAI.cpp
+++ b/DLL_Sources/CvUnitAI.cpp
@@ -4783,6 +4783,20 @@ bool CvUnitAI::AI_europeBuyNativeYields()
 		yields.push_back(YIELD_HORSES);
 	}
 	///Tks Med
+	int iArmorCounter = 1;
+	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
+	{
+		YieldTypes eYield = (YieldTypes)iYield;
+		if (YieldGroup_Heavy_Armor(eYield))
+		{
+			iArmorCounter++;
+			if (GC.getGameINLINE().getSorenRandNum(iArmorCounter, "AI buy heavy armor") == 0)
+			{
+				yields.push_back(eYield);
+			}
+		}
+	}
+#if 0
 	if (kOwner.isYieldEuropeTradable(YIELD_SCALE_ARMOR))
 	{
         if (GC.getGameINLINE().getSorenRandNum(2, "AI buy scale armor") == 0)
@@ -4806,6 +4820,7 @@ bool CvUnitAI::AI_europeBuyNativeYields()
             yields.push_back(YIELD_PLATE_ARMOR);
         }
 	}
+#endif
 	///TKe
 
 	GC.getGameINLINE().getSorenRand().shuffleArray(yields, NULL);
diff --git a/DLL_Sources/CvXMLLoadUtilitySet.cpp b/DLL_Sources/CvXMLLoadUtilitySet.cpp
index 99a4247..0539f61 100644
--- a/DLL_Sources/CvXMLLoadUtilitySet.cpp
+++ b/DLL_Sources/CvXMLLoadUtilitySet.cpp
@@ -817,14 +817,19 @@ bool CvXMLLoadUtility::LoadBasicInfos()
 	FAssertMsg(GC.getNumMonthInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getDenialInfo(), "CIV4DenialInfos", "BasicInfos", "Civ4DenialInfos/DenialInfos/DenialInfo", NULL);
 	FAssertMsg(GC.getNumDenialInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
+	GC.CheckEnumDenialTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getInvisibleInfo(), "CIV4InvisibleInfos", "BasicInfos", "Civ4InvisibleInfos/InvisibleInfos/InvisibleInfo", NULL);
 	FAssertMsg(GC.getNumInvisibleInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getUnitCombatInfo(), "CIV4UnitCombatInfos", "BasicInfos", "Civ4UnitCombatInfos/UnitCombatInfos/UnitCombatInfo", NULL);
 	FAssertMsg(GC.getNumUnitCombatInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getDomainInfo(), "CIV4DomainInfos", "BasicInfos", "Civ4DomainInfos/DomainInfos/DomainInfo", NULL);
+	GC.CheckEnumDomainTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getUnitAIInfo(), "CIV4UnitAIInfos", "BasicInfos", "Civ4UnitAIInfos/UnitAIInfos/UnitAIInfo", NULL);
+	GC.CheckEnumUnitAITypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getAttitudeInfo(), "CIV4AttitudeInfos", "BasicInfos", "Civ4AttitudeInfos/AttitudeInfos/AttitudeInfo", NULL);
+	GC.CheckEnumAttitudeTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getMemoryInfo(), "CIV4MemoryInfos", "BasicInfos", "Civ4MemoryInfos/MemoryInfos/MemoryInfo", NULL);
+	GC.CheckEnumMemoryTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getFatherCategoryInfo(), "CIV4FatherCategoryInfos", "BasicInfos", "Civ4FatherCategoryInfos/FatherCategoryInfos/FatherCategoryInfo", NULL);
 	FAssertMsg(GC.getNumFatherCategoryInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 
@@ -856,7 +861,7 @@ bool CvXMLLoadUtility::LoadPreMenuGlobals()
 	FAssertMsg(GC.getNumBuildingClassInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getYieldInfo(), "CIV4YieldInfos", "Terrain", "Civ4YieldInfos/YieldInfos/YieldInfo", NULL);
 	FAssertMsg(GC.getYieldInfo().size() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
-	GC.CheckEnumYields(); // XML enum check - Nightinggale
+	GC.CheckEnumYieldTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getAlarmInfo(), "CIV4AlarmInfos", "Civilizations", "Civ4AlarmInfos/AlarmInfos/AlarmInfo", NULL);
 	FAssertMsg(GC.getNumAlarmInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getGameSpeedInfo(), "CIV4GameSpeedInfo", "GameInfo", "Civ4GameSpeedInfo/GameSpeedInfos/GameSpeedInfo", NULL);
@@ -865,6 +870,7 @@ bool CvXMLLoadUtility::LoadPreMenuGlobals()
 	FAssertMsg(GC.getNumTurnTimerInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getWorldInfo(), "CIV4WorldInfo", "GameInfo", "Civ4WorldInfo/WorldInfos/WorldInfo", NULL);
 	FAssertMsg(GC.getNumWorldInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
+	GC.CheckEnumWorldSizeTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getClimateInfo(), "CIV4ClimateInfo", "GameInfo", "Civ4ClimateInfo/ClimateInfos/ClimateInfo", NULL);
 	FAssertMsg(GC.getNumClimateInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getSeaLevelInfo(), "CIV4SeaLevelInfo", "GameInfo", "Civ4SeaLevelInfo/SeaLevelInfos/SeaLevelInfo", NULL);
@@ -956,10 +962,12 @@ bool CvXMLLoadUtility::LoadPreMenuGlobals()
 
 	LoadGlobalClassInfo(GC.getGameOptionInfo(), "CIV4GameOptionInfos", "GameInfo", "Civ4GameOptionInfos/GameOptionInfos/GameOptionInfo", NULL);
 	FAssertMsg(GC.getNumGameOptionInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
+	GC.CheckEnumGameOptionTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getMPOptionInfo(), "CIV4MPOptionInfos", "GameInfo", "Civ4MPOptionInfos/MPOptionInfos/MPOptionInfo", NULL);
 	FAssertMsg(GC.getNumMPOptionInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 	LoadGlobalClassInfo(GC.getForceControlInfo(), "CIV4ForceControlInfos", "GameInfo", "Civ4ForceControlInfos/ForceControlInfos/ForceControlInfo", NULL);
 	FAssertMsg(GC.getNumForceControlInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
+	GC.CheckEnumForceControlTypes(); // XML enum check - Nightinggale
 
 	// add types to global var system
 	for (int i = 0; i < GC.getNumCursorInfos(); ++i)
@@ -1032,14 +1040,18 @@ bool CvXMLLoadUtility::LoadPostMenuGlobals()
 	UpdateProgressCB("Global Other");
 
 	LoadGlobalClassInfo(GC.getMissionInfo(), "CIV4MissionInfos", "Units", "Civ4MissionInfos/MissionInfos/MissionInfo", NULL);
+	GC.CheckEnumMissionTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getControlInfo(), "CIV4ControlInfos", "Units", "Civ4ControlInfos/ControlInfos/ControlInfo", NULL);
+	GC.CheckEnumControlTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getCommandInfo(), "CIV4CommandInfos", "Units", "Civ4CommandInfos/CommandInfos/CommandInfo", NULL);
+	GC.CheckEnumCommandTypes(); // XML enum check - Nightinggale
 	LoadGlobalClassInfo(GC.getAutomateInfo(), "CIV4AutomateInfos", "Units", "Civ4AutomateInfos/AutomateInfos/AutomateInfo", NULL);
 	FAssertMsg(GC.getNumAutomateInfos() == GC.XMLlength, CvString::format("XML read error. \"%s\" is used more than once", f_szXMLname)); // XML length check - Nightinggale
 
 	UpdateProgressCB("Global Interface");
 
 	LoadGlobalClassInfo(GC.getInterfaceModeInfo(), "CIV4InterfaceModeInfos", "Interface", "Civ4InterfaceModeInfos/InterfaceModeInfos/InterfaceModeInfo", NULL);
+	GC.CheckEnumInterfaceModeTypes(); // XML enum check - Nightinggale
 
 	SetGlobalActionInfo();
 
@@ -2133,6 +2145,7 @@ DllExport bool CvXMLLoadUtility::LoadPlayerOptions()
 
 	LoadGlobalClassInfo(GC.getPlayerOptionInfo(), "CIV4PlayerOptionInfos", "GameInfo", "Civ4PlayerOptionInfos/PlayerOptionInfos/PlayerOptionInfo", NULL);
 	FAssert(GC.getNumPlayerOptionInfos() == NUM_PLAYEROPTION_TYPES);
+	GC.CheckEnumPlayerOptionTypes(); // XML enum check - Nightinggale
 
 	DestroyFXml();
 	return true;
@@ -2145,6 +2158,7 @@ DllExport bool CvXMLLoadUtility::LoadGraphicOptions()
 
 	LoadGlobalClassInfo(GC.getGraphicOptionInfo(), "CIV4GraphicOptionInfos", "GameInfo", "Civ4GraphicOptionInfos/GraphicOptionInfos/GraphicOptionInfo", NULL);
 	FAssert(GC.getNumGraphicOptions() == NUM_GRAPHICOPTION_TYPES);
+	GC.CheckEnumGraphicOptionTypes(); // XML enum check - Nightinggale
 
 	DestroyFXml();
 	return true;
diff --git a/DLL_Sources/CyEnumsInterface.cpp b/DLL_Sources/CyEnumsInterface.cpp
index c504402..ca9a7c3 100644
--- a/DLL_Sources/CyEnumsInterface.cpp
+++ b/DLL_Sources/CyEnumsInterface.cpp
@@ -1,1763 +1,1794 @@
-#include "CvGameCoreDLL.h"
-#include"CvEnums.h"
-#include "CvGameCoreDLLUnDefNew.h"
-# include <boost/python/enum.hpp>
-#include "CvGameCoreDLLDefNew.h"
-//
-// Python interface for free enums
-//
-void CyEnumsPythonInterface()
-{
-	OutputDebugString("Python Extension Module - CyEnumsPythonInterface\n");
-	python::enum_<GameStateTypes>("GameStateTypes")
-		.value("GAMESTATE_ON", GAMESTATE_ON)
-		.value("GAMESTATE_OVER", GAMESTATE_OVER)
-		.value("GAMESTATE_EXTENDED", GAMESTATE_EXTENDED)
-		;
-	python::enum_<PopupStates>("PopupStates")
-		.value("POPUPSTATE_IMMEDIATE", POPUPSTATE_IMMEDIATE)
-		.value("POPUPSTATE_QUEUED", POPUPSTATE_QUEUED)
-		.value("POPUPSTATE_MINIMIZED", POPUPSTATE_MINIMIZED)
-		;
-	python::enum_<CameraLookAtTypes>("CameraLookAtTypes")
-		.value("CAMERALOOKAT_NORMAL", CAMERALOOKAT_NORMAL)
-		.value("CAMERALOOKAT_CITY_ZOOM_IN", CAMERALOOKAT_CITY_ZOOM_IN)
-		.value("CAMERALOOKAT_BATTLE", CAMERALOOKAT_BATTLE)
-		.value("CAMERALOOKAT_BATTLE_ZOOM_IN", CAMERALOOKAT_BATTLE_ZOOM_IN)
-		.value("CAMERALOOKAT_IMMEDIATE", CAMERALOOKAT_IMMEDIATE)
-		;
-	python::enum_<CameraMovementSpeeds>("CameraMovementSpeeds")
-		.value("CAMERAMOVEMENTSPEED_NORMAL", CAMERAMOVEMENTSPEED_NORMAL)
-		.value("CAMERAMOVEMENTSPEED_SLOW", CAMERAMOVEMENTSPEED_SLOW)
-		.value("CAMERAMOVEMENTSPEED_FAST", CAMERAMOVEMENTSPEED_FAST)
-		;
-	python::enum_<ZoomLevelTypes>("ZoomLevelTypes")
-		.value("ZOOM_UNKNOWN", ZOOM_UNKNOWN)
-		.value("ZOOM_GLOBEVIEW", ZOOM_GLOBEVIEW)
-		.value("ZOOM_NORMAL", ZOOM_NORMAL)
-		.value("ZOOM_DETAIL", ZOOM_DETAIL)
-		;
-	python::enum_<DirectionTypes>("DirectionTypes")
-		.value("NO_DIRECTION", NO_DIRECTION)
-		.value("DIRECTION_NORTH", DIRECTION_NORTH)
-		.value("DIRECTION_NORTHEAST", DIRECTION_NORTHEAST)
-		.value("DIRECTION_EAST", DIRECTION_EAST)
-		.value("DIRECTION_SOUTHEAST", DIRECTION_SOUTHEAST)
-		.value("DIRECTION_SOUTH", DIRECTION_SOUTH)
-		.value("DIRECTION_SOUTHWEST", DIRECTION_SOUTHWEST)
-		.value("DIRECTION_WEST", DIRECTION_WEST)
-		.value("DIRECTION_NORTHWEST", DIRECTION_NORTHWEST)
-		.value("NUM_DIRECTION_TYPES", NUM_DIRECTION_TYPES)
-		;
-	python::enum_<CardinalDirectionTypes>("CardinalDirectionTypes")
-		.value("NO_CARDINALDIRECTION", NO_CARDINALDIRECTION)
-		.value("CARDINALDIRECTION_NORTH", CARDINALDIRECTION_NORTH)
-		.value("CARDINALDIRECTION_EAST", CARDINALDIRECTION_EAST)
-		.value("CARDINALDIRECTION_SOUTH", CARDINALDIRECTION_SOUTH)
-		.value("CARDINALDIRECTION_WEST", CARDINALDIRECTION_WEST)
-		.value("NUM_CARDINALDIRECTION_TYPES", NUM_CARDINALDIRECTION_TYPES)
-		;
-	python::enum_<ColorTypes>("ColorTypes")
-		.value("NO_COLOR", NO_COLOR)
-		;
-	python::enum_<PlayerColorTypes>("PlayerColorTypes")
-		.value("NO_PLAYERCOLOR", NO_PLAYERCOLOR)
-		;
-	python::enum_<PlotStyles>("PlotStyles")
-		.value("PLOT_STYLE_NONE", PLOT_STYLE_NONE)
-		.value("PLOT_STYLE_NUMPAD_1", PLOT_STYLE_NUMPAD_1)
-		.value("PLOT_STYLE_NUMPAD_2", PLOT_STYLE_NUMPAD_2)
-		.value("PLOT_STYLE_NUMPAD_3", PLOT_STYLE_NUMPAD_3)
-		.value("PLOT_STYLE_NUMPAD_4", PLOT_STYLE_NUMPAD_4)
-		.value("PLOT_STYLE_NUMPAD_6", PLOT_STYLE_NUMPAD_6)
-		.value("PLOT_STYLE_NUMPAD_7", PLOT_STYLE_NUMPAD_7)
-		.value("PLOT_STYLE_NUMPAD_8", PLOT_STYLE_NUMPAD_8)
-		.value("PLOT_STYLE_NUMPAD_9", PLOT_STYLE_NUMPAD_9)
-		.value("PLOT_STYLE_NUMPAD_1_ANGLED", PLOT_STYLE_NUMPAD_1_ANGLED)
-		.value("PLOT_STYLE_NUMPAD_2_ANGLED", PLOT_STYLE_NUMPAD_2_ANGLED)
-		.value("PLOT_STYLE_NUMPAD_3_ANGLED", PLOT_STYLE_NUMPAD_3_ANGLED)
-		.value("PLOT_STYLE_NUMPAD_4_ANGLED", PLOT_STYLE_NUMPAD_4_ANGLED)
-		.value("PLOT_STYLE_NUMPAD_6_ANGLED", PLOT_STYLE_NUMPAD_6_ANGLED)
-		.value("PLOT_STYLE_NUMPAD_7_ANGLED", PLOT_STYLE_NUMPAD_7_ANGLED)
-		.value("PLOT_STYLE_NUMPAD_8_ANGLED", PLOT_STYLE_NUMPAD_8_ANGLED)
-		.value("PLOT_STYLE_NUMPAD_9_ANGLED", PLOT_STYLE_NUMPAD_9_ANGLED)
-		.value("PLOT_STYLE_BOX_FILL", PLOT_STYLE_BOX_FILL)
-		.value("PLOT_STYLE_BOX_OUTLINE", PLOT_STYLE_BOX_OUTLINE)
-		.value("PLOT_STYLE_RIVER_SOUTH", PLOT_STYLE_RIVER_SOUTH)
-		.value("PLOT_STYLE_RIVER_EAST", PLOT_STYLE_RIVER_EAST)
-		.value("PLOT_STYLE_SIDE_ARROWS", PLOT_STYLE_SIDE_ARROWS)
-		.value("PLOT_STYLE_CIRCLE", PLOT_STYLE_CIRCLE)
-		.value("PLOT_STYLE_TARGET", PLOT_STYLE_TARGET)
-		.value("PLOT_STYLE_DOT_TARGET", PLOT_STYLE_DOT_TARGET)
-		.value("PLOT_STYLE_WAVES", PLOT_STYLE_WAVES)
-		.value("PLOT_STYLE_DOTS", PLOT_STYLE_DOTS)
-		.value("PLOT_STYLE_CIRCLES", PLOT_STYLE_CIRCLES)
-		;
-	python::enum_<PlotLandscapeLayers>("PlotLandscapeLayers")
-		.value("PLOT_LANDSCAPE_LAYER_ALL", PLOT_LANDSCAPE_LAYER_ALL)
-		.value("PLOT_LANDSCAPE_LAYER_BASE", PLOT_LANDSCAPE_LAYER_BASE)
-		.value("PLOT_LANDSCAPE_LAYER_RECOMMENDED_PLOTS", PLOT_LANDSCAPE_LAYER_RECOMMENDED_PLOTS)
-		.value("PLOT_LANDSCAPE_LAYER_NUMPAD_HELP", PLOT_LANDSCAPE_LAYER_NUMPAD_HELP)
-		.value("PLOT_LANDSCAPE_LAYER_REVEALED_PLOTS", PLOT_LANDSCAPE_LAYER_REVEALED_PLOTS)
-		;
-	python::enum_<AreaBorderLayers>("AreaBorderLayers")
-		.value("AREA_BORDER_LAYER_REVEALED_PLOTS", AREA_BORDER_LAYER_REVEALED_PLOTS)
-		.value("AREA_BORDER_LAYER_WORLD_BUILDER", AREA_BORDER_LAYER_WORLD_BUILDER)
-		.value("AREA_BORDER_LAYER_FOUNDING_BORDER", AREA_BORDER_LAYER_FOUNDING_BORDER)
-		.value("AREA_BORDER_LAYER_CITY_RADIUS", AREA_BORDER_LAYER_CITY_RADIUS)
-		.value("AREA_BORDER_LAYER_RANGED", AREA_BORDER_LAYER_RANGED)
-		.value("AREA_BORDER_LAYER_HIGHLIGHT_PLOT", AREA_BORDER_LAYER_HIGHLIGHT_PLOT)
-		.value("AREA_BORDER_LAYER_EUROPE", AREA_BORDER_LAYER_EUROPE)
-		.value("NUM_AREA_BORDER_LAYERS", NUM_AREA_BORDER_LAYERS)
-		;
-	python::enum_<InterfaceModeTypes>("InterfaceModeTypes")
-		.value("NO_INTERFACEMODE", NO_INTERFACEMODE)
-		.value("INTERFACEMODE_SELECTION", INTERFACEMODE_SELECTION)
-		.value("INTERFACEMODE_PING", INTERFACEMODE_PING)
-		.value("INTERFACEMODE_SIGN", INTERFACEMODE_SIGN)
-		.value("INTERFACEMODE_GRIP", INTERFACEMODE_GRIP)
-		.value("INTERFACEMODE_GLOBELAYER_INPUT", INTERFACEMODE_GLOBELAYER_INPUT)
-		.value("INTERFACEMODE_GO_TO", INTERFACEMODE_GO_TO)
-		.value("INTERFACEMODE_GO_TO_TYPE", INTERFACEMODE_GO_TO_TYPE)
-		.value("INTERFACEMODE_GO_TO_ALL", INTERFACEMODE_GO_TO_ALL)
-		.value("INTERFACEMODE_ROUTE_TO", INTERFACEMODE_ROUTE_TO)
-		.value("INTERFACEMODE_PYTHON_PICK_PLOT", INTERFACEMODE_PYTHON_PICK_PLOT)
-		.value("INTERFACEMODE_SAVE_PLOT_NIFS", INTERFACEMODE_SAVE_PLOT_NIFS)
-		.value("NUM_INTERFACEMODE_TYPES", NUM_INTERFACEMODE_TYPES)
-		;
-	python::enum_<InterfaceMessageTypes>("InterfaceMessageTypes")
-		.value("NO_MESSAGE_TYPE", NO_MESSAGE_TYPE)
-		.value("MESSAGE_TYPE_INFO", MESSAGE_TYPE_INFO)
-		.value("MESSAGE_TYPE_LOG_ONLY", MESSAGE_TYPE_LOG_ONLY)
-		.value("MESSAGE_TYPE_DISPLAY_ONLY", MESSAGE_TYPE_DISPLAY_ONLY)
-		.value("MESSAGE_TYPE_MAJOR_EVENT", MESSAGE_TYPE_MAJOR_EVENT)
-		.value("MESSAGE_TYPE_MINOR_EVENT", MESSAGE_TYPE_MINOR_EVENT)
-		.value("MESSAGE_TYPE_CHAT", MESSAGE_TYPE_CHAT)
-		.value("MESSAGE_TYPE_COMBAT_MESSAGE", MESSAGE_TYPE_COMBAT_MESSAGE)
-		.value("MESSAGE_TYPE_QUEST", MESSAGE_TYPE_QUEST)
-		.value("MESSAGE_TYPE_TUTORIAL", MESSAGE_TYPE_TUTORIAL)
-		.value("NUM_INTERFACE_MESSAGE_TYPES", NUM_INTERFACE_MESSAGE_TYPES)
-		;
-	python::enum_<MinimapModeTypes>("MinimapModeTypes")
-		.value("NO_MINIMAPMODE", NO_MINIMAPMODE)
-		.value("MINIMAPMODE_TERRITORY", MINIMAPMODE_TERRITORY)
-		.value("MINIMAPMODE_TERRAIN", MINIMAPMODE_TERRAIN)
-		.value("MINIMAPMODE_REPLAY", MINIMAPMODE_REPLAY)
-		.value("MINIMAPMODE_MILITARY", MINIMAPMODE_MILITARY)
-		.value("NUM_MINIMAPMODE_TYPES", NUM_MINIMAPMODE_TYPES)
-		;
-	python::enum_<EngineDirtyBits>("EngineDirtyBits")
-		.value("GlobeTexture_DIRTY_BIT", GlobeTexture_DIRTY_BIT)
-		.value("MinimapTexture_DIRTY_BIT", MinimapTexture_DIRTY_BIT)
-		.value("CultureBorders_DIRTY_BIT", CultureBorders_DIRTY_BIT)
-		.value("NUM_ENGINE_DIRTY_BITS", NUM_ENGINE_DIRTY_BITS)
-		;
-	python::enum_<InterfaceDirtyBits>("InterfaceDirtyBits")
-		.value("SelectionCamera_DIRTY_BIT", SelectionCamera_DIRTY_BIT)
-		.value("Fog_DIRTY_BIT", Fog_DIRTY_BIT)
-		.value("GlobeLayer_DIRTY_BIT", GlobeLayer_DIRTY_BIT)
-		.value("GlobeInfo_DIRTY_BIT", GlobeInfo_DIRTY_BIT)
-		.value("Waypoints_DIRTY_BIT", Waypoints_DIRTY_BIT)
-		.value("MiscButtons_DIRTY_BIT", MiscButtons_DIRTY_BIT)
-		.value("PlotListButtons_DIRTY_BIT", PlotListButtons_DIRTY_BIT)
-		.value("SelectionButtons_DIRTY_BIT", SelectionButtons_DIRTY_BIT)
-		.value("CitizenButtons_DIRTY_BIT", CitizenButtons_DIRTY_BIT)
-		.value("Event_DIRTY_BIT", Event_DIRTY_BIT)
-		.value("Center_DIRTY_BIT", Center_DIRTY_BIT)
-		.value("GameData_DIRTY_BIT", GameData_DIRTY_BIT)
-		.value("Score_DIRTY_BIT", Score_DIRTY_BIT)
-		.value("TurnTimer_DIRTY_BIT", TurnTimer_DIRTY_BIT)
-		.value("Help_DIRTY_BIT", Help_DIRTY_BIT)
-		.value("MinimapSection_DIRTY_BIT", MinimapSection_DIRTY_BIT)
-		.value("SelectionSound_DIRTY_BIT", SelectionSound_DIRTY_BIT)
-		.value("Cursor_DIRTY_BIT", Cursor_DIRTY_BIT)
-		.value("CityInfo_DIRTY_BIT", CityInfo_DIRTY_BIT)
-		.value("UnitInfo_DIRTY_BIT", UnitInfo_DIRTY_BIT)
-		.value("Popup_DIRTY_BIT", Popup_DIRTY_BIT)
-		.value("CityScreen_DIRTY_BIT", CityScreen_DIRTY_BIT)
-		.value("InfoPane_DIRTY_BIT", InfoPane_DIRTY_BIT)
-		.value("Flag_DIRTY_BIT", Flag_DIRTY_BIT)
-		.value("HighlightPlot_DIRTY_BIT", HighlightPlot_DIRTY_BIT)
-		.value("ColoredPlots_DIRTY_BIT", ColoredPlots_DIRTY_BIT)
-		.value("Financial_Screen_DIRTY_BIT", Financial_Screen_DIRTY_BIT)
-		.value("Foreign_Screen_DIRTY_BIT", Foreign_Screen_DIRTY_BIT)
-		.value("Soundtrack_DIRTY_BIT", Soundtrack_DIRTY_BIT)
-		.value("Domestic_Advisor_DIRTY_BIT", Domestic_Advisor_DIRTY_BIT)
-		.value("Advanced_Start_DIRTY_BIT", Advanced_Start_DIRTY_BIT)
-		.value("EuropeScreen_DIRTY_BIT", EuropeScreen_DIRTY_BIT)
-		.value("ResourceTable_DIRTY_BIT", ResourceTable_DIRTY_BIT)
-		///Tks Med
-        .value("NewYieldAvailable_DIRTY_BIT", NewYieldAvailable_DIRTY_BIT)
-		///Tke
-		.value("NUM_INTERFACE_DIRTY_BITS", NUM_INTERFACE_DIRTY_BITS)
-		;
-	python::enum_<WidgetTypes>("WidgetTypes")
-		.value("WIDGET_PLOT_LIST", WIDGET_PLOT_LIST)
-		.value("WIDGET_PLOT_LIST_SHIFT", WIDGET_PLOT_LIST_SHIFT)
-		.value("WIDGET_CITY_SCROLL", WIDGET_CITY_SCROLL)
-		.value("WIDGET_LIBERATE_CITY", WIDGET_LIBERATE_CITY)
-		.value("WIDGET_CITY_NAME", WIDGET_CITY_NAME)
-		.value("WIDGET_UNIT_NAME", WIDGET_UNIT_NAME)
-		.value("WIDGET_CREATE_GROUP", WIDGET_CREATE_GROUP)
-		.value("WIDGET_DELETE_GROUP", WIDGET_DELETE_GROUP)
-		.value("WIDGET_TRAIN", WIDGET_TRAIN)
-		.value("WIDGET_CONSTRUCT", WIDGET_CONSTRUCT)
-		.value("WIDGET_CONVINCE", WIDGET_CONVINCE)
-		.value("WIDGET_HURRY", WIDGET_HURRY)
-		.value("WIDGET_PLAYER_HURRY", WIDGET_PLAYER_HURRY)
-		.value("WIDGET_MENU_ICON", WIDGET_MENU_ICON)
-		.value("WIDGET_ACTION", WIDGET_ACTION)
-		.value("WIDGET_CITIZEN", WIDGET_CITIZEN)
-		.value("WIDGET_CONTACT_CIV", WIDGET_CONTACT_CIV)
-		.value("WIDGET_SCORE_BREAKDOWN", WIDGET_SCORE_BREAKDOWN)
-		.value("WIDGET_ZOOM_CITY", WIDGET_ZOOM_CITY)
-		.value("WIDGET_END_TURN", WIDGET_END_TURN)
-		.value("WIDGET_WB_SAVE_BUTTON", WIDGET_WB_SAVE_BUTTON)
-		.value("WIDGET_WB_LOAD_BUTTON", WIDGET_WB_LOAD_BUTTON)
-		.value("WIDGET_WB_ALL_PLOTS_BUTTON", WIDGET_WB_ALL_PLOTS_BUTTON)
-		.value("WIDGET_WB_LANDMARK_BUTTON", WIDGET_WB_LANDMARK_BUTTON)
-		.value("WIDGET_WB_ERASE_BUTTON", WIDGET_WB_ERASE_BUTTON)
-		.value("WIDGET_WB_EXIT_BUTTON", WIDGET_WB_EXIT_BUTTON)
-		.value("WIDGET_WB_UNIT_EDIT_BUTTON", WIDGET_WB_UNIT_EDIT_BUTTON)
-		.value("WIDGET_WB_CITY_EDIT_BUTTON", WIDGET_WB_CITY_EDIT_BUTTON)
-		.value("WIDGET_WB_NORMAL_PLAYER_TAB_MODE_BUTTON", WIDGET_WB_NORMAL_PLAYER_TAB_MODE_BUTTON)
-		.value("WIDGET_WB_NORMAL_MAP_TAB_MODE_BUTTON", WIDGET_WB_NORMAL_MAP_TAB_MODE_BUTTON)
-		.value("WIDGET_WB_REVEAL_TAB_MODE_BUTTON", WIDGET_WB_REVEAL_TAB_MODE_BUTTON)
-		.value("WIDGET_WB_DIPLOMACY_MODE_BUTTON", WIDGET_WB_DIPLOMACY_MODE_BUTTON)
-		.value("WIDGET_WB_REVEAL_ALL_BUTTON", WIDGET_WB_REVEAL_ALL_BUTTON)
-		.value("WIDGET_WB_UNREVEAL_ALL_BUTTON", WIDGET_WB_UNREVEAL_ALL_BUTTON)
-		.value("WIDGET_WB_REGENERATE_MAP", WIDGET_WB_REGENERATE_MAP)
-		.value("WIDGET_AUTOMATE_CITIZENS", WIDGET_AUTOMATE_CITIZENS)
-		.value("WIDGET_AUTOMATE_PRODUCTION", WIDGET_AUTOMATE_PRODUCTION)
-		.value("WIDGET_EMPHASIZE", WIDGET_EMPHASIZE)
-		.value("WIDGET_DIPLOMACY_RESPONSE", WIDGET_DIPLOMACY_RESPONSE)
-		.value("WIDGET_GENERAL", WIDGET_GENERAL)
-		.value("WIDGET_FILE_LISTBOX", WIDGET_FILE_LISTBOX)
-		.value("WIDGET_FILE_EDITBOX", WIDGET_FILE_EDITBOX)
-		.value("WIDGET_TRADE_ITEM", WIDGET_TRADE_ITEM)
-		.value("WIDGET_UNIT_MODEL", WIDGET_UNIT_MODEL)
-		.value("WIDGET_POPUP_QUEUE", WIDGET_POPUP_QUEUE)
-		.value("WIDGET_PYTHON", WIDGET_PYTHON)
-		.value("WIDGET_HELP_DEFENSE", WIDGET_HELP_DEFENSE)
-		.value("WIDGET_HELP_POPULATION", WIDGET_HELP_POPULATION)
-		.value("WIDGET_HELP_REBEL", WIDGET_HELP_REBEL)
-		.value("WIDGET_HELP_GREAT_GENERAL", WIDGET_HELP_GREAT_GENERAL)
-		.value("WIDGET_HELP_SELECTED", WIDGET_HELP_SELECTED)
-		.value("WIDGET_HELP_YIELD", WIDGET_HELP_YIELD)
-		.value("WIDGET_HELP_PROMOTION", WIDGET_HELP_PROMOTION)
-		.value("WIDGET_HELP_UNIT_PROMOTION", WIDGET_HELP_UNIT_PROMOTION)
-		.value("WIDGET_CHOOSE_EVENT", WIDGET_CHOOSE_EVENT)
-		.value("WIDGET_PEDIA_JUMP_TO_UNIT", WIDGET_PEDIA_JUMP_TO_UNIT)
-		.value("WIDGET_PEDIA_JUMP_TO_PROFESSION", WIDGET_PEDIA_JUMP_TO_PROFESSION)
-		.value("WIDGET_PEDIA_JUMP_TO_BUILDING", WIDGET_PEDIA_JUMP_TO_BUILDING)
-		.value("WIDGET_PEDIA_BACK", WIDGET_PEDIA_BACK)
-		.value("WIDGET_PEDIA_FORWARD", WIDGET_PEDIA_FORWARD)
-		.value("WIDGET_PEDIA_JUMP_TO_BONUS", WIDGET_PEDIA_JUMP_TO_BONUS)
-		.value("WIDGET_PEDIA_MAIN", WIDGET_PEDIA_MAIN)
-		.value("WIDGET_PEDIA_JUMP_TO_PROMOTION", WIDGET_PEDIA_JUMP_TO_PROMOTION)
-		.value("WIDGET_PEDIA_JUMP_TO_IMPROVEMENT", WIDGET_PEDIA_JUMP_TO_IMPROVEMENT)
-		.value("WIDGET_PEDIA_JUMP_TO_CIVIC", WIDGET_PEDIA_JUMP_TO_CIVIC)
-		.value("WIDGET_PEDIA_JUMP_TO_CIV", WIDGET_PEDIA_JUMP_TO_CIV)
-		.value("WIDGET_PEDIA_JUMP_TO_LEADER", WIDGET_PEDIA_JUMP_TO_LEADER)
-		.value("WIDGET_PEDIA_JUMP_TO_TERRAIN", WIDGET_PEDIA_JUMP_TO_TERRAIN)
-		.value("WIDGET_PEDIA_JUMP_TO_YIELDS", WIDGET_PEDIA_JUMP_TO_YIELDS)
-		.value("WIDGET_PEDIA_JUMP_TO_FEATURE", WIDGET_PEDIA_JUMP_TO_FEATURE)
-		.value("WIDGET_PEDIA_JUMP_TO_FATHER", WIDGET_PEDIA_JUMP_TO_FATHER)
-		.value("WIDGET_TURN_EVENT", WIDGET_TURN_EVENT)
-		.value("WIDGET_PEDIA_DESCRIPTION", WIDGET_PEDIA_DESCRIPTION)
-		.value("WIDGET_PEDIA_DESCRIPTION_NO_HELP", WIDGET_PEDIA_DESCRIPTION_NO_HELP)
-		.value("WIDGET_DEAL_KILL", WIDGET_DEAL_KILL)
-		.value("WIDGET_MINIMAP_HIGHLIGHT", WIDGET_MINIMAP_HIGHLIGHT)
-		.value("WIDGET_PRODUCTION_MOD_HELP", WIDGET_PRODUCTION_MOD_HELP)
-		.value("WIDGET_LEADERHEAD", WIDGET_LEADERHEAD)
-		.value("WIDGET_LEADER_LINE", WIDGET_LEADER_LINE)
-		.value("WIDGET_CLOSE_SCREEN", WIDGET_CLOSE_SCREEN)
-		.value("WIDGET_GLOBELAYER", WIDGET_GLOBELAYER)
-		.value("WIDGET_GLOBELAYER_OPTION", WIDGET_GLOBELAYER_OPTION)
-		.value("WIDGET_GLOBELAYER_TOGGLE", WIDGET_GLOBELAYER_TOGGLE)
-		.value("WIDGET_CITY_UNIT_ASSIGN_PROFESSION", WIDGET_CITY_UNIT_ASSIGN_PROFESSION)
-		.value("WIDGET_MOVE_CARGO_TO_CITY", WIDGET_MOVE_CARGO_TO_CITY)
-		.value("WIDGET_RECEIVE_MOVE_CARGO_TO_CITY", WIDGET_RECEIVE_MOVE_CARGO_TO_CITY)
-		.value("WIDGET_MOVE_CARGO_TO_TRANSPORT", WIDGET_MOVE_CARGO_TO_TRANSPORT)
-		.value("WIDGET_RECEIVE_MOVE_CARGO_TO_TRANSPORT", WIDGET_RECEIVE_MOVE_CARGO_TO_TRANSPORT)
-		.value("WIDGET_CREATE_TRADE_ROUTE", WIDGET_CREATE_TRADE_ROUTE)
-		.value("WIDGET_EDIT_TRADE_ROUTE", WIDGET_EDIT_TRADE_ROUTE)
-		.value("WIDGET_YIELD_IMPORT_EXPORT", WIDGET_YIELD_IMPORT_EXPORT)
-		.value("WIDGET_ASSIGN_CITIZEN_TO_PLOT", WIDGET_ASSIGN_CITIZEN_TO_PLOT)
-		.value("WIDGET_ASSIGN_TRADE_ROUTE", WIDGET_ASSIGN_TRADE_ROUTE)
-		.value("WIDGET_EJECT_CITIZEN", WIDGET_EJECT_CITIZEN)
-		.value("WIDGET_SHIP_CARGO", WIDGET_SHIP_CARGO)
-		.value("WIDGET_DOCK", WIDGET_DOCK)
-		.value("WIDGET_SAIL", WIDGET_SAIL)
-		.value("WIDGET_GOTO_CITY", WIDGET_GOTO_CITY)
-		///TKs Invention Core Mod v 1.0
-		.value("WIDGET_INVENTORS_HOUSE", WIDGET_INVENTORS_HOUSE)
-		.value("WIDGET_PEDIA_JUMP_TO_TECHNOLOGY", WIDGET_PEDIA_JUMP_TO_TECHNOLOGY)
-		//TK Tax
-		.value("WIDGET_TAX_ADVISOR", WIDGET_TAX_ADVISOR)
-		//TKe
-		.value("WIDGET_ARMORSMITH", WIDGET_ARMORSMITH)
-		.value("WIDGET_MARKET", WIDGET_MARKET)
-		///TKe
-		.value("NUM_WIDGET_TYPES", NUM_WIDGET_TYPES)
-		;
-	python::enum_<ButtonPopupTypes>("ButtonPopupTypes")
-		.value("BUTTONPOPUP_TEXT", BUTTONPOPUP_TEXT)
-		.value("BUTTONPOPUP_MAIN_MENU", BUTTONPOPUP_MAIN_MENU)
-		.value("BUTTONPOPUP_CONFIRM_MENU", BUTTONPOPUP_CONFIRM_MENU)
-		.value("BUTTONPOPUP_DECLAREWARMOVE", BUTTONPOPUP_DECLAREWARMOVE)
-		.value("BUTTONPOPUP_CONFIRMCOMMAND", BUTTONPOPUP_CONFIRMCOMMAND)
-		.value("BUTTONPOPUP_CONFIRMTASK", BUTTONPOPUP_CONFIRMTASK)
-		.value("BUTTONPOPUP_LOADUNIT", BUTTONPOPUP_LOADUNIT)
-		.value("BUTTONPOPUP_LOAD_CARGO", BUTTONPOPUP_LOAD_CARGO)
-		.value("BUTTONPOPUP_LEADUNIT", BUTTONPOPUP_LEADUNIT)
-		.value("BUTTONPOPUP_RAZECITY", BUTTONPOPUP_RAZECITY)
-		.value("BUTTONPOPUP_CHOOSEPRODUCTION", BUTTONPOPUP_CHOOSEPRODUCTION)
-		.value("BUTTONPOPUP_CHOOSE_YIELD_BUILD", BUTTONPOPUP_CHOOSE_YIELD_BUILD)
-		.value("BUTTONPOPUP_CHOOSE_EDUCATION", BUTTONPOPUP_CHOOSE_EDUCATION)
-		.value("BUTTONPOPUP_ALARM", BUTTONPOPUP_ALARM)
-		.value("BUTTONPOPUP_DEAL_CANCELED", BUTTONPOPUP_DEAL_CANCELED)
-		.value("BUTTONPOPUP_PYTHON", BUTTONPOPUP_PYTHON)
-		.value("BUTTONPOPUP_FEAT", BUTTONPOPUP_FEAT)
-		.value("BUTTONPOPUP_PYTHON_SCREEN", BUTTONPOPUP_PYTHON_SCREEN)
-		.value("BUTTONPOPUP_MOVIE", BUTTONPOPUP_MOVIE)
-		.value("BUTTONPOPUP_DETAILS", BUTTONPOPUP_DETAILS)
-		.value("BUTTONPOPUP_ADMIN", BUTTONPOPUP_ADMIN)
-		.value("BUTTONPOPUP_ADMIN_PASSWORD", BUTTONPOPUP_ADMIN_PASSWORD)
-		.value("BUTTONPOPUP_EXTENDED_GAME", BUTTONPOPUP_EXTENDED_GAME)
-		.value("BUTTONPOPUP_DIPLOMACY", BUTTONPOPUP_DIPLOMACY)
-		.value("BUTTONPOPUP_ADDBUDDY", BUTTONPOPUP_ADDBUDDY)
-		.value("BUTTONPOPUP_FORCED_DISCONNECT", BUTTONPOPUP_FORCED_DISCONNECT)
-		.value("BUTTONPOPUP_PITBOSS_DISCONNECT", BUTTONPOPUP_PITBOSS_DISCONNECT)
-		.value("BUTTONPOPUP_KICKED", BUTTONPOPUP_PITBOSS_DISCONNECT)
-		.value("BUTTONPOPUP_EVENT", BUTTONPOPUP_EVENT)
-		.value("BUTTONPOPUP_FREE_COLONY", BUTTONPOPUP_FREE_COLONY)
-		.value("BUTTONPOPUP_CHOOSE_PROFESSION", BUTTONPOPUP_CHOOSE_PROFESSION)
-		.value("BUTTONPOPUP_PURCHASE_EUROPE_UNIT", BUTTONPOPUP_PURCHASE_EUROPE_UNIT)
-		.value("BUTTONPOPUP_FOUNDING_FATHER", BUTTONPOPUP_FOUNDING_FATHER)
-		.value("BUTTONPOPUP_CIVIC_OPTION", BUTTONPOPUP_CIVIC_OPTION)
-		.value("BUTTONPOPUP_TRADE_ROUTES", BUTTONPOPUP_TRADE_ROUTES)
-		.value("BUTTONPOPUP_YIELD_IMPORT_EXPORT", BUTTONPOPUP_YIELD_IMPORT_EXPORT)
-		.value("BUTTONPOPUP_PROMOTE", BUTTONPOPUP_PROMOTE)
-		.value("BUTTONPOPUP_CHOOSE_GOODY", BUTTONPOPUP_CHOOSE_GOODY)
-		.value("BUTTONPOPUP_SELECT_YIELD_AMOUNT", BUTTONPOPUP_SELECT_YIELD_AMOUNT)
-		.value("BUTTONPOPUP_EUROPE_UNIT", BUTTONPOPUP_EUROPE_UNIT)
-		.value("BUTTONPOPUP_TALK_NATIVES", BUTTONPOPUP_TALK_NATIVES)
-		.value("NUM_BUTTONPOPUP_TYPES", NUM_BUTTONPOPUP_TYPES)
-		;
-	python::enum_<ClimateTypes>("ClimateTypes")
-		.value("NO_CLIMATE", NO_CLIMATE)
-		;
-	python::enum_<SeaLevelTypes>("SeaLevelTypes")
-		.value("NO_SEALEVEL", NO_SEALEVEL)
-		;
-	python::enum_<CustomMapOptionTypes>("CustomMapOptionTypes")
-		.value("NO_CUSTOM_MAPOPTION", NO_CUSTOM_MAPOPTION)
-		;
-	python::enum_<WorldSizeTypes>("WorldSizeTypes")
-		.value("NO_WORLDSIZE", NO_WORLDSIZE)
-		.value("WORLDSIZE_TINY", WORLDSIZE_TINY)
-		.value("WORLDSIZE_SMALL", WORLDSIZE_SMALL)
-		.value("WORLDSIZE_STANDARD", WORLDSIZE_STANDARD)
-		.value("WORLDSIZE_LARGE", WORLDSIZE_LARGE)
-		.value("WORLDSIZE_HUGE", WORLDSIZE_HUGE)
-		.value("NUM_WORLDSIZE_TYPES", NUM_WORLDSIZE_TYPES)
-		;
-	python::enum_<TerrainTypes>("TerrainTypes")
-		.value("NO_TERRAIN", NO_TERRAIN)
-		;
-	python::enum_<PlotTypes>("PlotTypes")
-		.value("NO_PLOT", NO_PLOT)
-		.value("PLOT_PEAK", PLOT_PEAK)
-		.value("PLOT_HILLS", PLOT_HILLS)
-		.value("PLOT_LAND", PLOT_LAND)
-		.value("PLOT_OCEAN", PLOT_OCEAN)
-		.value("NUM_PLOT_TYPES", NUM_PLOT_TYPES)
-		;
-	python::enum_<YieldTypes>("YieldTypes")
-		.value("NO_YIELD", NO_YIELD)
-		///TKs ME
-		.value("YIELD_FOOD", YIELD_FOOD)
-		.value("YIELD_GRAIN", YIELD_GRAIN)
-		.value("YIELD_CATTLE", YIELD_CATTLE)
-		.value("YIELD_SHEEP", YIELD_SHEEP)
-		.value("YIELD_WOOL", YIELD_WOOL)
-		.value("YIELD_SALT", YIELD_SALT)
-		.value("YIELD_LUMBER", YIELD_LUMBER)
-		.value("YIELD_STONE", YIELD_STONE)
-		.value("YIELD_SILVER", YIELD_SILVER)
-//		.value("YIELD_IVORY", YIELD_IVORY)
-		.value("YIELD_SPICES", YIELD_SPICES)
-		.value("YIELD_SILVER", YIELD_SILVER)
-		.value("YIELD_FUR", YIELD_FUR)
-		.value("YIELD_COTTON", YIELD_COTTON)
-  		.value("YIELD_BARLEY", YIELD_BARLEY)
-		.value("YIELD_GRAPES", YIELD_GRAPES)
-		.value("YIELD_ORE", YIELD_ORE)
-		.value("YIELD_CLOTH", YIELD_CLOTH)
-		.value("YIELD_COATS", YIELD_COATS)
-		.value("YIELD_ALE", YIELD_ALE)
-		.value("YIELD_WINE", YIELD_WINE)
-//		.value("YIELD_LEATHER", YIELD_LEATHER)
-		.value("YIELD_TOOLS", YIELD_TOOLS)
-		.value("YIELD_WEAPONS", YIELD_WEAPONS)
-		.value("YIELD_HORSES", YIELD_HORSES)
-		.value("YIELD_LEATHER_ARMOR", YIELD_LEATHER_ARMOR)
-		.value("YIELD_SCALE_ARMOR", YIELD_SCALE_ARMOR)
-		.value("YIELD_MAIL_ARMOR", YIELD_MAIL_ARMOR)
-		.value("YIELD_PLATE_ARMOR", YIELD_PLATE_ARMOR)
-		.value("YIELD_TRADE_GOODS", YIELD_TRADE_GOODS)
-//		.value("YIELD_SILK", YIELD_SILK)
-//		.value("YIELD_PORCELAIN", YIELD_PORCELAIN)
-		.value("YIELD_HAMMERS", YIELD_HAMMERS)
-		.value("YIELD_BELLS", YIELD_BELLS)
-		.value("YIELD_CROSSES", YIELD_CROSSES)
-		.value("YIELD_EDUCATION", YIELD_EDUCATION)
-		.value("YIELD_IDEAS", YIELD_IDEAS)
-		.value("YIELD_CULTURE", YIELD_CULTURE)
-        .value("YIELD_GOLD", YIELD_GOLD)
-		///TKe
-		.value("NUM_YIELD_TYPES", NUM_YIELD_TYPES)
-		;
-	python::enum_<EmphasizeTypes>("EmphasizeTypes")
-		.value("NO_EMPHASIZE", NO_EMPHASIZE)
-		;
-	python::enum_<GameOptionTypes>("GameOptionTypes")
-		.value("NO_GAMEOPTION", NO_GAMEOPTION)
-		.value("GAMEOPTION_ADVANCED_START", GAMEOPTION_ADVANCED_START)
-		.value("GAMEOPTION_NO_CITY_RAZING", GAMEOPTION_NO_CITY_RAZING)
-		.value("GAMEOPTION_AGGRESSIVE_AI", GAMEOPTION_AGGRESSIVE_AI)
-		// < JAnimals Mod Start >
-		.value("GAMEOPTION_NO_WILD_LAND_ANIMALS", GAMEOPTION_NO_WILD_LAND_ANIMALS)
-		.value("GAMEOPTION_NO_WILD_SEA_ANIMALS", GAMEOPTION_NO_WILD_SEA_ANIMALS)
-		// < JAnimals Mod End >
-		.value("GAMEOPTION_LEAD_ANY_CIV", GAMEOPTION_LEAD_ANY_CIV)
-		.value("GAMEOPTION_PERMANENT_ALLIANCES", GAMEOPTION_PERMANENT_ALLIANCES)
-		.value("GAMEOPTION_ALWAYS_WAR", GAMEOPTION_ALWAYS_WAR)
-		.value("GAMEOPTION_ALWAYS_PEACE", GAMEOPTION_ALWAYS_PEACE)
-		.value("GAMEOPTION_ONE_CITY_CHALLENGE", GAMEOPTION_ONE_CITY_CHALLENGE)
-		.value("GAMEOPTION_NO_CHANGING_WAR_PEACE", GAMEOPTION_NO_CHANGING_WAR_PEACE)
-		.value("GAMEOPTION_NEW_RANDOM_SEED", GAMEOPTION_NEW_RANDOM_SEED)
-		.value("GAMEOPTION_LOCK_MODS", GAMEOPTION_LOCK_MODS)
-		.value("GAMEOPTION_NO_GOODY_HUTS", GAMEOPTION_NO_GOODY_HUTS)
-		.value("GAMEOPTION_NO_EVENTS", GAMEOPTION_NO_EVENTS)
-		.value("NUM_GAMEOPTION_TYPES", NUM_GAMEOPTION_TYPES)
-		;
-	python::enum_<MultiplayerOptionTypes>("MultiplayerOptionTypes")
-		.value("NO_MPOPTION", NO_MPOPTION)
-		.value("MPOPTION_SIMULTANEOUS_TURNS", MPOPTION_SIMULTANEOUS_TURNS)
-		.value("MPOPTION_TAKEOVER_AI", MPOPTION_TAKEOVER_AI)
-		.value("MPOPTION_SHUFFLE_TEAMS", MPOPTION_SHUFFLE_TEAMS)
-		.value("MPOPTION_ANONYMOUS", MPOPTION_ANONYMOUS)
-		.value("MPOPTION_TURN_TIMER", MPOPTION_TURN_TIMER)
-		.value("NUM_MPOPTION_TYPES", NUM_MPOPTION_TYPES)
-		;
-	python::enum_<SpecialOptionTypes>("SpecialOptionTypes")
-		.value("NO_SPECIALOPTION", NO_SPECIALOPTION)
-		.value("SPECIALOPTION_REPORT_STATS", SPECIALOPTION_REPORT_STATS)
-		.value("NUM_SPECIALOPTION_TYPES", NUM_SPECIALOPTION_TYPES)
-		;
-	python::enum_<PlayerOptionTypes>("PlayerOptionTypes")
-		.value("NO_PLAYEROPTION", NO_PLAYEROPTION)
-		.value("PLAYEROPTION_TUTORIAL", PLAYEROPTION_TUTORIAL)
-		.value("PLAYEROPTION_ADVISOR_POPUPS", PLAYEROPTION_ADVISOR_POPUPS)
-		.value("PLAYEROPTION_ADVISOR_HELP", PLAYEROPTION_ADVISOR_HELP)
-		.value("PLAYEROPTION_WAIT_END_TURN", PLAYEROPTION_WAIT_END_TURN)
-		.value("PLAYEROPTION_MINIMIZE_POP_UPS", PLAYEROPTION_MINIMIZE_POP_UPS)
-		.value("PLAYEROPTION_SHOW_FRIENDLY_MOVES", PLAYEROPTION_SHOW_FRIENDLY_MOVES)
-		.value("PLAYEROPTION_SHOW_ENEMY_MOVES", PLAYEROPTION_SHOW_ENEMY_MOVES)
-		.value("PLAYEROPTION_QUICK_MOVES", PLAYEROPTION_QUICK_MOVES)
-		.value("PLAYEROPTION_QUICK_ATTACK", PLAYEROPTION_QUICK_ATTACK)
-		.value("PLAYEROPTION_QUICK_DEFENSE", PLAYEROPTION_QUICK_DEFENSE)
-		.value("PLAYEROPTION_STACK_ATTACK", PLAYEROPTION_STACK_ATTACK)
-		.value("PLAYEROPTION_AUTO_PROMOTION", PLAYEROPTION_AUTO_PROMOTION)
-		.value("PLAYEROPTION_SAFE_AUTOMATION", PLAYEROPTION_SAFE_AUTOMATION)
-		.value("PLAYEROPTION_NUMPAD_HELP", PLAYEROPTION_NUMPAD_HELP)
-		.value("PLAYEROPTION_NO_UNIT_CYCLING", PLAYEROPTION_NO_UNIT_CYCLING)
-		.value("PLAYEROPTION_NO_UNIT_RECOMMENDATIONS", PLAYEROPTION_NO_UNIT_RECOMMENDATIONS)
-		.value("PLAYEROPTION_RIGHT_CLICK_MENU", PLAYEROPTION_RIGHT_CLICK_MENU)
-		.value("PLAYEROPTION_LEAVE_FORESTS", PLAYEROPTION_LEAVE_FORESTS)
-		.value("PLAYEROPTION_MODDER_1", PLAYEROPTION_MODDER_1)
-		.value("PLAYEROPTION_MODDER_2", PLAYEROPTION_MODDER_2)
-		.value("PLAYEROPTION_MODDER_3", PLAYEROPTION_MODDER_3)
-		///TK Med
-		.value("PLAYEROPTION_MODDER_4", PLAYEROPTION_MODDER_4)
-		.value("PLAYEROPTION_MODDER_5", PLAYEROPTION_MODDER_5)
-		.value("PLAYEROPTION_MODDER_6", PLAYEROPTION_MODDER_6)
-		///TK end
-		.value("NUM_PLAYEROPTION_TYPES", NUM_PLAYEROPTION_TYPES)
-		;
-	python::enum_<GraphicOptionTypes>("GraphicOptionTypes")
-		.value("NO_GRAPHICOPTION", NO_GRAPHICOPTION)
-		.value("GRAPHICOPTION_HEALTH_BARS", GRAPHICOPTION_HEALTH_BARS)
-		.value("GRAPHICOPTION_NO_COMBAT_ZOOM", GRAPHICOPTION_NO_COMBAT_ZOOM)
-		.value("GRAPHICOPTION_NO_ENEMY_GLOW", GRAPHICOPTION_NO_ENEMY_GLOW)
-		.value("GRAPHICOPTION_FROZEN_ANIMATIONS", GRAPHICOPTION_FROZEN_ANIMATIONS)
-		.value("GRAPHICOPTION_EFFECTS_DISABLED", GRAPHICOPTION_EFFECTS_DISABLED)
-		.value("GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED", GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED)
-		.value("GRAPHICOPTION_FULLSCREEN", GRAPHICOPTION_FULLSCREEN)
-		.value("GRAPHICOPTION_LOWRES_TEXTURES", GRAPHICOPTION_LOWRES_TEXTURES)
-		.value("GRAPHICOPTION_HIRES_TERRAIN", GRAPHICOPTION_HIRES_TERRAIN)
-		.value("GRAPHICOPTION_NO_MOVIES", GRAPHICOPTION_NO_MOVIES)
-		.value("NUM_GRAPHICOPTION_TYPES", NUM_GRAPHICOPTION_TYPES)
-		;
-	python::enum_<ForceControlTypes>("ForceControlTypes")
-		.value("NO_FORCECONTROL", NO_FORCECONTROL)
-		.value("FORCECONTROL_SPEED", FORCECONTROL_SPEED)
-		.value("FORCECONTROL_HANDICAP", FORCECONTROL_HANDICAP)
-		.value("FORCECONTROL_OPTIONS", FORCECONTROL_OPTIONS)
-		.value("FORCECONTROL_VICTORIES", FORCECONTROL_VICTORIES)
-		.value("FORCECONTROL_MAX_TURNS", FORCECONTROL_MAX_TURNS)
-		.value("FORCECONTROL_MAX_CITY_ELIMINATIONS", FORCECONTROL_MAX_CITY_ELIMINATION)
-		.value("FORCECONTROL_ADVANCED_START", FORCECONTROL_ADVANCED_START)
-		.value("NUM_FORCECONTROL_TYPES", NUM_FORCECONTROL_TYPES)
-		;
-	python::enum_<VictoryTypes>("VictoryTypes")
-		.value("NO_VICTORY", NO_VICTORY)
-		;
-	python::enum_<FeatureTypes>("FeatureTypes")
-		.value("NO_FEATURE", NO_FEATURE)
-		;
-	python::enum_<BonusTypes>("BonusTypes")
-		.value("NO_BONUS", NO_BONUS)
-		;
-	python::enum_<ImprovementTypes>("ImprovementTypes")
-		.value("NO_IMPROVEMENT", NO_IMPROVEMENT)
-		;
-	python::enum_<RouteTypes>("RouteTypes")
-		.value("NO_ROUTE", NO_ROUTE)
-		;
-	python::enum_<GoodyTypes>("GoodyTypes")
-		.value("NO_GOODY", NO_GOODY)
-		;
-	python::enum_<BuildTypes>("BuildTypes")
-		.value("NO_BUILD", NO_BUILD)
-		;
-	python::enum_<FontSymbols>("FontSymbols")
-		.value("HAPPY_CHAR", HAPPY_CHAR)
-		.value("UNHAPPY_CHAR", UNHAPPY_CHAR)
-		.value("HEALTHY_CHAR", HEALTHY_CHAR)
-		.value("UNHEALTHY_CHAR", UNHEALTHY_CHAR)
-		.value("BULLET_CHAR", BULLET_CHAR)
-		.value("STRENGTH_CHAR", STRENGTH_CHAR)
-		.value("MOVES_CHAR", MOVES_CHAR)
-		.value("RELIGION_CHAR", RELIGION_CHAR)
-		.value("STAR_CHAR", STAR_CHAR)
-		.value("SILVER_STAR_CHAR", SILVER_STAR_CHAR)
-		.value("TRADE_CHAR", TRADE_CHAR)
-		.value("DEFENSE_CHAR", DEFENSE_CHAR)
-		.value("GREAT_PEOPLE_CHAR", GREAT_PEOPLE_CHAR)
-		.value("BAD_GOLD_CHAR", BAD_GOLD_CHAR)
-		.value("BAD_FOOD_CHAR", BAD_FOOD_CHAR)
-		.value("EATEN_FOOD_CHAR", EATEN_FOOD_CHAR)
-		.value("GOLDEN_AGE_CHAR", GOLDEN_AGE_CHAR)
-		.value("ANGRY_POP_CHAR", ANGRY_POP_CHAR)
-		.value("OPEN_BORDERS_CHAR", OPEN_BORDERS_CHAR)
-		.value("DEFENSIVE_PACT_CHAR", DEFENSIVE_PACT_CHAR)
-		.value("MAP_CHAR", MAP_CHAR)
-		.value("OCCUPATION_CHAR", OCCUPATION_CHAR)
-		.value("REBEL_CHAR", REBEL_CHAR)
-		.value("GOLD_CHAR", GOLD_CHAR)
-		.value("POWER_CHAR", POWER_CHAR)
-		.value("MAX_NUM_SYMBOLS", MAX_NUM_SYMBOLS)
-		;
-	python::enum_<HandicapTypes>("HandicapTypes")
-		.value("NO_HANDICAP", NO_HANDICAP)
-		;
-	python::enum_<GameSpeedTypes>("GameSpeedTypes")
-		.value("NO_GAMESPEED", NO_GAMESPEED)
-		;
-	python::enum_<TurnTimerTypes>("TurnTimerTypes")
-		.value("NO_TURNTIMER", NO_TURNTIMER)
-		;
-	python::enum_<EraTypes>("EraTypes")
-		.value("NO_ERA", NO_ERA)
-		;
-	python::enum_<CivilizationTypes>("CivilizationTypes")
-		.value("NO_CIVILIZATION", NO_CIVILIZATION)
-		;
-	python::enum_<LeaderHeadTypes>("LeaderHeadTypes")
-		.value("NO_LEADER", NO_LEADER)
-		;
-	python::enum_<ArtStyleTypes>("ArtStyleTypes")
-		.value("NO_ARTSTYLE", NO_ARTSTYLE)
-		;
-    //Androrc UnitArtStyles
-	python::enum_<UnitArtStyleTypes>("UnitArtStyleTypes")
-		.value("NO_UNIT_ARTSTYLE", NO_UNIT_ARTSTYLE)
-		;
-	//Androrc End
-	python::enum_<CitySizeTypes>("CitySizeTypes")
-		.value("NO_CITYSIZE", NO_CITYSIZE)
-		.value("CITYSIZE_SMALL", CITYSIZE_SMALL)
-		.value("CITYSIZE_MEDIUM", CITYSIZE_MEDIUM)
-		.value("CITYSIZE_LARGE", CITYSIZE_LARGE)
-		.value("NUM_CITYSIZE_TYPES", NUM_CITYSIZE_TYPES)
-		;
-	python::enum_<FootstepAudioTypes>("FootstepAudioTypes")
-		.value("NO_FOOTSTEPAUDIO", NO_FOOTSTEPAUDIO)
-		;
-	python::enum_<FootstepAudioTags>("FootstepAudioTags")
-		.value("NO_FOOTSTEPAUDIO_TAG", NO_FOOTSTEPAUDIO_TAG)
-		;
-	python::enum_<ChatTargetTypes>("ChatTargetTypes")
-		.value("NO_CHATTARGET", NO_CHATTARGET)
-		.value("CHATTARGET_ALL", CHATTARGET_ALL)
-		.value("CHATTARGET_TEAM", CHATTARGET_TEAM)
-		;
-	python::enum_<VoiceTargetTypes>("VoiceTargetTypes")
-		.value("NO_VOICETARGET", NO_VOICETARGET)
-		.value("VOICETARGET_DIPLO", VOICETARGET_DIPLO)
-		.value("VOICETARGET_TEAM", VOICETARGET_TEAM)
-		.value("VOICETARGET_ALL", VOICETARGET_ALL)
-		.value("NUM_VOICETARGETS", NUM_VOICETARGETS)
-		;
-	python::enum_<TeamTypes>("TeamTypes")
-		.value("UNKNOWN_TEAM", UNKNOWN_TEAM)
-		.value("NO_TEAM", NO_TEAM)
-		;
-	python::enum_<PlayerTypes>("PlayerTypes")
-		.value("UNKNOWN_PLAYER", UNKNOWN_PLAYER)
-		.value("NO_PLAYER", NO_PLAYER)
-		;
-	python::enum_<TraitTypes>("TraitTypes")
-		.value("NO_TRAIT", NO_TRAIT)
-		;
-	python::enum_<OrderTypes>("OrderTypes")
-		.value("NO_ORDER", NO_ORDER)
-		.value("ORDER_TRAIN", ORDER_TRAIN)
-		.value("ORDER_CONSTRUCT", ORDER_CONSTRUCT)
-		.value("ORDER_CONVINCE", ORDER_CONVINCE)
-		.value("NUM_ORDER_TYPES", NUM_ORDER_TYPES)
-		;
-	python::enum_<TaskTypes>("TaskTypes")
-		.value("TASK_RAZE", TASK_RAZE)
-		.value("TASK_GIFT", TASK_GIFT)
-		.value("TASK_SET_ALL_CITIZENS_AUTOMATED", TASK_SET_ALL_CITIZENS_AUTOMATED)
-		.value("TASK_SET_CITIZEN_AUTOMATED", TASK_SET_CITIZEN_AUTOMATED)
-		.value("TASK_SET_AUTOMATED_PRODUCTION", TASK_SET_AUTOMATED_PRODUCTION)
-		.value("TASK_SET_EMPHASIZE", TASK_SET_EMPHASIZE)
-		.value("TASK_CHANGE_WORKING_PLOT", TASK_CHANGE_WORKING_PLOT)
-		.value("TASK_CHANGE_PROFESSION", TASK_CHANGE_PROFESSION)
-		.value("TASK_REPLACE_CITIZEN", TASK_REPLACE_CITIZEN)
-		.value("TASK_EJECT_TO_TRANSPORT", TASK_EJECT_TO_TRANSPORT)
-		.value("TASK_CLEAR_WORKING_OVERRIDE", TASK_CLEAR_WORKING_OVERRIDE)
-		.value("TASK_HURRY", TASK_HURRY)
-		.value("TASK_CLEAR_ORDERS", TASK_CLEAR_ORDERS)
-		.value("TASK_RALLY_PLOT", TASK_RALLY_PLOT)
-		.value("TASK_CLEAR_RALLY_PLOT", TASK_CLEAR_RALLY_PLOT)
-		.value("TASK_LIBERATE", TASK_LIBERATE)
-		.value("TASK_YIELD_IMPORT", TASK_YIELD_IMPORT)
-		.value("TASK_YIELD_EXPORT", TASK_YIELD_EXPORT)
-		.value("TASK_YIELD_LEVEL", TASK_YIELD_LEVEL)
-		.value("TASK_CLEAR_SPECIALTY", TASK_CLEAR_SPECIALTY)
-		.value("TASK_EDUCATE", TASK_EDUCATE)
-		.value("TASK_PUSH_TRAIN_UNIT", TASK_PUSH_TRAIN_UNIT)
-		.value("TASK_PUSH_CONSTRUCT_BUILDING", TASK_PUSH_CONSTRUCT_BUILDING)
-		.value("TASK_CHEAT", TASK_CHEAT)
-		.value("NUM_TASK_TYPES", NUM_TASK_TYPES)
-		;
-	python::enum_<PlayerActionTypes>("PlayerActionTypes")
-		.value("PLAYER_ACTION_BUY_EUROPE_UNIT", PLAYER_ACTION_BUY_EUROPE_UNIT)
-		.value("PLAYER_ACTION_SELL_YIELD_UNIT", PLAYER_ACTION_SELL_YIELD_UNIT)
-		.value("PLAYER_ACTION_BUY_YIELD_UNIT", PLAYER_ACTION_BUY_YIELD_UNIT)
-		.value("PLAYER_ACTION_LOAD_UNIT_FROM_EUROPE", PLAYER_ACTION_LOAD_UNIT_FROM_EUROPE)
-		.value("PLAYER_ACTION_UNLOAD_UNIT_TO_EUROPE", PLAYER_ACTION_UNLOAD_UNIT_TO_EUROPE)
-		.value("PLAYER_ACTION_TRANSFER_UNIT_IN_EUROPE", PLAYER_ACTION_TRANSFER_UNIT_IN_EUROPE)
-		.value("PLAYER_ACTION_SET_OPTION", PLAYER_ACTION_SET_OPTION)
-		.value("PLAYER_ACTION_AUTO_MOVES", PLAYER_ACTION_AUTO_MOVES)
-		.value("PLAYER_ACTION_TURN_COMPLETE", PLAYER_ACTION_TURN_COMPLETE)
-		.value("PLAYER_ACTION_APPLY_EVENT", PLAYER_ACTION_APPLY_EVENT)
-		.value("PLAYER_ACTION_CONVINCE_FATHER", PLAYER_ACTION_CONVINCE_FATHER)
-		.value("PLAYER_ACTION_SET_CIVIC", PLAYER_ACTION_SET_CIVIC)
-		.value("PLAYER_ACTION_RECEIVE_GOODY", PLAYER_ACTION_RECEIVE_GOODY)
-		.value("PLAYER_ACTION_FEAT", PLAYER_ACTION_FEAT)
-		.value("PLAYER_ACTION_BUY_UNITS_FROM_KING", PLAYER_ACTION_BUY_UNITS_FROM_KING)
-		.value("PLAYER_ACTION_HURRY", PLAYER_ACTION_HURRY)
-		.value("PLAYER_ACTION_EUROPE_CHANGE_PROFESSION", PLAYER_ACTION_EUROPE_CHANGE_PROFESSION)
-		.value("NUM_PLAYER_ACTION_TYPES", NUM_PLAYER_ACTION_TYPES)
-		;
-	python::enum_<BuildingClassTypes>("BuildingClassTypes")
-		.value("NO_BUILDINGCLASS", NO_BUILDINGCLASS)
-		;
-	python::enum_<BuildingTypes>("BuildingTypes")
-		.value("NO_BUILDING", NO_BUILDING)
-		;
-	python::enum_<SpecialBuildingTypes>("SpecialBuildingTypes")
-		.value("NO_SPECIALBUILDING", NO_SPECIALBUILDING)
-		;
-	python::enum_<InfoBarTypes>("InfoBarTypes")
-		.value("INFOBAR_STORED", INFOBAR_STORED)
-		.value("INFOBAR_RATE", INFOBAR_RATE)
-		.value("INFOBAR_RATE_EXTRA", INFOBAR_RATE_EXTRA)
-		.value("INFOBAR_EMPTY", INFOBAR_EMPTY)
-		.value("NUM_INFOBAR_TYPES", NUM_INFOBAR_TYPES)
-		;
-	python::enum_<HealthBarTypes>("HealthBarTypes")
-		.value("HEALTHBAR_ALIVE_ATTACK", HEALTHBAR_ALIVE_ATTACK)
-		.value("HEALTHBAR_ALIVE_DEFEND", HEALTHBAR_ALIVE_DEFEND)
-		.value("HEALTHBAR_DEAD", HEALTHBAR_DEAD)
-		.value("NUM_HEALTHBAR_TYPES", NUM_HEALTHBAR_TYPES)
-		;
-	python::enum_<ConceptTypes>("ConceptTypes")
-		.value("NO_CONCEPT", NO_CONCEPT)
-		;
-	python::enum_<CalendarTypes>("CalendarTypes")
-		.value("CALENDAR_DEFAULT", CALENDAR_DEFAULT)
-		.value("CALENDAR_BI_YEARLY", CALENDAR_BI_YEARLY)
-		.value("CALENDAR_YEARS", CALENDAR_YEARS)
-		.value("CALENDAR_TURNS", CALENDAR_TURNS)
-		.value("CALENDAR_SEASONS", CALENDAR_SEASONS)
-		.value("CALENDAR_MONTHS", CALENDAR_MONTHS)
-		.value("CALENDAR_WEEKS", CALENDAR_WEEKS)
-		;
-	python::enum_<SeasonTypes>("SeasonTypes")
-		.value("NO_SEASON", NO_SEASON)
-		;
-	python::enum_<MonthTypes>("MonthTypes")
-		.value("NO_MONTH", NO_MONTH)
-		;
-	python::enum_<DenialTypes>("DenialTypes")
-		.value("NO_DENIAL", NO_DENIAL)
-		.value("DENIAL_UNKNOWN", DENIAL_UNKNOWN)
-		.value("DENIAL_NEVER", DENIAL_NEVER)
-		.value("DENIAL_TOO_MUCH", DENIAL_TOO_MUCH)
-		.value("DENIAL_MYSTERY", DENIAL_MYSTERY)
-		.value("DENIAL_JOKING", DENIAL_JOKING)
-		.value("DENIAL_CONTACT_THEM", DENIAL_CONTACT_THEM)
-		.value("DENIAL_VICTORY", DENIAL_VICTORY)
-		.value("DENIAL_ATTITUDE", DENIAL_ATTITUDE)
-		.value("DENIAL_ATTITUDE_THEM", DENIAL_ATTITUDE_THEM)
-		.value("DENIAL_POWER_US", DENIAL_POWER_US)
-		.value("DENIAL_POWER_YOU", DENIAL_POWER_YOU)
-		.value("DENIAL_POWER_THEM", DENIAL_POWER_THEM)
-		.value("DENIAL_TOO_MANY_WARS", DENIAL_TOO_MANY_WARS)
-		.value("DENIAL_NO_GAIN", DENIAL_NO_GAIN)
-		.value("DENIAL_NOT_INTERESTED", DENIAL_NOT_INTERESTED)
-		.value("DENIAL_NOT_ALLIED", DENIAL_NOT_ALLIED)
-		.value("DENIAL_RECENT_CANCEL", DENIAL_RECENT_CANCEL)
-		.value("DENIAL_WORST_ENEMY", DENIAL_WORST_ENEMY)
-		.value("DENIAL_POWER_YOUR_ENEMIES", DENIAL_POWER_YOUR_ENEMIES)
-		.value("DENIAL_TOO_FAR", DENIAL_TOO_FAR)
-		///Tks Med
-		.value("DENIAL_CULTURE_YOU", DENIAL_CULTURE_YOU)
-		///Tke
-		.value("NUM_DENIAL_TYPES", NUM_DENIAL_TYPES)
-		;
-	python::enum_<DomainTypes>("DomainTypes")
-		.value("DOMAIN_SEA", DOMAIN_SEA)
-		.value("DOMAIN_LAND", DOMAIN_LAND)
-		.value("DOMAIN_IMMOBILE", DOMAIN_IMMOBILE)
-		.value("NUM_DOMAIN_TYPES", NUM_DOMAIN_TYPES)
-		;
-	python::enum_<UnitClassTypes>("UnitClassTypes")
-		.value("NO_UNITCLASS", NO_UNITCLASS)
-		;
-	python::enum_<UnitTypes>("UnitTypes")
-		.value("NO_UNIT", NO_UNIT)
-		;
-	python::enum_<ProfessionTypes>("ProfessionTypes")
-		.value("NO_PROFESSION", NO_PROFESSION)
-		;
-	python::enum_<SpecialUnitTypes>("SpecialUnitTypes")
-		.value("NO_SPECIALUNIT", NO_SPECIALUNIT)
-		;
-	python::enum_<UnitCombatTypes>("UnitCombatTypes")
-		.value("NO_UNITCOMBAT", NO_UNITCOMBAT)
-		;
-	python::enum_<UnitAITypes>("UnitAITypes")
-		.value("NO_UNITAI", NO_UNITAI)
-		.value("UNITAI_UNKNOWN", UNITAI_UNKNOWN)
-		// < JAnimals Mod Start >
-		.value("UNITAI_ANIMAL", UNITAI_ANIMAL)
-		// < JAnimals Mod End >
-		.value("UNITAI_COLONIST", UNITAI_COLONIST)
-		.value("UNITAI_SETTLER", UNITAI_SETTLER)
-		.value("UNITAI_WORKER", UNITAI_WORKER)
-		.value("UNITAI_MISSIONARY", UNITAI_MISSIONARY)
-		.value("UNITAI_SCOUT", UNITAI_SCOUT)
-		.value("UNITAI_WAGON", UNITAI_WAGON)
-		.value("UNITAI_TREASURE", UNITAI_TREASURE)
-		.value("UNITAI_DEFENSIVE", UNITAI_DEFENSIVE)
-		.value("UNITAI_OFFENSIVE", UNITAI_DEFENSIVE)
-		.value("UNITAI_COUNTER", UNITAI_COUNTER)
-		.value("UNITAI_TRANSPORT_SEA", UNITAI_TRANSPORT_SEA)
-		.value("UNITAI_ASSAULT_SEA", UNITAI_ASSAULT_SEA)
-		.value("UNITAI_COMBAT_SEA", UNITAI_COMBAT_SEA)
-		.value("UNITAI_PIRATE_SEA", UNITAI_PIRATE_SEA)
-		.value("NUM_UNITAI_TYPES", NUM_UNITAI_TYPES)
-		///TKs Med
-		.value("UNITAI_TRADER", UNITAI_TRADER)
-		.value("UNITAI_HUNTSMAN", UNITAI_HUNTSMAN)
-		.value("UNITAI_MARAUDER", UNITAI_MARAUDER)
-		///Tke
-		;
-	python::enum_<InvisibleTypes>("InvisibleTypes")
-		.value("NO_INVISIBLE", NO_INVISIBLE)
-		;
-	python::enum_<ProbabilityTypes>("ProbabilityTypes")
-		.value("NO_PROBABILITY", NO_PROBABILITY)
-		.value("PROBABILITY_LOW", PROBABILITY_LOW)
-		.value("PROBABILITY_REAL", PROBABILITY_REAL)
-		.value("PROBABILITY_HIGH", PROBABILITY_HIGH)
-		.value("NUM_PROBABILITY_TYPES", NUM_PROBABILITY_TYPES)
-		;
-	python::enum_<ActivityTypes>("ActivityTypes")
-		.value("NO_ACTIVITY", NO_ACTIVITY)
-		.value("ACTIVITY_AWAKE", ACTIVITY_AWAKE)
-		.value("ACTIVITY_HOLD", ACTIVITY_HOLD)
-		.value("ACTIVITY_SLEEP", ACTIVITY_SLEEP)
-		.value("ACTIVITY_HEAL", ACTIVITY_HEAL)
-		.value("ACTIVITY_SENTRY", ACTIVITY_SENTRY)
-		.value("ACTIVITY_MISSION", ACTIVITY_MISSION)
-		.value("NUM_ACTIVITY_TYPES", NUM_ACTIVITY_TYPES)
-		;
-	python::enum_<AutomateTypes>("AutomateTypes")
-		.value("NO_AUTOMATE", NO_AUTOMATE)
-		.value("AUTOMATE_BUILD", AUTOMATE_BUILD)
-		.value("AUTOMATE_CITY", AUTOMATE_CITY)
-		.value("AUTOMATE_EXPLORE", AUTOMATE_EXPLORE)
-		.value("AUTOMATE_SAIL", AUTOMATE_SAIL)
-		///TKs Med
-		.value("AUTOMATE_HUNT", AUTOMATE_HUNT)
-		.value("AUTOMATE_TRAVEL_FAIR", AUTOMATE_TRAVEL_FAIR)
-        ///TKe
-		.value("AUTOMATE_TRANSPORT_ROUTES", AUTOMATE_TRANSPORT_ROUTES)
-		.value("AUTOMATE_TRANSPORT_FULL", AUTOMATE_TRANSPORT_FULL)
-		///TKs Med
-		.value("AUTOMATE_RETURN_HOME", AUTOMATE_RETURN_HOME)
-		.value("AUTOMATE_IMMIGRATION", AUTOMATE_IMMIGRATION)
-        ///TKe
-		.value("AUTOMATE_FULL", AUTOMATE_FULL)
-		.value("NUM_AUTOMATE_TYPES", NUM_AUTOMATE_TYPES)
-		;
-	python::enum_<MissionTypes>("MissionTypes")
-		.value("NO_MISSION", NO_MISSION)
-		.value("MISSION_MOVE_TO", MISSION_MOVE_TO)
-		.value("MISSION_ROUTE_TO", MISSION_ROUTE_TO)
-		.value("MISSION_MOVE_TO_UNIT", MISSION_MOVE_TO_UNIT)
-		.value("MISSION_SKIP", MISSION_SKIP)
-		.value("MISSION_SLEEP", MISSION_SLEEP)
-		.value("MISSION_FORTIFY", MISSION_FORTIFY)
-		.value("MISSION_HEAL", MISSION_HEAL)
-		.value("MISSION_SENTRY", MISSION_SENTRY)
-		.value("MISSION_BOMBARD", MISSION_BOMBARD)
-		.value("MISSION_PILLAGE", MISSION_PILLAGE)
-		.value("MISSION_FOUND", MISSION_FOUND)
-		.value("MISSION_JOIN_CITY", MISSION_JOIN_CITY)
-		.value("MISSION_LEAD", MISSION_LEAD)
-		.value("MISSION_BUILD", MISSION_BUILD)
-		.value("MISSION_BEGIN_COMBAT", MISSION_BEGIN_COMBAT )
-		.value("MISSION_END_COMBAT", MISSION_END_COMBAT )
-		.value("MISSION_SURRENDER", MISSION_SURRENDER )
-		.value("MISSION_CAPTURED", MISSION_CAPTURED )
-		.value("MISSION_IDLE", MISSION_IDLE )
-		.value("MISSION_DIE", MISSION_DIE )
-		.value("MISSION_DAMAGE", MISSION_DAMAGE )
-		.value("MISSION_MULTI_SELECT", MISSION_MULTI_SELECT )
-		.value("MISSION_MULTI_DESELECT", MISSION_MULTI_DESELECT )
-		///Tks Med
-		.value("MISSION_FOUND_MONASTERY", MISSION_FOUND_MONASTERY)
-		.value("MISSION_FOUND_OUTPOST", MISSION_FOUND_OUTPOST)
-		.value("MISSION_COLLECT_TAXES", MISSION_COLLECT_TAXES)
-		.value("MISSION_HUNT", MISSION_HUNT)
-		.value("NUM_MISSION_TYPES", NUM_MISSION_TYPES )
-		;
-    python::enum_<MedCityTypes>("MedCityTypes")
-		.value("CITYTYPE_DEFAULT", CITYTYPE_DEFAULT)
-		.value("CITYTYPE_COMMERCE", CITYTYPE_COMMERCE)
-		.value("CITYTYPE_MONASTERY", CITYTYPE_MONASTERY)
-		.value("CITYTYPE_OUTPOST", CITYTYPE_OUTPOST)
-		.value("CITYTYPE_BAILEY", CITYTYPE_BAILEY)
-		.value("CITYTYPE_CASTLE", CITYTYPE_CASTLE)
-		.value("CITYTYPE_MILITARY", CITYTYPE_MILITARY)
-		.value("CITYTYPE_NONE_MILITARY", CITYTYPE_NONE_MILITARY)
-		.value("CITYTYPE_NONE_MONASTERY", CITYTYPE_NONE_MONASTERY)
-		.value("NUM_CITY_TYPES", NUM_CITY_TYPES)
-		;
-    python::enum_<TradeScreenTypes>("TradeScreenTypes")
-		.value("TRADE_SCREEN_DEFAULT", TRADE_SCREEN_DEFAULT)
-		.value("TRADE_SCREEN_MOTHERLAND", TRADE_SCREEN_MOTHERLAND)
-		.value("TRADE_SCREEN_TRADE_FAIR", TRADE_SCREEN_TRADE_FAIR)
-		.value("TRADE_SCREEN_SPICE_ROUTE", TRADE_SCREEN_SPICE_ROUTE)
-		.value("TRADE_SCREEN_SILK_ROAD", TRADE_SCREEN_SILK_ROAD)
-		.value("TRADE_SCREEN_EUROPE", TRADE_SCREEN_EUROPE)
-		.value("NUM_TRADE_SCREEN_TYPES", NUM_TRADE_SCREEN_TYPES)
-		;
-     python::enum_<ModCodeTypes>("ModCodeTypes")
-		.value("NO_MOD_CODE", NO_MOD_CODE)
-		.value("MODER_CODE_FASTER_CHOP_TREES", MODER_CODE_FASTER_CHOP_TREES)
-		.value("MODER_CODE_SPICE_ROUTE", MODER_CODE_SPICE_ROUTE)
-		.value("MODER_CODE_SILK_ROAD_ROUTE", MODER_CODE_SILK_ROAD_ROUTE)
-		.value("MODER_CODE_TRADING_POST", MODER_CODE_TRADING_POST)
-		.value("MODER_CODE_ONLY_NONE_NATIVES", MODER_CODE_ONLY_NONE_NATIVES)
-		.value("MODER_CODE_NATIVES_ONLY", MODER_CODE_NATIVES_ONLY)
-		.value("MODER_CODE_ANYONE", MODER_CODE_ANYONE)
-		.value("MODER_CODE_NATIVES_VIKING_AGE", MODER_CODE_NATIVES_VIKING_AGE)
-		.value("MODER_CODE_ALLOWS_TRADE_FAIR", MODER_CODE_ALLOWS_TRADE_FAIR)
-		.value("MODER_CODE_CANNOT_WORK_BUILDINGS", MODER_CODE_CANNOT_WORK_BUILDINGS)
-		.value("MODER_CODE_NONE_MILITARY", MODER_CODE_NONE_MILITARY)
-		.value("MODER_CODE_SQUIRE", MODER_CODE_SQUIRE)
-		.value("MODER_CODE_CRAFTMEN_NOBLES", MODER_CODE_CRAFTMEN_NOBLES)
-		.value("MODER_CODE__AI_ONLY", MODER_CODE_AI_ONLY)
-		.value("MODER_CODE_CANNOT_LEARN_NATIVE", MODER_CODE_CANNOT_LEARN_NATIVE)
-		.value("NUM_MOD_CODE_TYPES", NUM_MOD_CODE_TYPES)
-		;
-     python::enum_<CensureType>("CensureType")
-		.value("NO_CENSURE", NO_CENSURE)
-		.value("CENSURE_EXCOMMUNICATION", CENSURE_EXCOMMUNICATION)
-		.value("CENSURE_INTERDICT", CENSURE_INTERDICT)
-		.value("CENSURE_ANATHEMA", CENSURE_ANATHEMA)
-		.value("CENSURE_CRUSADE", CENSURE_CRUSADE)
-		.value("NUM_CENSURE_TYPES", NUM_CENSURE_TYPES)
-		;
-     python::enum_<TradeRouteTypes>("TradeRouteTypes")
-		.value("NO_TRADE_ROUTES", NO_TRADE_ROUTES)
-		.value("TRADE_ROUTE_EUROPE", TRADE_ROUTE_EUROPE)
-		.value("TRADE_ROUTE_FAIR", TRADE_ROUTE_FAIR)
-		.value("TRADE_ROUTE_SPICE_ROUTE", TRADE_ROUTE_SPICE_ROUTE)
-		.value("TRADE_ROUTE_SILK_ROAD", TRADE_ROUTE_SILK_ROAD)
-		.value("NUM_TRADE_ROUTES_TYPES", NUM_TRADE_ROUTES_TYPES)
-		;
-		///Tke
-	python::enum_<MissionAITypes>("MissionAITypes")
-		.value("NO_MISSIONAI", NO_MISSIONAI)
-		.value("MISSIONAI_SHADOW", MISSIONAI_SHADOW)
-		.value("MISSIONAI_GROUP", MISSIONAI_GROUP)
-		.value("MISSIONAI_LOAD_ASSAULT", MISSIONAI_LOAD_ASSAULT)
-		.value("MISSIONAI_LOAD_SETTLER", MISSIONAI_LOAD_SETTLER)
-		.value("MISSIONAI_LOAD_SPECIAL", MISSIONAI_LOAD_SPECIAL)
-		.value("MISSIONAI_GUARD_CITY", MISSIONAI_GUARD_CITY)
-		.value("MISSIONAI_GUARD_BONUS", MISSIONAI_GUARD_BONUS)
-		.value("MISSIONAI_GUARD_TRADE_NET", MISSIONAI_GUARD_TRADE_NET)
-		.value("MISSIONAI_SPREAD", MISSIONAI_SPREAD)
-		.value("MISSIONAI_EXPLORE", MISSIONAI_EXPLORE)
-		.value("MISSIONAI_PILLAGE", MISSIONAI_PILLAGE)
-		.value("MISSIONAI_FOUND", MISSIONAI_FOUND)
-		.value("MISSIONAI_BUILD", MISSIONAI_BUILD)
-		.value("MISSIONAI_ASSAULT", MISSIONAI_ASSAULT)
-		.value("MISSIONAI_PICKUP", MISSIONAI_PICKUP)
-		.value("MISSIONAI_AWAIT_PICKUP", MISSIONAI_AWAIT_PICKUP)
-		.value("MISSIONAI_SAIL_TO_EUROPE", MISSIONAI_SAIL_TO_EUROPE)
-		.value("MISSIONAI_SAIL_FROM_EUROPE", MISSIONAI_SAIL_FROM_EUROPE)
-		.value("MISSIONAI_TRANSPORT", MISSIONAI_TRANSPORT)
-		.value("MISSIONAI_TRANSPORT_SEA", MISSIONAI_TRANSPORT_SEA)
-		.value("MISSIONAI_PIRACY", MISSIONAI_PIRACY)
-		.value("MISSIONAI_BOMBARD", MISSIONAI_BOMBARD)
-		.value("MISSIONAI_LEARN", MISSIONAI_LEARN)
-		///Tks Med
-		.value("MISSIONAI_PILGRAM", MISSIONAI_PILGRAM)
-		.value("MISSIONAI_HUNT", MISSIONAI_HUNT)
-		///Tke
-		.value("NUM_MISSIONAI_TYPES", NUM_MISSIONAI_TYPES)
-		;
-	// any additions need to be reflected in GlobalTypes.xml
-	python::enum_<CommandTypes>("CommandTypes")
-		.value("NO_COMMAND", NO_COMMAND)
-		.value("COMMAND_PROMOTION", COMMAND_PROMOTION)
-		.value("COMMAND_UPGRADE", COMMAND_UPGRADE)
-		.value("COMMAND_AUTOMATE", COMMAND_AUTOMATE)
-		.value("COMMAND_WAKE", COMMAND_WAKE)
-		.value("COMMAND_CANCEL", COMMAND_CANCEL)
-		.value("COMMAND_CANCEL_ALL", COMMAND_CANCEL_ALL)
-		.value("COMMAND_STOP_AUTOMATION", COMMAND_STOP_AUTOMATION)
-		.value("COMMAND_DELETE", COMMAND_DELETE)
-		.value("COMMAND_GIFT", COMMAND_GIFT)
-		.value("COMMAND_LOAD", COMMAND_LOAD)
-		.value("COMMAND_LOAD_UNIT", COMMAND_LOAD_UNIT)
-		.value("COMMAND_LOAD_CARGO", COMMAND_LOAD_CARGO)
-		.value("COMMAND_LOAD_YIELD", COMMAND_LOAD_YIELD)
-		.value("COMMAND_UNLOAD", COMMAND_UNLOAD)
-		.value("COMMAND_UNLOAD_ALL", COMMAND_UNLOAD_ALL)
-		.value("COMMAND_LEARN", COMMAND_LEARN)
-		.value("COMMAND_KING_TRANSPORT", COMMAND_KING_TRANSPORT)
-		.value("COMMAND_ESTABLISH_MISSION", COMMAND_ESTABLISH_MISSION)
-		.value("COMMAND_SPEAK_WITH_CHIEF", COMMAND_SPEAK_WITH_CHIEF)
-		.value("COMMAND_YIELD_TRADE", COMMAND_YIELD_TRADE)
-		.value("COMMAND_SAIL_TO_EUROPE", COMMAND_SAIL_TO_EUROPE)
-		.value("COMMAND_CHOOSE_TRADE_ROUTES", COMMAND_CHOOSE_TRADE_ROUTES)
-		.value("COMMAND_ASSIGN_TRADE_ROUTE", COMMAND_ASSIGN_TRADE_ROUTE)
-		.value("COMMAND_PROMOTE", COMMAND_PROMOTE)
-		.value("COMMAND_PROFESSION", COMMAND_PROFESSION)
-		.value("COMMAND_CLEAR_SPECIALTY", COMMAND_CLEAR_SPECIALTY)
-		.value("COMMAND_HOTKEY", COMMAND_HOTKEY)
-		///Tks Med
-		.value("COMMAND_CONVERT_UNIT", COMMAND_CONVERT_UNIT)
-		.value("COMMAND_HOLD_FEAST", COMMAND_HOLD_FEAST)
-		.value("COMMAND_TRAVEL_TO_FAIR", COMMAND_TRAVEL_TO_FAIR)
-		.value("COMMAND_SAIL_SPICE_ROUTE", COMMAND_SAIL_SPICE_ROUTE)
-		.value("COMMAND_TRAVEL_SILK_ROAD", COMMAND_TRAVEL_SILK_ROAD)
-		.value("COMMAND_ASSIGN_HOME_CITY", COMMAND_ASSIGN_HOME_CITY)
-		///Tke
-		.value("NUM_COMMAND_TYPES", NUM_COMMAND_TYPES)
-		;
-	python::enum_<ControlTypes>("ControlTypes")
-		.value("NO_CONTROL", NO_CONTROL)
-		.value("CONTROL_CENTERONSELECTION", CONTROL_CENTERONSELECTION)
-		.value("CONTROL_SELECTYUNITTYPE", CONTROL_SELECTYUNITTYPE)
-		.value("CONTROL_SELECTYUNITALL", CONTROL_SELECTYUNITALL)
-		.value("CONTROL_SELECTCITY", CONTROL_SELECTCITY)
-		.value("CONTROL_SELECTCAPITAL", CONTROL_SELECTCAPITAL)
-		.value("CONTROL_NEXTCITY", CONTROL_NEXTCITY)
-		.value("CONTROL_PREVCITY", CONTROL_PREVCITY)
-		.value("CONTROL_NEXTUNIT", CONTROL_NEXTUNIT)
-		.value("CONTROL_PREVUNIT", CONTROL_PREVUNIT)
-		.value("CONTROL_CYCLEUNIT", CONTROL_CYCLEUNIT)
-		.value("CONTROL_CYCLEUNIT_ALT", CONTROL_CYCLEUNIT_ALT)
-		.value("CONTROL_LASTUNIT", CONTROL_LASTUNIT)
-		.value("CONTROL_ENDTURN", CONTROL_ENDTURN)
-		.value("CONTROL_ENDTURN_ALT", CONTROL_ENDTURN_ALT)
-		.value("CONTROL_FORCEENDTURN", CONTROL_FORCEENDTURN)
-		.value("CONTROL_AUTOMOVES", CONTROL_AUTOMOVES)
-		.value("CONTROL_PING", CONTROL_PING)
-		.value("CONTROL_SIGN", CONTROL_SIGN)
-		.value("CONTROL_GRID", CONTROL_GRID)
-		.value("CONTROL_BARE_MAP", CONTROL_BARE_MAP)
-		.value("CONTROL_YIELDS", CONTROL_YIELDS)
-		.value("CONTROL_RESOURCE_ALL", CONTROL_RESOURCE_ALL)
-		.value("CONTROL_UNIT_ICONS", CONTROL_UNIT_ICONS)
-		.value("CONTROL_GLOBELAYER", CONTROL_GLOBELAYER)
-		.value("CONTROL_SCORES", CONTROL_SCORES)
-		.value("CONTROL_LOAD_GAME", CONTROL_LOAD_GAME)
-		.value("CONTROL_OPTIONS_SCREEN", CONTROL_OPTIONS_SCREEN)
-		.value("CONTROL_RETIRE", CONTROL_RETIRE)
-		.value("CONTROL_SAVE_GROUP", CONTROL_SAVE_GROUP)
-		.value("CONTROL_SAVE_NORMAL", CONTROL_SAVE_NORMAL)
-		.value("CONTROL_QUICK_SAVE", CONTROL_QUICK_SAVE)
-		.value("CONTROL_QUICK_LOAD", CONTROL_QUICK_LOAD)
-		.value("CONTROL_ORTHO_CAMERA", CONTROL_ORTHO_CAMERA)
-		.value("CONTROL_CYCLE_CAMERA_FLYING_MODES", CONTROL_CYCLE_CAMERA_FLYING_MODES)
-		.value("CONTROL_ISOMETRIC_CAMERA_LEFT", CONTROL_ISOMETRIC_CAMERA_LEFT)
-		.value("CONTROL_ISOMETRIC_CAMERA_RIGHT", CONTROL_ISOMETRIC_CAMERA_RIGHT)
-		.value("CONTROL_FLYING_CAMERA", CONTROL_FLYING_CAMERA)
-		.value("CONTROL_MOUSE_FLYING_CAMERA", CONTROL_MOUSE_FLYING_CAMERA)
-		.value("CONTROL_TOP_DOWN_CAMERA", CONTROL_TOP_DOWN_CAMERA)
-		.value("CONTROL_CIVILOPEDIA", CONTROL_CIVILOPEDIA)
-		.value("CONTROL_FOREIGN_SCREEN", CONTROL_FOREIGN_SCREEN)
-		.value("CONTROL_CONGRESS_SCREEN", CONTROL_CONGRESS_SCREEN)
-		.value("CONTROL_REVOLUTION_SCREEN", CONTROL_REVOLUTION_SCREEN)
-		.value("CONTROL_EUROPE_SCREEN", CONTROL_EUROPE_SCREEN)
-		.value("CONTROL_MILITARY_SCREEN", CONTROL_MILITARY_SCREEN)
-		.value("CONTROL_FATHER_SCREEN", CONTROL_FATHER_SCREEN)
-		///TKs Invention Core Mod v 1.0
-		.value("CONTROL_TECHNOLOGY_SCREEN", CONTROL_TECHNOLOGY_SCREEN)
-		.value("CONTROL_TRADE_SCREEN", CONTROL_TRADE_SCREEN)
-		.value("CONTROL_SPICE_ROUTE_SCREEN", CONTROL_SPICE_ROUTE_SCREEN)
-		.value("CONTROL_SILK_ROAD_SCREEN", CONTROL_SILK_ROAD_SCREEN)
-		.value("CONTROL_TRADE_FAIR_SCREEN", CONTROL_TRADE_FAIR_SCREEN)
-		.value("CONTROL_IMMIGRATION_SCREEN", CONTROL_IMMIGRATION_SCREEN)
-		///TKe
-		.value("CONTROL_TURN_LOG", CONTROL_TURN_LOG)
-		.value("CONTROL_CHAT_ALL", CONTROL_CHAT_ALL)
-		.value("CONTROL_CHAT_TEAM", CONTROL_CHAT_TEAM)
-		.value("CONTROL_DOMESTIC_SCREEN", CONTROL_DOMESTIC_SCREEN)
-		.value("CONTROL_VICTORY_SCREEN", CONTROL_VICTORY_SCREEN)
-		.value("CONTROL_INFO", CONTROL_INFO)
-		.value("CONTROL_GLOBE_VIEW", CONTROL_GLOBE_VIEW)
-		.value("CONTROL_DETAILS", CONTROL_DETAILS)
-		.value("CONTROL_ADMIN_DETAILS", CONTROL_ADMIN_DETAILS)
-		.value("CONTROL_HALL_OF_FAME", CONTROL_HALL_OF_FAME)
-		.value("CONTROL_WORLD_BUILDER", CONTROL_WORLD_BUILDER)
-		.value("CONTROL_DIPLOMACY", CONTROL_DIPLOMACY)
-		.value("CONTROL_SELECT_HEALTHY", CONTROL_SELECT_HEALTHY)
-		.value("CONTROL_FREE_COLONY", CONTROL_FREE_COLONY)
-		.value("NUM_CONTROL_TYPES", NUM_CONTROL_TYPES)
-		;
-	python::enum_<PromotionTypes>("PromotionTypes")
-		.value("NO_PROMOTION", NO_PROMOTION)
-		;
-	python::enum_<HurryTypes>("HurryTypes")
-		.value("NO_HURRY", NO_HURRY)
-		;
-	python::enum_<CultureLevelTypes>("CultureLevelTypes")
-		.value("NO_CULTURELEVEL", NO_CULTURELEVEL)
-		;
-	python::enum_<CivicOptionTypes>("CivicOptionTypes")
-		.value("NO_CIVICOPTION", NO_CIVICOPTION)
-		;
-	python::enum_<CivicTypes>("CivicTypes")
-		.value("NO_CIVIC", NO_CIVIC)
-		;
-	python::enum_<WarPlanTypes>("WarPlanTypes")
-		.value("NO_WARPLAN", NO_WARPLAN)
-		.value("WARPLAN_ATTACKED_RECENT", WARPLAN_ATTACKED_RECENT)
-		.value("WARPLAN_ATTACKED", WARPLAN_ATTACKED)
-		.value("WARPLAN_PREPARING_LIMITED", WARPLAN_PREPARING_LIMITED)
-		.value("WARPLAN_PREPARING_TOTAL", WARPLAN_PREPARING_TOTAL)
-		.value("WARPLAN_LIMITED", WARPLAN_LIMITED)
-		.value("WARPLAN_TOTAL", WARPLAN_TOTAL)
-		.value("WARPLAN_DOGPILE", WARPLAN_DOGPILE)
-		.value("WARPLAN_EXTORTION", WARPLAN_EXTORTION)
-		.value("NUM_WARPLAN_TYPES", NUM_WARPLAN_TYPES)
-		;
-	python::enum_<AreaAITypes>("AreaAITypes")
-		.value("NO_AREAAI", NO_AREAAI)
-		.value("AREAAI_OFFENSIVE", AREAAI_OFFENSIVE)
-		.value("AREAAI_BALANCED", AREAAI_BALANCED)
-		.value("AREAAI_DEFENSIVE", AREAAI_DEFENSIVE)
-		.value("AREAAI_MASSING", AREAAI_MASSING)
-		.value("AREAAI_ASSAULT", AREAAI_ASSAULT)
-		.value("AREAAI_ASSAULT_MASSING", AREAAI_ASSAULT_MASSING)
-		.value("AREAAI_NEUTRAL", AREAAI_NEUTRAL)
-		.value("NUM_AREAAI_TYPES", NUM_AREAAI_TYPES)
-		;
-	python::enum_<EmotionTypes>("EmotionTypes")
-		.value("NO_EMOTION", NO_EMOTION)
-		.value("EMOTION_GREED", EMOTION_GREED)
-		.value("EMOTION_ANGER", EMOTION_ANGER)
-		.value("EMOTION_ENVY", EMOTION_ENVY)
-		.value("EMOTION_ANXIETY", EMOTION_ANXIETY)
-		.value("EMOTION_SUBMISSION", EMOTION_SUBMISSION)
-		.value("NUM_EMOTION_TYPES", NUM_EMOTION_TYPES)
-		;
-	python::enum_<EndTurnButtonStates>("EndTurnButtonStates")
-		.value("END_TURN_GO", END_TURN_GO)
-		.value("END_TURN_OVER_HIGHLIGHT", END_TURN_OVER_HIGHLIGHT)
-		.value("END_TURN_OVER_DARK", END_TURN_OVER_DARK)
-		.value("NUM_END_TURN_STATES", NUM_END_TURN_STATES)
-		;
-	python::enum_<FogOfWarModeTypes>("FogOfWarModeTypes")
-		.value("FOGOFWARMODE_OFF", FOGOFWARMODE_OFF)
-		.value("FOGOFWARMODE_UNEXPLORED", FOGOFWARMODE_UNEXPLORED)
-		.value("NUM_FOGOFWARMODE_TYPES", NUM_FOGOFWARMODE_TYPES)
-		;
-	python::enum_<AnimationTypes>("AnimationTypes")
-		.value("NONE_ANIMATION", NONE_ANIMATION)
-		.value("BONUSANIMATION_UNIMPROVED", BONUSANIMATION_UNIMPROVED)
-		.value("BONUSANIMATION_NOT_WORKED", BONUSANIMATION_NOT_WORKED)
-		.value("BONUSANIMATION_WORKED", BONUSANIMATION_WORKED)
-		.value("IMPROVEMENTANIMATION_OFF", IMPROVEMENTANIMATION_OFF)
-		.value("IMPROVEMENTANIMATION_ON", IMPROVEMENTANIMATION_ON)
-		.value("IMPROVEMENTANIMATION_OFF_EXTRA", IMPROVEMENTANIMATION_OFF_EXTRA)
-		.value("IMPROVEMENTANIMATION_ON_EXTRA_1", IMPROVEMENTANIMATION_ON_EXTRA_1)
-		.value("IMPROVEMENTANIMATION_ON_EXTRA_2", IMPROVEMENTANIMATION_ON_EXTRA_2)
-		.value("IMPROVEMENTANIMATION_ON_EXTRA_3", IMPROVEMENTANIMATION_ON_EXTRA_3)
-		.value("IMPROVEMENTANIMATION_ON_EXTRA_4", IMPROVEMENTANIMATION_ON_EXTRA_4)
-		;
-	python::enum_<EntityEventTypes>("EntityEventTypes")
-		.value( "ENTITY_EVENT_NONE", ENTITY_EVENT_NONE )
-		;
-	python::enum_<AnimationPathTypes>("AnimationPathTypes")
-		.value( "ANIMATIONPATH_NONE", ANIMATIONPATH_NONE )
-		.value( "ANIMATIONPATH_IDLE", ANIMATIONPATH_IDLE )
-		.value( "ANIMATIONPATH_MOVE", ANIMATIONPATH_MOVE )
-		.value( "ANIMATIONPATH_RANDOMIZE_ANIMATION_SET", ANIMATIONPATH_RANDOMIZE_ANIMATION_SET )
-		.value( "ANIMATIONPATH_MELEE_STRIKE", ANIMATIONPATH_MELEE_STRIKE )
-		.value( "ANIMATIONPATH_MELEE_HURT", ANIMATIONPATH_MELEE_HURT )
-		.value( "ANIMATIONPATH_MELEE_DIE", ANIMATIONPATH_MELEE_DIE )
-		.value( "ANIMATIONPATH_MELEE_FORTIFIED", ANIMATIONPATH_MELEE_FORTIFIED )
-		.value( "ANIMATIONPATH_MELEE_DIE_FADE", ANIMATIONPATH_MELEE_DIE_FADE )
-		.value( "ANIMATIONPATH_RANGED_STRIKE", ANIMATIONPATH_RANGED_STRIKE )
-		.value( "ANIMATIONPATH_RANGED_DIE", ANIMATIONPATH_RANGED_DIE )
-		.value( "ANIMATIONPATH_RANGED_FORTIFIED", ANIMATIONPATH_RANGED_FORTIFIED )
-		.value( "ANIMATIONPATH_RANGED_RUNHIT", ANIMATIONPATH_RANGED_RUNHIT )
-		.value( "ANIMATIONPATH_RANGED_RUNDIE", ANIMATIONPATH_RANGED_RUNDIE )
-		.value( "ANIMATIONPATH_RANGED_DIE_FADE", ANIMATIONPATH_RANGED_DIE_FADE )
-		.value( "ANIMATIONPATH_LEADER_COMMAND", ANIMATIONPATH_LEADER_COMMAND )
-		;
-	python::enum_<AnimationCategoryTypes>("AnimationCategoryTypes")
-		.value("ANIMCAT_NONE", ANIMCAT_NONE)
-		;
-	python::enum_<CursorTypes>("CursorTypes")
-		.value("NO_CURSOR", NO_CURSOR)
-		;
-	python::enum_<TradeableItems>("TradeableItems")
-		.value("NO_TRADEABLE_ITEMS", TRADE_ITEM_NONE)
-		.value("TRADE_GOLD", TRADE_GOLD)
-		.value("TRADE_MAPS", TRADE_MAPS)
-		.value("TRADE_OPEN_BORDERS", TRADE_OPEN_BORDERS)
-		.value("TRADE_DEFENSIVE_PACT", TRADE_DEFENSIVE_PACT)
-		.value("TRADE_PERMANENT_ALLIANCE", TRADE_PERMANENT_ALLIANCE)
-		.value("TRADE_PEACE_TREATY", TRADE_PEACE_TREATY)
-
-		.value("NUM_BASIC_ITEMS", NUM_BASIC_ITEMS)
-		.value("TRADE_YIELD", TRADE_YIELD)
-		///TKs Invention Core Mod v 1.0
-		.value("TRADE_IDEAS", TRADE_IDEAS)
-		.value("TRADE_RESEARCH", TRADE_RESEARCH)
-		///TKe
-		.value("TRADE_CITIES", TRADE_CITIES)
-		.value("TRADE_PEACE", TRADE_PEACE)
-		.value("TRADE_WAR", TRADE_WAR)
-		.value("TRADE_EMBARGO", TRADE_EMBARGO)
-		.value("NUM_TRADEABLE_HEADINGS", NUM_TRADEABLE_HEADINGS)
-		.value("NUM_TRADEABLE_ITEMS", NUM_TRADEABLE_ITEMS)
-		;
-	python::enum_<DiploEventTypes>("DiploEventTypes")
-		.value("NO_DIPLOEVENT", NO_DIPLOEVENT)
-		.value("DIPLOEVENT_CONTACT", DIPLOEVENT_CONTACT)
-		.value("DIPLOEVENT_AI_CONTACT", DIPLOEVENT_AI_CONTACT)
-		.value("DIPLOEVENT_FAILED_CONTACT", DIPLOEVENT_FAILED_CONTACT)
-		.value("DIPLOEVENT_GIVE_HELP", DIPLOEVENT_GIVE_HELP)
-		.value("DIPLOEVENT_REFUSED_HELP", DIPLOEVENT_REFUSED_HELP)
-		.value("DIPLOEVENT_ACCEPT_DEMAND", DIPLOEVENT_ACCEPT_DEMAND)
-		.value("DIPLOEVENT_REJECTED_DEMAND", DIPLOEVENT_REJECTED_DEMAND)
-		.value("DIPLOEVENT_DEMAND_WAR", DIPLOEVENT_DEMAND_WAR)
-		.value("DIPLOEVENT_JOIN_WAR", DIPLOEVENT_JOIN_WAR)
-		.value("DIPLOEVENT_NO_JOIN_WAR", DIPLOEVENT_NO_JOIN_WAR)
-		.value("DIPLOEVENT_STOP_TRADING", DIPLOEVENT_STOP_TRADING)
-		.value("DIPLOEVENT_NO_STOP_TRADING", DIPLOEVENT_NO_STOP_TRADING)
-		.value("DIPLOEVENT_ASK_HELP", DIPLOEVENT_ASK_HELP)
-		.value("DIPLOEVENT_MADE_DEMAND", DIPLOEVENT_MADE_DEMAND)
-		.value("DIPLOEVENT_TARGET_CITY", DIPLOEVENT_TARGET_CITY)
-		.value("DIPLOEVENT_ACCEPT_TAX_RATE", DIPLOEVENT_ACCEPT_TAX_RATE)
-		.value("DIPLOEVENT_REFUSE_TAX_RATE", DIPLOEVENT_REFUSE_TAX_RATE)
-		.value("DIPLOEVENT_ACCEPT_KING_GOLD", DIPLOEVENT_ACCEPT_KING_GOLD)
-		.value("DIPLOEVENT_REFUSE_KING_GOLD", DIPLOEVENT_REFUSE_KING_GOLD)
-		.value("DIPLOEVENT_LIVE_AMONG_NATIVES", DIPLOEVENT_LIVE_AMONG_NATIVES)
-		.value("DIPLOEVENT_TRANSPORT_TREASURE", DIPLOEVENT_TRANSPORT_TREASURE)
-		.value("DIPLOEVENT_FOUND_CITY", DIPLOEVENT_FOUND_CITY)
-		.value("DIPLOEVENT_FOUND_CITY_CHECK_NATIVES", DIPLOEVENT_FOUND_CITY_CHECK_NATIVES)
-		///Tks Med
-		.value("DIPLOEVENT_INSULT_FIRSTCONTACT", DIPLOEVENT_INSULT_FIRSTCONTACT)
-		.value("DIPLOEVENT_ACCEPT_VASSAL", DIPLOEVENT_ACCEPT_VASSAL)
-		.value("DIPLOEVENT_DEMAND_VASSAL_LANDS", DIPLOEVENT_DEMAND_VASSAL_LANDS)
-		///Tke
-		.value("NUM_DIPLOEVENT_TYPES", NUM_DIPLOEVENT_TYPES)
-		;
-	python::enum_<DiploCommentTypes>("DiploCommentTypes")
-		.value("NO_DIPLOCOMMENT", NO_DIPLOCOMMENT)
-		;
-	python::enum_<NetContactTypes>("NetContactTypes")
-		.value("NO_NETCONTACT", NO_NETCONTACT)
-		.value("NETCONTACT_INITIAL", NETCONTACT_INITIAL)
-		.value("NETCONTACT_RESPONSE", NETCONTACT_RESPONSE)
-		.value("NETCONTACT_ESTABLISHED", NETCONTACT_ESTABLISHED)
-		.value("NETCONTACT_BUSY", NETCONTACT_BUSY)
-		.value("NUM_NETCONTACT_TYPES", NUM_NETCONTACT_TYPES)
-		;
-	python::enum_<ContactTypes>("ContactTypes")
-		.value("CONTACT_JOIN_WAR", CONTACT_JOIN_WAR)
-		.value("CONTACT_STOP_TRADING", CONTACT_STOP_TRADING)
-		.value("CONTACT_GIVE_HELP", CONTACT_GIVE_HELP)
-		.value("CONTACT_ASK_FOR_HELP", CONTACT_ASK_FOR_HELP)
-		.value("CONTACT_DEMAND_TRIBUTE", CONTACT_DEMAND_TRIBUTE)
-		.value("CONTACT_OPEN_BORDERS", CONTACT_OPEN_BORDERS)
-		.value("CONTACT_DEFENSIVE_PACT", CONTACT_DEFENSIVE_PACT)
-		.value("CONTACT_PERMANENT_ALLIANCE", CONTACT_PERMANENT_ALLIANCE)
-		.value("CONTACT_PEACE_TREATY", CONTACT_PEACE_TREATY)
-		.value("CONTACT_TRADE_MAP", CONTACT_TRADE_MAP)
-		.value("CONTACT_YIELD_GIFT", CONTACT_YIELD_GIFT)
-		///TKs Invention Core Mod v 1.0
-		.value("CONTACT_TRADE_IDEAS", CONTACT_TRADE_IDEAS)
-		.value("CONTACT_TRADE_RESEARCH", CONTACT_TRADE_RESEARCH)
-		///TKe
-		.value("NUM_CONTACT_TYPES", NUM_CONTACT_TYPES)
-		;
-	python::enum_<MemoryTypes>("MemoryTypes")
-		.value("MEMORY_DECLARED_WAR", MEMORY_DECLARED_WAR)
-		.value("MEMORY_DECLARED_WAR_ON_FRIEND", MEMORY_DECLARED_WAR_ON_FRIEND)
-		.value("MEMORY_HIRED_WAR_ALLY", MEMORY_HIRED_WAR_ALLY)
-		.value("MEMORY_RAZED_CITY", MEMORY_RAZED_CITY)
-		.value("MEMORY_GIVE_HELP", MEMORY_GIVE_HELP)
-		.value("MEMORY_REFUSED_HELP", MEMORY_REFUSED_HELP)
-		.value("MEMORY_ACCEPT_DEMAND", MEMORY_ACCEPT_DEMAND)
-		.value("MEMORY_REJECTED_DEMAND", MEMORY_REJECTED_DEMAND)
-		.value("MEMORY_ACCEPTED_JOIN_WAR", MEMORY_ACCEPTED_JOIN_WAR)
-		.value("MEMORY_DENIED_JOIN_WAR", MEMORY_DENIED_JOIN_WAR)
-		.value("MEMORY_ACCEPTED_STOP_TRADING", MEMORY_ACCEPTED_STOP_TRADING)
-		.value("MEMORY_DENIED_STOP_TRADING", MEMORY_DENIED_STOP_TRADING)
-		.value("MEMORY_STOPPED_TRADING", MEMORY_STOPPED_TRADING)
-		.value("MEMORY_STOPPED_TRADING_RECENT", MEMORY_STOPPED_TRADING_RECENT)
-		.value("MEMORY_HIRED_TRADE_EMBARGO", MEMORY_HIRED_TRADE_EMBARGO)
-		.value("MEMORY_MADE_DEMAND", MEMORY_MADE_DEMAND)
-		.value("MEMORY_MADE_DEMAND_RECENT", MEMORY_MADE_DEMAND_RECENT)
-		.value("MEMORY_CANCELLED_OPEN_BORDERS", MEMORY_CANCELLED_OPEN_BORDERS)
-		.value("MEMORY_EVENT_GOOD_TO_US", MEMORY_EVENT_GOOD_TO_US)
-		.value("MEMORY_EVENT_BAD_TO_US", MEMORY_EVENT_BAD_TO_US)
-		.value("MEMORY_LIBERATED_CITIES", MEMORY_LIBERATED_CITIES)
-		.value("MEMORY_MISSIONARY_FAIL", MEMORY_MISSIONARY_FAIL)
-		///Tks Med
-		.value("MEMORY_INSULTED", MEMORY_INSULTED)
-		.value("MEMORY_MADE_VASSAL_DEMAND", MEMORY_MADE_VASSAL_DEMAND)
-		///Tke
-		.value("NUM_MEMORY_TYPES", NUM_MEMORY_TYPES)
-		;
-	python::enum_<AttitudeTypes>("AttitudeTypes")
-		.value("NO_ATTITUDE", NO_ATTITUDE)
-		.value("ATTITUDE_FURIOUS", ATTITUDE_FURIOUS)
-		.value("ATTITUDE_ANNOYED", ATTITUDE_ANNOYED)
-		.value("ATTITUDE_CAUTIOUS", ATTITUDE_CAUTIOUS)
-		.value("ATTITUDE_PLEASED", ATTITUDE_PLEASED)
-		.value("ATTITUDE_FRIENDLY", ATTITUDE_FRIENDLY)
-		.value("NUM_ATTITUDE_TYPES", NUM_ATTITUDE_TYPES)
-		;
-	python::enum_<LeaderheadAction>("LeaderheadAction")
-		.value( "NO_LEADERANIM", NO_LEADERANIM )
-		.value( "LEADERANIM_GREETING", LEADERANIM_GREETING )
-		.value( "LEADERANIM_FRIENDLY", LEADERANIM_FRIENDLY )
-		.value( "LEADERANIM_PLEASED", LEADERANIM_PLEASED )
-		.value( "LEADERANIM_CAUTIOUS", LEADERANIM_CAUTIOUS )
-		.value( "LEADERANIM_ANNOYED", LEADERANIM_ANNOYED )
-		.value( "LEADERANIM_FURIOUS", LEADERANIM_FURIOUS )
-		.value( "LEADERANIM_DISAGREE", LEADERANIM_DISAGREE )
-		.value( "LEADERANIM_AGREE", LEADERANIM_AGREE )
-		.value( "LEADERANIM_OFFER_PINKY", LEADERANIM_OFFER_PINKY )
-		.value( "LEADERANIM_PINKY_IDLE", LEADERANIM_PINKY_IDLE )
-		.value( "LEADERANIM_PINKY_ACCEPT", LEADERANIM_PINKY_ACCEPT )
-		.value( "LEADERANIM_PINKY_REJECT", LEADERANIM_PINKY_REJECT )
-		.value( "NUM_LEADERANIM_TYPES", NUM_LEADERANIM_TYPES )
-		;
-	python::enum_<DiplomacyPowerTypes>("DiplomacyPowerTypes")
-		.value("NO_DIPLOMACYPOWER", NO_DIPLOMACYPOWER)
-		.value("DIPLOMACYPOWER_WEAKER", DIPLOMACYPOWER_WEAKER)
-		.value("DIPLOMACYPOWER_EQUAL", DIPLOMACYPOWER_EQUAL)
-		.value("DIPLOMACYPOWER_STRONGER", DIPLOMACYPOWER_STRONGER)
-		.value("NUM_DIPLOMACYPOWER_TYPES", NUM_DIPLOMACYPOWER_TYPES)
-		;
-	python::enum_<FeatTypes>("FeatTypes")
-		.value("FEAT_TREASURE", FEAT_TREASURE)
-		.value("FEAT_TREASURE_IN_PORT", FEAT_TREASURE_IN_PORT)
-		.value("FEAT_CITY_MISSING_YIELD", FEAT_CITY_MISSING_YIELD)
-		.value("FEAT_CITY_NO_FOOD", FEAT_CITY_NO_FOOD)
-		.value("FEAT_CITY_INLAND", FEAT_CITY_INLAND)
-		.value("FEAT_EUROPE_SHIPS", FEAT_EUROPE_SHIPS)
-		.value("FEAT_GOTO_EUROPE", FEAT_GOTO_EUROPE)
-		.value("FEAT_TALK_NATIVES", FEAT_TALK_NATIVES)
-		.value("FEAT_CITY_SCREEN", FEAT_CITY_SCREEN)
-		.value("FEAT_PAD", FEAT_PAD)
-		.value("NUM_FEAT_TYPES", NUM_FEAT_TYPES)
-		;
-	python::enum_<SaveGameTypes>("SaveGameTypes")
-		.value("SAVEGAME_NONE", SAVEGAME_NONE)
-		.value("SAVEGAME_AUTO", SAVEGAME_AUTO)
-		.value("SAVEGAME_RECOVERY", SAVEGAME_RECOVERY)
-		.value("SAVEGAME_QUICK", SAVEGAME_QUICK)
-		.value("SAVEGAME_NORMAL", SAVEGAME_NORMAL)
-		.value("SAVEGAME_GROUP", SAVEGAME_GROUP)
-		.value("SAVEGAME_DROP_QUIT", SAVEGAME_DROP_QUIT)
-		.value("SAVEGAME_DROP_CONTINUE", SAVEGAME_DROP_CONTINUE)
-		.value("SAVEGAME_PBEM", SAVEGAME_PBEM)
-		.value("SAVEGAME_REPLAY", SAVEGAME_REPLAY)
-		.value("NUM_SAVEGAME_TYPES", NUM_SAVEGAME_TYPES)
-		;
-	python::enum_<GameType>("GameType")
-		.value("GAME_NONE", GAME_NONE)
-		.value("GAME_SP_NEW", GAME_SP_NEW)
-		.value("GAME_SP_SCENARIO", GAME_SP_SCENARIO)
-		.value("GAME_SP_LOAD", GAME_SP_LOAD)
-		.value("GAME_MP_NEW", GAME_MP_NEW)
-		.value("GAME_MP_SCENARIO", GAME_MP_SCENARIO)
-		.value("GAME_MP_LOAD", GAME_MP_LOAD)
-		.value("GAME_HOTSEAT_NEW", GAME_HOTSEAT_NEW)
-		.value("GAME_HOTSEAT_SCENARIO", GAME_HOTSEAT_SCENARIO)
-		.value("GAME_HOTSEAT_LOAD", GAME_HOTSEAT_LOAD)
-		.value("GAME_PBEM_NEW", GAME_PBEM_NEW)
-		.value("GAME_PBEM_SCENARIO", GAME_PBEM_SCENARIO)
-		.value("GAME_PBEM_LOAD", GAME_PBEM_LOAD)
-		.value("GAME_REPLAY", GAME_REPLAY)
-		.value("NUM_GAMETYPES", NUM_GAMETYPES)
-		;
-	python::enum_<GameMode>("GameMode")
-		.value("NO_GAMEMODE", NO_GAMEMODE)
-		.value("GAMEMODE_NORMAL", GAMEMODE_NORMAL)
-		.value("GAMEMODE_PITBOSS", GAMEMODE_PITBOSS)
-		.value("NUM_GAMEMODES", NUM_GAMEMODES)
-		;
-	python::enum_<InterfaceVisibility>("InterfaceVisibility")
-		.value("INTERFACE_SHOW", INTERFACE_SHOW)
-		.value("INTERFACE_HIDE", INTERFACE_HIDE)
-		.value("INTERFACE_HIDE_ALL", INTERFACE_HIDE_ALL)
-		.value("INTERFACE_MINIMAP_ONLY", INTERFACE_MINIMAP_ONLY)
-		.value("INTERFACE_ADVANCED_START", INTERFACE_ADVANCED_START)
-		;
-	python::enum_<GenericButtonSizes>("GenericButtonSizes")
-		.value("BUTTON_SIZE_46", BUTTON_SIZE_46)
-		.value("BUTTON_SIZE_32", BUTTON_SIZE_32)
-		.value("BUTTON_SIZE_24", BUTTON_SIZE_24)
-		.value("BUTTON_SIZE_16", BUTTON_SIZE_16)
-		.value("BUTTON_SIZE_CUSTOM", BUTTON_SIZE_CUSTOM)
-		;
-	python::enum_<WorldBuilderPopupTypes>("WorldBuilderPopupTypes")
-		.value("WBPOPUP_NONE", WBPOPUP_NONE)
-		.value("WBPOPUP_START", WBPOPUP_START)
-		.value("WBPOPUP_CITY", WBPOPUP_CITY)
-		.value("WBPOPUP_UNIT", WBPOPUP_UNIT)
-		.value("WBPOPUP_PLAYER", WBPOPUP_PLAYER)
-		.value("WBPOPUP_PLOT", WBPOPUP_PLOT)
-		.value("WBPOPUP_TERRAIN", WBPOPUP_TERRAIN)
-		.value("WBPOPUP_FEATURE", WBPOPUP_FEATURE)
-		.value("WBPOPUP_IMPROVEMENT", WBPOPUP_IMPROVEMENT)
-		.value("WBPOPUP_GAME", WBPOPUP_GAME)
-		.value("NUM_WBPOPUP", NUM_WBPOPUP)
-		;
-	python::enum_<EventType>("EventType")
-		.value("EVT_LBUTTONDOWN", EVT_LBUTTONDOWN)
-		.value("EVT_LBUTTONDBLCLICK", EVT_LBUTTONDBLCLICK)
-		.value("EVT_RBUTTONDOWN", EVT_RBUTTONDOWN)
-		.value("EVT_BACK", EVT_BACK)
-		.value("EVT_FORWARD", EVT_FORWARD)
-		.value("EVT_KEYDOWN", EVT_KEYDOWN)
-		.value("EVT_KEYUP", EVT_KEYUP)
-		;
-	python::enum_<LoadType>("LoadType")
-		.value("LOAD_NORMAL", LOAD_NORMAL)
-		.value("LOAD_INIT", LOAD_INIT)
-		.value("LOAD_SETUP", LOAD_SETUP)
-		.value("LOAD_GAMETYPE", LOAD_GAMETYPE)
-		.value("LOAD_REPLAY", LOAD_REPLAY)
-		;
-	python::enum_<FontTypes>("FontTypes")
-		.value("TITLE_FONT", TITLE_FONT)
-		.value("GAME_FONT", GAME_FONT)
-		.value("SMALL_FONT", SMALL_FONT)
-		.value("MENU_FONT", MENU_FONT)
-		.value("MENU_HIGHLIGHT_FONT", MENU_HIGHLIGHT_FONT)
-		;
-	python::enum_<PanelStyles>("PanelStyles")
-		.value("PANEL_STYLE_STANDARD",PANEL_STYLE_STANDARD)
-		.value("PANEL_STYLE_SOLID",PANEL_STYLE_SOLID)
-		.value("PANEL_STYLE_EMPTY",PANEL_STYLE_EMPTY)
-		.value("PANEL_STYLE_FLAT",PANEL_STYLE_FLAT)
-		.value("PANEL_STYLE_IN",PANEL_STYLE_IN)
-		.value("PANEL_STYLE_OUT",PANEL_STYLE_OUT)
-		.value("PANEL_STYLE_EXTERNAL",PANEL_STYLE_EXTERNAL)
-		.value("PANEL_STYLE_DEFAULT",PANEL_STYLE_DEFAULT)
-		.value("PANEL_STYLE_CIVILPEDIA",PANEL_STYLE_CIVILPEDIA)
-		.value("PANEL_STYLE_STONE",PANEL_STYLE_STONE)
-		.value("PANEL_STYLE_BLUELARGE",PANEL_STYLE_BLUELARGE)
-		.value("PANEL_STYLE_UNITSTAT",PANEL_STYLE_UNITSTAT)
-		.value("PANEL_STYLE_BLUE50",PANEL_STYLE_BLUE50)
-		.value("PANEL_STYLE_TOPBAR",PANEL_STYLE_TOPBAR)
-		.value("PANEL_STYLE_BOTTOMBAR",PANEL_STYLE_BOTTOMBAR)
-		.value("PANEL_STYLE_TECH",PANEL_STYLE_TECH)
-		.value("PANEL_STYLE_GAMEHUD_LEFT",PANEL_STYLE_GAMEHUD_LEFT)
-		.value("PANEL_STYLE_GAMEHUD_RIGHT",PANEL_STYLE_GAMEHUD_RIGHT)
-		.value("PANEL_STYLE_GAMEHUD_CENTER",PANEL_STYLE_GAMEHUD_CENTER)
-		.value("PANEL_STYLE_GAMEHUD_STATS",PANEL_STYLE_GAMEHUD_STATS)
-		.value("PANEL_STYLE_GAME_MAP",PANEL_STYLE_GAME_MAP)
-		.value("PANEL_STYLE_GAME_TOPBAR",PANEL_STYLE_GAME_TOPBAR)
-		.value("PANEL_STYLE_HUD_HELP", PANEL_STYLE_HUD_HELP)
-		.value("PANEL_STYLE_CITY_LEFT",PANEL_STYLE_CITY_LEFT)
-		.value("PANEL_STYLE_CITY_RIGHT",PANEL_STYLE_CITY_RIGHT)
-		.value("PANEL_STYLE_CITY_TOP",PANEL_STYLE_CITY_TOP)
-		.value("PANEL_STYLE_CITY_TANSHADE",PANEL_STYLE_CITY_TANSHADE)
-		.value("PANEL_STYLE_CITY_INFO",PANEL_STYLE_CITY_INFO)
-		.value("PANEL_STYLE_CITY_TANTL",PANEL_STYLE_CITY_TANTL)
-		.value("PANEL_STYLE_CITY_TANTR",PANEL_STYLE_CITY_TANTR)
-		.value("PANEL_STYLE_CITY_COLUMNL",PANEL_STYLE_CITY_COLUMNL)
-		.value("PANEL_STYLE_CITY_COLUMNC",PANEL_STYLE_CITY_COLUMNC)
-		.value("PANEL_STYLE_CITY_COLUMNR",PANEL_STYLE_CITY_COLUMNR)
-		.value("PANEL_STYLE_CITY_TITLE",PANEL_STYLE_CITY_TITLE)
-		.value("PANEL_STYLE_DAWN",PANEL_STYLE_DAWN)
-		.value("PANEL_STYLE_DAWNTOP",PANEL_STYLE_DAWNTOP)
-		.value("PANEL_STYLE_DAWNBOTTOM",PANEL_STYLE_DAWNBOTTOM)
-		.value("PANEL_STYLE_MAIN",PANEL_STYLE_MAIN)
-		.value("PANEL_STYLE_MAIN_BLACK25",PANEL_STYLE_MAIN_BLACK25)
-		.value("PANEL_STYLE_MAIN_BLACK50",PANEL_STYLE_MAIN_BLACK50)
-		.value("PANEL_STYLE_MAIN_WHITE",PANEL_STYLE_MAIN_WHITE)
-		.value("PANEL_STYLE_MAIN_WHITETAB",PANEL_STYLE_MAIN_WHITETAB)
-		.value("PANEL_STYLE_MAIN_TAN",PANEL_STYLE_MAIN_TAN)
-		.value("PANEL_STYLE_MAIN_TAN15",PANEL_STYLE_MAIN_TAN15)
-		.value("PANEL_STYLE_MAIN_TANL",PANEL_STYLE_MAIN_TANL)
-		.value("PANEL_STYLE_MAIN_TANR",PANEL_STYLE_MAIN_TANR)
-		.value("PANEL_STYLE_MAIN_TANT",PANEL_STYLE_MAIN_TANT)
-		.value("PANEL_STYLE_MAIN_TANB",PANEL_STYLE_MAIN_TANB)
-		.value("PANEL_STYLE_MAIN_BOTTOMBAR",PANEL_STYLE_MAIN_BOTTOMBAR)
-		.value("PANEL_STYLE_MAIN_SELECT",PANEL_STYLE_MAIN_SELECT)
-		;
-	python::enum_<ButtonStyles>("ButtonStyles")
-		.value("BUTTON_STYLE_STANDARD", BUTTON_STYLE_STANDARD)
-		.value("BUTTON_STYLE_ETCHED", BUTTON_STYLE_ETCHED)
-		.value("BUTTON_STYLE_FLAT", BUTTON_STYLE_FLAT)
-		.value("BUTTON_STYLE_IMAGE", BUTTON_STYLE_IMAGE)
-		.value("BUTTON_STYLE_LABEL", BUTTON_STYLE_LABEL)
-		.value("BUTTON_STYLE_LINK", BUTTON_STYLE_LINK)
-		.value("BUTTON_STYLE_SQUARE", BUTTON_STYLE_SQUARE)
-		.value("BUTTON_STYLE_TOOL", BUTTON_STYLE_TOOL)
-		.value("BUTTON_STYLE_DEFAULT", BUTTON_STYLE_DEFAULT)
-		.value("BUTTON_STYLE_CIRCLE", BUTTON_STYLE_CIRCLE)
-		.value("BUTTON_STYLE_CITY_B01", BUTTON_STYLE_CITY_B01)
-		.value("BUTTON_STYLE_CITY_B02TL", BUTTON_STYLE_CITY_B02TL)
-		.value("BUTTON_STYLE_CITY_B02TR", BUTTON_STYLE_CITY_B02TR)
-		.value("BUTTON_STYLE_CITY_B02BL", BUTTON_STYLE_CITY_B02BL)
-		.value("BUTTON_STYLE_CITY_B02BR", BUTTON_STYLE_CITY_B02BR)
-		.value("BUTTON_STYLE_CITY_B03TL", BUTTON_STYLE_CITY_B03TL)
-		.value("BUTTON_STYLE_CITY_B03TC", BUTTON_STYLE_CITY_B03TC)
-		.value("BUTTON_STYLE_CITY_B03TR", BUTTON_STYLE_CITY_B03TR)
-		.value("BUTTON_STYLE_CITY_B03BL", BUTTON_STYLE_CITY_B03BL)
-		.value("BUTTON_STYLE_CITY_B03BC", BUTTON_STYLE_CITY_B03BC)
-		.value("BUTTON_STYLE_CITY_B03BR", BUTTON_STYLE_CITY_B03BR)
-		.value("BUTTON_STYLE_CITY_FLAT", BUTTON_STYLE_CITY_FLAT)
-		.value("BUTTON_STYLE_CITY_PLUS", BUTTON_STYLE_CITY_PLUS)
-		.value("BUTTON_STYLE_CITY_MINUS", BUTTON_STYLE_CITY_MINUS)
-		.value("BUTTON_STYLE_ARROW_LEFT", BUTTON_STYLE_ARROW_LEFT)
-		.value("BUTTON_STYLE_ARROW_RIGHT", BUTTON_STYLE_ARROW_RIGHT)
-		.value("BUTTON_STYLE_ARROW_UP", BUTTON_STYLE_ARROW_UP)
-		.value("BUTTON_STYLE_ARROW_DOWN", BUTTON_STYLE_ARROW_DOWN)
-		;
-	python::enum_<ImageShapes>("ImageShapes")
-		.value("IMAGE_SHAPE_RECTANGLE", IMAGE_SHAPE_RECTANGLE)
-		.value("IMAGE_SHAPE_ELLIPSE", IMAGE_SHAPE_ELLIPSE)
-		.value("IMAGE_SHAPE_PARABOLA_TOP", IMAGE_SHAPE_PARABOLA_TOP)
-		;
-	python::enum_<TableStyles>("TableStyles")
-		.value("TABLE_STYLE_STANDARD", TABLE_STYLE_STANDARD)
-		.value("TABLE_STYLE_EMPTY", TABLE_STYLE_EMPTY)
-		.value("TABLE_STYLE_ALTEMPTY", TABLE_STYLE_ALTEMPTY)
-		.value("TABLE_STYLE_CITY", TABLE_STYLE_CITY)
-		.value("TABLE_STYLE_EMPTYSELECTINACTIVE", TABLE_STYLE_EMPTYSELECTINACTIVE)
-		.value("TABLE_STYLE_ALTDEFAULT", TABLE_STYLE_ALTDEFAULT)
-		.value("TABLE_STYLE_STAGINGROOM", TABLE_STYLE_STAGINGROOM)
-		;
-	python::enum_<EventContextTypes>("EventContextTypes")
-		.value("NO_EVENTCONTEXT", NO_EVENTCONTEXT)
-		.value("EVENTCONTEXT_SELF", EVENTCONTEXT_SELF)
-		.value("EVENTCONTEXT_ALL", EVENTCONTEXT_ALL)
-		;
-	python::enum_<TabGroupTypes>("TabGroupTypes")
-		.value("NO_TABGROUP", NO_TABGROUP)
-		.value("TABGROUP_GAME", TABGROUP_GAME)
-		.value("TABGROUP_INPUT", TABGROUP_INPUT)
-		.value("TABGROUP_GRAPHICS", TABGROUP_GRAPHICS)
-		.value("TABGROUP_AUDIO", TABGROUP_AUDIO)
-		.value("TABGROUP_CLOCK", TABGROUP_CLOCK)
-		.value("NUM_TABGROUPS", NUM_TABGROUPS)
-		;
-	python::enum_<ReplayMessageTypes>("ReplayMessageTypes")
-		.value("NO_REPLAY_MESSAGE", NO_REPLAY_MESSAGE)
-		.value("REPLAY_MESSAGE_MAJOR_EVENT", REPLAY_MESSAGE_MAJOR_EVENT)
-		.value("REPLAY_MESSAGE_CITY_FOUNDED", REPLAY_MESSAGE_CITY_FOUNDED)
-		.value("REPLAY_MESSAGE_PLOT_OWNER_CHANGE", REPLAY_MESSAGE_PLOT_OWNER_CHANGE)
-		.value("NUM_REPLAY_MESSAGE_TYPES", NUM_REPLAY_MESSAGE_TYPES)
-		;
-	python::enum_<AudioTag>("AudioTag")
-		.value("AUDIOTAG_NONE", AUDIOTAG_NONE)
-		.value("AUDIOTAG_SOUNDID", AUDIOTAG_SOUNDID)
-		.value("AUDIOTAG_CONTEXTID", AUDIOTAG_CONTEXTID)
-		.value("AUDIOTAG_SOUNDTYPE", AUDIOTAG_SOUNDTYPE)
-		.value("AUDIOTAG_2DSCRIPT", AUDIOTAG_2DSCRIPT)
-		.value("AUDIOTAG_3DSCRIPT", AUDIOTAG_3DSCRIPT)
-		.value("AUDIOTAG_SOUNDSCAPE", AUDIOTAG_SOUNDSCAPE)
-		.value("AUDIOTAG_POSITION", AUDIOTAG_POSITION)
-		.value("AUDIOTAG_SCRIPTTYPE", AUDIOTAG_SCRIPTTYPE)
-		.value("AUDIOTAG_LOADTYPE", AUDIOTAG_LOADTYPE)
-		.value("AUDIOTAG_COUNT", AUDIOTAG_COUNT)
-		;
-	python::enum_<CivilopediaPageTypes>("CivilopediaPageTypes")
-		.value("NO_CIVILOPEDIA_PAGE", NO_CIVILOPEDIA_PAGE)
-		.value("CIVILOPEDIA_PAGE_UNIT", CIVILOPEDIA_PAGE_UNIT)
-		.value("CIVILOPEDIA_PAGE_PROFESSION", CIVILOPEDIA_PAGE_PROFESSION)
-		.value("CIVILOPEDIA_PAGE_BUILDING", CIVILOPEDIA_PAGE_BUILDING)
-		.value("CIVILOPEDIA_PAGE_FATHER", CIVILOPEDIA_PAGE_FATHER)
-		.value("CIVILOPEDIA_PAGE_BONUS", CIVILOPEDIA_PAGE_BONUS)
-		.value("CIVILOPEDIA_PAGE_IMPROVEMENT", CIVILOPEDIA_PAGE_IMPROVEMENT)
-		.value("CIVILOPEDIA_PAGE_PROMOTION", CIVILOPEDIA_PAGE_PROMOTION)
-		.value("CIVILOPEDIA_PAGE_CIV", CIVILOPEDIA_PAGE_CIV)
-		.value("CIVILOPEDIA_PAGE_LEADER", CIVILOPEDIA_PAGE_LEADER)
-		.value("CIVILOPEDIA_PAGE_CIVIC", CIVILOPEDIA_PAGE_CIVIC)
-		.value("CIVILOPEDIA_PAGE_CONCEPT", CIVILOPEDIA_PAGE_CONCEPT)
-		.value("CIVILOPEDIA_PAGE_TERRAIN", CIVILOPEDIA_PAGE_TERRAIN)
-		.value("CIVILOPEDIA_PAGE_YIELDS", CIVILOPEDIA_PAGE_YIELDS)
-		.value("CIVILOPEDIA_PAGE_FEATURE", CIVILOPEDIA_PAGE_FEATURE)
-		.value("CIVILOPEDIA_PAGE_HINTS", CIVILOPEDIA_PAGE_HINTS)
-		///TKs Invention Core Mod v 1.0
-		.value("CIVILOPEDIA_PAGE_TECHNOLOGY", CIVILOPEDIA_PAGE_TECHNOLOGY)
-		///TKe
-		.value("NUM_CIVILOPEDIA_PAGE_TYPES", NUM_CIVILOPEDIA_PAGE_TYPES)
-		;
-	python::enum_<ActionSubTypes>("ActionSubTypes")
-		.value("NO_ACTIONSUBTYPE", NO_ACTIONSUBTYPE)
-		.value("ACTIONSUBTYPE_INTERFACEMODE", ACTIONSUBTYPE_INTERFACEMODE)
-		.value("ACTIONSUBTYPE_COMMAND", ACTIONSUBTYPE_COMMAND)
-		.value("ACTIONSUBTYPE_BUILD", ACTIONSUBTYPE_BUILD)
-		.value("ACTIONSUBTYPE_PROMOTION", ACTIONSUBTYPE_PROMOTION)
-		.value("ACTIONSUBTYPE_UNIT", ACTIONSUBTYPE_UNIT)
-		.value("ACTIONSUBTYPE_CONTROL", ACTIONSUBTYPE_CONTROL)
-		.value("ACTIONSUBTYPE_AUTOMATE", ACTIONSUBTYPE_AUTOMATE)
-		.value("ACTIONSUBTYPE_MISSION", ACTIONSUBTYPE_MISSION)
-		.value("NUM_ACTIONSUBTYPES", NUM_ACTIONSUBTYPES)
-		;
-	python::enum_<GameMessageTypes>("GameMessageTypes")
-		.value("GAMEMESSAGE_NETWORK_READY", GAMEMESSAGE_NETWORK_READY)
-		.value("GAMEMESSAGE_SAVE_GAME_FLAG", GAMEMESSAGE_SAVE_GAME_FLAG)
-		.value("GAMEMESSAGE_SAVE_FLAG_ACK", GAMEMESSAGE_SAVE_FLAG_ACK)
-		.value("GAMEMESSAGE_VERIFY_VERSION", GAMEMESSAGE_VERIFY_VERSION)
-		.value("GAMEMESSAGE_VERSION_NACK", GAMEMESSAGE_VERSION_NACK)
-		.value("GAMEMESSAGE_VERSION_WARNING", GAMEMESSAGE_VERSION_WARNING)
-		.value("GAMEMESSAGE_GAME_TYPE", GAMEMESSAGE_GAME_TYPE)
-		.value("GAMEMESSAGE_ID_ASSIGNMENT", GAMEMESSAGE_ID_ASSIGNMENT)
-		.value("GAMEMESSAGE_FILE_INFO", GAMEMESSAGE_FILE_INFO)
-		.value("GAMEMESSAGE_PICK_YOUR_CIV", GAMEMESSAGE_PICK_YOUR_CIV)
-		.value("GAMEMESSAGE_CIV_CHOICE", GAMEMESSAGE_CIV_CHOICE)
-		.value("GAMEMESSAGE_CONFIRM_CIV_CLAIM", GAMEMESSAGE_CONFIRM_CIV_CLAIM)
-		.value("GAMEMESSAGE_CLAIM_INFO", GAMEMESSAGE_CLAIM_INFO)
-		.value("GAMEMESSAGE_CIV_CHOICE_ACK", GAMEMESSAGE_CIV_CHOICE_ACK)
-		.value("GAMEMESSAGE_CIV_CHOICE_NACK", GAMEMESSAGE_CIV_CHOICE_NACK)
-		.value("GAMEMESSAGE_CIV_CHOSEN", GAMEMESSAGE_CIV_CHOSEN)
-		.value("GAMEMESSAGE_INTERIM_NOTICE", GAMEMESSAGE_INTERIM_NOTICE)
-		.value("GAMEMESSAGE_INIT_INFO", GAMEMESSAGE_INIT_INFO)
-		.value("GAMEMESSAGE_MAPSCRIPT_CHECK", GAMEMESSAGE_MAPSCRIPT_CHECK)
-		.value("GAMEMESSAGE_MAPSCRIPT_ACK", GAMEMESSAGE_MAPSCRIPT_ACK)
-		.value("GAMEMESSAGE_LOAD_GAME", GAMEMESSAGE_LOAD_GAME)
-		.value("GAMEMESSAGE_PLAYER_ID", GAMEMESSAGE_PLAYER_ID)
-		.value("GAMEMESSAGE_SLOT_REASSIGNMENT", GAMEMESSAGE_SLOT_REASSIGNMENT)
-		.value("GAMEMESSAGE_PLAYER_INFO", GAMEMESSAGE_PLAYER_INFO)
-		.value("GAMEMESSAGE_GAME_INFO", GAMEMESSAGE_GAME_INFO)
-		.value("GAMEMESSAGE_REASSIGN_PLAYER", GAMEMESSAGE_REASSIGN_PLAYER)
-		.value("GAMEMESSAGE_PITBOSS_INFO", GAMEMESSAGE_PITBOSS_INFO)
-		.value("GAMEMESSAGE_LAUNCHING_INFO", GAMEMESSAGE_LAUNCHING_INFO)
-		.value("GAMEMESSAGE_INIT_GAME", GAMEMESSAGE_INIT_GAME)
-		.value("GAMEMESSAGE_INIT_PLAYERS", GAMEMESSAGE_INIT_PLAYERS)
-		.value("GAMEMESSAGE_AUTH_REQUEST", GAMEMESSAGE_AUTH_REQUEST)
-		.value("GAMEMESSAGE_AUTH_RESPONSE", GAMEMESSAGE_AUTH_RESPONSE)
-		.value("GAMEMESSAGE_SYNCH_START", GAMEMESSAGE_SYNCH_START)
-		.value("GAMEMESSAGE_EXTENDED_GAME", GAMEMESSAGE_EXTENDED_GAME)
-		.value("GAMEMESSAGE_JOIN_GROUP", GAMEMESSAGE_JOIN_GROUP)
-		.value("GAMEMESSAGE_PUSH_MISSION", GAMEMESSAGE_PUSH_MISSION)
-		.value("GAMEMESSAGE_AUTO_MISSION", GAMEMESSAGE_AUTO_MISSION)
-		.value("GAMEMESSAGE_DO_COMMAND", GAMEMESSAGE_DO_COMMAND)
-		.value("GAMEMESSAGE_PUSH_ORDER", GAMEMESSAGE_PUSH_ORDER)
-		.value("GAMEMESSAGE_POP_ORDER", GAMEMESSAGE_POP_ORDER)
-		.value("GAMEMESSAGE_DO_TASK", GAMEMESSAGE_DO_TASK)
-		.value("GAMEMESSAGE_CHAT", GAMEMESSAGE_CHAT)
-		.value("GAMEMESSAGE_PING", GAMEMESSAGE_PING)
-		.value("GAMEMESSAGE_SIGN", GAMEMESSAGE_SIGN)
-		.value("GAMEMESSAGE_LINE_ENTITY", GAMEMESSAGE_LINE_ENTITY)
-		.value("GAMEMESSAGE_SIGN_DELETE", GAMEMESSAGE_SIGN_DELETE)
-		.value("GAMEMESSAGE_LINE_ENTITY_DELETE", GAMEMESSAGE_LINE_ENTITY_DELETE)
-		.value("GAMEMESSAGE_LINE_GROUP_DELETE", GAMEMESSAGE_LINE_GROUP_DELETE)
-		.value("GAMEMESSAGE_PAUSE", GAMEMESSAGE_PAUSE)
-		.value("GAMEMESSAGE_MP_KICK", GAMEMESSAGE_MP_KICK)
-		.value("GAMEMESSAGE_MP_RETIRE", GAMEMESSAGE_MP_RETIRE)
-		.value("GAMEMESSAGE_CLOSE_CONNECTION", GAMEMESSAGE_CLOSE_CONNECTION)
-		.value("GAMEMESSAGE_NEVER_JOINED", GAMEMESSAGE_NEVER_JOINED)
-		.value("GAMEMESSAGE_MP_DROP_INIT", GAMEMESSAGE_MP_DROP_INIT)
-		.value("GAMEMESSAGE_MP_DROP_VOTE", GAMEMESSAGE_MP_DROP_VOTE)
-		.value("GAMEMESSAGE_MP_DROP_UPDATE", GAMEMESSAGE_MP_DROP_UPDATE)
-		.value("GAMEMESSAGE_MP_DROP_RESULT", GAMEMESSAGE_MP_DROP_RESULT)
-		.value("GAMEMESSAGE_MP_DROP_SAVE", GAMEMESSAGE_MP_DROP_SAVE)
-		.value("GAMEMESSAGE_TOGGLE_TRADE", GAMEMESSAGE_TOGGLE_TRADE)
-		.value("GAMEMESSAGE_IMPLEMENT_OFFER", GAMEMESSAGE_IMPLEMENT_OFFER)
-		.value("GAMEMESSAGE_CHANGE_WAR", GAMEMESSAGE_CHANGE_WAR)
-		.value("GAMEMESSAGE_APPLY_EVENT", GAMEMESSAGE_APPLY_EVENT)
-		.value("GAMEMESSAGE_CONTACT_CIV", GAMEMESSAGE_CONTACT_CIV)
-		.value("GAMEMESSAGE_DIPLO_CHAT", GAMEMESSAGE_DIPLO_CHAT)
-		.value("GAMEMESSAGE_SEND_OFFER", GAMEMESSAGE_SEND_OFFER)
-		.value("GAMEMESSAGE_DIPLO_EVENT", GAMEMESSAGE_DIPLO_EVENT)
-		.value("GAMEMESSAGE_RENEGOTIATE", GAMEMESSAGE_RENEGOTIATE)
-		.value("GAMEMESSAGE_RENEGOTIATE_ITEM", GAMEMESSAGE_RENEGOTIATE_ITEM)
-		.value("GAMEMESSAGE_EXIT_TRADE", GAMEMESSAGE_EXIT_TRADE)
-		.value("GAMEMESSAGE_KILL_DEAL", GAMEMESSAGE_KILL_DEAL)
-		.value("GAMEMESSAGE_SAVE_GAME", GAMEMESSAGE_SAVE_GAME)
-		.value("GAMEMESSAGE_UPDATE_CIVICS", GAMEMESSAGE_UPDATE_CIVICS)
-		.value("GAMEMESSAGE_CLEAR_TABLE", GAMEMESSAGE_CLEAR_TABLE)
-		.value("GAMEMESSAGE_POPUP_PROCESSED", GAMEMESSAGE_POPUP_PROCESSED)
-		.value("GAMEMESSAGE_DIPLOMACY_PROCESSED", GAMEMESSAGE_DIPLOMACY_PROCESSED)
-		.value("GAMEMESSAGE_HOT_JOIN_NOTICE", GAMEMESSAGE_HOT_JOIN_NOTICE)
-		.value("GAMEMESSAGE_HOT_DROP_NOTICE", GAMEMESSAGE_HOT_DROP_NOTICE)
-		.value("GAMEMESSAGE_DIPLOMACY", GAMEMESSAGE_DIPLOMACY)
-		.value("GAMEMESSAGE_POPUP", GAMEMESSAGE_POPUP)
-		.value("GAMEMESSAGE_ADVANCED_START_ACTION", GAMEMESSAGE_ADVANCED_START_ACTION)
-		.value("GAMEMESSAGE_PLAYER_ACTION", GAMEMESSAGE_PLAYER_ACTION)
-		.value("GAMEMESSAGE_MOD_NET_MESSAGE", GAMEMESSAGE_MOD_NET_MESSAGE)
-		;
-	python::enum_<PopupControlLayout>("PopupControlLayout")
-		.value("POPUP_LAYOUT_LEFT", POPUP_LAYOUT_LEFT)
-		.value("POPUP_LAYOUT_CENTER", POPUP_LAYOUT_CENTER)
-		.value("POPUP_LAYOUT_RIGHT", POPUP_LAYOUT_RIGHT)
-		.value("POPUP_LAYOUT_STRETCH", POPUP_LAYOUT_STRETCH)
-		.value("POPUP_LAYOUT_TOP", POPUP_LAYOUT_TOP)
-		.value("POPUP_LAYOUT_NUMLAYOUTS", POPUP_LAYOUT_NUMLAYOUTS)
-		;
-	python::enum_<JustificationTypes>("JustificationTypes")
-		.value("DLL_FONT_LEFT_JUSTIFY", DLL_FONT_LEFT_JUSTIFY)
-		.value("DLL_FONT_RIGHT_JUSTIFY", DLL_FONT_RIGHT_JUSTIFY)
-		.value("DLL_FONT_CENTER_JUSTIFY", DLL_FONT_CENTER_JUSTIFY)
-		.value("DLL_FONT_CENTER_VERTICALLY", DLL_FONT_CENTER_VERTICALLY)
-		.value("DLL_FONT_ADDITIVE", DLL_FONT_ADDITIVE)
-		;
-	python::enum_<ToolTipAlignTypes>("ToolTipAlignTypes")
-		.value("TOOLTIP_TOP_LEFT", TOOLTIP_TOP_LEFT)
-		.value("TOOLTIP_TOP_INLEFT", TOOLTIP_TOP_INLEFT)
-		.value("TOOLTIP_TOP_CENTER", TOOLTIP_TOP_CENTER)
-		.value("TOOLTIP_TOP_INRIGHT", TOOLTIP_TOP_INRIGHT)
-		.value("TOOLTIP_TOP_RIGHT", TOOLTIP_TOP_RIGHT)
-		.value("TOOLTIP_INTOP_RIGHT", TOOLTIP_INTOP_RIGHT)
-		.value("TOOLTIP_CENTER_RIGHT", TOOLTIP_CENTER_RIGHT)
-		.value("TOOLTIP_INBOTTOM_RIGHT", TOOLTIP_INBOTTOM_RIGHT)
-		.value("TOOLTIP_BOTTOM_RIGHT", TOOLTIP_BOTTOM_RIGHT)
-		.value("TOOLTIP_BOTTOM_INRIGHT", TOOLTIP_BOTTOM_INRIGHT)
-		.value("TOOLTIP_BOTTOM_CENTER", TOOLTIP_BOTTOM_CENTER)
-		.value("TOOLTIP_BOTTOM_INLEFT", TOOLTIP_BOTTOM_INLEFT)
-		.value("TOOLTIP_BOTTOM_LEFT", TOOLTIP_BOTTOM_LEFT)
-		.value("TOOLTIP_INBOTTOM_LEFT", TOOLTIP_INBOTTOM_LEFT)
-		.value("TOOLTIP_CENTER_LEFT", TOOLTIP_CENTER_LEFT)
-		.value("TOOLTIP_INTOP_LEFT", TOOLTIP_INTOP_LEFT)
-		;
-	python::enum_<ActivationTypes>("ActivationTypes")
-		.value("ACTIVATE_NORMAL", ACTIVATE_NORMAL)
-		.value("ACTIVATE_CHILDFOCUS", ACTIVATE_CHILDFOCUS)
-		.value("ACTIVATE_MIMICPARENT", ACTIVATE_MIMICPARENT)
-		.value("ACTIVATE_MIMICPARENTFOCUS", ACTIVATE_MIMICPARENTFOCUS)
-		;
-	python::enum_<HitTestTypes>("HitTestTypes")
-		.value("HITTEST_DEFAULT", HITTEST_DEFAULT)
-		.value("HITTEST_NOHIT", HITTEST_NOHIT)
-		.value("HITTEST_SOLID", HITTEST_SOLID)
-		.value("HITTEST_ON", HITTEST_ON)
-		.value("HITTEST_CHILDREN", HITTEST_CHILDREN)
-		;
-	python::enum_<GraphicLevelTypes>("GraphicLevelTypes")
-		.value("GRAPHICLEVEL_HIGH", GRAPHICLEVEL_HIGH)
-		.value("GRAPHICLEVEL_MEDIUM", GRAPHICLEVEL_MEDIUM)
-		.value("GRAPHICLEVEL_LOW", GRAPHICLEVEL_LOW)
-		.value("GRAPHICLEVEL_CURRENT", GRAPHICLEVEL_CURRENT)
-		.value("GRAPHICLEVEL_BELOW_SPEC", GRAPHICLEVEL_BELOW_SPEC)
-		.value("NUM_GRAPHICLEVELS", NUM_GRAPHICLEVELS)
-		;
-	python::enum_<EventTypes>("EventTypes")
-		.value("NO_EVENT", NO_EVENT)
-		;
-	python::enum_<EventTriggerTypes>("EventTriggerTypes")
-		.value("NO_EVENTTRIGGER", NO_EVENTTRIGGER)
-		;
-	python::enum_<AdvancedStartActionTypes>("AdvancedStartActionTypes")
-		.value("NO_ADVANCEDSTARTACTION", NO_ADVANCEDSTARTACTION)
-		.value("ADVANCEDSTARTACTION_EXIT", ADVANCEDSTARTACTION_EXIT)
-		.value("ADVANCEDSTARTACTION_UNIT", ADVANCEDSTARTACTION_UNIT)
-		.value("ADVANCEDSTARTACTION_CITY", ADVANCEDSTARTACTION_CITY)
-		.value("ADVANCEDSTARTACTION_POP", ADVANCEDSTARTACTION_POP)
-		.value("ADVANCEDSTARTACTION_CULTURE", ADVANCEDSTARTACTION_CULTURE)
-		.value("ADVANCEDSTARTACTION_BUILDING", ADVANCEDSTARTACTION_BUILDING)
-		.value("ADVANCEDSTARTACTION_IMPROVEMENT", ADVANCEDSTARTACTION_IMPROVEMENT)
-		.value("ADVANCEDSTARTACTION_ROUTE", ADVANCEDSTARTACTION_ROUTE)
-		.value("ADVANCEDSTARTACTION_VISIBILITY", ADVANCEDSTARTACTION_VISIBILITY)
-		.value("ADVANCEDSTARTACTION_AUTOMATE", ADVANCEDSTARTACTION_AUTOMATE)
-		.value("NUM_ADVANCEDSTARTACTIONS", NUM_ADVANCEDSTARTACTIONS)
-		;
-	python::enum_<UnitTravelStates>("UnitTravelStates")
-		.value("NO_UNIT_TRAVEL_STATE", NO_UNIT_TRAVEL_STATE)
-		.value("UNIT_TRAVEL_STATE_TO_EUROPE", UNIT_TRAVEL_STATE_TO_EUROPE)
-		.value("UNIT_TRAVEL_STATE_IN_EUROPE", UNIT_TRAVEL_STATE_IN_EUROPE)
-		.value("UNIT_TRAVEL_STATE_FROM_EUROPE", UNIT_TRAVEL_STATE_FROM_EUROPE)
-		.value("UNIT_TRAVEL_STATE_LIVE_AMONG_NATIVES", UNIT_TRAVEL_STATE_LIVE_AMONG_NATIVES)
-		///TKs Med
-		.value("UNIT_TRAVEL_STATE_HIDE_UNIT", UNIT_TRAVEL_STATE_HIDE_UNIT)
-		.value("UNIT_TRAVEL_LOST_AT_SEA", UNIT_TRAVEL_LOST_AT_SEA)
-		.value("UNIT_TRAVEL_STATE_TO_SPICE_ROUTE", UNIT_TRAVEL_STATE_TO_SPICE_ROUTE)
-		.value("UNIT_TRAVEL_STATE_IN_SPICE_ROUTE", UNIT_TRAVEL_STATE_IN_SPICE_ROUTE)
-		.value("UNIT_TRAVEL_STATE_FROM_SPICE_ROUTE", UNIT_TRAVEL_STATE_FROM_SPICE_ROUTE)
-		.value("UNIT_TRAVEL_STATE_TO_SILK_ROAD", UNIT_TRAVEL_STATE_TO_SILK_ROAD)
-		.value("UNIT_TRAVEL_STATE_IN_SILK_ROAD", UNIT_TRAVEL_STATE_IN_SILK_ROAD)
-		.value("UNIT_TRAVEL_STATE_FROM_SILK_ROAD", UNIT_TRAVEL_STATE_FROM_SILK_ROAD)
-		.value("UNIT_TRAVEL_STATE_TO_TRADE_FAIR", UNIT_TRAVEL_STATE_TO_TRADE_FAIR)
-		.value("UNIT_TRAVEL_STATE_FROM_TRADE_FAIR", UNIT_TRAVEL_STATE_FROM_TRADE_FAIR)
-		.value("UNIT_TRAVEL_STATE_IN_TRADE_FAIR", UNIT_TRAVEL_STATE_IN_TRADE_FAIR)
-		.value("UNIT_TRAVEL_STATE_FROM_IMMIGRATION", UNIT_TRAVEL_STATE_FROM_IMMIGRATION)
-		///TKe
-		.value("NUM_UNIT_TRAVEL_STATES", NUM_UNIT_TRAVEL_STATES)
-		;
-	python::enum_<FatherCategoryTypes>("FatherCategoryTypes")
-		.value("NO_FATHERCATEGORY", NO_FATHERCATEGORY)
-		;
-	python::enum_<FatherTypes>("FatherTypes")
-		.value("NO_FATHER", NO_FATHER)
-		;
-	python::enum_<FatherPointTypes>("FatherPointTypes")
-		.value("NO_FATHER_POINT_TYPE", NO_FATHER_POINT_TYPE)
-		;
-	python::enum_<AlarmTypes>("AlarmTypes")
-		.value("NO_ALARM", NO_ALARM)
-		;
-}
+#include "CvGameCoreDLL.h"
+#include"CvEnums.h"
+#include "CvGameCoreDLLUnDefNew.h"
+# include <boost/python/enum.hpp>
+#include "CvGameCoreDLLDefNew.h"
+//
+// Python interface for free enums
+//
+void CyEnumsPythonInterface()
+{
+	OutputDebugString("Python Extension Module - CyEnumsPythonInterface\n");
+	python::enum_<GameStateTypes>("GameStateTypes")
+		.value("GAMESTATE_ON", GAMESTATE_ON)
+		.value("GAMESTATE_OVER", GAMESTATE_OVER)
+		.value("GAMESTATE_EXTENDED", GAMESTATE_EXTENDED)
+		;
+	python::enum_<PopupStates>("PopupStates")
+		.value("POPUPSTATE_IMMEDIATE", POPUPSTATE_IMMEDIATE)
+		.value("POPUPSTATE_QUEUED", POPUPSTATE_QUEUED)
+		.value("POPUPSTATE_MINIMIZED", POPUPSTATE_MINIMIZED)
+		;
+	python::enum_<CameraLookAtTypes>("CameraLookAtTypes")
+		.value("CAMERALOOKAT_NORMAL", CAMERALOOKAT_NORMAL)
+		.value("CAMERALOOKAT_CITY_ZOOM_IN", CAMERALOOKAT_CITY_ZOOM_IN)
+		.value("CAMERALOOKAT_BATTLE", CAMERALOOKAT_BATTLE)
+		.value("CAMERALOOKAT_BATTLE_ZOOM_IN", CAMERALOOKAT_BATTLE_ZOOM_IN)
+		.value("CAMERALOOKAT_IMMEDIATE", CAMERALOOKAT_IMMEDIATE)
+		;
+	python::enum_<CameraMovementSpeeds>("CameraMovementSpeeds")
+		.value("CAMERAMOVEMENTSPEED_NORMAL", CAMERAMOVEMENTSPEED_NORMAL)
+		.value("CAMERAMOVEMENTSPEED_SLOW", CAMERAMOVEMENTSPEED_SLOW)
+		.value("CAMERAMOVEMENTSPEED_FAST", CAMERAMOVEMENTSPEED_FAST)
+		;
+	python::enum_<ZoomLevelTypes>("ZoomLevelTypes")
+		.value("ZOOM_UNKNOWN", ZOOM_UNKNOWN)
+		.value("ZOOM_GLOBEVIEW", ZOOM_GLOBEVIEW)
+		.value("ZOOM_NORMAL", ZOOM_NORMAL)
+		.value("ZOOM_DETAIL", ZOOM_DETAIL)
+		;
+	python::enum_<DirectionTypes>("DirectionTypes")
+		.value("NO_DIRECTION", NO_DIRECTION)
+		.value("DIRECTION_NORTH", DIRECTION_NORTH)
+		.value("DIRECTION_NORTHEAST", DIRECTION_NORTHEAST)
+		.value("DIRECTION_EAST", DIRECTION_EAST)
+		.value("DIRECTION_SOUTHEAST", DIRECTION_SOUTHEAST)
+		.value("DIRECTION_SOUTH", DIRECTION_SOUTH)
+		.value("DIRECTION_SOUTHWEST", DIRECTION_SOUTHWEST)
+		.value("DIRECTION_WEST", DIRECTION_WEST)
+		.value("DIRECTION_NORTHWEST", DIRECTION_NORTHWEST)
+		.value("NUM_DIRECTION_TYPES", NUM_DIRECTION_TYPES)
+		;
+	python::enum_<CardinalDirectionTypes>("CardinalDirectionTypes")
+		.value("NO_CARDINALDIRECTION", NO_CARDINALDIRECTION)
+		.value("CARDINALDIRECTION_NORTH", CARDINALDIRECTION_NORTH)
+		.value("CARDINALDIRECTION_EAST", CARDINALDIRECTION_EAST)
+		.value("CARDINALDIRECTION_SOUTH", CARDINALDIRECTION_SOUTH)
+		.value("CARDINALDIRECTION_WEST", CARDINALDIRECTION_WEST)
+		.value("NUM_CARDINALDIRECTION_TYPES", NUM_CARDINALDIRECTION_TYPES)
+		;
+	python::enum_<ColorTypes>("ColorTypes")
+		.value("NO_COLOR", NO_COLOR)
+		;
+	python::enum_<PlayerColorTypes>("PlayerColorTypes")
+		.value("NO_PLAYERCOLOR", NO_PLAYERCOLOR)
+		;
+	python::enum_<PlotStyles>("PlotStyles")
+		.value("PLOT_STYLE_NONE", PLOT_STYLE_NONE)
+		.value("PLOT_STYLE_NUMPAD_1", PLOT_STYLE_NUMPAD_1)
+		.value("PLOT_STYLE_NUMPAD_2", PLOT_STYLE_NUMPAD_2)
+		.value("PLOT_STYLE_NUMPAD_3", PLOT_STYLE_NUMPAD_3)
+		.value("PLOT_STYLE_NUMPAD_4", PLOT_STYLE_NUMPAD_4)
+		.value("PLOT_STYLE_NUMPAD_6", PLOT_STYLE_NUMPAD_6)
+		.value("PLOT_STYLE_NUMPAD_7", PLOT_STYLE_NUMPAD_7)
+		.value("PLOT_STYLE_NUMPAD_8", PLOT_STYLE_NUMPAD_8)
+		.value("PLOT_STYLE_NUMPAD_9", PLOT_STYLE_NUMPAD_9)
+		.value("PLOT_STYLE_NUMPAD_1_ANGLED", PLOT_STYLE_NUMPAD_1_ANGLED)
+		.value("PLOT_STYLE_NUMPAD_2_ANGLED", PLOT_STYLE_NUMPAD_2_ANGLED)
+		.value("PLOT_STYLE_NUMPAD_3_ANGLED", PLOT_STYLE_NUMPAD_3_ANGLED)
+		.value("PLOT_STYLE_NUMPAD_4_ANGLED", PLOT_STYLE_NUMPAD_4_ANGLED)
+		.value("PLOT_STYLE_NUMPAD_6_ANGLED", PLOT_STYLE_NUMPAD_6_ANGLED)
+		.value("PLOT_STYLE_NUMPAD_7_ANGLED", PLOT_STYLE_NUMPAD_7_ANGLED)
+		.value("PLOT_STYLE_NUMPAD_8_ANGLED", PLOT_STYLE_NUMPAD_8_ANGLED)
+		.value("PLOT_STYLE_NUMPAD_9_ANGLED", PLOT_STYLE_NUMPAD_9_ANGLED)
+		.value("PLOT_STYLE_BOX_FILL", PLOT_STYLE_BOX_FILL)
+		.value("PLOT_STYLE_BOX_OUTLINE", PLOT_STYLE_BOX_OUTLINE)
+		.value("PLOT_STYLE_RIVER_SOUTH", PLOT_STYLE_RIVER_SOUTH)
+		.value("PLOT_STYLE_RIVER_EAST", PLOT_STYLE_RIVER_EAST)
+		.value("PLOT_STYLE_SIDE_ARROWS", PLOT_STYLE_SIDE_ARROWS)
+		.value("PLOT_STYLE_CIRCLE", PLOT_STYLE_CIRCLE)
+		.value("PLOT_STYLE_TARGET", PLOT_STYLE_TARGET)
+		.value("PLOT_STYLE_DOT_TARGET", PLOT_STYLE_DOT_TARGET)
+		.value("PLOT_STYLE_WAVES", PLOT_STYLE_WAVES)
+		.value("PLOT_STYLE_DOTS", PLOT_STYLE_DOTS)
+		.value("PLOT_STYLE_CIRCLES", PLOT_STYLE_CIRCLES)
+		;
+	python::enum_<PlotLandscapeLayers>("PlotLandscapeLayers")
+		.value("PLOT_LANDSCAPE_LAYER_ALL", PLOT_LANDSCAPE_LAYER_ALL)
+		.value("PLOT_LANDSCAPE_LAYER_BASE", PLOT_LANDSCAPE_LAYER_BASE)
+		.value("PLOT_LANDSCAPE_LAYER_RECOMMENDED_PLOTS", PLOT_LANDSCAPE_LAYER_RECOMMENDED_PLOTS)
+		.value("PLOT_LANDSCAPE_LAYER_NUMPAD_HELP", PLOT_LANDSCAPE_LAYER_NUMPAD_HELP)
+		.value("PLOT_LANDSCAPE_LAYER_REVEALED_PLOTS", PLOT_LANDSCAPE_LAYER_REVEALED_PLOTS)
+		;
+	python::enum_<AreaBorderLayers>("AreaBorderLayers")
+		.value("AREA_BORDER_LAYER_REVEALED_PLOTS", AREA_BORDER_LAYER_REVEALED_PLOTS)
+		.value("AREA_BORDER_LAYER_WORLD_BUILDER", AREA_BORDER_LAYER_WORLD_BUILDER)
+		.value("AREA_BORDER_LAYER_FOUNDING_BORDER", AREA_BORDER_LAYER_FOUNDING_BORDER)
+		.value("AREA_BORDER_LAYER_CITY_RADIUS", AREA_BORDER_LAYER_CITY_RADIUS)
+		.value("AREA_BORDER_LAYER_RANGED", AREA_BORDER_LAYER_RANGED)
+		.value("AREA_BORDER_LAYER_HIGHLIGHT_PLOT", AREA_BORDER_LAYER_HIGHLIGHT_PLOT)
+		.value("AREA_BORDER_LAYER_EUROPE", AREA_BORDER_LAYER_EUROPE)
+		.value("NUM_AREA_BORDER_LAYERS", NUM_AREA_BORDER_LAYERS)
+		;
+	python::enum_<InterfaceModeTypes>("InterfaceModeTypes")
+		.value("NO_INTERFACEMODE", NO_INTERFACEMODE)
+		.value("INTERFACEMODE_SELECTION", INTERFACEMODE_SELECTION)
+		.value("INTERFACEMODE_PING", INTERFACEMODE_PING)
+		.value("INTERFACEMODE_SIGN", INTERFACEMODE_SIGN)
+		.value("INTERFACEMODE_GRIP", INTERFACEMODE_GRIP)
+		.value("INTERFACEMODE_GLOBELAYER_INPUT", INTERFACEMODE_GLOBELAYER_INPUT)
+		.value("INTERFACEMODE_GO_TO", INTERFACEMODE_GO_TO)
+		.value("INTERFACEMODE_GO_TO_TYPE", INTERFACEMODE_GO_TO_TYPE)
+		.value("INTERFACEMODE_GO_TO_ALL", INTERFACEMODE_GO_TO_ALL)
+		.value("INTERFACEMODE_ROUTE_TO", INTERFACEMODE_ROUTE_TO)
+		.value("INTERFACEMODE_PYTHON_PICK_PLOT", INTERFACEMODE_PYTHON_PICK_PLOT)
+		.value("INTERFACEMODE_SAVE_PLOT_NIFS", INTERFACEMODE_SAVE_PLOT_NIFS)
+		.value("NUM_INTERFACEMODE_TYPES", NUM_INTERFACEMODE_TYPES)
+		;
+	python::enum_<InterfaceMessageTypes>("InterfaceMessageTypes")
+		.value("NO_MESSAGE_TYPE", NO_MESSAGE_TYPE)
+		.value("MESSAGE_TYPE_INFO", MESSAGE_TYPE_INFO)
+		.value("MESSAGE_TYPE_LOG_ONLY", MESSAGE_TYPE_LOG_ONLY)
+		.value("MESSAGE_TYPE_DISPLAY_ONLY", MESSAGE_TYPE_DISPLAY_ONLY)
+		.value("MESSAGE_TYPE_MAJOR_EVENT", MESSAGE_TYPE_MAJOR_EVENT)
+		.value("MESSAGE_TYPE_MINOR_EVENT", MESSAGE_TYPE_MINOR_EVENT)
+		.value("MESSAGE_TYPE_CHAT", MESSAGE_TYPE_CHAT)
+		.value("MESSAGE_TYPE_COMBAT_MESSAGE", MESSAGE_TYPE_COMBAT_MESSAGE)
+		.value("MESSAGE_TYPE_QUEST", MESSAGE_TYPE_QUEST)
+		.value("MESSAGE_TYPE_TUTORIAL", MESSAGE_TYPE_TUTORIAL)
+		.value("NUM_INTERFACE_MESSAGE_TYPES", NUM_INTERFACE_MESSAGE_TYPES)
+		;
+	python::enum_<MinimapModeTypes>("MinimapModeTypes")
+		.value("NO_MINIMAPMODE", NO_MINIMAPMODE)
+		.value("MINIMAPMODE_TERRITORY", MINIMAPMODE_TERRITORY)
+		.value("MINIMAPMODE_TERRAIN", MINIMAPMODE_TERRAIN)
+		.value("MINIMAPMODE_REPLAY", MINIMAPMODE_REPLAY)
+		.value("MINIMAPMODE_MILITARY", MINIMAPMODE_MILITARY)
+		.value("NUM_MINIMAPMODE_TYPES", NUM_MINIMAPMODE_TYPES)
+		;
+	python::enum_<EngineDirtyBits>("EngineDirtyBits")
+		.value("GlobeTexture_DIRTY_BIT", GlobeTexture_DIRTY_BIT)
+		.value("MinimapTexture_DIRTY_BIT", MinimapTexture_DIRTY_BIT)
+		.value("CultureBorders_DIRTY_BIT", CultureBorders_DIRTY_BIT)
+		.value("NUM_ENGINE_DIRTY_BITS", NUM_ENGINE_DIRTY_BITS)
+		;
+	python::enum_<InterfaceDirtyBits>("InterfaceDirtyBits")
+		.value("SelectionCamera_DIRTY_BIT", SelectionCamera_DIRTY_BIT)
+		.value("Fog_DIRTY_BIT", Fog_DIRTY_BIT)
+		.value("GlobeLayer_DIRTY_BIT", GlobeLayer_DIRTY_BIT)
+		.value("GlobeInfo_DIRTY_BIT", GlobeInfo_DIRTY_BIT)
+		.value("Waypoints_DIRTY_BIT", Waypoints_DIRTY_BIT)
+		.value("MiscButtons_DIRTY_BIT", MiscButtons_DIRTY_BIT)
+		.value("PlotListButtons_DIRTY_BIT", PlotListButtons_DIRTY_BIT)
+		.value("SelectionButtons_DIRTY_BIT", SelectionButtons_DIRTY_BIT)
+		.value("CitizenButtons_DIRTY_BIT", CitizenButtons_DIRTY_BIT)
+		.value("Event_DIRTY_BIT", Event_DIRTY_BIT)
+		.value("Center_DIRTY_BIT", Center_DIRTY_BIT)
+		.value("GameData_DIRTY_BIT", GameData_DIRTY_BIT)
+		.value("Score_DIRTY_BIT", Score_DIRTY_BIT)
+		.value("TurnTimer_DIRTY_BIT", TurnTimer_DIRTY_BIT)
+		.value("Help_DIRTY_BIT", Help_DIRTY_BIT)
+		.value("MinimapSection_DIRTY_BIT", MinimapSection_DIRTY_BIT)
+		.value("SelectionSound_DIRTY_BIT", SelectionSound_DIRTY_BIT)
+		.value("Cursor_DIRTY_BIT", Cursor_DIRTY_BIT)
+		.value("CityInfo_DIRTY_BIT", CityInfo_DIRTY_BIT)
+		.value("UnitInfo_DIRTY_BIT", UnitInfo_DIRTY_BIT)
+		.value("Popup_DIRTY_BIT", Popup_DIRTY_BIT)
+		.value("CityScreen_DIRTY_BIT", CityScreen_DIRTY_BIT)
+		.value("InfoPane_DIRTY_BIT", InfoPane_DIRTY_BIT)
+		.value("Flag_DIRTY_BIT", Flag_DIRTY_BIT)
+		.value("HighlightPlot_DIRTY_BIT", HighlightPlot_DIRTY_BIT)
+		.value("ColoredPlots_DIRTY_BIT", ColoredPlots_DIRTY_BIT)
+		.value("Financial_Screen_DIRTY_BIT", Financial_Screen_DIRTY_BIT)
+		.value("Foreign_Screen_DIRTY_BIT", Foreign_Screen_DIRTY_BIT)
+		.value("Soundtrack_DIRTY_BIT", Soundtrack_DIRTY_BIT)
+		.value("Domestic_Advisor_DIRTY_BIT", Domestic_Advisor_DIRTY_BIT)
+		.value("Advanced_Start_DIRTY_BIT", Advanced_Start_DIRTY_BIT)
+		.value("EuropeScreen_DIRTY_BIT", EuropeScreen_DIRTY_BIT)
+		.value("ResourceTable_DIRTY_BIT", ResourceTable_DIRTY_BIT)
+		///Tks Med
+        .value("NewYieldAvailable_DIRTY_BIT", NewYieldAvailable_DIRTY_BIT)
+		///Tke
+		.value("NUM_INTERFACE_DIRTY_BITS", NUM_INTERFACE_DIRTY_BITS)
+		;
+	python::enum_<WidgetTypes>("WidgetTypes")
+		.value("WIDGET_PLOT_LIST", WIDGET_PLOT_LIST)
+		.value("WIDGET_PLOT_LIST_SHIFT", WIDGET_PLOT_LIST_SHIFT)
+		.value("WIDGET_CITY_SCROLL", WIDGET_CITY_SCROLL)
+		.value("WIDGET_LIBERATE_CITY", WIDGET_LIBERATE_CITY)
+		.value("WIDGET_CITY_NAME", WIDGET_CITY_NAME)
+		.value("WIDGET_UNIT_NAME", WIDGET_UNIT_NAME)
+		.value("WIDGET_CREATE_GROUP", WIDGET_CREATE_GROUP)
+		.value("WIDGET_DELETE_GROUP", WIDGET_DELETE_GROUP)
+		.value("WIDGET_TRAIN", WIDGET_TRAIN)
+		.value("WIDGET_CONSTRUCT", WIDGET_CONSTRUCT)
+		.value("WIDGET_CONVINCE", WIDGET_CONVINCE)
+		.value("WIDGET_HURRY", WIDGET_HURRY)
+		.value("WIDGET_PLAYER_HURRY", WIDGET_PLAYER_HURRY)
+		.value("WIDGET_MENU_ICON", WIDGET_MENU_ICON)
+		.value("WIDGET_ACTION", WIDGET_ACTION)
+		.value("WIDGET_CITIZEN", WIDGET_CITIZEN)
+		.value("WIDGET_CONTACT_CIV", WIDGET_CONTACT_CIV)
+		.value("WIDGET_SCORE_BREAKDOWN", WIDGET_SCORE_BREAKDOWN)
+		.value("WIDGET_ZOOM_CITY", WIDGET_ZOOM_CITY)
+		.value("WIDGET_END_TURN", WIDGET_END_TURN)
+		.value("WIDGET_WB_SAVE_BUTTON", WIDGET_WB_SAVE_BUTTON)
+		.value("WIDGET_WB_LOAD_BUTTON", WIDGET_WB_LOAD_BUTTON)
+		.value("WIDGET_WB_ALL_PLOTS_BUTTON", WIDGET_WB_ALL_PLOTS_BUTTON)
+		.value("WIDGET_WB_LANDMARK_BUTTON", WIDGET_WB_LANDMARK_BUTTON)
+		.value("WIDGET_WB_ERASE_BUTTON", WIDGET_WB_ERASE_BUTTON)
+		.value("WIDGET_WB_EXIT_BUTTON", WIDGET_WB_EXIT_BUTTON)
+		.value("WIDGET_WB_UNIT_EDIT_BUTTON", WIDGET_WB_UNIT_EDIT_BUTTON)
+		.value("WIDGET_WB_CITY_EDIT_BUTTON", WIDGET_WB_CITY_EDIT_BUTTON)
+		.value("WIDGET_WB_NORMAL_PLAYER_TAB_MODE_BUTTON", WIDGET_WB_NORMAL_PLAYER_TAB_MODE_BUTTON)
+		.value("WIDGET_WB_NORMAL_MAP_TAB_MODE_BUTTON", WIDGET_WB_NORMAL_MAP_TAB_MODE_BUTTON)
+		.value("WIDGET_WB_REVEAL_TAB_MODE_BUTTON", WIDGET_WB_REVEAL_TAB_MODE_BUTTON)
+		.value("WIDGET_WB_DIPLOMACY_MODE_BUTTON", WIDGET_WB_DIPLOMACY_MODE_BUTTON)
+		.value("WIDGET_WB_REVEAL_ALL_BUTTON", WIDGET_WB_REVEAL_ALL_BUTTON)
+		.value("WIDGET_WB_UNREVEAL_ALL_BUTTON", WIDGET_WB_UNREVEAL_ALL_BUTTON)
+		.value("WIDGET_WB_REGENERATE_MAP", WIDGET_WB_REGENERATE_MAP)
+		.value("WIDGET_AUTOMATE_CITIZENS", WIDGET_AUTOMATE_CITIZENS)
+		.value("WIDGET_AUTOMATE_PRODUCTION", WIDGET_AUTOMATE_PRODUCTION)
+		.value("WIDGET_EMPHASIZE", WIDGET_EMPHASIZE)
+		.value("WIDGET_DIPLOMACY_RESPONSE", WIDGET_DIPLOMACY_RESPONSE)
+		.value("WIDGET_GENERAL", WIDGET_GENERAL)
+		.value("WIDGET_FILE_LISTBOX", WIDGET_FILE_LISTBOX)
+		.value("WIDGET_FILE_EDITBOX", WIDGET_FILE_EDITBOX)
+		.value("WIDGET_TRADE_ITEM", WIDGET_TRADE_ITEM)
+		.value("WIDGET_UNIT_MODEL", WIDGET_UNIT_MODEL)
+		.value("WIDGET_POPUP_QUEUE", WIDGET_POPUP_QUEUE)
+		.value("WIDGET_PYTHON", WIDGET_PYTHON)
+		.value("WIDGET_HELP_DEFENSE", WIDGET_HELP_DEFENSE)
+		.value("WIDGET_HELP_POPULATION", WIDGET_HELP_POPULATION)
+		.value("WIDGET_HELP_REBEL", WIDGET_HELP_REBEL)
+		.value("WIDGET_HELP_GREAT_GENERAL", WIDGET_HELP_GREAT_GENERAL)
+		.value("WIDGET_HELP_SELECTED", WIDGET_HELP_SELECTED)
+		.value("WIDGET_HELP_YIELD", WIDGET_HELP_YIELD)
+		.value("WIDGET_HELP_PROMOTION", WIDGET_HELP_PROMOTION)
+		.value("WIDGET_HELP_UNIT_PROMOTION", WIDGET_HELP_UNIT_PROMOTION)
+		.value("WIDGET_CHOOSE_EVENT", WIDGET_CHOOSE_EVENT)
+		.value("WIDGET_PEDIA_JUMP_TO_UNIT", WIDGET_PEDIA_JUMP_TO_UNIT)
+		.value("WIDGET_PEDIA_JUMP_TO_PROFESSION", WIDGET_PEDIA_JUMP_TO_PROFESSION)
+		.value("WIDGET_PEDIA_JUMP_TO_BUILDING", WIDGET_PEDIA_JUMP_TO_BUILDING)
+		.value("WIDGET_PEDIA_BACK", WIDGET_PEDIA_BACK)
+		.value("WIDGET_PEDIA_FORWARD", WIDGET_PEDIA_FORWARD)
+		.value("WIDGET_PEDIA_JUMP_TO_BONUS", WIDGET_PEDIA_JUMP_TO_BONUS)
+		.value("WIDGET_PEDIA_MAIN", WIDGET_PEDIA_MAIN)
+		.value("WIDGET_PEDIA_JUMP_TO_PROMOTION", WIDGET_PEDIA_JUMP_TO_PROMOTION)
+		.value("WIDGET_PEDIA_JUMP_TO_IMPROVEMENT", WIDGET_PEDIA_JUMP_TO_IMPROVEMENT)
+		.value("WIDGET_PEDIA_JUMP_TO_CIVIC", WIDGET_PEDIA_JUMP_TO_CIVIC)
+		.value("WIDGET_PEDIA_JUMP_TO_CIV", WIDGET_PEDIA_JUMP_TO_CIV)
+		.value("WIDGET_PEDIA_JUMP_TO_LEADER", WIDGET_PEDIA_JUMP_TO_LEADER)
+		.value("WIDGET_PEDIA_JUMP_TO_TERRAIN", WIDGET_PEDIA_JUMP_TO_TERRAIN)
+		.value("WIDGET_PEDIA_JUMP_TO_YIELDS", WIDGET_PEDIA_JUMP_TO_YIELDS)
+		.value("WIDGET_PEDIA_JUMP_TO_FEATURE", WIDGET_PEDIA_JUMP_TO_FEATURE)
+		.value("WIDGET_PEDIA_JUMP_TO_FATHER", WIDGET_PEDIA_JUMP_TO_FATHER)
+		.value("WIDGET_TURN_EVENT", WIDGET_TURN_EVENT)
+		.value("WIDGET_PEDIA_DESCRIPTION", WIDGET_PEDIA_DESCRIPTION)
+		.value("WIDGET_PEDIA_DESCRIPTION_NO_HELP", WIDGET_PEDIA_DESCRIPTION_NO_HELP)
+		.value("WIDGET_DEAL_KILL", WIDGET_DEAL_KILL)
+		.value("WIDGET_MINIMAP_HIGHLIGHT", WIDGET_MINIMAP_HIGHLIGHT)
+		.value("WIDGET_PRODUCTION_MOD_HELP", WIDGET_PRODUCTION_MOD_HELP)
+		.value("WIDGET_LEADERHEAD", WIDGET_LEADERHEAD)
+		.value("WIDGET_LEADER_LINE", WIDGET_LEADER_LINE)
+		.value("WIDGET_CLOSE_SCREEN", WIDGET_CLOSE_SCREEN)
+		.value("WIDGET_GLOBELAYER", WIDGET_GLOBELAYER)
+		.value("WIDGET_GLOBELAYER_OPTION", WIDGET_GLOBELAYER_OPTION)
+		.value("WIDGET_GLOBELAYER_TOGGLE", WIDGET_GLOBELAYER_TOGGLE)
+		.value("WIDGET_CITY_UNIT_ASSIGN_PROFESSION", WIDGET_CITY_UNIT_ASSIGN_PROFESSION)
+		.value("WIDGET_MOVE_CARGO_TO_CITY", WIDGET_MOVE_CARGO_TO_CITY)
+		.value("WIDGET_RECEIVE_MOVE_CARGO_TO_CITY", WIDGET_RECEIVE_MOVE_CARGO_TO_CITY)
+		.value("WIDGET_MOVE_CARGO_TO_TRANSPORT", WIDGET_MOVE_CARGO_TO_TRANSPORT)
+		.value("WIDGET_RECEIVE_MOVE_CARGO_TO_TRANSPORT", WIDGET_RECEIVE_MOVE_CARGO_TO_TRANSPORT)
+		.value("WIDGET_CREATE_TRADE_ROUTE", WIDGET_CREATE_TRADE_ROUTE)
+		.value("WIDGET_EDIT_TRADE_ROUTE", WIDGET_EDIT_TRADE_ROUTE)
+		.value("WIDGET_YIELD_IMPORT_EXPORT", WIDGET_YIELD_IMPORT_EXPORT)
+		.value("WIDGET_ASSIGN_CITIZEN_TO_PLOT", WIDGET_ASSIGN_CITIZEN_TO_PLOT)
+		.value("WIDGET_ASSIGN_TRADE_ROUTE", WIDGET_ASSIGN_TRADE_ROUTE)
+		.value("WIDGET_EJECT_CITIZEN", WIDGET_EJECT_CITIZEN)
+		.value("WIDGET_SHIP_CARGO", WIDGET_SHIP_CARGO)
+		.value("WIDGET_DOCK", WIDGET_DOCK)
+		.value("WIDGET_SAIL", WIDGET_SAIL)
+		.value("WIDGET_GOTO_CITY", WIDGET_GOTO_CITY)
+		///TKs Invention Core Mod v 1.0
+		.value("WIDGET_INVENTORS_HOUSE", WIDGET_INVENTORS_HOUSE)
+		.value("WIDGET_PEDIA_JUMP_TO_TECHNOLOGY", WIDGET_PEDIA_JUMP_TO_TECHNOLOGY)
+		//TK Tax
+		.value("WIDGET_TAX_ADVISOR", WIDGET_TAX_ADVISOR)
+		//TKe
+		.value("WIDGET_ARMORSMITH", WIDGET_ARMORSMITH)
+		.value("WIDGET_MARKET", WIDGET_MARKET)
+		///TKe
+		.value("NUM_WIDGET_TYPES", NUM_WIDGET_TYPES)
+		;
+	python::enum_<ButtonPopupTypes>("ButtonPopupTypes")
+		.value("BUTTONPOPUP_TEXT", BUTTONPOPUP_TEXT)
+		.value("BUTTONPOPUP_MAIN_MENU", BUTTONPOPUP_MAIN_MENU)
+		.value("BUTTONPOPUP_CONFIRM_MENU", BUTTONPOPUP_CONFIRM_MENU)
+		.value("BUTTONPOPUP_DECLAREWARMOVE", BUTTONPOPUP_DECLAREWARMOVE)
+		.value("BUTTONPOPUP_CONFIRMCOMMAND", BUTTONPOPUP_CONFIRMCOMMAND)
+		.value("BUTTONPOPUP_CONFIRMTASK", BUTTONPOPUP_CONFIRMTASK)
+		.value("BUTTONPOPUP_LOADUNIT", BUTTONPOPUP_LOADUNIT)
+		.value("BUTTONPOPUP_LOAD_CARGO", BUTTONPOPUP_LOAD_CARGO)
+		.value("BUTTONPOPUP_LEADUNIT", BUTTONPOPUP_LEADUNIT)
+		.value("BUTTONPOPUP_RAZECITY", BUTTONPOPUP_RAZECITY)
+		.value("BUTTONPOPUP_CHOOSEPRODUCTION", BUTTONPOPUP_CHOOSEPRODUCTION)
+		.value("BUTTONPOPUP_CHOOSE_YIELD_BUILD", BUTTONPOPUP_CHOOSE_YIELD_BUILD)
+		.value("BUTTONPOPUP_CHOOSE_EDUCATION", BUTTONPOPUP_CHOOSE_EDUCATION)
+		.value("BUTTONPOPUP_ALARM", BUTTONPOPUP_ALARM)
+		.value("BUTTONPOPUP_DEAL_CANCELED", BUTTONPOPUP_DEAL_CANCELED)
+		.value("BUTTONPOPUP_PYTHON", BUTTONPOPUP_PYTHON)
+		.value("BUTTONPOPUP_FEAT", BUTTONPOPUP_FEAT)
+		.value("BUTTONPOPUP_PYTHON_SCREEN", BUTTONPOPUP_PYTHON_SCREEN)
+		.value("BUTTONPOPUP_MOVIE", BUTTONPOPUP_MOVIE)
+		.value("BUTTONPOPUP_DETAILS", BUTTONPOPUP_DETAILS)
+		.value("BUTTONPOPUP_ADMIN", BUTTONPOPUP_ADMIN)
+		.value("BUTTONPOPUP_ADMIN_PASSWORD", BUTTONPOPUP_ADMIN_PASSWORD)
+		.value("BUTTONPOPUP_EXTENDED_GAME", BUTTONPOPUP_EXTENDED_GAME)
+		.value("BUTTONPOPUP_DIPLOMACY", BUTTONPOPUP_DIPLOMACY)
+		.value("BUTTONPOPUP_ADDBUDDY", BUTTONPOPUP_ADDBUDDY)
+		.value("BUTTONPOPUP_FORCED_DISCONNECT", BUTTONPOPUP_FORCED_DISCONNECT)
+		.value("BUTTONPOPUP_PITBOSS_DISCONNECT", BUTTONPOPUP_PITBOSS_DISCONNECT)
+		.value("BUTTONPOPUP_KICKED", BUTTONPOPUP_PITBOSS_DISCONNECT)
+		.value("BUTTONPOPUP_EVENT", BUTTONPOPUP_EVENT)
+		.value("BUTTONPOPUP_FREE_COLONY", BUTTONPOPUP_FREE_COLONY)
+		.value("BUTTONPOPUP_CHOOSE_PROFESSION", BUTTONPOPUP_CHOOSE_PROFESSION)
+		.value("BUTTONPOPUP_PURCHASE_EUROPE_UNIT", BUTTONPOPUP_PURCHASE_EUROPE_UNIT)
+		.value("BUTTONPOPUP_FOUNDING_FATHER", BUTTONPOPUP_FOUNDING_FATHER)
+		.value("BUTTONPOPUP_CIVIC_OPTION", BUTTONPOPUP_CIVIC_OPTION)
+		.value("BUTTONPOPUP_TRADE_ROUTES", BUTTONPOPUP_TRADE_ROUTES)
+		.value("BUTTONPOPUP_YIELD_IMPORT_EXPORT", BUTTONPOPUP_YIELD_IMPORT_EXPORT)
+		.value("BUTTONPOPUP_PROMOTE", BUTTONPOPUP_PROMOTE)
+		.value("BUTTONPOPUP_CHOOSE_GOODY", BUTTONPOPUP_CHOOSE_GOODY)
+		.value("BUTTONPOPUP_SELECT_YIELD_AMOUNT", BUTTONPOPUP_SELECT_YIELD_AMOUNT)
+		.value("BUTTONPOPUP_EUROPE_UNIT", BUTTONPOPUP_EUROPE_UNIT)
+		.value("BUTTONPOPUP_TALK_NATIVES", BUTTONPOPUP_TALK_NATIVES)
+		.value("NUM_BUTTONPOPUP_TYPES", NUM_BUTTONPOPUP_TYPES)
+		;
+	python::enum_<ClimateTypes>("ClimateTypes")
+		.value("NO_CLIMATE", NO_CLIMATE)
+		;
+	python::enum_<SeaLevelTypes>("SeaLevelTypes")
+		.value("NO_SEALEVEL", NO_SEALEVEL)
+		;
+	python::enum_<CustomMapOptionTypes>("CustomMapOptionTypes")
+		.value("NO_CUSTOM_MAPOPTION", NO_CUSTOM_MAPOPTION)
+		;
+	python::enum_<WorldSizeTypes>("WorldSizeTypes")
+		.value("NO_WORLDSIZE", NO_WORLDSIZE)
+		.value("WORLDSIZE_TINY", WORLDSIZE_TINY)
+		.value("WORLDSIZE_SMALL", WORLDSIZE_SMALL)
+		.value("WORLDSIZE_STANDARD", WORLDSIZE_STANDARD)
+		.value("WORLDSIZE_LARGE", WORLDSIZE_LARGE)
+		.value("WORLDSIZE_HUGE", WORLDSIZE_HUGE)
+		.value("NUM_WORLDSIZE_TYPES", NUM_WORLDSIZE_TYPES)
+		;
+	python::enum_<TerrainTypes>("TerrainTypes")
+		.value("NO_TERRAIN", NO_TERRAIN)
+		;
+	python::enum_<PlotTypes>("PlotTypes")
+		.value("NO_PLOT", NO_PLOT)
+		.value("PLOT_PEAK", PLOT_PEAK)
+		.value("PLOT_HILLS", PLOT_HILLS)
+		.value("PLOT_LAND", PLOT_LAND)
+		.value("PLOT_OCEAN", PLOT_OCEAN)
+		.value("NUM_PLOT_TYPES", NUM_PLOT_TYPES)
+		;
+	python::enum_<YieldTypes>("YieldTypes")
+		.value("NO_YIELD", NO_YIELD)
+		///TKs ME
+#if defined(MEDIEVAL_TECH)
+		.value("YIELD_FOOD", YIELD_FOOD)
+		.value("YIELD_GRAIN", YIELD_GRAIN)
+		.value("YIELD_CATTLE", YIELD_CATTLE)
+		.value("YIELD_SHEEP", YIELD_SHEEP)
+		.value("YIELD_WOOL", YIELD_WOOL)
+		.value("YIELD_LUMBER", YIELD_LUMBER)
+		.value("YIELD_STONE", YIELD_STONE)
+		.value("YIELD_SILVER", YIELD_SILVER)
+		.value("YIELD_SALT", YIELD_SALT)
+		.value("YIELD_SPICES", YIELD_SPICES)
+		.value("YIELD_FUR", YIELD_FUR)
+		.value("YIELD_COTTON", YIELD_COTTON)
+		.value("YIELD_BARLEY", YIELD_BARLEY)
+		.value("YIELD_GRAPES", YIELD_GRAPES)
+		.value("YIELD_ORE", YIELD_ORE)
+		.value("YIELD_CLOTH", YIELD_CLOTH)
+		.value("YIELD_COATS", YIELD_COATS)
+		.value("YIELD_ALE", YIELD_ALE)
+		.value("YIELD_WINE", YIELD_WINE)
+		.value("YIELD_TOOLS", YIELD_TOOLS)
+		.value("YIELD_WEAPONS", YIELD_WEAPONS)
+		.value("YIELD_HORSES", YIELD_HORSES)
+		.value("YIELD_LEATHER_ARMOR", YIELD_LEATHER_ARMOR)
+		.value("YIELD_SCALE_ARMOR", YIELD_SCALE_ARMOR)
+		.value("YIELD_MAIL_ARMOR", YIELD_MAIL_ARMOR)
+		.value("YIELD_PLATE_ARMOR", YIELD_PLATE_ARMOR)
+		.value("YIELD_TRADE_GOODS", YIELD_TRADE_GOODS)
+		.value("YIELD_HAMMERS", YIELD_HAMMERS)
+		.value("YIELD_BELLS", YIELD_BELLS)
+		.value("YIELD_CROSSES", YIELD_CROSSES)
+		.value("YIELD_EDUCATION", YIELD_EDUCATION)
+		.value("YIELD_IDEAS", YIELD_IDEAS)
+		.value("YIELD_CULTURE", YIELD_CULTURE)
+		.value("YIELD_GOLD", YIELD_GOLD)
+#elif defined(COLONIZATION_2071) 
+		.value("YIELD_NUTRIENTS", YIELD_NUTRIENTS)
+		.value("YIELD_BIOPOLYMERS", YIELD_BIOPOLYMERS)
+		.value("YIELD_SILICATES", YIELD_SILICATES)
+		.value("YIELD_BASE_METALS", YIELD_BASE_METALS)
+		.value("YIELD_PRECIOUS_METALS", YIELD_PRECIOUS_METALS)
+		.value("YIELD_ISOTOPES", YIELD_ISOTOPES)
+		.value("YIELD_URANIUM", YIELD_URANIUM)
+		.value("YIELD_RARE_EARTHS", YIELD_RARE_EARTHS)
+		.value("YIELD_CRYSTALLOIDS", YIELD_CRYSTALLOIDS)
+		.value("YIELD_TISSUE_SAMPLES", YIELD_TISSUE_SAMPLES)
+		.value("YIELD_YIELD_NUCLEIC_ACIDS", YIELD_YIELD_NUCLEIC_ACIDS)
+		.value("YIELD_AMINO_ACIDS", YIELD_AMINO_ACIDS)
+		.value("YIELD_MICROBES", YIELD_MICROBES)
+		.value("YIELD_PROGENITOR_ARTIFACTS", YIELD_PROGENITOR_ARTIFACTS)
+		.value("YIELD_ALIEN_SPECIMENS", YIELD_ALIEN_SPECIMENS)
+		.value("YIELD_ENCRYPTED_DATA", YIELD_ENCRYPTED_DATA)
+		.value("YIELD_OPIATES", YIELD_OPIATES)
+		.value("YIELD_XENOTOXINS", YIELD_XENOTOXINS)
+		.value("YIELD_BOTANICALS", YIELD_BOTANICALS)
+		.value("YIELD_HYDROCARBONS", YIELD_HYDROCARBONS)
+		.value("YIELD_HALOGENS", YIELD_HALOGENS)
+		.value("YIELD_CORE_SAMPLES", YIELD_CORE_SAMPLES)
+		.value("YIELD_TOOLS", YIELD_TOOLS)
+		.value("YIELD_WEAPONS", YIELD_WEAPONS)
+		.value("YIELD_HORSES", YIELD_HORSES)
+		.value("YIELD_TRADE_GOODS", YIELD_TRADE_GOODS)
+		.value("YIELD_HAMMERS", YIELD_HAMMERS)
+		.value("YIELD_BELLS", YIELD_BELLS)
+		.value("YIELD_CROSSES", YIELD_CROSSES)
+		.value("YIELD_EDUCATION", YIELD_EDUCATION)
+		.value("YIELD_IDEAS", YIELD_IDEAS)
+		.value("YIELD_CULTURE", YIELD_CULTURE)
+		.value("YIELD_GOLD", YIELD_GOLD)
+#endif
+		///TKe
+		.value("NUM_YIELD_TYPES", NUM_YIELD_TYPES)
+		;
+	python::enum_<EmphasizeTypes>("EmphasizeTypes")
+		.value("NO_EMPHASIZE", NO_EMPHASIZE)
+		;
+	python::enum_<GameOptionTypes>("GameOptionTypes")
+		.value("NO_GAMEOPTION", NO_GAMEOPTION)
+		.value("GAMEOPTION_ADVANCED_START", GAMEOPTION_ADVANCED_START)
+		.value("GAMEOPTION_NO_CITY_RAZING", GAMEOPTION_NO_CITY_RAZING)
+		.value("GAMEOPTION_AGGRESSIVE_AI", GAMEOPTION_AGGRESSIVE_AI)
+		// < JAnimals Mod Start >
+		.value("GAMEOPTION_NO_WILD_LAND_ANIMALS", GAMEOPTION_NO_WILD_LAND_ANIMALS)
+		.value("GAMEOPTION_NO_WILD_SEA_ANIMALS", GAMEOPTION_NO_WILD_SEA_ANIMALS)
+		// < JAnimals Mod End >
+		.value("GAMEOPTION_LEAD_ANY_CIV", GAMEOPTION_LEAD_ANY_CIV)
+		.value("GAMEOPTION_PERMANENT_ALLIANCES", GAMEOPTION_PERMANENT_ALLIANCES)
+		.value("GAMEOPTION_ALWAYS_WAR", GAMEOPTION_ALWAYS_WAR)
+		.value("GAMEOPTION_ALWAYS_PEACE", GAMEOPTION_ALWAYS_PEACE)
+		.value("GAMEOPTION_ONE_CITY_CHALLENGE", GAMEOPTION_ONE_CITY_CHALLENGE)
+		.value("GAMEOPTION_NO_CHANGING_WAR_PEACE", GAMEOPTION_NO_CHANGING_WAR_PEACE)
+		.value("GAMEOPTION_NEW_RANDOM_SEED", GAMEOPTION_NEW_RANDOM_SEED)
+		.value("GAMEOPTION_LOCK_MODS", GAMEOPTION_LOCK_MODS)
+		.value("GAMEOPTION_NO_GOODY_HUTS", GAMEOPTION_NO_GOODY_HUTS)
+		.value("GAMEOPTION_NO_EVENTS", GAMEOPTION_NO_EVENTS)
+		.value("NUM_GAMEOPTION_TYPES", NUM_GAMEOPTION_TYPES)
+		;
+	python::enum_<MultiplayerOptionTypes>("MultiplayerOptionTypes")
+		.value("NO_MPOPTION", NO_MPOPTION)
+		.value("MPOPTION_SIMULTANEOUS_TURNS", MPOPTION_SIMULTANEOUS_TURNS)
+		.value("MPOPTION_TAKEOVER_AI", MPOPTION_TAKEOVER_AI)
+		.value("MPOPTION_SHUFFLE_TEAMS", MPOPTION_SHUFFLE_TEAMS)
+		.value("MPOPTION_ANONYMOUS", MPOPTION_ANONYMOUS)
+		.value("MPOPTION_TURN_TIMER", MPOPTION_TURN_TIMER)
+		.value("NUM_MPOPTION_TYPES", NUM_MPOPTION_TYPES)
+		;
+	python::enum_<SpecialOptionTypes>("SpecialOptionTypes")
+		.value("NO_SPECIALOPTION", NO_SPECIALOPTION)
+		.value("SPECIALOPTION_REPORT_STATS", SPECIALOPTION_REPORT_STATS)
+		.value("NUM_SPECIALOPTION_TYPES", NUM_SPECIALOPTION_TYPES)
+		;
+	python::enum_<PlayerOptionTypes>("PlayerOptionTypes")
+		.value("NO_PLAYEROPTION", NO_PLAYEROPTION)
+		.value("PLAYEROPTION_TUTORIAL", PLAYEROPTION_TUTORIAL)
+		.value("PLAYEROPTION_ADVISOR_POPUPS", PLAYEROPTION_ADVISOR_POPUPS)
+		.value("PLAYEROPTION_ADVISOR_HELP", PLAYEROPTION_ADVISOR_HELP)
+		.value("PLAYEROPTION_WAIT_END_TURN", PLAYEROPTION_WAIT_END_TURN)
+		.value("PLAYEROPTION_MINIMIZE_POP_UPS", PLAYEROPTION_MINIMIZE_POP_UPS)
+		.value("PLAYEROPTION_SHOW_FRIENDLY_MOVES", PLAYEROPTION_SHOW_FRIENDLY_MOVES)
+		.value("PLAYEROPTION_SHOW_ENEMY_MOVES", PLAYEROPTION_SHOW_ENEMY_MOVES)
+		.value("PLAYEROPTION_QUICK_MOVES", PLAYEROPTION_QUICK_MOVES)
+		.value("PLAYEROPTION_QUICK_ATTACK", PLAYEROPTION_QUICK_ATTACK)
+		.value("PLAYEROPTION_QUICK_DEFENSE", PLAYEROPTION_QUICK_DEFENSE)
+		.value("PLAYEROPTION_STACK_ATTACK", PLAYEROPTION_STACK_ATTACK)
+		.value("PLAYEROPTION_AUTO_PROMOTION", PLAYEROPTION_AUTO_PROMOTION)
+		.value("PLAYEROPTION_SAFE_AUTOMATION", PLAYEROPTION_SAFE_AUTOMATION)
+		.value("PLAYEROPTION_NUMPAD_HELP", PLAYEROPTION_NUMPAD_HELP)
+		.value("PLAYEROPTION_NO_UNIT_CYCLING", PLAYEROPTION_NO_UNIT_CYCLING)
+		.value("PLAYEROPTION_NO_UNIT_RECOMMENDATIONS", PLAYEROPTION_NO_UNIT_RECOMMENDATIONS)
+		.value("PLAYEROPTION_RIGHT_CLICK_MENU", PLAYEROPTION_RIGHT_CLICK_MENU)
+		.value("PLAYEROPTION_LEAVE_FORESTS", PLAYEROPTION_LEAVE_FORESTS)
+		.value("PLAYEROPTION_MODDER_1", PLAYEROPTION_MODDER_1)
+		.value("PLAYEROPTION_MODDER_2", PLAYEROPTION_MODDER_2)
+		.value("PLAYEROPTION_MODDER_3", PLAYEROPTION_MODDER_3)
+		///TK Med
+		.value("PLAYEROPTION_MODDER_4", PLAYEROPTION_MODDER_4)
+		.value("PLAYEROPTION_MODDER_5", PLAYEROPTION_MODDER_5)
+		.value("PLAYEROPTION_MODDER_6", PLAYEROPTION_MODDER_6)
+		///TK end
+		.value("NUM_PLAYEROPTION_TYPES", NUM_PLAYEROPTION_TYPES)
+		;
+	python::enum_<GraphicOptionTypes>("GraphicOptionTypes")
+		.value("NO_GRAPHICOPTION", NO_GRAPHICOPTION)
+		.value("GRAPHICOPTION_HEALTH_BARS", GRAPHICOPTION_HEALTH_BARS)
+		.value("GRAPHICOPTION_NO_COMBAT_ZOOM", GRAPHICOPTION_NO_COMBAT_ZOOM)
+		.value("GRAPHICOPTION_NO_ENEMY_GLOW", GRAPHICOPTION_NO_ENEMY_GLOW)
+		.value("GRAPHICOPTION_FROZEN_ANIMATIONS", GRAPHICOPTION_FROZEN_ANIMATIONS)
+		.value("GRAPHICOPTION_EFFECTS_DISABLED", GRAPHICOPTION_EFFECTS_DISABLED)
+		.value("GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED", GRAPHICOPTION_GLOBE_VIEW_BUILDINGS_DISABLED)
+		.value("GRAPHICOPTION_FULLSCREEN", GRAPHICOPTION_FULLSCREEN)
+		.value("GRAPHICOPTION_LOWRES_TEXTURES", GRAPHICOPTION_LOWRES_TEXTURES)
+		.value("GRAPHICOPTION_HIRES_TERRAIN", GRAPHICOPTION_HIRES_TERRAIN)
+		.value("GRAPHICOPTION_NO_MOVIES", GRAPHICOPTION_NO_MOVIES)
+		.value("NUM_GRAPHICOPTION_TYPES", NUM_GRAPHICOPTION_TYPES)
+		;
+	python::enum_<ForceControlTypes>("ForceControlTypes")
+		.value("NO_FORCECONTROL", NO_FORCECONTROL)
+		.value("FORCECONTROL_SPEED", FORCECONTROL_SPEED)
+		.value("FORCECONTROL_HANDICAP", FORCECONTROL_HANDICAP)
+		.value("FORCECONTROL_OPTIONS", FORCECONTROL_OPTIONS)
+		.value("FORCECONTROL_VICTORIES", FORCECONTROL_VICTORIES)
+		.value("FORCECONTROL_MAX_TURNS", FORCECONTROL_MAX_TURNS)
+		.value("FORCECONTROL_MAX_CITY_ELIMINATIONS", FORCECONTROL_MAX_CITY_ELIMINATION)
+		.value("FORCECONTROL_ADVANCED_START", FORCECONTROL_ADVANCED_START)
+		.value("NUM_FORCECONTROL_TYPES", NUM_FORCECONTROL_TYPES)
+		;
+	python::enum_<VictoryTypes>("VictoryTypes")
+		.value("NO_VICTORY", NO_VICTORY)
+		;
+	python::enum_<FeatureTypes>("FeatureTypes")
+		.value("NO_FEATURE", NO_FEATURE)
+		;
+	python::enum_<BonusTypes>("BonusTypes")
+		.value("NO_BONUS", NO_BONUS)
+		;
+	python::enum_<ImprovementTypes>("ImprovementTypes")
+		.value("NO_IMPROVEMENT", NO_IMPROVEMENT)
+		;
+	python::enum_<RouteTypes>("RouteTypes")
+		.value("NO_ROUTE", NO_ROUTE)
+		;
+	python::enum_<GoodyTypes>("GoodyTypes")
+		.value("NO_GOODY", NO_GOODY)
+		;
+	python::enum_<BuildTypes>("BuildTypes")
+		.value("NO_BUILD", NO_BUILD)
+		;
+	python::enum_<FontSymbols>("FontSymbols")
+		.value("HAPPY_CHAR", HAPPY_CHAR)
+		.value("UNHAPPY_CHAR", UNHAPPY_CHAR)
+		.value("HEALTHY_CHAR", HEALTHY_CHAR)
+		.value("UNHEALTHY_CHAR", UNHEALTHY_CHAR)
+		.value("BULLET_CHAR", BULLET_CHAR)
+		.value("STRENGTH_CHAR", STRENGTH_CHAR)
+		.value("MOVES_CHAR", MOVES_CHAR)
+		.value("RELIGION_CHAR", RELIGION_CHAR)
+		.value("STAR_CHAR", STAR_CHAR)
+		.value("SILVER_STAR_CHAR", SILVER_STAR_CHAR)
+		.value("TRADE_CHAR", TRADE_CHAR)
+		.value("DEFENSE_CHAR", DEFENSE_CHAR)
+		.value("GREAT_PEOPLE_CHAR", GREAT_PEOPLE_CHAR)
+		.value("BAD_GOLD_CHAR", BAD_GOLD_CHAR)
+		.value("BAD_FOOD_CHAR", BAD_FOOD_CHAR)
+		.value("EATEN_FOOD_CHAR", EATEN_FOOD_CHAR)
+		.value("GOLDEN_AGE_CHAR", GOLDEN_AGE_CHAR)
+		.value("ANGRY_POP_CHAR", ANGRY_POP_CHAR)
+		.value("OPEN_BORDERS_CHAR", OPEN_BORDERS_CHAR)
+		.value("DEFENSIVE_PACT_CHAR", DEFENSIVE_PACT_CHAR)
+		.value("MAP_CHAR", MAP_CHAR)
+		.value("OCCUPATION_CHAR", OCCUPATION_CHAR)
+		.value("REBEL_CHAR", REBEL_CHAR)
+		.value("GOLD_CHAR", GOLD_CHAR)
+		.value("POWER_CHAR", POWER_CHAR)
+		.value("MAX_NUM_SYMBOLS", MAX_NUM_SYMBOLS)
+		;
+	python::enum_<HandicapTypes>("HandicapTypes")
+		.value("NO_HANDICAP", NO_HANDICAP)
+		;
+	python::enum_<GameSpeedTypes>("GameSpeedTypes")
+		.value("NO_GAMESPEED", NO_GAMESPEED)
+		;
+	python::enum_<TurnTimerTypes>("TurnTimerTypes")
+		.value("NO_TURNTIMER", NO_TURNTIMER)
+		;
+	python::enum_<EraTypes>("EraTypes")
+		.value("NO_ERA", NO_ERA)
+		;
+	python::enum_<CivilizationTypes>("CivilizationTypes")
+		.value("NO_CIVILIZATION", NO_CIVILIZATION)
+		;
+	python::enum_<LeaderHeadTypes>("LeaderHeadTypes")
+		.value("NO_LEADER", NO_LEADER)
+		;
+	python::enum_<ArtStyleTypes>("ArtStyleTypes")
+		.value("NO_ARTSTYLE", NO_ARTSTYLE)
+		;
+    //Androrc UnitArtStyles
+	python::enum_<UnitArtStyleTypes>("UnitArtStyleTypes")
+		.value("NO_UNIT_ARTSTYLE", NO_UNIT_ARTSTYLE)
+		;
+	//Androrc End
+	python::enum_<CitySizeTypes>("CitySizeTypes")
+		.value("NO_CITYSIZE", NO_CITYSIZE)
+		.value("CITYSIZE_SMALL", CITYSIZE_SMALL)
+		.value("CITYSIZE_MEDIUM", CITYSIZE_MEDIUM)
+		.value("CITYSIZE_LARGE", CITYSIZE_LARGE)
+		.value("NUM_CITYSIZE_TYPES", NUM_CITYSIZE_TYPES)
+		;
+	python::enum_<FootstepAudioTypes>("FootstepAudioTypes")
+		.value("NO_FOOTSTEPAUDIO", NO_FOOTSTEPAUDIO)
+		;
+	python::enum_<FootstepAudioTags>("FootstepAudioTags")
+		.value("NO_FOOTSTEPAUDIO_TAG", NO_FOOTSTEPAUDIO_TAG)
+		;
+	python::enum_<ChatTargetTypes>("ChatTargetTypes")
+		.value("NO_CHATTARGET", NO_CHATTARGET)
+		.value("CHATTARGET_ALL", CHATTARGET_ALL)
+		.value("CHATTARGET_TEAM", CHATTARGET_TEAM)
+		;
+	python::enum_<VoiceTargetTypes>("VoiceTargetTypes")
+		.value("NO_VOICETARGET", NO_VOICETARGET)
+		.value("VOICETARGET_DIPLO", VOICETARGET_DIPLO)
+		.value("VOICETARGET_TEAM", VOICETARGET_TEAM)
+		.value("VOICETARGET_ALL", VOICETARGET_ALL)
+		.value("NUM_VOICETARGETS", NUM_VOICETARGETS)
+		;
+	python::enum_<TeamTypes>("TeamTypes")
+		.value("UNKNOWN_TEAM", UNKNOWN_TEAM)
+		.value("NO_TEAM", NO_TEAM)
+		;
+	python::enum_<PlayerTypes>("PlayerTypes")
+		.value("UNKNOWN_PLAYER", UNKNOWN_PLAYER)
+		.value("NO_PLAYER", NO_PLAYER)
+		;
+	python::enum_<TraitTypes>("TraitTypes")
+		.value("NO_TRAIT", NO_TRAIT)
+		;
+	python::enum_<OrderTypes>("OrderTypes")
+		.value("NO_ORDER", NO_ORDER)
+		.value("ORDER_TRAIN", ORDER_TRAIN)
+		.value("ORDER_CONSTRUCT", ORDER_CONSTRUCT)
+		.value("ORDER_CONVINCE", ORDER_CONVINCE)
+		.value("NUM_ORDER_TYPES", NUM_ORDER_TYPES)
+		;
+	python::enum_<TaskTypes>("TaskTypes")
+		.value("TASK_RAZE", TASK_RAZE)
+		.value("TASK_GIFT", TASK_GIFT)
+		.value("TASK_SET_ALL_CITIZENS_AUTOMATED", TASK_SET_ALL_CITIZENS_AUTOMATED)
+		.value("TASK_SET_CITIZEN_AUTOMATED", TASK_SET_CITIZEN_AUTOMATED)
+		.value("TASK_SET_AUTOMATED_PRODUCTION", TASK_SET_AUTOMATED_PRODUCTION)
+		.value("TASK_SET_EMPHASIZE", TASK_SET_EMPHASIZE)
+		.value("TASK_CHANGE_WORKING_PLOT", TASK_CHANGE_WORKING_PLOT)
+		.value("TASK_CHANGE_PROFESSION", TASK_CHANGE_PROFESSION)
+		.value("TASK_REPLACE_CITIZEN", TASK_REPLACE_CITIZEN)
+		.value("TASK_EJECT_TO_TRANSPORT", TASK_EJECT_TO_TRANSPORT)
+		.value("TASK_CLEAR_WORKING_OVERRIDE", TASK_CLEAR_WORKING_OVERRIDE)
+		.value("TASK_HURRY", TASK_HURRY)
+		.value("TASK_CLEAR_ORDERS", TASK_CLEAR_ORDERS)
+		.value("TASK_RALLY_PLOT", TASK_RALLY_PLOT)
+		.value("TASK_CLEAR_RALLY_PLOT", TASK_CLEAR_RALLY_PLOT)
+		.value("TASK_LIBERATE", TASK_LIBERATE)
+		.value("TASK_YIELD_IMPORT", TASK_YIELD_IMPORT)
+		.value("TASK_YIELD_EXPORT", TASK_YIELD_EXPORT)
+		.value("TASK_YIELD_LEVEL", TASK_YIELD_LEVEL)
+		.value("TASK_CLEAR_SPECIALTY", TASK_CLEAR_SPECIALTY)
+		.value("TASK_EDUCATE", TASK_EDUCATE)
+		.value("TASK_PUSH_TRAIN_UNIT", TASK_PUSH_TRAIN_UNIT)
+		.value("TASK_PUSH_CONSTRUCT_BUILDING", TASK_PUSH_CONSTRUCT_BUILDING)
+		.value("TASK_CHEAT", TASK_CHEAT)
+		.value("NUM_TASK_TYPES", NUM_TASK_TYPES)
+		;
+	python::enum_<PlayerActionTypes>("PlayerActionTypes")
+		.value("PLAYER_ACTION_BUY_EUROPE_UNIT", PLAYER_ACTION_BUY_EUROPE_UNIT)
+		.value("PLAYER_ACTION_SELL_YIELD_UNIT", PLAYER_ACTION_SELL_YIELD_UNIT)
+		.value("PLAYER_ACTION_BUY_YIELD_UNIT", PLAYER_ACTION_BUY_YIELD_UNIT)
+		.value("PLAYER_ACTION_LOAD_UNIT_FROM_EUROPE", PLAYER_ACTION_LOAD_UNIT_FROM_EUROPE)
+		.value("PLAYER_ACTION_UNLOAD_UNIT_TO_EUROPE", PLAYER_ACTION_UNLOAD_UNIT_TO_EUROPE)
+		.value("PLAYER_ACTION_TRANSFER_UNIT_IN_EUROPE", PLAYER_ACTION_TRANSFER_UNIT_IN_EUROPE)
+		.value("PLAYER_ACTION_SET_OPTION", PLAYER_ACTION_SET_OPTION)
+		.value("PLAYER_ACTION_AUTO_MOVES", PLAYER_ACTION_AUTO_MOVES)
+		.value("PLAYER_ACTION_TURN_COMPLETE", PLAYER_ACTION_TURN_COMPLETE)
+		.value("PLAYER_ACTION_APPLY_EVENT", PLAYER_ACTION_APPLY_EVENT)
+		.value("PLAYER_ACTION_CONVINCE_FATHER", PLAYER_ACTION_CONVINCE_FATHER)
+		.value("PLAYER_ACTION_SET_CIVIC", PLAYER_ACTION_SET_CIVIC)
+		.value("PLAYER_ACTION_RECEIVE_GOODY", PLAYER_ACTION_RECEIVE_GOODY)
+		.value("PLAYER_ACTION_FEAT", PLAYER_ACTION_FEAT)
+		.value("PLAYER_ACTION_BUY_UNITS_FROM_KING", PLAYER_ACTION_BUY_UNITS_FROM_KING)
+		.value("PLAYER_ACTION_HURRY", PLAYER_ACTION_HURRY)
+		.value("PLAYER_ACTION_EUROPE_CHANGE_PROFESSION", PLAYER_ACTION_EUROPE_CHANGE_PROFESSION)
+		.value("NUM_PLAYER_ACTION_TYPES", NUM_PLAYER_ACTION_TYPES)
+		;
+	python::enum_<BuildingClassTypes>("BuildingClassTypes")
+		.value("NO_BUILDINGCLASS", NO_BUILDINGCLASS)
+		;
+	python::enum_<BuildingTypes>("BuildingTypes")
+		.value("NO_BUILDING", NO_BUILDING)
+		;
+	python::enum_<SpecialBuildingTypes>("SpecialBuildingTypes")
+		.value("NO_SPECIALBUILDING", NO_SPECIALBUILDING)
+		;
+	python::enum_<InfoBarTypes>("InfoBarTypes")
+		.value("INFOBAR_STORED", INFOBAR_STORED)
+		.value("INFOBAR_RATE", INFOBAR_RATE)
+		.value("INFOBAR_RATE_EXTRA", INFOBAR_RATE_EXTRA)
+		.value("INFOBAR_EMPTY", INFOBAR_EMPTY)
+		.value("NUM_INFOBAR_TYPES", NUM_INFOBAR_TYPES)
+		;
+	python::enum_<HealthBarTypes>("HealthBarTypes")
+		.value("HEALTHBAR_ALIVE_ATTACK", HEALTHBAR_ALIVE_ATTACK)
+		.value("HEALTHBAR_ALIVE_DEFEND", HEALTHBAR_ALIVE_DEFEND)
+		.value("HEALTHBAR_DEAD", HEALTHBAR_DEAD)
+		.value("NUM_HEALTHBAR_TYPES", NUM_HEALTHBAR_TYPES)
+		;
+	python::enum_<ConceptTypes>("ConceptTypes")
+		.value("NO_CONCEPT", NO_CONCEPT)
+		;
+	python::enum_<CalendarTypes>("CalendarTypes")
+		.value("CALENDAR_DEFAULT", CALENDAR_DEFAULT)
+		.value("CALENDAR_BI_YEARLY", CALENDAR_BI_YEARLY)
+		.value("CALENDAR_YEARS", CALENDAR_YEARS)
+		.value("CALENDAR_TURNS", CALENDAR_TURNS)
+		.value("CALENDAR_SEASONS", CALENDAR_SEASONS)
+		.value("CALENDAR_MONTHS", CALENDAR_MONTHS)
+		.value("CALENDAR_WEEKS", CALENDAR_WEEKS)
+		;
+	python::enum_<SeasonTypes>("SeasonTypes")
+		.value("NO_SEASON", NO_SEASON)
+		;
+	python::enum_<MonthTypes>("MonthTypes")
+		.value("NO_MONTH", NO_MONTH)
+		;
+	python::enum_<DenialTypes>("DenialTypes")
+		.value("NO_DENIAL", NO_DENIAL)
+		.value("DENIAL_UNKNOWN", DENIAL_UNKNOWN)
+		.value("DENIAL_NEVER", DENIAL_NEVER)
+		.value("DENIAL_TOO_MUCH", DENIAL_TOO_MUCH)
+		.value("DENIAL_MYSTERY", DENIAL_MYSTERY)
+		.value("DENIAL_JOKING", DENIAL_JOKING)
+		.value("DENIAL_CONTACT_THEM", DENIAL_CONTACT_THEM)
+		.value("DENIAL_VICTORY", DENIAL_VICTORY)
+		.value("DENIAL_ATTITUDE", DENIAL_ATTITUDE)
+		.value("DENIAL_ATTITUDE_THEM", DENIAL_ATTITUDE_THEM)
+		.value("DENIAL_POWER_US", DENIAL_POWER_US)
+		.value("DENIAL_POWER_YOU", DENIAL_POWER_YOU)
+		.value("DENIAL_POWER_THEM", DENIAL_POWER_THEM)
+		.value("DENIAL_TOO_MANY_WARS", DENIAL_TOO_MANY_WARS)
+		.value("DENIAL_NO_GAIN", DENIAL_NO_GAIN)
+		.value("DENIAL_NOT_INTERESTED", DENIAL_NOT_INTERESTED)
+		.value("DENIAL_NOT_ALLIED", DENIAL_NOT_ALLIED)
+		.value("DENIAL_RECENT_CANCEL", DENIAL_RECENT_CANCEL)
+		.value("DENIAL_WORST_ENEMY", DENIAL_WORST_ENEMY)
+		.value("DENIAL_POWER_YOUR_ENEMIES", DENIAL_POWER_YOUR_ENEMIES)
+		.value("DENIAL_TOO_FAR", DENIAL_TOO_FAR)
+		///Tks Med
+		.value("DENIAL_CULTURE_YOU", DENIAL_CULTURE_YOU)
+		///Tke
+		.value("NUM_DENIAL_TYPES", NUM_DENIAL_TYPES)
+		;
+	python::enum_<DomainTypes>("DomainTypes")
+		.value("DOMAIN_SEA", DOMAIN_SEA)
+		.value("DOMAIN_LAND", DOMAIN_LAND)
+		.value("DOMAIN_IMMOBILE", DOMAIN_IMMOBILE)
+		.value("NUM_DOMAIN_TYPES", NUM_DOMAIN_TYPES)
+		;
+	python::enum_<UnitClassTypes>("UnitClassTypes")
+		.value("NO_UNITCLASS", NO_UNITCLASS)
+		;
+	python::enum_<UnitTypes>("UnitTypes")
+		.value("NO_UNIT", NO_UNIT)
+		;
+	python::enum_<ProfessionTypes>("ProfessionTypes")
+		.value("NO_PROFESSION", NO_PROFESSION)
+		;
+	python::enum_<SpecialUnitTypes>("SpecialUnitTypes")
+		.value("NO_SPECIALUNIT", NO_SPECIALUNIT)
+		;
+	python::enum_<UnitCombatTypes>("UnitCombatTypes")
+		.value("NO_UNITCOMBAT", NO_UNITCOMBAT)
+		;
+	python::enum_<UnitAITypes>("UnitAITypes")
+		.value("NO_UNITAI", NO_UNITAI)
+		.value("UNITAI_UNKNOWN", UNITAI_UNKNOWN)
+		// < JAnimals Mod Start >
+		.value("UNITAI_ANIMAL", UNITAI_ANIMAL)
+		// < JAnimals Mod End >
+		.value("UNITAI_COLONIST", UNITAI_COLONIST)
+		.value("UNITAI_SETTLER", UNITAI_SETTLER)
+		.value("UNITAI_WORKER", UNITAI_WORKER)
+		.value("UNITAI_MISSIONARY", UNITAI_MISSIONARY)
+		.value("UNITAI_SCOUT", UNITAI_SCOUT)
+		.value("UNITAI_WAGON", UNITAI_WAGON)
+		.value("UNITAI_TREASURE", UNITAI_TREASURE)
+		.value("UNITAI_DEFENSIVE", UNITAI_DEFENSIVE)
+		.value("UNITAI_OFFENSIVE", UNITAI_DEFENSIVE)
+		.value("UNITAI_COUNTER", UNITAI_COUNTER)
+		.value("UNITAI_TRANSPORT_SEA", UNITAI_TRANSPORT_SEA)
+		.value("UNITAI_ASSAULT_SEA", UNITAI_ASSAULT_SEA)
+		.value("UNITAI_COMBAT_SEA", UNITAI_COMBAT_SEA)
+		.value("UNITAI_PIRATE_SEA", UNITAI_PIRATE_SEA)
+		.value("NUM_UNITAI_TYPES", NUM_UNITAI_TYPES)
+		///TKs Med
+		.value("UNITAI_TRADER", UNITAI_TRADER)
+		.value("UNITAI_HUNTSMAN", UNITAI_HUNTSMAN)
+		.value("UNITAI_MARAUDER", UNITAI_MARAUDER)
+		///Tke
+		;
+	python::enum_<InvisibleTypes>("InvisibleTypes")
+		.value("NO_INVISIBLE", NO_INVISIBLE)
+		;
+	python::enum_<ProbabilityTypes>("ProbabilityTypes")
+		.value("NO_PROBABILITY", NO_PROBABILITY)
+		.value("PROBABILITY_LOW", PROBABILITY_LOW)
+		.value("PROBABILITY_REAL", PROBABILITY_REAL)
+		.value("PROBABILITY_HIGH", PROBABILITY_HIGH)
+		.value("NUM_PROBABILITY_TYPES", NUM_PROBABILITY_TYPES)
+		;
+	python::enum_<ActivityTypes>("ActivityTypes")
+		.value("NO_ACTIVITY", NO_ACTIVITY)
+		.value("ACTIVITY_AWAKE", ACTIVITY_AWAKE)
+		.value("ACTIVITY_HOLD", ACTIVITY_HOLD)
+		.value("ACTIVITY_SLEEP", ACTIVITY_SLEEP)
+		.value("ACTIVITY_HEAL", ACTIVITY_HEAL)
+		.value("ACTIVITY_SENTRY", ACTIVITY_SENTRY)
+		.value("ACTIVITY_MISSION", ACTIVITY_MISSION)
+		.value("NUM_ACTIVITY_TYPES", NUM_ACTIVITY_TYPES)
+		;
+	python::enum_<AutomateTypes>("AutomateTypes")
+		.value("NO_AUTOMATE", NO_AUTOMATE)
+		.value("AUTOMATE_BUILD", AUTOMATE_BUILD)
+		.value("AUTOMATE_CITY", AUTOMATE_CITY)
+		.value("AUTOMATE_EXPLORE", AUTOMATE_EXPLORE)
+		.value("AUTOMATE_SAIL", AUTOMATE_SAIL)
+		///TKs Med
+		.value("AUTOMATE_HUNT", AUTOMATE_HUNT)
+		.value("AUTOMATE_TRAVEL_FAIR", AUTOMATE_TRAVEL_FAIR)
+        ///TKe
+		.value("AUTOMATE_TRANSPORT_ROUTES", AUTOMATE_TRANSPORT_ROUTES)
+		.value("AUTOMATE_TRANSPORT_FULL", AUTOMATE_TRANSPORT_FULL)
+		///TKs Med
+		.value("AUTOMATE_RETURN_HOME", AUTOMATE_RETURN_HOME)
+		.value("AUTOMATE_IMMIGRATION", AUTOMATE_IMMIGRATION)
+        ///TKe
+		.value("AUTOMATE_FULL", AUTOMATE_FULL)
+		.value("NUM_AUTOMATE_TYPES", NUM_AUTOMATE_TYPES)
+		;
+	python::enum_<MissionTypes>("MissionTypes")
+		.value("NO_MISSION", NO_MISSION)
+		.value("MISSION_MOVE_TO", MISSION_MOVE_TO)
+		.value("MISSION_ROUTE_TO", MISSION_ROUTE_TO)
+		.value("MISSION_MOVE_TO_UNIT", MISSION_MOVE_TO_UNIT)
+		.value("MISSION_SKIP", MISSION_SKIP)
+		.value("MISSION_SLEEP", MISSION_SLEEP)
+		.value("MISSION_FORTIFY", MISSION_FORTIFY)
+		.value("MISSION_HEAL", MISSION_HEAL)
+		.value("MISSION_SENTRY", MISSION_SENTRY)
+		.value("MISSION_BOMBARD", MISSION_BOMBARD)
+		.value("MISSION_PILLAGE", MISSION_PILLAGE)
+		.value("MISSION_FOUND", MISSION_FOUND)
+		.value("MISSION_JOIN_CITY", MISSION_JOIN_CITY)
+		.value("MISSION_LEAD", MISSION_LEAD)
+		.value("MISSION_BUILD", MISSION_BUILD)
+		.value("MISSION_BEGIN_COMBAT", MISSION_BEGIN_COMBAT )
+		.value("MISSION_END_COMBAT", MISSION_END_COMBAT )
+		.value("MISSION_SURRENDER", MISSION_SURRENDER )
+		.value("MISSION_CAPTURED", MISSION_CAPTURED )
+		.value("MISSION_IDLE", MISSION_IDLE )
+		.value("MISSION_DIE", MISSION_DIE )
+		.value("MISSION_DAMAGE", MISSION_DAMAGE )
+		.value("MISSION_MULTI_SELECT", MISSION_MULTI_SELECT )
+		.value("MISSION_MULTI_DESELECT", MISSION_MULTI_DESELECT )
+		///Tks Med
+		.value("MISSION_FOUND_MONASTERY", MISSION_FOUND_MONASTERY)
+		.value("MISSION_FOUND_OUTPOST", MISSION_FOUND_OUTPOST)
+		.value("MISSION_COLLECT_TAXES", MISSION_COLLECT_TAXES)
+		.value("MISSION_HUNT", MISSION_HUNT)
+		.value("NUM_MISSION_TYPES", NUM_MISSION_TYPES )
+		;
+    python::enum_<MedCityTypes>("MedCityTypes")
+		.value("CITYTYPE_DEFAULT", CITYTYPE_DEFAULT)
+		.value("CITYTYPE_COMMERCE", CITYTYPE_COMMERCE)
+		.value("CITYTYPE_MONASTERY", CITYTYPE_MONASTERY)
+		.value("CITYTYPE_OUTPOST", CITYTYPE_OUTPOST)
+		.value("CITYTYPE_BAILEY", CITYTYPE_BAILEY)
+		.value("CITYTYPE_CASTLE", CITYTYPE_CASTLE)
+		.value("CITYTYPE_MILITARY", CITYTYPE_MILITARY)
+		.value("CITYTYPE_NONE_MILITARY", CITYTYPE_NONE_MILITARY)
+		.value("CITYTYPE_NONE_MONASTERY", CITYTYPE_NONE_MONASTERY)
+		.value("NUM_CITY_TYPES", NUM_CITY_TYPES)
+		;
+    python::enum_<TradeScreenTypes>("TradeScreenTypes")
+		.value("TRADE_SCREEN_DEFAULT", TRADE_SCREEN_DEFAULT)
+		.value("TRADE_SCREEN_MOTHERLAND", TRADE_SCREEN_MOTHERLAND)
+		.value("TRADE_SCREEN_TRADE_FAIR", TRADE_SCREEN_TRADE_FAIR)
+		.value("TRADE_SCREEN_SPICE_ROUTE", TRADE_SCREEN_SPICE_ROUTE)
+		.value("TRADE_SCREEN_SILK_ROAD", TRADE_SCREEN_SILK_ROAD)
+		.value("TRADE_SCREEN_EUROPE", TRADE_SCREEN_EUROPE)
+		.value("NUM_TRADE_SCREEN_TYPES", NUM_TRADE_SCREEN_TYPES)
+		;
+     python::enum_<ModCodeTypes>("ModCodeTypes")
+		.value("NO_MOD_CODE", NO_MOD_CODE)
+		.value("MODER_CODE_FASTER_CHOP_TREES", MODER_CODE_FASTER_CHOP_TREES)
+		.value("MODER_CODE_SPICE_ROUTE", MODER_CODE_SPICE_ROUTE)
+		.value("MODER_CODE_SILK_ROAD_ROUTE", MODER_CODE_SILK_ROAD_ROUTE)
+		.value("MODER_CODE_TRADING_POST", MODER_CODE_TRADING_POST)
+		.value("MODER_CODE_ONLY_NONE_NATIVES", MODER_CODE_ONLY_NONE_NATIVES)
+		.value("MODER_CODE_NATIVES_ONLY", MODER_CODE_NATIVES_ONLY)
+		.value("MODER_CODE_ANYONE", MODER_CODE_ANYONE)
+		.value("MODER_CODE_NATIVES_VIKING_AGE", MODER_CODE_NATIVES_VIKING_AGE)
+		.value("MODER_CODE_ALLOWS_TRADE_FAIR", MODER_CODE_ALLOWS_TRADE_FAIR)
+		.value("MODER_CODE_CANNOT_WORK_BUILDINGS", MODER_CODE_CANNOT_WORK_BUILDINGS)
+		.value("MODER_CODE_NONE_MILITARY", MODER_CODE_NONE_MILITARY)
+		.value("MODER_CODE_SQUIRE", MODER_CODE_SQUIRE)
+		.value("MODER_CODE_CRAFTMEN_NOBLES", MODER_CODE_CRAFTMEN_NOBLES)
+		.value("MODER_CODE__AI_ONLY", MODER_CODE_AI_ONLY)
+		.value("MODER_CODE_CANNOT_LEARN_NATIVE", MODER_CODE_CANNOT_LEARN_NATIVE)
+		.value("NUM_MOD_CODE_TYPES", NUM_MOD_CODE_TYPES)
+		;
+     python::enum_<CensureType>("CensureType")
+		.value("NO_CENSURE", NO_CENSURE)
+		.value("CENSURE_EXCOMMUNICATION", CENSURE_EXCOMMUNICATION)
+		.value("CENSURE_INTERDICT", CENSURE_INTERDICT)
+		.value("CENSURE_ANATHEMA", CENSURE_ANATHEMA)
+		.value("CENSURE_CRUSADE", CENSURE_CRUSADE)
+		.value("NUM_CENSURE_TYPES", NUM_CENSURE_TYPES)
+		;
+     python::enum_<TradeRouteTypes>("TradeRouteTypes")
+		.value("NO_TRADE_ROUTES", NO_TRADE_ROUTES)
+		.value("TRADE_ROUTE_EUROPE", TRADE_ROUTE_EUROPE)
+		.value("TRADE_ROUTE_FAIR", TRADE_ROUTE_FAIR)
+		.value("TRADE_ROUTE_SPICE_ROUTE", TRADE_ROUTE_SPICE_ROUTE)
+		.value("TRADE_ROUTE_SILK_ROAD", TRADE_ROUTE_SILK_ROAD)
+		.value("NUM_TRADE_ROUTES_TYPES", NUM_TRADE_ROUTES_TYPES)
+		;
+		///Tke
+	python::enum_<MissionAITypes>("MissionAITypes")
+		.value("NO_MISSIONAI", NO_MISSIONAI)
+		.value("MISSIONAI_SHADOW", MISSIONAI_SHADOW)
+		.value("MISSIONAI_GROUP", MISSIONAI_GROUP)
+		.value("MISSIONAI_LOAD_ASSAULT", MISSIONAI_LOAD_ASSAULT)
+		.value("MISSIONAI_LOAD_SETTLER", MISSIONAI_LOAD_SETTLER)
+		.value("MISSIONAI_LOAD_SPECIAL", MISSIONAI_LOAD_SPECIAL)
+		.value("MISSIONAI_GUARD_CITY", MISSIONAI_GUARD_CITY)
+		.value("MISSIONAI_GUARD_BONUS", MISSIONAI_GUARD_BONUS)
+		.value("MISSIONAI_GUARD_TRADE_NET", MISSIONAI_GUARD_TRADE_NET)
+		.value("MISSIONAI_SPREAD", MISSIONAI_SPREAD)
+		.value("MISSIONAI_EXPLORE", MISSIONAI_EXPLORE)
+		.value("MISSIONAI_PILLAGE", MISSIONAI_PILLAGE)
+		.value("MISSIONAI_FOUND", MISSIONAI_FOUND)
+		.value("MISSIONAI_BUILD", MISSIONAI_BUILD)
+		.value("MISSIONAI_ASSAULT", MISSIONAI_ASSAULT)
+		.value("MISSIONAI_PICKUP", MISSIONAI_PICKUP)
+		.value("MISSIONAI_AWAIT_PICKUP", MISSIONAI_AWAIT_PICKUP)
+		.value("MISSIONAI_SAIL_TO_EUROPE", MISSIONAI_SAIL_TO_EUROPE)
+		.value("MISSIONAI_SAIL_FROM_EUROPE", MISSIONAI_SAIL_FROM_EUROPE)
+		.value("MISSIONAI_TRANSPORT", MISSIONAI_TRANSPORT)
+		.value("MISSIONAI_TRANSPORT_SEA", MISSIONAI_TRANSPORT_SEA)
+		.value("MISSIONAI_PIRACY", MISSIONAI_PIRACY)
+		.value("MISSIONAI_BOMBARD", MISSIONAI_BOMBARD)
+		.value("MISSIONAI_LEARN", MISSIONAI_LEARN)
+		///Tks Med
+		.value("MISSIONAI_PILGRAM", MISSIONAI_PILGRAM)
+		.value("MISSIONAI_HUNT", MISSIONAI_HUNT)
+		///Tke
+		.value("NUM_MISSIONAI_TYPES", NUM_MISSIONAI_TYPES)
+		;
+	// any additions need to be reflected in GlobalTypes.xml
+	python::enum_<CommandTypes>("CommandTypes")
+		.value("NO_COMMAND", NO_COMMAND)
+		.value("COMMAND_PROMOTION", COMMAND_PROMOTION)
+		.value("COMMAND_UPGRADE", COMMAND_UPGRADE)
+		.value("COMMAND_AUTOMATE", COMMAND_AUTOMATE)
+		.value("COMMAND_WAKE", COMMAND_WAKE)
+		.value("COMMAND_CANCEL", COMMAND_CANCEL)
+		.value("COMMAND_CANCEL_ALL", COMMAND_CANCEL_ALL)
+		.value("COMMAND_STOP_AUTOMATION", COMMAND_STOP_AUTOMATION)
+		.value("COMMAND_DELETE", COMMAND_DELETE)
+		.value("COMMAND_GIFT", COMMAND_GIFT)
+		.value("COMMAND_LOAD", COMMAND_LOAD)
+		.value("COMMAND_LOAD_UNIT", COMMAND_LOAD_UNIT)
+		.value("COMMAND_LOAD_CARGO", COMMAND_LOAD_CARGO)
+		.value("COMMAND_LOAD_YIELD", COMMAND_LOAD_YIELD)
+		.value("COMMAND_UNLOAD", COMMAND_UNLOAD)
+		.value("COMMAND_UNLOAD_ALL", COMMAND_UNLOAD_ALL)
+		.value("COMMAND_LEARN", COMMAND_LEARN)
+		.value("COMMAND_KING_TRANSPORT", COMMAND_KING_TRANSPORT)
+		.value("COMMAND_ESTABLISH_MISSION", COMMAND_ESTABLISH_MISSION)
+		.value("COMMAND_SPEAK_WITH_CHIEF", COMMAND_SPEAK_WITH_CHIEF)
+		.value("COMMAND_YIELD_TRADE", COMMAND_YIELD_TRADE)
+		.value("COMMAND_SAIL_TO_EUROPE", COMMAND_SAIL_TO_EUROPE)
+		.value("COMMAND_CHOOSE_TRADE_ROUTES", COMMAND_CHOOSE_TRADE_ROUTES)
+		.value("COMMAND_ASSIGN_TRADE_ROUTE", COMMAND_ASSIGN_TRADE_ROUTE)
+		.value("COMMAND_PROMOTE", COMMAND_PROMOTE)
+		.value("COMMAND_PROFESSION", COMMAND_PROFESSION)
+		.value("COMMAND_CLEAR_SPECIALTY", COMMAND_CLEAR_SPECIALTY)
+		.value("COMMAND_HOTKEY", COMMAND_HOTKEY)
+		///Tks Med
+		.value("COMMAND_CONVERT_UNIT", COMMAND_CONVERT_UNIT)
+		.value("COMMAND_HOLD_FEAST", COMMAND_HOLD_FEAST)
+		.value("COMMAND_TRAVEL_TO_FAIR", COMMAND_TRAVEL_TO_FAIR)
+		.value("COMMAND_SAIL_SPICE_ROUTE", COMMAND_SAIL_SPICE_ROUTE)
+		.value("COMMAND_TRAVEL_SILK_ROAD", COMMAND_TRAVEL_SILK_ROAD)
+		.value("COMMAND_ASSIGN_HOME_CITY", COMMAND_ASSIGN_HOME_CITY)
+		///Tke
+		.value("NUM_COMMAND_TYPES", NUM_COMMAND_TYPES)
+		;
+	python::enum_<ControlTypes>("ControlTypes")
+		.value("NO_CONTROL", NO_CONTROL)
+		.value("CONTROL_CENTERONSELECTION", CONTROL_CENTERONSELECTION)
+		.value("CONTROL_SELECTYUNITTYPE", CONTROL_SELECTYUNITTYPE)
+		.value("CONTROL_SELECTYUNITALL", CONTROL_SELECTYUNITALL)
+		.value("CONTROL_SELECTCITY", CONTROL_SELECTCITY)
+		.value("CONTROL_SELECTCAPITAL", CONTROL_SELECTCAPITAL)
+		.value("CONTROL_NEXTCITY", CONTROL_NEXTCITY)
+		.value("CONTROL_PREVCITY", CONTROL_PREVCITY)
+		.value("CONTROL_NEXTUNIT", CONTROL_NEXTUNIT)
+		.value("CONTROL_PREVUNIT", CONTROL_PREVUNIT)
+		.value("CONTROL_CYCLEUNIT", CONTROL_CYCLEUNIT)
+		.value("CONTROL_CYCLEUNIT_ALT", CONTROL_CYCLEUNIT_ALT)
+		.value("CONTROL_LASTUNIT", CONTROL_LASTUNIT)
+		.value("CONTROL_ENDTURN", CONTROL_ENDTURN)
+		.value("CONTROL_ENDTURN_ALT", CONTROL_ENDTURN_ALT)
+		.value("CONTROL_FORCEENDTURN", CONTROL_FORCEENDTURN)
+		.value("CONTROL_AUTOMOVES", CONTROL_AUTOMOVES)
+		.value("CONTROL_PING", CONTROL_PING)
+		.value("CONTROL_SIGN", CONTROL_SIGN)
+		.value("CONTROL_GRID", CONTROL_GRID)
+		.value("CONTROL_BARE_MAP", CONTROL_BARE_MAP)
+		.value("CONTROL_YIELDS", CONTROL_YIELDS)
+		.value("CONTROL_RESOURCE_ALL", CONTROL_RESOURCE_ALL)
+		.value("CONTROL_UNIT_ICONS", CONTROL_UNIT_ICONS)
+		.value("CONTROL_GLOBELAYER", CONTROL_GLOBELAYER)
+		.value("CONTROL_SCORES", CONTROL_SCORES)
+		.value("CONTROL_LOAD_GAME", CONTROL_LOAD_GAME)
+		.value("CONTROL_OPTIONS_SCREEN", CONTROL_OPTIONS_SCREEN)
+		.value("CONTROL_RETIRE", CONTROL_RETIRE)
+		.value("CONTROL_SAVE_GROUP", CONTROL_SAVE_GROUP)
+		.value("CONTROL_SAVE_NORMAL", CONTROL_SAVE_NORMAL)
+		.value("CONTROL_QUICK_SAVE", CONTROL_QUICK_SAVE)
+		.value("CONTROL_QUICK_LOAD", CONTROL_QUICK_LOAD)
+		.value("CONTROL_ORTHO_CAMERA", CONTROL_ORTHO_CAMERA)
+		.value("CONTROL_CYCLE_CAMERA_FLYING_MODES", CONTROL_CYCLE_CAMERA_FLYING_MODES)
+		.value("CONTROL_ISOMETRIC_CAMERA_LEFT", CONTROL_ISOMETRIC_CAMERA_LEFT)
+		.value("CONTROL_ISOMETRIC_CAMERA_RIGHT", CONTROL_ISOMETRIC_CAMERA_RIGHT)
+		.value("CONTROL_FLYING_CAMERA", CONTROL_FLYING_CAMERA)
+		.value("CONTROL_MOUSE_FLYING_CAMERA", CONTROL_MOUSE_FLYING_CAMERA)
+		.value("CONTROL_TOP_DOWN_CAMERA", CONTROL_TOP_DOWN_CAMERA)
+		.value("CONTROL_CIVILOPEDIA", CONTROL_CIVILOPEDIA)
+		.value("CONTROL_FOREIGN_SCREEN", CONTROL_FOREIGN_SCREEN)
+		.value("CONTROL_CONGRESS_SCREEN", CONTROL_CONGRESS_SCREEN)
+		.value("CONTROL_REVOLUTION_SCREEN", CONTROL_REVOLUTION_SCREEN)
+		.value("CONTROL_EUROPE_SCREEN", CONTROL_EUROPE_SCREEN)
+		.value("CONTROL_MILITARY_SCREEN", CONTROL_MILITARY_SCREEN)
+		.value("CONTROL_FATHER_SCREEN", CONTROL_FATHER_SCREEN)
+		///TKs Invention Core Mod v 1.0
+		.value("CONTROL_TECHNOLOGY_SCREEN", CONTROL_TECHNOLOGY_SCREEN)
+		.value("CONTROL_TRADE_SCREEN", CONTROL_TRADE_SCREEN)
+		.value("CONTROL_SPICE_ROUTE_SCREEN", CONTROL_SPICE_ROUTE_SCREEN)
+		.value("CONTROL_SILK_ROAD_SCREEN", CONTROL_SILK_ROAD_SCREEN)
+		.value("CONTROL_TRADE_FAIR_SCREEN", CONTROL_TRADE_FAIR_SCREEN)
+		.value("CONTROL_IMMIGRATION_SCREEN", CONTROL_IMMIGRATION_SCREEN)
+		///TKe
+		.value("CONTROL_TURN_LOG", CONTROL_TURN_LOG)
+		.value("CONTROL_CHAT_ALL", CONTROL_CHAT_ALL)
+		.value("CONTROL_CHAT_TEAM", CONTROL_CHAT_TEAM)
+		.value("CONTROL_DOMESTIC_SCREEN", CONTROL_DOMESTIC_SCREEN)
+		.value("CONTROL_VICTORY_SCREEN", CONTROL_VICTORY_SCREEN)
+		.value("CONTROL_INFO", CONTROL_INFO)
+		.value("CONTROL_GLOBE_VIEW", CONTROL_GLOBE_VIEW)
+		.value("CONTROL_DETAILS", CONTROL_DETAILS)
+		.value("CONTROL_ADMIN_DETAILS", CONTROL_ADMIN_DETAILS)
+		.value("CONTROL_HALL_OF_FAME", CONTROL_HALL_OF_FAME)
+		.value("CONTROL_WORLD_BUILDER", CONTROL_WORLD_BUILDER)
+		.value("CONTROL_DIPLOMACY", CONTROL_DIPLOMACY)
+		.value("CONTROL_SELECT_HEALTHY", CONTROL_SELECT_HEALTHY)
+		.value("CONTROL_FREE_COLONY", CONTROL_FREE_COLONY)
+		.value("NUM_CONTROL_TYPES", NUM_CONTROL_TYPES)
+		;
+	python::enum_<PromotionTypes>("PromotionTypes")
+		.value("NO_PROMOTION", NO_PROMOTION)
+		;
+	python::enum_<HurryTypes>("HurryTypes")
+		.value("NO_HURRY", NO_HURRY)
+		;
+	python::enum_<CultureLevelTypes>("CultureLevelTypes")
+		.value("NO_CULTURELEVEL", NO_CULTURELEVEL)
+		;
+	python::enum_<CivicOptionTypes>("CivicOptionTypes")
+		.value("NO_CIVICOPTION", NO_CIVICOPTION)
+		;
+	python::enum_<CivicTypes>("CivicTypes")
+		.value("NO_CIVIC", NO_CIVIC)
+		;
+	python::enum_<WarPlanTypes>("WarPlanTypes")
+		.value("NO_WARPLAN", NO_WARPLAN)
+		.value("WARPLAN_ATTACKED_RECENT", WARPLAN_ATTACKED_RECENT)
+		.value("WARPLAN_ATTACKED", WARPLAN_ATTACKED)
+		.value("WARPLAN_PREPARING_LIMITED", WARPLAN_PREPARING_LIMITED)
+		.value("WARPLAN_PREPARING_TOTAL", WARPLAN_PREPARING_TOTAL)
+		.value("WARPLAN_LIMITED", WARPLAN_LIMITED)
+		.value("WARPLAN_TOTAL", WARPLAN_TOTAL)
+		.value("WARPLAN_DOGPILE", WARPLAN_DOGPILE)
+		.value("WARPLAN_EXTORTION", WARPLAN_EXTORTION)
+		.value("NUM_WARPLAN_TYPES", NUM_WARPLAN_TYPES)
+		;
+	python::enum_<AreaAITypes>("AreaAITypes")
+		.value("NO_AREAAI", NO_AREAAI)
+		.value("AREAAI_OFFENSIVE", AREAAI_OFFENSIVE)
+		.value("AREAAI_BALANCED", AREAAI_BALANCED)
+		.value("AREAAI_DEFENSIVE", AREAAI_DEFENSIVE)
+		.value("AREAAI_MASSING", AREAAI_MASSING)
+		.value("AREAAI_ASSAULT", AREAAI_ASSAULT)
+		.value("AREAAI_ASSAULT_MASSING", AREAAI_ASSAULT_MASSING)
+		.value("AREAAI_NEUTRAL", AREAAI_NEUTRAL)
+		.value("NUM_AREAAI_TYPES", NUM_AREAAI_TYPES)
+		;
+	python::enum_<EmotionTypes>("EmotionTypes")
+		.value("NO_EMOTION", NO_EMOTION)
+		.value("EMOTION_GREED", EMOTION_GREED)
+		.value("EMOTION_ANGER", EMOTION_ANGER)
+		.value("EMOTION_ENVY", EMOTION_ENVY)
+		.value("EMOTION_ANXIETY", EMOTION_ANXIETY)
+		.value("EMOTION_SUBMISSION", EMOTION_SUBMISSION)
+		.value("NUM_EMOTION_TYPES", NUM_EMOTION_TYPES)
+		;
+	python::enum_<EndTurnButtonStates>("EndTurnButtonStates")
+		.value("END_TURN_GO", END_TURN_GO)
+		.value("END_TURN_OVER_HIGHLIGHT", END_TURN_OVER_HIGHLIGHT)
+		.value("END_TURN_OVER_DARK", END_TURN_OVER_DARK)
+		.value("NUM_END_TURN_STATES", NUM_END_TURN_STATES)
+		;
+	python::enum_<FogOfWarModeTypes>("FogOfWarModeTypes")
+		.value("FOGOFWARMODE_OFF", FOGOFWARMODE_OFF)
+		.value("FOGOFWARMODE_UNEXPLORED", FOGOFWARMODE_UNEXPLORED)
+		.value("NUM_FOGOFWARMODE_TYPES", NUM_FOGOFWARMODE_TYPES)
+		;
+	python::enum_<AnimationTypes>("AnimationTypes")
+		.value("NONE_ANIMATION", NONE_ANIMATION)
+		.value("BONUSANIMATION_UNIMPROVED", BONUSANIMATION_UNIMPROVED)
+		.value("BONUSANIMATION_NOT_WORKED", BONUSANIMATION_NOT_WORKED)
+		.value("BONUSANIMATION_WORKED", BONUSANIMATION_WORKED)
+		.value("IMPROVEMENTANIMATION_OFF", IMPROVEMENTANIMATION_OFF)
+		.value("IMPROVEMENTANIMATION_ON", IMPROVEMENTANIMATION_ON)
+		.value("IMPROVEMENTANIMATION_OFF_EXTRA", IMPROVEMENTANIMATION_OFF_EXTRA)
+		.value("IMPROVEMENTANIMATION_ON_EXTRA_1", IMPROVEMENTANIMATION_ON_EXTRA_1)
+		.value("IMPROVEMENTANIMATION_ON_EXTRA_2", IMPROVEMENTANIMATION_ON_EXTRA_2)
+		.value("IMPROVEMENTANIMATION_ON_EXTRA_3", IMPROVEMENTANIMATION_ON_EXTRA_3)
+		.value("IMPROVEMENTANIMATION_ON_EXTRA_4", IMPROVEMENTANIMATION_ON_EXTRA_4)
+		;
+	python::enum_<EntityEventTypes>("EntityEventTypes")
+		.value( "ENTITY_EVENT_NONE", ENTITY_EVENT_NONE )
+		;
+	python::enum_<AnimationPathTypes>("AnimationPathTypes")
+		.value( "ANIMATIONPATH_NONE", ANIMATIONPATH_NONE )
+		.value( "ANIMATIONPATH_IDLE", ANIMATIONPATH_IDLE )
+		.value( "ANIMATIONPATH_MOVE", ANIMATIONPATH_MOVE )
+		.value( "ANIMATIONPATH_RANDOMIZE_ANIMATION_SET", ANIMATIONPATH_RANDOMIZE_ANIMATION_SET )
+		.value( "ANIMATIONPATH_MELEE_STRIKE", ANIMATIONPATH_MELEE_STRIKE )
+		.value( "ANIMATIONPATH_MELEE_HURT", ANIMATIONPATH_MELEE_HURT )
+		.value( "ANIMATIONPATH_MELEE_DIE", ANIMATIONPATH_MELEE_DIE )
+		.value( "ANIMATIONPATH_MELEE_FORTIFIED", ANIMATIONPATH_MELEE_FORTIFIED )
+		.value( "ANIMATIONPATH_MELEE_DIE_FADE", ANIMATIONPATH_MELEE_DIE_FADE )
+		.value( "ANIMATIONPATH_RANGED_STRIKE", ANIMATIONPATH_RANGED_STRIKE )
+		.value( "ANIMATIONPATH_RANGED_DIE", ANIMATIONPATH_RANGED_DIE )
+		.value( "ANIMATIONPATH_RANGED_FORTIFIED", ANIMATIONPATH_RANGED_FORTIFIED )
+		.value( "ANIMATIONPATH_RANGED_RUNHIT", ANIMATIONPATH_RANGED_RUNHIT )
+		.value( "ANIMATIONPATH_RANGED_RUNDIE", ANIMATIONPATH_RANGED_RUNDIE )
+		.value( "ANIMATIONPATH_RANGED_DIE_FADE", ANIMATIONPATH_RANGED_DIE_FADE )
+		.value( "ANIMATIONPATH_LEADER_COMMAND", ANIMATIONPATH_LEADER_COMMAND )
+		;
+	python::enum_<AnimationCategoryTypes>("AnimationCategoryTypes")
+		.value("ANIMCAT_NONE", ANIMCAT_NONE)
+		;
+	python::enum_<CursorTypes>("CursorTypes")
+		.value("NO_CURSOR", NO_CURSOR)
+		;
+	python::enum_<TradeableItems>("TradeableItems")
+		.value("NO_TRADEABLE_ITEMS", TRADE_ITEM_NONE)
+		.value("TRADE_GOLD", TRADE_GOLD)
+		.value("TRADE_MAPS", TRADE_MAPS)
+		.value("TRADE_OPEN_BORDERS", TRADE_OPEN_BORDERS)
+		.value("TRADE_DEFENSIVE_PACT", TRADE_DEFENSIVE_PACT)
+		.value("TRADE_PERMANENT_ALLIANCE", TRADE_PERMANENT_ALLIANCE)
+		.value("TRADE_PEACE_TREATY", TRADE_PEACE_TREATY)
+
+		.value("NUM_BASIC_ITEMS", NUM_BASIC_ITEMS)
+		.value("TRADE_YIELD", TRADE_YIELD)
+		///TKs Invention Core Mod v 1.0
+		.value("TRADE_IDEAS", TRADE_IDEAS)
+		.value("TRADE_RESEARCH", TRADE_RESEARCH)
+		///TKe
+		.value("TRADE_CITIES", TRADE_CITIES)
+		.value("TRADE_PEACE", TRADE_PEACE)
+		.value("TRADE_WAR", TRADE_WAR)
+		.value("TRADE_EMBARGO", TRADE_EMBARGO)
+		.value("NUM_TRADEABLE_HEADINGS", NUM_TRADEABLE_HEADINGS)
+		.value("NUM_TRADEABLE_ITEMS", NUM_TRADEABLE_ITEMS)
+		;
+	python::enum_<DiploEventTypes>("DiploEventTypes")
+		.value("NO_DIPLOEVENT", NO_DIPLOEVENT)
+		.value("DIPLOEVENT_CONTACT", DIPLOEVENT_CONTACT)
+		.value("DIPLOEVENT_AI_CONTACT", DIPLOEVENT_AI_CONTACT)
+		.value("DIPLOEVENT_FAILED_CONTACT", DIPLOEVENT_FAILED_CONTACT)
+		.value("DIPLOEVENT_GIVE_HELP", DIPLOEVENT_GIVE_HELP)
+		.value("DIPLOEVENT_REFUSED_HELP", DIPLOEVENT_REFUSED_HELP)
+		.value("DIPLOEVENT_ACCEPT_DEMAND", DIPLOEVENT_ACCEPT_DEMAND)
+		.value("DIPLOEVENT_REJECTED_DEMAND", DIPLOEVENT_REJECTED_DEMAND)
+		.value("DIPLOEVENT_DEMAND_WAR", DIPLOEVENT_DEMAND_WAR)
+		.value("DIPLOEVENT_JOIN_WAR", DIPLOEVENT_JOIN_WAR)
+		.value("DIPLOEVENT_NO_JOIN_WAR", DIPLOEVENT_NO_JOIN_WAR)
+		.value("DIPLOEVENT_STOP_TRADING", DIPLOEVENT_STOP_TRADING)
+		.value("DIPLOEVENT_NO_STOP_TRADING", DIPLOEVENT_NO_STOP_TRADING)
+		.value("DIPLOEVENT_ASK_HELP", DIPLOEVENT_ASK_HELP)
+		.value("DIPLOEVENT_MADE_DEMAND", DIPLOEVENT_MADE_DEMAND)
+		.value("DIPLOEVENT_TARGET_CITY", DIPLOEVENT_TARGET_CITY)
+		.value("DIPLOEVENT_ACCEPT_TAX_RATE", DIPLOEVENT_ACCEPT_TAX_RATE)
+		.value("DIPLOEVENT_REFUSE_TAX_RATE", DIPLOEVENT_REFUSE_TAX_RATE)
+		.value("DIPLOEVENT_ACCEPT_KING_GOLD", DIPLOEVENT_ACCEPT_KING_GOLD)
+		.value("DIPLOEVENT_REFUSE_KING_GOLD", DIPLOEVENT_REFUSE_KING_GOLD)
+		.value("DIPLOEVENT_LIVE_AMONG_NATIVES", DIPLOEVENT_LIVE_AMONG_NATIVES)
+		.value("DIPLOEVENT_TRANSPORT_TREASURE", DIPLOEVENT_TRANSPORT_TREASURE)
+		.value("DIPLOEVENT_FOUND_CITY", DIPLOEVENT_FOUND_CITY)
+		.value("DIPLOEVENT_FOUND_CITY_CHECK_NATIVES", DIPLOEVENT_FOUND_CITY_CHECK_NATIVES)
+		///Tks Med
+		.value("DIPLOEVENT_INSULT_FIRSTCONTACT", DIPLOEVENT_INSULT_FIRSTCONTACT)
+		.value("DIPLOEVENT_ACCEPT_VASSAL", DIPLOEVENT_ACCEPT_VASSAL)
+		.value("DIPLOEVENT_DEMAND_VASSAL_LANDS", DIPLOEVENT_DEMAND_VASSAL_LANDS)
+		///Tke
+		.value("NUM_DIPLOEVENT_TYPES", NUM_DIPLOEVENT_TYPES)
+		;
+	python::enum_<DiploCommentTypes>("DiploCommentTypes")
+		.value("NO_DIPLOCOMMENT", NO_DIPLOCOMMENT)
+		;
+	python::enum_<NetContactTypes>("NetContactTypes")
+		.value("NO_NETCONTACT", NO_NETCONTACT)
+		.value("NETCONTACT_INITIAL", NETCONTACT_INITIAL)
+		.value("NETCONTACT_RESPONSE", NETCONTACT_RESPONSE)
+		.value("NETCONTACT_ESTABLISHED", NETCONTACT_ESTABLISHED)
+		.value("NETCONTACT_BUSY", NETCONTACT_BUSY)
+		.value("NUM_NETCONTACT_TYPES", NUM_NETCONTACT_TYPES)
+		;
+	python::enum_<ContactTypes>("ContactTypes")
+		.value("CONTACT_JOIN_WAR", CONTACT_JOIN_WAR)
+		.value("CONTACT_STOP_TRADING", CONTACT_STOP_TRADING)
+		.value("CONTACT_GIVE_HELP", CONTACT_GIVE_HELP)
+		.value("CONTACT_ASK_FOR_HELP", CONTACT_ASK_FOR_HELP)
+		.value("CONTACT_DEMAND_TRIBUTE", CONTACT_DEMAND_TRIBUTE)
+		.value("CONTACT_OPEN_BORDERS", CONTACT_OPEN_BORDERS)
+		.value("CONTACT_DEFENSIVE_PACT", CONTACT_DEFENSIVE_PACT)
+		.value("CONTACT_PERMANENT_ALLIANCE", CONTACT_PERMANENT_ALLIANCE)
+		.value("CONTACT_PEACE_TREATY", CONTACT_PEACE_TREATY)
+		.value("CONTACT_TRADE_MAP", CONTACT_TRADE_MAP)
+		.value("CONTACT_YIELD_GIFT", CONTACT_YIELD_GIFT)
+		///TKs Invention Core Mod v 1.0
+		.value("CONTACT_TRADE_IDEAS", CONTACT_TRADE_IDEAS)
+		.value("CONTACT_TRADE_RESEARCH", CONTACT_TRADE_RESEARCH)
+		///TKe
+		.value("NUM_CONTACT_TYPES", NUM_CONTACT_TYPES)
+		;
+	python::enum_<MemoryTypes>("MemoryTypes")
+		.value("MEMORY_DECLARED_WAR", MEMORY_DECLARED_WAR)
+		.value("MEMORY_DECLARED_WAR_ON_FRIEND", MEMORY_DECLARED_WAR_ON_FRIEND)
+		.value("MEMORY_HIRED_WAR_ALLY", MEMORY_HIRED_WAR_ALLY)
+		.value("MEMORY_RAZED_CITY", MEMORY_RAZED_CITY)
+		.value("MEMORY_GIVE_HELP", MEMORY_GIVE_HELP)
+		.value("MEMORY_REFUSED_HELP", MEMORY_REFUSED_HELP)
+		.value("MEMORY_ACCEPT_DEMAND", MEMORY_ACCEPT_DEMAND)
+		.value("MEMORY_REJECTED_DEMAND", MEMORY_REJECTED_DEMAND)
+		.value("MEMORY_ACCEPTED_JOIN_WAR", MEMORY_ACCEPTED_JOIN_WAR)
+		.value("MEMORY_DENIED_JOIN_WAR", MEMORY_DENIED_JOIN_WAR)
+		.value("MEMORY_ACCEPTED_STOP_TRADING", MEMORY_ACCEPTED_STOP_TRADING)
+		.value("MEMORY_DENIED_STOP_TRADING", MEMORY_DENIED_STOP_TRADING)
+		.value("MEMORY_STOPPED_TRADING", MEMORY_STOPPED_TRADING)
+		.value("MEMORY_STOPPED_TRADING_RECENT", MEMORY_STOPPED_TRADING_RECENT)
+		.value("MEMORY_HIRED_TRADE_EMBARGO", MEMORY_HIRED_TRADE_EMBARGO)
+		.value("MEMORY_MADE_DEMAND", MEMORY_MADE_DEMAND)
+		.value("MEMORY_MADE_DEMAND_RECENT", MEMORY_MADE_DEMAND_RECENT)
+		.value("MEMORY_CANCELLED_OPEN_BORDERS", MEMORY_CANCELLED_OPEN_BORDERS)
+		.value("MEMORY_EVENT_GOOD_TO_US", MEMORY_EVENT_GOOD_TO_US)
+		.value("MEMORY_EVENT_BAD_TO_US", MEMORY_EVENT_BAD_TO_US)
+		.value("MEMORY_LIBERATED_CITIES", MEMORY_LIBERATED_CITIES)
+		.value("MEMORY_MISSIONARY_FAIL", MEMORY_MISSIONARY_FAIL)
+		///Tks Med
+		.value("MEMORY_INSULTED", MEMORY_INSULTED)
+		.value("MEMORY_MADE_VASSAL_DEMAND", MEMORY_MADE_VASSAL_DEMAND)
+		///Tke
+		.value("NUM_MEMORY_TYPES", NUM_MEMORY_TYPES)
+		;
+	python::enum_<AttitudeTypes>("AttitudeTypes")
+		.value("NO_ATTITUDE", NO_ATTITUDE)
+		.value("ATTITUDE_FURIOUS", ATTITUDE_FURIOUS)
+		.value("ATTITUDE_ANNOYED", ATTITUDE_ANNOYED)
+		.value("ATTITUDE_CAUTIOUS", ATTITUDE_CAUTIOUS)
+		.value("ATTITUDE_PLEASED", ATTITUDE_PLEASED)
+		.value("ATTITUDE_FRIENDLY", ATTITUDE_FRIENDLY)
+		.value("NUM_ATTITUDE_TYPES", NUM_ATTITUDE_TYPES)
+		;
+	python::enum_<LeaderheadAction>("LeaderheadAction")
+		.value( "NO_LEADERANIM", NO_LEADERANIM )
+		.value( "LEADERANIM_GREETING", LEADERANIM_GREETING )
+		.value( "LEADERANIM_FRIENDLY", LEADERANIM_FRIENDLY )
+		.value( "LEADERANIM_PLEASED", LEADERANIM_PLEASED )
+		.value( "LEADERANIM_CAUTIOUS", LEADERANIM_CAUTIOUS )
+		.value( "LEADERANIM_ANNOYED", LEADERANIM_ANNOYED )
+		.value( "LEADERANIM_FURIOUS", LEADERANIM_FURIOUS )
+		.value( "LEADERANIM_DISAGREE", LEADERANIM_DISAGREE )
+		.value( "LEADERANIM_AGREE", LEADERANIM_AGREE )
+		.value( "LEADERANIM_OFFER_PINKY", LEADERANIM_OFFER_PINKY )
+		.value( "LEADERANIM_PINKY_IDLE", LEADERANIM_PINKY_IDLE )
+		.value( "LEADERANIM_PINKY_ACCEPT", LEADERANIM_PINKY_ACCEPT )
+		.value( "LEADERANIM_PINKY_REJECT", LEADERANIM_PINKY_REJECT )
+		.value( "NUM_LEADERANIM_TYPES", NUM_LEADERANIM_TYPES )
+		;
+	python::enum_<DiplomacyPowerTypes>("DiplomacyPowerTypes")
+		.value("NO_DIPLOMACYPOWER", NO_DIPLOMACYPOWER)
+		.value("DIPLOMACYPOWER_WEAKER", DIPLOMACYPOWER_WEAKER)
+		.value("DIPLOMACYPOWER_EQUAL", DIPLOMACYPOWER_EQUAL)
+		.value("DIPLOMACYPOWER_STRONGER", DIPLOMACYPOWER_STRONGER)
+		.value("NUM_DIPLOMACYPOWER_TYPES", NUM_DIPLOMACYPOWER_TYPES)
+		;
+	python::enum_<FeatTypes>("FeatTypes")
+		.value("FEAT_TREASURE", FEAT_TREASURE)
+		.value("FEAT_TREASURE_IN_PORT", FEAT_TREASURE_IN_PORT)
+		.value("FEAT_CITY_MISSING_YIELD", FEAT_CITY_MISSING_YIELD)
+		.value("FEAT_CITY_NO_FOOD", FEAT_CITY_NO_FOOD)
+		.value("FEAT_CITY_INLAND", FEAT_CITY_INLAND)
+		.value("FEAT_EUROPE_SHIPS", FEAT_EUROPE_SHIPS)
+		.value("FEAT_GOTO_EUROPE", FEAT_GOTO_EUROPE)
+		.value("FEAT_TALK_NATIVES", FEAT_TALK_NATIVES)
+		.value("FEAT_CITY_SCREEN", FEAT_CITY_SCREEN)
+		.value("FEAT_PAD", FEAT_PAD)
+		.value("NUM_FEAT_TYPES", NUM_FEAT_TYPES)
+		;
+	python::enum_<SaveGameTypes>("SaveGameTypes")
+		.value("SAVEGAME_NONE", SAVEGAME_NONE)
+		.value("SAVEGAME_AUTO", SAVEGAME_AUTO)
+		.value("SAVEGAME_RECOVERY", SAVEGAME_RECOVERY)
+		.value("SAVEGAME_QUICK", SAVEGAME_QUICK)
+		.value("SAVEGAME_NORMAL", SAVEGAME_NORMAL)
+		.value("SAVEGAME_GROUP", SAVEGAME_GROUP)
+		.value("SAVEGAME_DROP_QUIT", SAVEGAME_DROP_QUIT)
+		.value("SAVEGAME_DROP_CONTINUE", SAVEGAME_DROP_CONTINUE)
+		.value("SAVEGAME_PBEM", SAVEGAME_PBEM)
+		.value("SAVEGAME_REPLAY", SAVEGAME_REPLAY)
+		.value("NUM_SAVEGAME_TYPES", NUM_SAVEGAME_TYPES)
+		;
+	python::enum_<GameType>("GameType")
+		.value("GAME_NONE", GAME_NONE)
+		.value("GAME_SP_NEW", GAME_SP_NEW)
+		.value("GAME_SP_SCENARIO", GAME_SP_SCENARIO)
+		.value("GAME_SP_LOAD", GAME_SP_LOAD)
+		.value("GAME_MP_NEW", GAME_MP_NEW)
+		.value("GAME_MP_SCENARIO", GAME_MP_SCENARIO)
+		.value("GAME_MP_LOAD", GAME_MP_LOAD)
+		.value("GAME_HOTSEAT_NEW", GAME_HOTSEAT_NEW)
+		.value("GAME_HOTSEAT_SCENARIO", GAME_HOTSEAT_SCENARIO)
+		.value("GAME_HOTSEAT_LOAD", GAME_HOTSEAT_LOAD)
+		.value("GAME_PBEM_NEW", GAME_PBEM_NEW)
+		.value("GAME_PBEM_SCENARIO", GAME_PBEM_SCENARIO)
+		.value("GAME_PBEM_LOAD", GAME_PBEM_LOAD)
+		.value("GAME_REPLAY", GAME_REPLAY)
+		.value("NUM_GAMETYPES", NUM_GAMETYPES)
+		;
+	python::enum_<GameMode>("GameMode")
+		.value("NO_GAMEMODE", NO_GAMEMODE)
+		.value("GAMEMODE_NORMAL", GAMEMODE_NORMAL)
+		.value("GAMEMODE_PITBOSS", GAMEMODE_PITBOSS)
+		.value("NUM_GAMEMODES", NUM_GAMEMODES)
+		;
+	python::enum_<InterfaceVisibility>("InterfaceVisibility")
+		.value("INTERFACE_SHOW", INTERFACE_SHOW)
+		.value("INTERFACE_HIDE", INTERFACE_HIDE)
+		.value("INTERFACE_HIDE_ALL", INTERFACE_HIDE_ALL)
+		.value("INTERFACE_MINIMAP_ONLY", INTERFACE_MINIMAP_ONLY)
+		.value("INTERFACE_ADVANCED_START", INTERFACE_ADVANCED_START)
+		;
+	python::enum_<GenericButtonSizes>("GenericButtonSizes")
+		.value("BUTTON_SIZE_46", BUTTON_SIZE_46)
+		.value("BUTTON_SIZE_32", BUTTON_SIZE_32)
+		.value("BUTTON_SIZE_24", BUTTON_SIZE_24)
+		.value("BUTTON_SIZE_16", BUTTON_SIZE_16)
+		.value("BUTTON_SIZE_CUSTOM", BUTTON_SIZE_CUSTOM)
+		;
+	python::enum_<WorldBuilderPopupTypes>("WorldBuilderPopupTypes")
+		.value("WBPOPUP_NONE", WBPOPUP_NONE)
+		.value("WBPOPUP_START", WBPOPUP_START)
+		.value("WBPOPUP_CITY", WBPOPUP_CITY)
+		.value("WBPOPUP_UNIT", WBPOPUP_UNIT)
+		.value("WBPOPUP_PLAYER", WBPOPUP_PLAYER)
+		.value("WBPOPUP_PLOT", WBPOPUP_PLOT)
+		.value("WBPOPUP_TERRAIN", WBPOPUP_TERRAIN)
+		.value("WBPOPUP_FEATURE", WBPOPUP_FEATURE)
+		.value("WBPOPUP_IMPROVEMENT", WBPOPUP_IMPROVEMENT)
+		.value("WBPOPUP_GAME", WBPOPUP_GAME)
+		.value("NUM_WBPOPUP", NUM_WBPOPUP)
+		;
+	python::enum_<EventType>("EventType")
+		.value("EVT_LBUTTONDOWN", EVT_LBUTTONDOWN)
+		.value("EVT_LBUTTONDBLCLICK", EVT_LBUTTONDBLCLICK)
+		.value("EVT_RBUTTONDOWN", EVT_RBUTTONDOWN)
+		.value("EVT_BACK", EVT_BACK)
+		.value("EVT_FORWARD", EVT_FORWARD)
+		.value("EVT_KEYDOWN", EVT_KEYDOWN)
+		.value("EVT_KEYUP", EVT_KEYUP)
+		;
+	python::enum_<LoadType>("LoadType")
+		.value("LOAD_NORMAL", LOAD_NORMAL)
+		.value("LOAD_INIT", LOAD_INIT)
+		.value("LOAD_SETUP", LOAD_SETUP)
+		.value("LOAD_GAMETYPE", LOAD_GAMETYPE)
+		.value("LOAD_REPLAY", LOAD_REPLAY)
+		;
+	python::enum_<FontTypes>("FontTypes")
+		.value("TITLE_FONT", TITLE_FONT)
+		.value("GAME_FONT", GAME_FONT)
+		.value("SMALL_FONT", SMALL_FONT)
+		.value("MENU_FONT", MENU_FONT)
+		.value("MENU_HIGHLIGHT_FONT", MENU_HIGHLIGHT_FONT)
+		;
+	python::enum_<PanelStyles>("PanelStyles")
+		.value("PANEL_STYLE_STANDARD",PANEL_STYLE_STANDARD)
+		.value("PANEL_STYLE_SOLID",PANEL_STYLE_SOLID)
+		.value("PANEL_STYLE_EMPTY",PANEL_STYLE_EMPTY)
+		.value("PANEL_STYLE_FLAT",PANEL_STYLE_FLAT)
+		.value("PANEL_STYLE_IN",PANEL_STYLE_IN)
+		.value("PANEL_STYLE_OUT",PANEL_STYLE_OUT)
+		.value("PANEL_STYLE_EXTERNAL",PANEL_STYLE_EXTERNAL)
+		.value("PANEL_STYLE_DEFAULT",PANEL_STYLE_DEFAULT)
+		.value("PANEL_STYLE_CIVILPEDIA",PANEL_STYLE_CIVILPEDIA)
+		.value("PANEL_STYLE_STONE",PANEL_STYLE_STONE)
+		.value("PANEL_STYLE_BLUELARGE",PANEL_STYLE_BLUELARGE)
+		.value("PANEL_STYLE_UNITSTAT",PANEL_STYLE_UNITSTAT)
+		.value("PANEL_STYLE_BLUE50",PANEL_STYLE_BLUE50)
+		.value("PANEL_STYLE_TOPBAR",PANEL_STYLE_TOPBAR)
+		.value("PANEL_STYLE_BOTTOMBAR",PANEL_STYLE_BOTTOMBAR)
+		.value("PANEL_STYLE_TECH",PANEL_STYLE_TECH)
+		.value("PANEL_STYLE_GAMEHUD_LEFT",PANEL_STYLE_GAMEHUD_LEFT)
+		.value("PANEL_STYLE_GAMEHUD_RIGHT",PANEL_STYLE_GAMEHUD_RIGHT)
+		.value("PANEL_STYLE_GAMEHUD_CENTER",PANEL_STYLE_GAMEHUD_CENTER)
+		.value("PANEL_STYLE_GAMEHUD_STATS",PANEL_STYLE_GAMEHUD_STATS)
+		.value("PANEL_STYLE_GAME_MAP",PANEL_STYLE_GAME_MAP)
+		.value("PANEL_STYLE_GAME_TOPBAR",PANEL_STYLE_GAME_TOPBAR)
+		.value("PANEL_STYLE_HUD_HELP", PANEL_STYLE_HUD_HELP)
+		.value("PANEL_STYLE_CITY_LEFT",PANEL_STYLE_CITY_LEFT)
+		.value("PANEL_STYLE_CITY_RIGHT",PANEL_STYLE_CITY_RIGHT)
+		.value("PANEL_STYLE_CITY_TOP",PANEL_STYLE_CITY_TOP)
+		.value("PANEL_STYLE_CITY_TANSHADE",PANEL_STYLE_CITY_TANSHADE)
+		.value("PANEL_STYLE_CITY_INFO",PANEL_STYLE_CITY_INFO)
+		.value("PANEL_STYLE_CITY_TANTL",PANEL_STYLE_CITY_TANTL)
+		.value("PANEL_STYLE_CITY_TANTR",PANEL_STYLE_CITY_TANTR)
+		.value("PANEL_STYLE_CITY_COLUMNL",PANEL_STYLE_CITY_COLUMNL)
+		.value("PANEL_STYLE_CITY_COLUMNC",PANEL_STYLE_CITY_COLUMNC)
+		.value("PANEL_STYLE_CITY_COLUMNR",PANEL_STYLE_CITY_COLUMNR)
+		.value("PANEL_STYLE_CITY_TITLE",PANEL_STYLE_CITY_TITLE)
+		.value("PANEL_STYLE_DAWN",PANEL_STYLE_DAWN)
+		.value("PANEL_STYLE_DAWNTOP",PANEL_STYLE_DAWNTOP)
+		.value("PANEL_STYLE_DAWNBOTTOM",PANEL_STYLE_DAWNBOTTOM)
+		.value("PANEL_STYLE_MAIN",PANEL_STYLE_MAIN)
+		.value("PANEL_STYLE_MAIN_BLACK25",PANEL_STYLE_MAIN_BLACK25)
+		.value("PANEL_STYLE_MAIN_BLACK50",PANEL_STYLE_MAIN_BLACK50)
+		.value("PANEL_STYLE_MAIN_WHITE",PANEL_STYLE_MAIN_WHITE)
+		.value("PANEL_STYLE_MAIN_WHITETAB",PANEL_STYLE_MAIN_WHITETAB)
+		.value("PANEL_STYLE_MAIN_TAN",PANEL_STYLE_MAIN_TAN)
+		.value("PANEL_STYLE_MAIN_TAN15",PANEL_STYLE_MAIN_TAN15)
+		.value("PANEL_STYLE_MAIN_TANL",PANEL_STYLE_MAIN_TANL)
+		.value("PANEL_STYLE_MAIN_TANR",PANEL_STYLE_MAIN_TANR)
+		.value("PANEL_STYLE_MAIN_TANT",PANEL_STYLE_MAIN_TANT)
+		.value("PANEL_STYLE_MAIN_TANB",PANEL_STYLE_MAIN_TANB)
+		.value("PANEL_STYLE_MAIN_BOTTOMBAR",PANEL_STYLE_MAIN_BOTTOMBAR)
+		.value("PANEL_STYLE_MAIN_SELECT",PANEL_STYLE_MAIN_SELECT)
+		;
+	python::enum_<ButtonStyles>("ButtonStyles")
+		.value("BUTTON_STYLE_STANDARD", BUTTON_STYLE_STANDARD)
+		.value("BUTTON_STYLE_ETCHED", BUTTON_STYLE_ETCHED)
+		.value("BUTTON_STYLE_FLAT", BUTTON_STYLE_FLAT)
+		.value("BUTTON_STYLE_IMAGE", BUTTON_STYLE_IMAGE)
+		.value("BUTTON_STYLE_LABEL", BUTTON_STYLE_LABEL)
+		.value("BUTTON_STYLE_LINK", BUTTON_STYLE_LINK)
+		.value("BUTTON_STYLE_SQUARE", BUTTON_STYLE_SQUARE)
+		.value("BUTTON_STYLE_TOOL", BUTTON_STYLE_TOOL)
+		.value("BUTTON_STYLE_DEFAULT", BUTTON_STYLE_DEFAULT)
+		.value("BUTTON_STYLE_CIRCLE", BUTTON_STYLE_CIRCLE)
+		.value("BUTTON_STYLE_CITY_B01", BUTTON_STYLE_CITY_B01)
+		.value("BUTTON_STYLE_CITY_B02TL", BUTTON_STYLE_CITY_B02TL)
+		.value("BUTTON_STYLE_CITY_B02TR", BUTTON_STYLE_CITY_B02TR)
+		.value("BUTTON_STYLE_CITY_B02BL", BUTTON_STYLE_CITY_B02BL)
+		.value("BUTTON_STYLE_CITY_B02BR", BUTTON_STYLE_CITY_B02BR)
+		.value("BUTTON_STYLE_CITY_B03TL", BUTTON_STYLE_CITY_B03TL)
+		.value("BUTTON_STYLE_CITY_B03TC", BUTTON_STYLE_CITY_B03TC)
+		.value("BUTTON_STYLE_CITY_B03TR", BUTTON_STYLE_CITY_B03TR)
+		.value("BUTTON_STYLE_CITY_B03BL", BUTTON_STYLE_CITY_B03BL)
+		.value("BUTTON_STYLE_CITY_B03BC", BUTTON_STYLE_CITY_B03BC)
+		.value("BUTTON_STYLE_CITY_B03BR", BUTTON_STYLE_CITY_B03BR)
+		.value("BUTTON_STYLE_CITY_FLAT", BUTTON_STYLE_CITY_FLAT)
+		.value("BUTTON_STYLE_CITY_PLUS", BUTTON_STYLE_CITY_PLUS)
+		.value("BUTTON_STYLE_CITY_MINUS", BUTTON_STYLE_CITY_MINUS)
+		.value("BUTTON_STYLE_ARROW_LEFT", BUTTON_STYLE_ARROW_LEFT)
+		.value("BUTTON_STYLE_ARROW_RIGHT", BUTTON_STYLE_ARROW_RIGHT)
+		.value("BUTTON_STYLE_ARROW_UP", BUTTON_STYLE_ARROW_UP)
+		.value("BUTTON_STYLE_ARROW_DOWN", BUTTON_STYLE_ARROW_DOWN)
+		;
+	python::enum_<ImageShapes>("ImageShapes")
+		.value("IMAGE_SHAPE_RECTANGLE", IMAGE_SHAPE_RECTANGLE)
+		.value("IMAGE_SHAPE_ELLIPSE", IMAGE_SHAPE_ELLIPSE)
+		.value("IMAGE_SHAPE_PARABOLA_TOP", IMAGE_SHAPE_PARABOLA_TOP)
+		;
+	python::enum_<TableStyles>("TableStyles")
+		.value("TABLE_STYLE_STANDARD", TABLE_STYLE_STANDARD)
+		.value("TABLE_STYLE_EMPTY", TABLE_STYLE_EMPTY)
+		.value("TABLE_STYLE_ALTEMPTY", TABLE_STYLE_ALTEMPTY)
+		.value("TABLE_STYLE_CITY", TABLE_STYLE_CITY)
+		.value("TABLE_STYLE_EMPTYSELECTINACTIVE", TABLE_STYLE_EMPTYSELECTINACTIVE)
+		.value("TABLE_STYLE_ALTDEFAULT", TABLE_STYLE_ALTDEFAULT)
+		.value("TABLE_STYLE_STAGINGROOM", TABLE_STYLE_STAGINGROOM)
+		;
+	python::enum_<EventContextTypes>("EventContextTypes")
+		.value("NO_EVENTCONTEXT", NO_EVENTCONTEXT)
+		.value("EVENTCONTEXT_SELF", EVENTCONTEXT_SELF)
+		.value("EVENTCONTEXT_ALL", EVENTCONTEXT_ALL)
+		;
+	python::enum_<TabGroupTypes>("TabGroupTypes")
+		.value("NO_TABGROUP", NO_TABGROUP)
+		.value("TABGROUP_GAME", TABGROUP_GAME)
+		.value("TABGROUP_INPUT", TABGROUP_INPUT)
+		.value("TABGROUP_GRAPHICS", TABGROUP_GRAPHICS)
+		.value("TABGROUP_AUDIO", TABGROUP_AUDIO)
+		.value("TABGROUP_CLOCK", TABGROUP_CLOCK)
+		.value("NUM_TABGROUPS", NUM_TABGROUPS)
+		;
+	python::enum_<ReplayMessageTypes>("ReplayMessageTypes")
+		.value("NO_REPLAY_MESSAGE", NO_REPLAY_MESSAGE)
+		.value("REPLAY_MESSAGE_MAJOR_EVENT", REPLAY_MESSAGE_MAJOR_EVENT)
+		.value("REPLAY_MESSAGE_CITY_FOUNDED", REPLAY_MESSAGE_CITY_FOUNDED)
+		.value("REPLAY_MESSAGE_PLOT_OWNER_CHANGE", REPLAY_MESSAGE_PLOT_OWNER_CHANGE)
+		.value("NUM_REPLAY_MESSAGE_TYPES", NUM_REPLAY_MESSAGE_TYPES)
+		;
+	python::enum_<AudioTag>("AudioTag")
+		.value("AUDIOTAG_NONE", AUDIOTAG_NONE)
+		.value("AUDIOTAG_SOUNDID", AUDIOTAG_SOUNDID)
+		.value("AUDIOTAG_CONTEXTID", AUDIOTAG_CONTEXTID)
+		.value("AUDIOTAG_SOUNDTYPE", AUDIOTAG_SOUNDTYPE)
+		.value("AUDIOTAG_2DSCRIPT", AUDIOTAG_2DSCRIPT)
+		.value("AUDIOTAG_3DSCRIPT", AUDIOTAG_3DSCRIPT)
+		.value("AUDIOTAG_SOUNDSCAPE", AUDIOTAG_SOUNDSCAPE)
+		.value("AUDIOTAG_POSITION", AUDIOTAG_POSITION)
+		.value("AUDIOTAG_SCRIPTTYPE", AUDIOTAG_SCRIPTTYPE)
+		.value("AUDIOTAG_LOADTYPE", AUDIOTAG_LOADTYPE)
+		.value("AUDIOTAG_COUNT", AUDIOTAG_COUNT)
+		;
+	python::enum_<CivilopediaPageTypes>("CivilopediaPageTypes")
+		.value("NO_CIVILOPEDIA_PAGE", NO_CIVILOPEDIA_PAGE)
+		.value("CIVILOPEDIA_PAGE_UNIT", CIVILOPEDIA_PAGE_UNIT)
+		.value("CIVILOPEDIA_PAGE_PROFESSION", CIVILOPEDIA_PAGE_PROFESSION)
+		.value("CIVILOPEDIA_PAGE_BUILDING", CIVILOPEDIA_PAGE_BUILDING)
+		.value("CIVILOPEDIA_PAGE_FATHER", CIVILOPEDIA_PAGE_FATHER)
+		.value("CIVILOPEDIA_PAGE_BONUS", CIVILOPEDIA_PAGE_BONUS)
+		.value("CIVILOPEDIA_PAGE_IMPROVEMENT", CIVILOPEDIA_PAGE_IMPROVEMENT)
+		.value("CIVILOPEDIA_PAGE_PROMOTION", CIVILOPEDIA_PAGE_PROMOTION)
+		.value("CIVILOPEDIA_PAGE_CIV", CIVILOPEDIA_PAGE_CIV)
+		.value("CIVILOPEDIA_PAGE_LEADER", CIVILOPEDIA_PAGE_LEADER)
+		.value("CIVILOPEDIA_PAGE_CIVIC", CIVILOPEDIA_PAGE_CIVIC)
+		.value("CIVILOPEDIA_PAGE_CONCEPT", CIVILOPEDIA_PAGE_CONCEPT)
+		.value("CIVILOPEDIA_PAGE_TERRAIN", CIVILOPEDIA_PAGE_TERRAIN)
+		.value("CIVILOPEDIA_PAGE_YIELDS", CIVILOPEDIA_PAGE_YIELDS)
+		.value("CIVILOPEDIA_PAGE_FEATURE", CIVILOPEDIA_PAGE_FEATURE)
+		.value("CIVILOPEDIA_PAGE_HINTS", CIVILOPEDIA_PAGE_HINTS)
+		///TKs Invention Core Mod v 1.0
+		.value("CIVILOPEDIA_PAGE_TECHNOLOGY", CIVILOPEDIA_PAGE_TECHNOLOGY)
+		///TKe
+		.value("NUM_CIVILOPEDIA_PAGE_TYPES", NUM_CIVILOPEDIA_PAGE_TYPES)
+		;
+	python::enum_<ActionSubTypes>("ActionSubTypes")
+		.value("NO_ACTIONSUBTYPE", NO_ACTIONSUBTYPE)
+		.value("ACTIONSUBTYPE_INTERFACEMODE", ACTIONSUBTYPE_INTERFACEMODE)
+		.value("ACTIONSUBTYPE_COMMAND", ACTIONSUBTYPE_COMMAND)
+		.value("ACTIONSUBTYPE_BUILD", ACTIONSUBTYPE_BUILD)
+		.value("ACTIONSUBTYPE_PROMOTION", ACTIONSUBTYPE_PROMOTION)
+		.value("ACTIONSUBTYPE_UNIT", ACTIONSUBTYPE_UNIT)
+		.value("ACTIONSUBTYPE_CONTROL", ACTIONSUBTYPE_CONTROL)
+		.value("ACTIONSUBTYPE_AUTOMATE", ACTIONSUBTYPE_AUTOMATE)
+		.value("ACTIONSUBTYPE_MISSION", ACTIONSUBTYPE_MISSION)
+		.value("NUM_ACTIONSUBTYPES", NUM_ACTIONSUBTYPES)
+		;
+	python::enum_<GameMessageTypes>("GameMessageTypes")
+		.value("GAMEMESSAGE_NETWORK_READY", GAMEMESSAGE_NETWORK_READY)
+		.value("GAMEMESSAGE_SAVE_GAME_FLAG", GAMEMESSAGE_SAVE_GAME_FLAG)
+		.value("GAMEMESSAGE_SAVE_FLAG_ACK", GAMEMESSAGE_SAVE_FLAG_ACK)
+		.value("GAMEMESSAGE_VERIFY_VERSION", GAMEMESSAGE_VERIFY_VERSION)
+		.value("GAMEMESSAGE_VERSION_NACK", GAMEMESSAGE_VERSION_NACK)
+		.value("GAMEMESSAGE_VERSION_WARNING", GAMEMESSAGE_VERSION_WARNING)
+		.value("GAMEMESSAGE_GAME_TYPE", GAMEMESSAGE_GAME_TYPE)
+		.value("GAMEMESSAGE_ID_ASSIGNMENT", GAMEMESSAGE_ID_ASSIGNMENT)
+		.value("GAMEMESSAGE_FILE_INFO", GAMEMESSAGE_FILE_INFO)
+		.value("GAMEMESSAGE_PICK_YOUR_CIV", GAMEMESSAGE_PICK_YOUR_CIV)
+		.value("GAMEMESSAGE_CIV_CHOICE", GAMEMESSAGE_CIV_CHOICE)
+		.value("GAMEMESSAGE_CONFIRM_CIV_CLAIM", GAMEMESSAGE_CONFIRM_CIV_CLAIM)
+		.value("GAMEMESSAGE_CLAIM_INFO", GAMEMESSAGE_CLAIM_INFO)
+		.value("GAMEMESSAGE_CIV_CHOICE_ACK", GAMEMESSAGE_CIV_CHOICE_ACK)
+		.value("GAMEMESSAGE_CIV_CHOICE_NACK", GAMEMESSAGE_CIV_CHOICE_NACK)
+		.value("GAMEMESSAGE_CIV_CHOSEN", GAMEMESSAGE_CIV_CHOSEN)
+		.value("GAMEMESSAGE_INTERIM_NOTICE", GAMEMESSAGE_INTERIM_NOTICE)
+		.value("GAMEMESSAGE_INIT_INFO", GAMEMESSAGE_INIT_INFO)
+		.value("GAMEMESSAGE_MAPSCRIPT_CHECK", GAMEMESSAGE_MAPSCRIPT_CHECK)
+		.value("GAMEMESSAGE_MAPSCRIPT_ACK", GAMEMESSAGE_MAPSCRIPT_ACK)
+		.value("GAMEMESSAGE_LOAD_GAME", GAMEMESSAGE_LOAD_GAME)
+		.value("GAMEMESSAGE_PLAYER_ID", GAMEMESSAGE_PLAYER_ID)
+		.value("GAMEMESSAGE_SLOT_REASSIGNMENT", GAMEMESSAGE_SLOT_REASSIGNMENT)
+		.value("GAMEMESSAGE_PLAYER_INFO", GAMEMESSAGE_PLAYER_INFO)
+		.value("GAMEMESSAGE_GAME_INFO", GAMEMESSAGE_GAME_INFO)
+		.value("GAMEMESSAGE_REASSIGN_PLAYER", GAMEMESSAGE_REASSIGN_PLAYER)
+		.value("GAMEMESSAGE_PITBOSS_INFO", GAMEMESSAGE_PITBOSS_INFO)
+		.value("GAMEMESSAGE_LAUNCHING_INFO", GAMEMESSAGE_LAUNCHING_INFO)
+		.value("GAMEMESSAGE_INIT_GAME", GAMEMESSAGE_INIT_GAME)
+		.value("GAMEMESSAGE_INIT_PLAYERS", GAMEMESSAGE_INIT_PLAYERS)
+		.value("GAMEMESSAGE_AUTH_REQUEST", GAMEMESSAGE_AUTH_REQUEST)
+		.value("GAMEMESSAGE_AUTH_RESPONSE", GAMEMESSAGE_AUTH_RESPONSE)
+		.value("GAMEMESSAGE_SYNCH_START", GAMEMESSAGE_SYNCH_START)
+		.value("GAMEMESSAGE_EXTENDED_GAME", GAMEMESSAGE_EXTENDED_GAME)
+		.value("GAMEMESSAGE_JOIN_GROUP", GAMEMESSAGE_JOIN_GROUP)
+		.value("GAMEMESSAGE_PUSH_MISSION", GAMEMESSAGE_PUSH_MISSION)
+		.value("GAMEMESSAGE_AUTO_MISSION", GAMEMESSAGE_AUTO_MISSION)
+		.value("GAMEMESSAGE_DO_COMMAND", GAMEMESSAGE_DO_COMMAND)
+		.value("GAMEMESSAGE_PUSH_ORDER", GAMEMESSAGE_PUSH_ORDER)
+		.value("GAMEMESSAGE_POP_ORDER", GAMEMESSAGE_POP_ORDER)
+		.value("GAMEMESSAGE_DO_TASK", GAMEMESSAGE_DO_TASK)
+		.value("GAMEMESSAGE_CHAT", GAMEMESSAGE_CHAT)
+		.value("GAMEMESSAGE_PING", GAMEMESSAGE_PING)
+		.value("GAMEMESSAGE_SIGN", GAMEMESSAGE_SIGN)
+		.value("GAMEMESSAGE_LINE_ENTITY", GAMEMESSAGE_LINE_ENTITY)
+		.value("GAMEMESSAGE_SIGN_DELETE", GAMEMESSAGE_SIGN_DELETE)
+		.value("GAMEMESSAGE_LINE_ENTITY_DELETE", GAMEMESSAGE_LINE_ENTITY_DELETE)
+		.value("GAMEMESSAGE_LINE_GROUP_DELETE", GAMEMESSAGE_LINE_GROUP_DELETE)
+		.value("GAMEMESSAGE_PAUSE", GAMEMESSAGE_PAUSE)
+		.value("GAMEMESSAGE_MP_KICK", GAMEMESSAGE_MP_KICK)
+		.value("GAMEMESSAGE_MP_RETIRE", GAMEMESSAGE_MP_RETIRE)
+		.value("GAMEMESSAGE_CLOSE_CONNECTION", GAMEMESSAGE_CLOSE_CONNECTION)
+		.value("GAMEMESSAGE_NEVER_JOINED", GAMEMESSAGE_NEVER_JOINED)
+		.value("GAMEMESSAGE_MP_DROP_INIT", GAMEMESSAGE_MP_DROP_INIT)
+		.value("GAMEMESSAGE_MP_DROP_VOTE", GAMEMESSAGE_MP_DROP_VOTE)
+		.value("GAMEMESSAGE_MP_DROP_UPDATE", GAMEMESSAGE_MP_DROP_UPDATE)
+		.value("GAMEMESSAGE_MP_DROP_RESULT", GAMEMESSAGE_MP_DROP_RESULT)
+		.value("GAMEMESSAGE_MP_DROP_SAVE", GAMEMESSAGE_MP_DROP_SAVE)
+		.value("GAMEMESSAGE_TOGGLE_TRADE", GAMEMESSAGE_TOGGLE_TRADE)
+		.value("GAMEMESSAGE_IMPLEMENT_OFFER", GAMEMESSAGE_IMPLEMENT_OFFER)
+		.value("GAMEMESSAGE_CHANGE_WAR", GAMEMESSAGE_CHANGE_WAR)
+		.value("GAMEMESSAGE_APPLY_EVENT", GAMEMESSAGE_APPLY_EVENT)
+		.value("GAMEMESSAGE_CONTACT_CIV", GAMEMESSAGE_CONTACT_CIV)
+		.value("GAMEMESSAGE_DIPLO_CHAT", GAMEMESSAGE_DIPLO_CHAT)
+		.value("GAMEMESSAGE_SEND_OFFER", GAMEMESSAGE_SEND_OFFER)
+		.value("GAMEMESSAGE_DIPLO_EVENT", GAMEMESSAGE_DIPLO_EVENT)
+		.value("GAMEMESSAGE_RENEGOTIATE", GAMEMESSAGE_RENEGOTIATE)
+		.value("GAMEMESSAGE_RENEGOTIATE_ITEM", GAMEMESSAGE_RENEGOTIATE_ITEM)
+		.value("GAMEMESSAGE_EXIT_TRADE", GAMEMESSAGE_EXIT_TRADE)
+		.value("GAMEMESSAGE_KILL_DEAL", GAMEMESSAGE_KILL_DEAL)
+		.value("GAMEMESSAGE_SAVE_GAME", GAMEMESSAGE_SAVE_GAME)
+		.value("GAMEMESSAGE_UPDATE_CIVICS", GAMEMESSAGE_UPDATE_CIVICS)
+		.value("GAMEMESSAGE_CLEAR_TABLE", GAMEMESSAGE_CLEAR_TABLE)
+		.value("GAMEMESSAGE_POPUP_PROCESSED", GAMEMESSAGE_POPUP_PROCESSED)
+		.value("GAMEMESSAGE_DIPLOMACY_PROCESSED", GAMEMESSAGE_DIPLOMACY_PROCESSED)
+		.value("GAMEMESSAGE_HOT_JOIN_NOTICE", GAMEMESSAGE_HOT_JOIN_NOTICE)
+		.value("GAMEMESSAGE_HOT_DROP_NOTICE", GAMEMESSAGE_HOT_DROP_NOTICE)
+		.value("GAMEMESSAGE_DIPLOMACY", GAMEMESSAGE_DIPLOMACY)
+		.value("GAMEMESSAGE_POPUP", GAMEMESSAGE_POPUP)
+		.value("GAMEMESSAGE_ADVANCED_START_ACTION", GAMEMESSAGE_ADVANCED_START_ACTION)
+		.value("GAMEMESSAGE_PLAYER_ACTION", GAMEMESSAGE_PLAYER_ACTION)
+		.value("GAMEMESSAGE_MOD_NET_MESSAGE", GAMEMESSAGE_MOD_NET_MESSAGE)
+		;
+	python::enum_<PopupControlLayout>("PopupControlLayout")
+		.value("POPUP_LAYOUT_LEFT", POPUP_LAYOUT_LEFT)
+		.value("POPUP_LAYOUT_CENTER", POPUP_LAYOUT_CENTER)
+		.value("POPUP_LAYOUT_RIGHT", POPUP_LAYOUT_RIGHT)
+		.value("POPUP_LAYOUT_STRETCH", POPUP_LAYOUT_STRETCH)
+		.value("POPUP_LAYOUT_TOP", POPUP_LAYOUT_TOP)
+		.value("POPUP_LAYOUT_NUMLAYOUTS", POPUP_LAYOUT_NUMLAYOUTS)
+		;
+	python::enum_<JustificationTypes>("JustificationTypes")
+		.value("DLL_FONT_LEFT_JUSTIFY", DLL_FONT_LEFT_JUSTIFY)
+		.value("DLL_FONT_RIGHT_JUSTIFY", DLL_FONT_RIGHT_JUSTIFY)
+		.value("DLL_FONT_CENTER_JUSTIFY", DLL_FONT_CENTER_JUSTIFY)
+		.value("DLL_FONT_CENTER_VERTICALLY", DLL_FONT_CENTER_VERTICALLY)
+		.value("DLL_FONT_ADDITIVE", DLL_FONT_ADDITIVE)
+		;
+	python::enum_<ToolTipAlignTypes>("ToolTipAlignTypes")
+		.value("TOOLTIP_TOP_LEFT", TOOLTIP_TOP_LEFT)
+		.value("TOOLTIP_TOP_INLEFT", TOOLTIP_TOP_INLEFT)
+		.value("TOOLTIP_TOP_CENTER", TOOLTIP_TOP_CENTER)
+		.value("TOOLTIP_TOP_INRIGHT", TOOLTIP_TOP_INRIGHT)
+		.value("TOOLTIP_TOP_RIGHT", TOOLTIP_TOP_RIGHT)
+		.value("TOOLTIP_INTOP_RIGHT", TOOLTIP_INTOP_RIGHT)
+		.value("TOOLTIP_CENTER_RIGHT", TOOLTIP_CENTER_RIGHT)
+		.value("TOOLTIP_INBOTTOM_RIGHT", TOOLTIP_INBOTTOM_RIGHT)
+		.value("TOOLTIP_BOTTOM_RIGHT", TOOLTIP_BOTTOM_RIGHT)
+		.value("TOOLTIP_BOTTOM_INRIGHT", TOOLTIP_BOTTOM_INRIGHT)
+		.value("TOOLTIP_BOTTOM_CENTER", TOOLTIP_BOTTOM_CENTER)
+		.value("TOOLTIP_BOTTOM_INLEFT", TOOLTIP_BOTTOM_INLEFT)
+		.value("TOOLTIP_BOTTOM_LEFT", TOOLTIP_BOTTOM_LEFT)
+		.value("TOOLTIP_INBOTTOM_LEFT", TOOLTIP_INBOTTOM_LEFT)
+		.value("TOOLTIP_CENTER_LEFT", TOOLTIP_CENTER_LEFT)
+		.value("TOOLTIP_INTOP_LEFT", TOOLTIP_INTOP_LEFT)
+		;
+	python::enum_<ActivationTypes>("ActivationTypes")
+		.value("ACTIVATE_NORMAL", ACTIVATE_NORMAL)
+		.value("ACTIVATE_CHILDFOCUS", ACTIVATE_CHILDFOCUS)
+		.value("ACTIVATE_MIMICPARENT", ACTIVATE_MIMICPARENT)
+		.value("ACTIVATE_MIMICPARENTFOCUS", ACTIVATE_MIMICPARENTFOCUS)
+		;
+	python::enum_<HitTestTypes>("HitTestTypes")
+		.value("HITTEST_DEFAULT", HITTEST_DEFAULT)
+		.value("HITTEST_NOHIT", HITTEST_NOHIT)
+		.value("HITTEST_SOLID", HITTEST_SOLID)
+		.value("HITTEST_ON", HITTEST_ON)
+		.value("HITTEST_CHILDREN", HITTEST_CHILDREN)
+		;
+	python::enum_<GraphicLevelTypes>("GraphicLevelTypes")
+		.value("GRAPHICLEVEL_HIGH", GRAPHICLEVEL_HIGH)
+		.value("GRAPHICLEVEL_MEDIUM", GRAPHICLEVEL_MEDIUM)
+		.value("GRAPHICLEVEL_LOW", GRAPHICLEVEL_LOW)
+		.value("GRAPHICLEVEL_CURRENT", GRAPHICLEVEL_CURRENT)
+		.value("GRAPHICLEVEL_BELOW_SPEC", GRAPHICLEVEL_BELOW_SPEC)
+		.value("NUM_GRAPHICLEVELS", NUM_GRAPHICLEVELS)
+		;
+	python::enum_<EventTypes>("EventTypes")
+		.value("NO_EVENT", NO_EVENT)
+		;
+	python::enum_<EventTriggerTypes>("EventTriggerTypes")
+		.value("NO_EVENTTRIGGER", NO_EVENTTRIGGER)
+		;
+	python::enum_<AdvancedStartActionTypes>("AdvancedStartActionTypes")
+		.value("NO_ADVANCEDSTARTACTION", NO_ADVANCEDSTARTACTION)
+		.value("ADVANCEDSTARTACTION_EXIT", ADVANCEDSTARTACTION_EXIT)
+		.value("ADVANCEDSTARTACTION_UNIT", ADVANCEDSTARTACTION_UNIT)
+		.value("ADVANCEDSTARTACTION_CITY", ADVANCEDSTARTACTION_CITY)
+		.value("ADVANCEDSTARTACTION_POP", ADVANCEDSTARTACTION_POP)
+		.value("ADVANCEDSTARTACTION_CULTURE", ADVANCEDSTARTACTION_CULTURE)
+		.value("ADVANCEDSTARTACTION_BUILDING", ADVANCEDSTARTACTION_BUILDING)
+		.value("ADVANCEDSTARTACTION_IMPROVEMENT", ADVANCEDSTARTACTION_IMPROVEMENT)
+		.value("ADVANCEDSTARTACTION_ROUTE", ADVANCEDSTARTACTION_ROUTE)
+		.value("ADVANCEDSTARTACTION_VISIBILITY", ADVANCEDSTARTACTION_VISIBILITY)
+		.value("ADVANCEDSTARTACTION_AUTOMATE", ADVANCEDSTARTACTION_AUTOMATE)
+		.value("NUM_ADVANCEDSTARTACTIONS", NUM_ADVANCEDSTARTACTIONS)
+		;
+	python::enum_<UnitTravelStates>("UnitTravelStates")
+		.value("NO_UNIT_TRAVEL_STATE", NO_UNIT_TRAVEL_STATE)
+		.value("UNIT_TRAVEL_STATE_TO_EUROPE", UNIT_TRAVEL_STATE_TO_EUROPE)
+		.value("UNIT_TRAVEL_STATE_IN_EUROPE", UNIT_TRAVEL_STATE_IN_EUROPE)
+		.value("UNIT_TRAVEL_STATE_FROM_EUROPE", UNIT_TRAVEL_STATE_FROM_EUROPE)
+		.value("UNIT_TRAVEL_STATE_LIVE_AMONG_NATIVES", UNIT_TRAVEL_STATE_LIVE_AMONG_NATIVES)
+		///TKs Med
+		.value("UNIT_TRAVEL_STATE_HIDE_UNIT", UNIT_TRAVEL_STATE_HIDE_UNIT)
+		.value("UNIT_TRAVEL_LOST_AT_SEA", UNIT_TRAVEL_LOST_AT_SEA)
+		.value("UNIT_TRAVEL_STATE_TO_SPICE_ROUTE", UNIT_TRAVEL_STATE_TO_SPICE_ROUTE)
+		.value("UNIT_TRAVEL_STATE_IN_SPICE_ROUTE", UNIT_TRAVEL_STATE_IN_SPICE_ROUTE)
+		.value("UNIT_TRAVEL_STATE_FROM_SPICE_ROUTE", UNIT_TRAVEL_STATE_FROM_SPICE_ROUTE)
+		.value("UNIT_TRAVEL_STATE_TO_SILK_ROAD", UNIT_TRAVEL_STATE_TO_SILK_ROAD)
+		.value("UNIT_TRAVEL_STATE_IN_SILK_ROAD", UNIT_TRAVEL_STATE_IN_SILK_ROAD)
+		.value("UNIT_TRAVEL_STATE_FROM_SILK_ROAD", UNIT_TRAVEL_STATE_FROM_SILK_ROAD)
+		.value("UNIT_TRAVEL_STATE_TO_TRADE_FAIR", UNIT_TRAVEL_STATE_TO_TRADE_FAIR)
+		.value("UNIT_TRAVEL_STATE_FROM_TRADE_FAIR", UNIT_TRAVEL_STATE_FROM_TRADE_FAIR)
+		.value("UNIT_TRAVEL_STATE_IN_TRADE_FAIR", UNIT_TRAVEL_STATE_IN_TRADE_FAIR)
+		.value("UNIT_TRAVEL_STATE_FROM_IMMIGRATION", UNIT_TRAVEL_STATE_FROM_IMMIGRATION)
+		///TKe
+		.value("NUM_UNIT_TRAVEL_STATES", NUM_UNIT_TRAVEL_STATES)
+		;
+	python::enum_<FatherCategoryTypes>("FatherCategoryTypes")
+		.value("NO_FATHERCATEGORY", NO_FATHERCATEGORY)
+		;
+	python::enum_<FatherTypes>("FatherTypes")
+		.value("NO_FATHER", NO_FATHER)
+		;
+	python::enum_<FatherPointTypes>("FatherPointTypes")
+		.value("NO_FATHER_POINT_TYPE", NO_FATHER_POINT_TYPE)
+		;
+	python::enum_<AlarmTypes>("AlarmTypes")
+		.value("NO_ALARM", NO_ALARM)
+		;
+}
diff --git a/DLL_Sources/Medieval_Tech.sln b/DLL_Sources/Medieval_Tech.sln
index 2363fa5..2142a62 100644
--- a/DLL_Sources/Medieval_Tech.sln
+++ b/DLL_Sources/Medieval_Tech.sln
@@ -8,6 +8,7 @@ Global
 		Assert|Win32 = Assert|Win32
 		Assert-fast|Win32 = Assert-fast|Win32
 		Assert-upload|Win32 = Assert-upload|Win32
+		Colonization 2071|Win32 = Colonization 2071|Win32
 		Debug|Win32 = Debug|Win32
 		Profile|Win32 = Profile|Win32
 		Release|Win32 = Release|Win32
@@ -20,6 +21,8 @@ Global
 		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Assert-fast|Win32.Build.0 = Assert-fast|Win32
 		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Assert-upload|Win32.ActiveCfg = Assert-upload|Win32
 		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Assert-upload|Win32.Build.0 = Assert-upload|Win32
+		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Colonization 2071|Win32.ActiveCfg = Colonization 2071|Win32
+		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Colonization 2071|Win32.Build.0 = Colonization 2071|Win32
 		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Debug|Win32.ActiveCfg = Debug|Win32
 		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Debug|Win32.Build.0 = Debug|Win32
 		{3021AF0E-699D-4232-86F6-FC374A0C9957}.Profile|Win32.ActiveCfg = Profile|Win32
diff --git a/DLL_Sources/Medieval_Tech.vcxproj b/DLL_Sources/Medieval_Tech.vcxproj
index d9adfc9..4fbaf4d 100644
--- a/DLL_Sources/Medieval_Tech.vcxproj
+++ b/DLL_Sources/Medieval_Tech.vcxproj
@@ -13,6 +13,10 @@
       <Configuration>Assert</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
+    <ProjectConfiguration Include="Colonization 2071|Win32">
+      <Configuration>Colonization 2071</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
       <Platform>Win32</Platform>
@@ -31,6 +35,9 @@
     </ProjectConfiguration>
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="Yields_Colonization_2071.cpp" />
+    <ClCompile Include="Yields_Medieval_Tech.cpp" />
+    <ClCompile Include="Yields.cpp" />
     <ClCompile Include="CvArea.cpp" />
     <ClCompile Include="CvArtFileMgr.cpp" />
     <ClCompile Include="CvCity.cpp" />
@@ -130,6 +137,10 @@
     <None Include="interfaceDirtyBits.inl" />
   </ItemGroup>
   <ItemGroup>
+    <ClInclude Include="YieldsTestBase.h" />
+    <ClInclude Include="Yields_Colonization_2071.h" />
+    <ClInclude Include="Yields_Medieval_Tech.h" />
+    <ClInclude Include="Yields.h" />
     <ClInclude Include="JustInTimeArray.h" />
     <ClInclude Include="CvArea.h" />
     <ClInclude Include="CvArtFileMgr.h" />
@@ -258,6 +269,11 @@
     <UseDebugLibraries>false</UseDebugLibraries>
     <CLRSupport>true</CLRSupport>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Colonization 2071|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <CLRSupport>true</CLRSupport>
+  </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Assert-upload|Win32'" Label="Configuration">
     <ConfigurationType>Makefile</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
@@ -284,6 +300,9 @@
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Assert-fast|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Colonization 2071|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Assert-upload|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
   </ImportGroup>
@@ -358,6 +377,19 @@ bin\jom build</NMakeReBuildCommandLine>
 nmake clean</NMakeCleanCommandLine>
     <AdditionalOptions>/DWIN32 /D_WINDOWS /D_USRDLL /DCVGAMECOREDLL_EXPORTS /DNDEBUG /DFINAL_RELEASE /DFASSERT_ENABLE</AdditionalOptions>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Colonization 2071|Win32'">
+    <NMakePreprocessorDefinitions>WIN32;NDEBUG;$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeBuildCommandLine>set TARGET=Assert
+nmake precompile
+bin\jom build</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine>set TARGET=Assert
+nmake clean
+nmake precompile
+bin\jom build</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine>set TARGET=Assert
+nmake clean</NMakeCleanCommandLine>
+    <AdditionalOptions>/DWIN32 /D_WINDOWS /D_USRDLL /DCVGAMECOREDLL_EXPORTS /DNDEBUG /DFINAL_RELEASE /DFASSERT_ENABLE /DCOLONIZATION_2071</AdditionalOptions>
+  </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Assert-upload|Win32'">
     <NMakePreprocessorDefinitions>WIN32;NDEBUG;$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
     <NMakeBuildCommandLine>set TARGET=Assert
diff --git a/DLL_Sources/Yields.cpp b/DLL_Sources/Yields.cpp
new file mode 100644
index 0000000..f0b9927
--- /dev/null
+++ b/DLL_Sources/Yields.cpp
@@ -0,0 +1,118 @@
+//
+// Yields.cpp
+// Written by Nightinggale
+//
+#include "CvGameCoreDLL.h"
+#include "CvGlobals.h"
+#include "YieldsTestBase.h"
+
+void BaseCheckYieldGroup::build()
+{
+	FAssertMsg(false, "The base function shouldn't call this virtual function");
+}
+
+bool BaseCheckYieldGroup::function(YieldTypes eYield)
+{
+	FAssertMsg(false, "The base function shouldn't call this virtual function");
+	return false;
+}
+
+void BaseCheckYieldGroup::check()
+{
+	this->build();
+
+	bool checklist[NUM_YIELD_TYPES];
+
+	for (int i = 0; i < NUM_YIELD_TYPES; i++)
+	{
+		checklist[i] = false;
+	}
+
+	for(unsigned int iYield = 0; iYield < YieldVector.size(); iYield++) {
+		FAssert(YieldVector[iYield] < NUM_YIELD_TYPES);
+		FAssert(YieldVector[iYield] >= 0);
+		checklist[YieldVector[iYield]] = true;
+	}
+
+	for (int i = 0; i < NUM_YIELD_TYPES; i++)
+	{
+		YieldTypes eYield = (YieldTypes)i;
+		if (checklist[i])
+		{
+			FAssertMsg(bAllowVirtual || !YieldGroup_Virtual(eYield), CvString::format("Virtual yield %s used in %s even though this group doesn't allow virtual yields", GC.getYieldInfo(eYield).getType(), func_name).c_str());
+			FAssertMsg(this->function(eYield), CvString::format("Yield %s missing in %s", GC.getYieldInfo(eYield).getType(), func_name).c_str());
+		} else {
+			FAssertMsg(!this->function(eYield), CvString::format("Yield %s is a false positive in %s", GC.getYieldInfo(eYield).getType(), func_name).c_str());
+		}
+	}
+}
+
+void BaseCheckYieldGroup::checkSingleXMLType(YieldTypes eYield, const char* XMLname)
+{
+	FAssert(eYield >= 0 && eYield < NUM_YIELD_TYPES);
+	XMLnameChecked[eYield] = true;
+	FAssertMsg(!strcmp(GC.getYieldInfo(eYield).getType(), XMLname), CvString::format("XML error. Found %s instead of %s at index %d", GC.getYieldInfo(eYield).getType(), XMLname, eYield).c_str());
+}
+
+void CvGlobals::CheckEnumYieldTypes() const
+{
+#ifdef FASSERT_ENABLE
+	BaseCheckYieldGroup BaseGroup;
+	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
+	{
+		BaseGroup.XMLnameChecked[iYield] = false;
+	}
+	
+	BaseGroup.checkXML();
+	FAssertMsg(GC.getYieldInfo().size() == NUM_YIELD_TYPES, CvString::format("XML error. Expected %d types, but found %d", NUM_YIELD_TYPES, GC.getYieldInfo().size()));
+
+	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
+	{
+		YieldTypes eYield = (YieldTypes)iYield;
+		FAssertMsg(BaseGroup.XMLnameChecked[iYield], CvString::format("Yield %s not checked for consistency between enum and XML", GC.getYieldInfo(eYield).getType()).c_str());
+		if (YieldGroup_Virtual(eYield))
+		{
+			FAssertMsg(!GC.getYieldInfo(eYield).isCargo(), CvString::format("Virtual yield %s has bCargo set in XML", GC.getYieldInfo(eYield).getType()).c_str());
+		} else {
+			FAssertMsg(GC.getYieldInfo(eYield).isCargo(), CvString::format("Non-virtual yield %s has bCargo unset in XML", GC.getYieldInfo(eYield).getType()).c_str());
+		}
+	}
+
+	Check_YieldGroup_AI_Sell AI_Sell;
+	AI_Sell.check();
+	Check_YieldGroup_AI_Sell_To_Europe AI_Sell_To_Europe;
+	AI_Sell_To_Europe.check();
+	Check_YieldGroup_AI_Buy_From_Natives AI_Buy_From_Natives;
+	AI_Buy_From_Natives.check();
+	Check_YieldGroup_AI_Buy_From_Europe AI_Buy_From_Europe;
+	AI_Buy_From_Europe.check();
+	Check_YieldGroup_AI_Raw_Material AI_Raw_Material;
+	AI_Raw_Material.check();
+	Check_YieldGroup_AI_Native_Product AI_Native_Product;
+	AI_Native_Product.check();
+	Check_YieldGroup_City_Billboard City_Billboard;
+	City_Billboard.check();
+	Check_YieldGroup_City_Billboard_Offset_Fix City_Billboard_Offset_Fix;
+	City_Billboard_Offset_Fix.check();
+	Check_YieldGroup_Armor Armor;
+	Armor.check();
+	Check_YieldGroup_Light_Armor Light_Armor;
+	Light_Armor.check();
+	Check_YieldGroup_Heavy_Armor Heavy_Armor;
+	Heavy_Armor.check();
+
+	// check armor groups
+	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
+	{
+		YieldTypes eYield = (YieldTypes)iYield;
+		if (YieldGroup_Armor(eYield))
+		{
+			FAssertMsg(YieldGroup_Light_Armor(eYield) || YieldGroup_Heavy_Armor(eYield), CvString::format("%s is armor, but neither light or heavy armor", GC.getYieldInfo(eYield).getType()).c_str());
+			FAssertMsg(!(YieldGroup_Light_Armor(eYield) && YieldGroup_Heavy_Armor(eYield)), CvString::format("%s is both light and heavy armor", GC.getYieldInfo(eYield).getType()).c_str());
+		} else {
+			FAssertMsg(!YieldGroup_Light_Armor(eYield), CvString::format("%s is light armor, but not armor", GC.getYieldInfo(eYield).getType()).c_str());
+			FAssertMsg(!YieldGroup_Heavy_Armor(eYield), CvString::format("%s is heavy armor, but not armor", GC.getYieldInfo(eYield).getType()).c_str());
+		}
+	}
+#endif
+}
\ No newline at end of file
diff --git a/DLL_Sources/Yields.h b/DLL_Sources/Yields.h
new file mode 100644
index 0000000..6018a85
--- /dev/null
+++ b/DLL_Sources/Yields.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#ifndef YIELDS_H
+#define YIELDS_H
+
+//
+// Yields.h
+// Written by Nightinggale
+//
+
+#include "CvDefines.h"
+
+#include "Yields_Medieval_Tech.h"
+#include "Yields_Colonization_2071.h"
+
+// virtual means it can't be loaded into a ship, meaning it's yields like crosses and bells.
+// Invert the output from this group and you will only get yields, which can be loaded into ships.
+static inline bool YieldGroup_Virtual(YieldTypes eYield)
+{
+	// Vanilla assumes hammers to be the first virtual yield. This is deeply hardcoded in C++ as well as python.
+	return eYield >= YIELD_HAMMERS;
+}
+
+#endif	// YIELDS_H
diff --git a/DLL_Sources/YieldsTestBase.h b/DLL_Sources/YieldsTestBase.h
new file mode 100644
index 0000000..61e3d43
--- /dev/null
+++ b/DLL_Sources/YieldsTestBase.h
@@ -0,0 +1,122 @@
+//
+// YieldsTestBase.h
+// Written by Nightinggale
+//
+
+#ifndef YIELDS_TEST_BASE_H
+#define YIELDS_TEST_BASE_H
+
+#include "Yields.h"
+
+class BaseCheckYieldGroup
+{
+public:
+	BaseCheckYieldGroup()
+	{
+		func_name = "error";
+		bAllowVirtual = false;
+	}
+
+	bool XMLnameChecked[NUM_YIELD_TYPES];
+protected:
+	bool bAllowVirtual;
+	char *func_name;
+	std::vector<YieldTypes> YieldVector;
+
+	virtual bool function(YieldTypes eYield);
+	virtual void build();
+	void checkSingleXMLType(YieldTypes eYield, const char* XMLname);
+public:
+	void check();
+	void checkXML();
+};
+
+class Check_YieldGroup_AI_Sell: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_AI_Sell() { func_name = "YieldGroup_AI_Sell"; }
+	bool function(YieldTypes eYield) {return YieldGroup_AI_Sell(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_AI_Sell_To_Europe: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_AI_Sell_To_Europe() { func_name = "YieldGroup_AI_Sell_To_Europe"; }
+	bool function(YieldTypes eYield) {return YieldGroup_AI_Sell_To_Europe(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_AI_Buy_From_Natives: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_AI_Buy_From_Natives() { func_name = "YieldGroup_AI_Buy_From_Natives"; }
+	bool function(YieldTypes eYield) {return YieldGroup_AI_Buy_From_Natives(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_AI_Buy_From_Europe: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_AI_Buy_From_Europe() { func_name = "YieldGroup_AI_Buy_From_Europe"; }
+	bool function(YieldTypes eYield) {return YieldGroup_AI_Buy_From_Europe(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_AI_Raw_Material: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_AI_Raw_Material() { func_name = "YieldGroup_AI_Raw_Material"; }
+	bool function(YieldTypes eYield) {return YieldGroup_AI_Raw_Material(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_AI_Native_Product: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_AI_Native_Product() { func_name = "YieldGroup_AI_Native_Product"; }
+	bool function(YieldTypes eYield) {return YieldGroup_AI_Native_Product(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_City_Billboard: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_City_Billboard() { func_name = "YieldGroup_City_Billboard"; }
+	bool function(YieldTypes eYield) {return YieldGroup_City_Billboard(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_City_Billboard_Offset_Fix: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_City_Billboard_Offset_Fix() { func_name = "YieldGroup_City_Billboard_Offset_Fix"; }
+	bool function(YieldTypes eYield) {return YieldGroup_City_Billboard_Offset_Fix(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_Armor: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_Armor() { func_name = "YieldGroup_Armor"; }
+	bool function(YieldTypes eYield) {return YieldGroup_Armor(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_Light_Armor: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_Light_Armor() { func_name = "YieldGroup_Light_Armor"; }
+	bool function(YieldTypes eYield) {return YieldGroup_Light_Armor(eYield);}
+	void build();
+};
+
+class Check_YieldGroup_Heavy_Armor: public BaseCheckYieldGroup
+{
+public:
+	Check_YieldGroup_Heavy_Armor() { func_name = "YieldGroup_Heavy_Armor"; }
+	bool function(YieldTypes eYield) {return YieldGroup_Heavy_Armor(eYield);}
+	void build();
+};
+
+#endif // YIELDS_TEST_BASE_H
diff --git a/DLL_Sources/Yields_Colonization_2071.cpp b/DLL_Sources/Yields_Colonization_2071.cpp
new file mode 100644
index 0000000..310db91
--- /dev/null
+++ b/DLL_Sources/Yields_Colonization_2071.cpp
@@ -0,0 +1,123 @@
+//
+// Yields_Colonization_2071.cpp
+// Written by Nightinggale
+//
+#include "CvGameCoreDLL.h"
+#include "CvGlobals.h"
+#include "YieldsTestBase.h"
+
+#ifdef COLONIZATION_2071
+
+// AI sells unconditionally to natives and Europe unless they are raw materials as well
+void Check_YieldGroup_AI_Sell::build()
+{
+	YieldVector.push_back(YIELD_TRADE_GOODS);
+}
+
+// AI sells these in Europe
+// AI can also sell unneeded raw materials even if they aren't listed here
+void Check_YieldGroup_AI_Sell_To_Europe::build()
+{
+	YieldVector.push_back(YIELD_ORE);
+}
+
+// AI attemps to buy from natives as needed (or whenever offered?)
+void Check_YieldGroup_AI_Buy_From_Natives::build()
+{
+	YieldVector.push_back(YIELD_TOOLS);
+}
+
+// AI attemps to buy from Europe (Europe as in vanilla functionality)
+void Check_YieldGroup_AI_Buy_From_Europe::build()
+{
+	YieldVector.push_back(YIELD_TOOLS);
+	YieldVector.push_back(YIELD_WEAPONS);
+	YieldVector.push_back(YIELD_HORSES);
+	YieldVector.push_back(YIELD_TRADE_GOODS);
+}
+
+// AI sells unless they are needed
+// Used for production building input like ore, cotton etc.
+void Check_YieldGroup_AI_Raw_Material::build()
+{
+	YieldVector.push_back(YIELD_ORE);
+	YieldVector.push_back(YIELD_STONE);
+}
+
+// Set yields the natives will produce
+// Natives will also produce yields, which has bIsNativeTrade set in XML
+// Other code might give natives the ability to produce even more yields.
+//   They can produce yields, which is accepted by any one of the options.
+void Check_YieldGroup_AI_Native_Product::build()
+{
+}
+
+// Yields to show up on city billboards
+void Check_YieldGroup_City_Billboard::build()
+{
+	YieldVector.push_back(YIELD_HORSES);
+	YieldVector.push_back(YIELD_TOOLS);
+}
+
+// yields, which are affected by an off by one offset error when displaying billboard icons
+// TODO: find the real culprint of this bug instead of working around it.
+void Check_YieldGroup_City_Billboard_Offset_Fix::build()
+{
+	YieldVector.push_back(YIELD_HORSES);
+	YieldVector.push_back(YIELD_TOOLS);
+}
+
+// yield is either light or heavy armor (not both)
+void Check_YieldGroup_Armor::build()
+{
+}
+
+// yield is light armor
+void Check_YieldGroup_Light_Armor::build()
+{
+}
+
+// yield is heavy armor
+void Check_YieldGroup_Heavy_Armor::build()
+{
+}
+
+// check YieldTypes vs XML yield names
+void BaseCheckYieldGroup::checkXML()
+{
+	// first argument is YieldTypes enum value while the second is the name in XML
+	checkSingleXMLType(YIELD_NUTRIENTS,          "YIELD_NUTRIENTS");
+	checkSingleXMLType(YIELD_BIOPOLYMERS,        "YIELD_BIOPOLYMERS");
+	checkSingleXMLType(YIELD_SILICATES,          "YIELD_SILICATES");
+	checkSingleXMLType(YIELD_BASE_METALS,        "YIELD_BASE_METALS");
+	checkSingleXMLType(YIELD_PRECIOUS_METALS,    "YIELD_PRECIOUS_METALS");
+	checkSingleXMLType(YIELD_ISOTOPES,           "YIELD_ISOTOPES");
+	checkSingleXMLType(YIELD_URANIUM,            "YIELD_URANIUM");
+	checkSingleXMLType(YIELD_RARE_EARTHS,        "YIELD_RARE_EARTHS");
+	checkSingleXMLType(YIELD_CRYSTALLOIDS,       "YIELD_CRYSTALLOIDS");
+	checkSingleXMLType(YIELD_TISSUE_SAMPLES,     "YIELD_TISSUE_SAMPLES");
+	checkSingleXMLType(YIELD_YIELD_NUCLEIC_ACIDS,"YIELD_YIELD_NUCLEIC_ACIDS");
+	checkSingleXMLType(YIELD_AMINO_ACIDS,        "YIELD_AMINO_ACIDS");
+	checkSingleXMLType(YIELD_MICROBES,           "YIELD_MICROBES");
+	checkSingleXMLType(YIELD_PROGENITOR_ARTIFACTS,"YIELD_PROGENITOR_ARTIFACTS");
+	checkSingleXMLType(YIELD_ALIEN_SPECIMENS,    "YIELD_ALIEN_SPECIMENS");
+	checkSingleXMLType(YIELD_ENCRYPTED_DATA,     "YIELD_ENCRYPTED_DATA");
+	checkSingleXMLType(YIELD_OPIATES,            "YIELD_OPIATES");
+	checkSingleXMLType(YIELD_XENOTOXINS,         "YIELD_XENOTOXINS");
+	checkSingleXMLType(YIELD_BOTANICALS,         "YIELD_BOTANICALS");
+	checkSingleXMLType(YIELD_HYDROCARBONS,       "YIELD_HYDROCARBONS");
+	checkSingleXMLType(YIELD_HALOGENS,           "YIELD_HALOGENS");
+	checkSingleXMLType(YIELD_CORE_SAMPLES,       "YIELD_CORE_SAMPLES");
+	checkSingleXMLType(YIELD_TOOLS,              "YIELD_TOOLS");
+	checkSingleXMLType(YIELD_WEAPONS,            "YIELD_WEAPONS");
+	checkSingleXMLType(YIELD_HORSES,             "YIELD_HORSES");
+	checkSingleXMLType(YIELD_TRADE_GOODS,        "YIELD_TRADE_GOODS");
+	checkSingleXMLType(YIELD_HAMMERS,            "YIELD_HAMMERS");
+	checkSingleXMLType(YIELD_BELLS,              "YIELD_BELLS");
+	checkSingleXMLType(YIELD_CROSSES,            "YIELD_CROSSES");
+	checkSingleXMLType(YIELD_EDUCATION,          "YIELD_EDUCATION");
+	checkSingleXMLType(YIELD_IDEAS,              "YIELD_IDEAS");
+	checkSingleXMLType(YIELD_CULTURE,            "YIELD_CULTURE");
+	checkSingleXMLType(YIELD_GOLD,               "YIELD_GOLD");
+}
+#endif // COLONIZATION_2071
diff --git a/DLL_Sources/Yields_Colonization_2071.h b/DLL_Sources/Yields_Colonization_2071.h
new file mode 100644
index 0000000..b565b47
--- /dev/null
+++ b/DLL_Sources/Yields_Colonization_2071.h
@@ -0,0 +1,137 @@
+#pragma once
+
+#ifndef YIELDS_COLONIZATION_2071_H
+#define YIELDS_COLONIZATION_2071_H
+
+//
+// Yields_Colonization_2071.h
+// Written by Nightinggale
+//
+
+#ifdef COLONIZATION_2071
+
+// keep this enum in sync with python::enum_<YieldTypes>("YieldTypes") in CyEnumsInterface.cpp
+
+enum DllExport YieldTypes
+{
+	NO_YIELD = -1,
+
+	YIELD_NUTRIENTS,
+	YIELD_BIOPOLYMERS,
+	YIELD_SILICATES,
+	YIELD_BASE_METALS,
+	YIELD_PRECIOUS_METALS,
+	YIELD_ISOTOPES,
+	YIELD_URANIUM,
+	YIELD_RARE_EARTHS,
+	YIELD_CRYSTALLOIDS,
+	YIELD_TISSUE_SAMPLES,
+	YIELD_YIELD_NUCLEIC_ACIDS,
+	YIELD_AMINO_ACIDS,
+	YIELD_MICROBES,
+	YIELD_PROGENITOR_ARTIFACTS,
+	YIELD_ALIEN_SPECIMENS,
+	YIELD_ENCRYPTED_DATA,
+	YIELD_OPIATES,
+	YIELD_XENOTOXINS,
+	YIELD_BOTANICALS,
+	YIELD_HYDROCARBONS,
+	YIELD_HALOGENS,
+	YIELD_CORE_SAMPLES,
+
+	// next 4 have hardcoded names
+	YIELD_TOOLS,
+	YIELD_WEAPONS,
+	YIELD_HORSES,
+	YIELD_TRADE_GOODS,
+	
+	// virtual yields
+	YIELD_HAMMERS,
+	YIELD_BELLS,
+	YIELD_CROSSES,
+	YIELD_EDUCATION,
+	YIELD_IDEAS,
+	YIELD_CULTURE,
+    YIELD_GOLD,
+
+#ifdef _USRDLL
+	NUM_YIELD_TYPES,
+#endif
+
+	YIELD_FROM_ANIMALS = NO_YIELD,
+
+	// name connection with hardcoded names
+	YIELD_FOOD        = YIELD_NUTRIENTS,
+	YIELD_LUMBER      = YIELD_BIOPOLYMERS,
+	YIELD_STONE       = YIELD_SILICATES,
+	YIELD_ORE         = YIELD_BASE_METALS,
+	//YIELD_TOOLS       = YIELD_TOOLS,
+	//YIELD_WEAPONS     = YIELD_WEAPONS,
+	//YIELD_HORSES      = YIELD_HORSES,
+	//YIELD_TRADE_GOODS = YIELD_TRADE_GOODS,
+
+};
+
+static inline bool YieldGroup_AI_Sell(YieldTypes eYield)
+{
+	return eYield == YIELD_TRADE_GOODS;
+}
+
+static inline bool YieldGroup_AI_Sell_To_Europe(YieldTypes eYield)
+{
+	return eYield == YIELD_ORE;
+}
+
+static inline bool YieldGroup_AI_Buy_From_Natives(YieldTypes eYield)
+{
+	return eYield == YIELD_TOOLS;
+}
+
+static inline bool YieldGroup_AI_Buy_From_Europe(YieldTypes eYield)
+{
+	return eYield >= YIELD_TOOLS && eYield <= YIELD_TRADE_GOODS;
+}
+
+static inline bool YieldGroup_AI_Raw_Material(YieldTypes eYield)
+{
+	return eYield == YIELD_ORE || eYield == YIELD_STONE;
+}
+
+static inline bool YieldGroup_AI_Native_Product(YieldTypes eYield)
+{
+	return false;
+}
+
+static inline bool YieldGroup_City_Billboard(YieldTypes eYield)
+{
+	return eYield == YIELD_HORSES || eYield == YIELD_TOOLS;
+}
+
+static inline bool YieldGroup_City_Billboard_Offset_Fix(YieldTypes eYield)
+{
+	return eYield == YIELD_HORSES || eYield == YIELD_TOOLS;
+}
+
+static inline bool YieldGroup_Armor(YieldTypes eYield)
+{
+	return false;
+}
+
+static inline bool YieldGroup_Light_Armor(YieldTypes eYield)
+{
+	return false;
+}
+
+static inline bool YieldGroup_Heavy_Armor(YieldTypes eYield)
+{
+	return false;
+}
+
+static inline bool YieldGroup_Luxury_Food(YieldTypes eYield)
+{
+	return false;
+}
+
+#endif // COLONIZATION_2071
+
+#endif	// YIELDS_MEDIEVAL_TECH_H
diff --git a/DLL_Sources/Yields_Medieval_Tech.cpp b/DLL_Sources/Yields_Medieval_Tech.cpp
new file mode 100644
index 0000000..d2c312c
--- /dev/null
+++ b/DLL_Sources/Yields_Medieval_Tech.cpp
@@ -0,0 +1,178 @@
+//
+// Yields_Medieval_Tech.cpp
+// Written by Nightinggale
+//
+#include "CvGameCoreDLL.h"
+#include "CvGlobals.h"
+#include "YieldsTestBase.h"
+
+#ifdef MEDIEVAL_TECH
+
+// AI sells unconditionally to natives and Europe unless they are raw materials as well
+void Check_YieldGroup_AI_Sell::build()
+{
+	YieldVector.push_back(YIELD_SILVER);
+	YieldVector.push_back(YIELD_CLOTH);
+	YieldVector.push_back(YIELD_COATS);
+	YieldVector.push_back(YIELD_ALE);
+	YieldVector.push_back(YIELD_WINE);
+	YieldVector.push_back(YIELD_TRADE_GOODS);
+}
+
+// AI sells these in Europe
+// AI can also sell unneeded raw materials even if they aren't listed here
+void Check_YieldGroup_AI_Sell_To_Europe::build()
+{
+	YieldVector.push_back(YIELD_SALT);
+	YieldVector.push_back(YIELD_SILVER);
+	YieldVector.push_back(YIELD_COTTON);
+	YieldVector.push_back(YIELD_FUR);
+	YieldVector.push_back(YIELD_BARLEY);
+	YieldVector.push_back(YIELD_GRAPES);
+	YieldVector.push_back(YIELD_ORE);
+	YieldVector.push_back(YIELD_CLOTH);
+	YieldVector.push_back(YIELD_COATS);
+	YieldVector.push_back(YIELD_ALE);
+	YieldVector.push_back(YIELD_WINE);
+	YieldVector.push_back(YIELD_CATTLE);
+	YieldVector.push_back(YIELD_SHEEP);
+	YieldVector.push_back(YIELD_WOOL);
+	YieldVector.push_back(YIELD_SPICES);
+}
+
+// AI attemps to buy from natives as needed (or whenever offered?)
+void Check_YieldGroup_AI_Buy_From_Natives::build()
+{
+	YieldVector.push_back(YIELD_SPICES);
+	YieldVector.push_back(YIELD_TOOLS);
+	YieldVector.push_back(YIELD_GRAIN);
+	YieldVector.push_back(YIELD_CATTLE);
+}
+
+// AI attemps to buy from Europe (Europe as in vanilla functionality)
+void Check_YieldGroup_AI_Buy_From_Europe::build()
+{
+	YieldVector.push_back(YIELD_LEATHER_ARMOR);
+	YieldVector.push_back(YIELD_SCALE_ARMOR);
+	YieldVector.push_back(YIELD_MAIL_ARMOR);
+	YieldVector.push_back(YIELD_PLATE_ARMOR);
+	YieldVector.push_back(YIELD_TOOLS);
+	YieldVector.push_back(YIELD_WEAPONS);
+	YieldVector.push_back(YIELD_HORSES);
+	YieldVector.push_back(YIELD_TRADE_GOODS);
+	YieldVector.push_back(YIELD_SPICES);
+}
+
+// AI sells unless they are needed
+// Used for production building input like ore, cotton etc.
+void Check_YieldGroup_AI_Raw_Material::build()
+{
+	YieldVector.push_back(YIELD_COTTON);
+	YieldVector.push_back(YIELD_BARLEY);
+	YieldVector.push_back(YIELD_GRAPES);
+	YieldVector.push_back(YIELD_ORE);
+	YieldVector.push_back(YIELD_CATTLE);
+	YieldVector.push_back(YIELD_SPICES);
+	YieldVector.push_back(YIELD_SHEEP);
+	YieldVector.push_back(YIELD_WOOL);
+	YieldVector.push_back(YIELD_SALT);
+	YieldVector.push_back(YIELD_STONE);
+	YieldVector.push_back(YIELD_FUR);
+}
+
+// Set yields the natives will produce
+// Natives will also produce yields, which has bIsNativeTrade set in XML
+// Other code might give natives the ability to produce even more yields.
+//   They can produce yields, which is accepted by any one of the options.
+void Check_YieldGroup_AI_Native_Product::build()
+{
+	YieldVector.push_back(YIELD_WOOL);
+	YieldVector.push_back(YIELD_CATTLE);
+	YieldVector.push_back(YIELD_SHEEP);
+}
+
+// Yields to show up on city billboards
+void Check_YieldGroup_City_Billboard::build()
+{
+	YieldVector.push_back(YIELD_SPICES);
+	YieldVector.push_back(YIELD_HORSES);
+	YieldVector.push_back(YIELD_CATTLE);
+	YieldVector.push_back(YIELD_SHEEP);
+	YieldVector.push_back(YIELD_SALT);
+	YieldVector.push_back(YIELD_TOOLS);
+}
+
+// yields, which are affected by an off by one offset error when displaying billboard icons
+// TODO: find the real culprint of this bug instead of working around it.
+void Check_YieldGroup_City_Billboard_Offset_Fix::build()
+{
+	YieldVector.push_back(YIELD_SPICES);
+	YieldVector.push_back(YIELD_HORSES);
+	YieldVector.push_back(YIELD_SALT);
+	YieldVector.push_back(YIELD_TOOLS);
+}
+
+// yield is either light or heavy armor (not both)
+void Check_YieldGroup_Armor::build()
+{
+	YieldVector.push_back(YIELD_LEATHER_ARMOR);
+	YieldVector.push_back(YIELD_SCALE_ARMOR);
+	YieldVector.push_back(YIELD_MAIL_ARMOR);
+	YieldVector.push_back(YIELD_PLATE_ARMOR);
+}
+
+// yield is light armor
+void Check_YieldGroup_Light_Armor::build()
+{
+	YieldVector.push_back(YIELD_LEATHER_ARMOR);
+}
+
+// yield is heavy armor
+void Check_YieldGroup_Heavy_Armor::build()
+{
+	YieldVector.push_back(YIELD_SCALE_ARMOR);
+	YieldVector.push_back(YIELD_MAIL_ARMOR);
+	YieldVector.push_back(YIELD_PLATE_ARMOR);
+}
+
+// check YieldTypes vs XML yield names
+void BaseCheckYieldGroup::checkXML()
+{
+	// first argument is YieldTypes enum value while the second is the name in XML
+	checkSingleXMLType(YIELD_FOOD,               "YIELD_FOOD");
+	checkSingleXMLType(YIELD_GRAIN,              "YIELD_GRAIN");
+	checkSingleXMLType(YIELD_CATTLE,             "YIELD_CATTLE");
+	checkSingleXMLType(YIELD_SHEEP,              "YIELD_SHEEP");
+	checkSingleXMLType(YIELD_WOOL,               "YIELD_WOOL");
+	checkSingleXMLType(YIELD_LUMBER,             "YIELD_LUMBER");
+	checkSingleXMLType(YIELD_STONE,              "YIELD_STONE");
+	checkSingleXMLType(YIELD_SILVER,             "YIELD_SILVER");
+	checkSingleXMLType(YIELD_SALT,               "YIELD_SALT");
+	checkSingleXMLType(YIELD_SPICES,             "YIELD_SPICES");
+	checkSingleXMLType(YIELD_FUR,                "YIELD_FUR");
+	checkSingleXMLType(YIELD_COTTON,             "YIELD_COTTON");
+	checkSingleXMLType(YIELD_BARLEY,             "YIELD_BARLEY");
+	checkSingleXMLType(YIELD_GRAPES,             "YIELD_GRAPES");
+	checkSingleXMLType(YIELD_ORE,                "YIELD_ORE");
+	checkSingleXMLType(YIELD_CLOTH,              "YIELD_CLOTH");
+	checkSingleXMLType(YIELD_COATS,              "YIELD_COATS");
+	checkSingleXMLType(YIELD_ALE,                "YIELD_ALE");
+	checkSingleXMLType(YIELD_WINE,               "YIELD_WINE");
+	checkSingleXMLType(YIELD_TOOLS,              "YIELD_TOOLS");
+	checkSingleXMLType(YIELD_WEAPONS,            "YIELD_WEAPONS");
+	checkSingleXMLType(YIELD_HORSES,             "YIELD_HORSES");
+	checkSingleXMLType(YIELD_LEATHER_ARMOR,      "YIELD_LEATHER_ARMOR");
+	checkSingleXMLType(YIELD_SCALE_ARMOR,        "YIELD_SCALE_ARMOR");
+	checkSingleXMLType(YIELD_MAIL_ARMOR,         "YIELD_MAIL_ARMOR");
+	checkSingleXMLType(YIELD_PLATE_ARMOR,        "YIELD_PLATE_ARMOR");
+	checkSingleXMLType(YIELD_TRADE_GOODS,        "YIELD_TRADE_GOODS");
+	checkSingleXMLType(YIELD_HAMMERS,            "YIELD_HAMMERS");
+	checkSingleXMLType(YIELD_BELLS,              "YIELD_BELLS");
+	checkSingleXMLType(YIELD_CROSSES,            "YIELD_CROSSES");
+	checkSingleXMLType(YIELD_EDUCATION,          "YIELD_EDUCATION");
+	checkSingleXMLType(YIELD_IDEAS,              "YIELD_IDEAS");
+	checkSingleXMLType(YIELD_CULTURE,            "YIELD_CULTURE");
+	checkSingleXMLType(YIELD_GOLD,               "YIELD_GOLD");
+
+}
+#endif // MEDIEVAL_TECH
diff --git a/DLL_Sources/Yields_Medieval_Tech.h b/DLL_Sources/Yields_Medieval_Tech.h
new file mode 100644
index 0000000..607c8d2
--- /dev/null
+++ b/DLL_Sources/Yields_Medieval_Tech.h
@@ -0,0 +1,134 @@
+#pragma once
+
+#ifndef YIELDS_MEDIEVAL_TECH_H
+#define YIELDS_MEDIEVAL_TECH_H
+
+//
+// Yields_Medieval_Tech.h
+// Written by Nightinggale
+//
+
+#ifdef MEDIEVAL_TECH
+
+// keep this enum in sync with python::enum_<YieldTypes>("YieldTypes") in CyEnumsInterface.cpp
+
+enum DllExport YieldTypes
+{
+	NO_YIELD = -1,
+
+	YIELD_FOOD,///0
+	///TKs ME
+	YIELD_GRAIN,///1NEW*
+	YIELD_CATTLE,///2/NEW*
+	YIELD_SHEEP,///3/NEW*
+	YIELD_WOOL,///4NEW*
+	//YIELD_SALT,///5NEW*
+	YIELD_LUMBER,///6
+	YIELD_STONE,///7NEW*
+//	YIELD_LEATHER,///20NEW*
+	YIELD_SILVER,///8
+	//YIELD_GOLD,///9/NEW*
+//	YIELD_IVORY,//9/NEW*
+    YIELD_SALT,///5NEW*
+	YIELD_SPICES,///10NEW*
+	YIELD_FUR,///11
+	YIELD_COTTON,///12
+	YIELD_BARLEY,///13YIELD_SUGAR,
+	YIELD_GRAPES,///14YIELD_TOBACCO,
+	YIELD_ORE,///15
+	YIELD_CLOTH,///16
+	YIELD_COATS,///17
+	YIELD_ALE,///18YIELD_RUM,
+	YIELD_WINE,///19YIELD_CIGARS,
+	YIELD_TOOLS,///20
+	YIELD_WEAPONS,///21YIELD_MUSKETS,
+	YIELD_HORSES,///22
+	YIELD_LEATHER_ARMOR,///23NEW*
+	YIELD_SCALE_ARMOR,///24NEW*
+	YIELD_MAIL_ARMOR,///25NEW*
+	YIELD_PLATE_ARMOR,///26NEW*
+	YIELD_TRADE_GOODS,///27
+//	YIELD_SILK,///29NEW*
+//	YIELD_PORCELAIN,///30NEW*
+	YIELD_HAMMERS,///28
+	YIELD_BELLS,///29
+	YIELD_CROSSES,///30
+	YIELD_EDUCATION,///31
+	///TKs Invention Core Mod v 1.0
+	YIELD_IDEAS,///32
+	YIELD_CULTURE,///33
+    YIELD_GOLD,///34/NEW*
+
+	///TKe
+
+#ifdef _USRDLL
+	NUM_YIELD_TYPES,
+#endif
+
+	// Setup for which yields to have certain hardcoded functions
+	YIELD_FROM_ANIMALS = YIELD_GRAIN,
+};
+
+static inline bool YieldGroup_AI_Sell(YieldTypes eYield)
+{
+	return (eYield >= YIELD_CLOTH && eYield <= YIELD_WINE) || eYield == YIELD_SILVER || eYield == YIELD_TRADE_GOODS;
+}
+
+static inline bool YieldGroup_AI_Sell_To_Europe(YieldTypes eYield)
+{
+	return (eYield >= YIELD_SILVER && eYield <= YIELD_WINE) || (eYield >= YIELD_CATTLE && eYield <= YIELD_WOOL);
+}
+
+static inline bool YieldGroup_AI_Buy_From_Natives(YieldTypes eYield)
+{
+	return eYield == YIELD_SPICES || eYield == YIELD_TOOLS || eYield ==  YIELD_GRAIN || eYield == YIELD_CATTLE;
+}
+
+static inline bool YieldGroup_AI_Buy_From_Europe(YieldTypes eYield)
+{
+	return (eYield >= YIELD_TOOLS && eYield <= YIELD_TRADE_GOODS) || eYield == YIELD_SPICES;
+}
+
+static inline bool YieldGroup_AI_Raw_Material(YieldTypes eYield)
+{
+	return (eYield >= YIELD_SALT && eYield <= YIELD_ORE) || (eYield <= YIELD_STONE && eYield >= YIELD_CATTLE && eYield != YIELD_LUMBER);
+}
+
+static inline bool YieldGroup_AI_Native_Product(YieldTypes eYield)
+{
+	return eYield <= YIELD_WOOL && eYield >= YIELD_CATTLE;
+}
+
+static inline bool YieldGroup_City_Billboard(YieldTypes eYield)
+{
+	return eYield == YIELD_SPICES || eYield == YIELD_HORSES || eYield == YIELD_CATTLE || eYield == YIELD_SHEEP || eYield == YIELD_SALT || eYield == YIELD_TOOLS;
+}
+
+static inline bool YieldGroup_City_Billboard_Offset_Fix(YieldTypes eYield)
+{
+	return eYield == YIELD_SPICES || eYield == YIELD_HORSES || eYield == YIELD_SALT || eYield == YIELD_TOOLS;
+}
+
+static inline bool YieldGroup_Armor(YieldTypes eYield)
+{
+	return eYield >= YIELD_LEATHER_ARMOR && eYield <= YIELD_PLATE_ARMOR;
+}
+
+static inline bool YieldGroup_Light_Armor(YieldTypes eYield)
+{
+	return eYield == YIELD_LEATHER_ARMOR;
+}
+
+static inline bool YieldGroup_Heavy_Armor(YieldTypes eYield)
+{
+	return eYield >= YIELD_SCALE_ARMOR && eYield <= YIELD_PLATE_ARMOR;
+}
+
+static inline bool YieldGroup_Luxury_Food(YieldTypes eYield)
+{
+	return eYield == YIELD_GRAIN;
+}
+
+#endif // MEDIEVAL_TECH
+
+#endif	// YIELDS_MEDIEVAL_TECH_H
